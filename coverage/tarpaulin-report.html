<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","imalison","Projects","lastfm-edit","examples","artist_tracks_direct.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    let artist = \"The Beatles\";\n\n    println!(\"=== Artist Tracks Direct Example ===\\n\");\n    println!(\"ğŸµ Comparing album-based vs direct approach for: {artist}\");\n\n    // Test the direct approach\n    println!(\"\\nğŸ“„ Using direct paginated endpoint:\");\n    let mut direct_tracks = client.artist_tracks_direct(artist);\n    let direct_tracks_list = direct_tracks.take(10).await?;\n\n    println!(\n        \"âœ… Found {} tracks using direct approach:\",\n        direct_tracks_list.len()\n    );\n    for (i, track) in direct_tracks_list.iter().enumerate() {\n        println!(\n            \"  {}. {} (played {} times)\",\n            i + 1,\n            track.name,\n            track.playcount\n        );\n        if let Some(album) = \u0026track.album {\n            println!(\"     Album: {album}\");\n        }\n    }\n\n    // Compare with album-based approach\n    println!(\"\\nğŸ“€ Using album-based approach:\");\n    let mut album_tracks = client.artist_tracks(artist);\n    let album_tracks_list = album_tracks.take(10).await?;\n\n    println!(\n        \"âœ… Found {} tracks using album-based approach:\",\n        album_tracks_list.len()\n    );\n    for (i, track) in album_tracks_list.iter().enumerate() {\n        println!(\n            \"  {}. {} (played {} times)\",\n            i + 1,\n            track.name,\n            track.playcount\n        );\n        if let Some(album) = \u0026track.album {\n            println!(\"     Album: {album}\");\n        }\n    }\n\n    println!(\"\\nğŸ’¡ The direct approach is more efficient as it uses:\");\n    println!(\n        \"   /user/{{username}}/library/music/{}/+tracks?page=N\u0026ajax=true\",\n        artist.replace(\" \", \"+\")\n    );\n    println!(\"   Instead of iterating through albums first.\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","clean_artist_tracks.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\nuse regex::Regex;\nuse std::collections::HashSet;\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let args: Vec\u003cString\u003e = env::args().collect();\n\n    if args.len() != 3 {\n        eprintln!(\n            \"Usage: cargo run --example clean_artist_tracks -- \\\"Artist Name\\\" \\\"Regex Pattern\\\"\"\n        );\n        eprintln!(\"Examples:\");\n        eprintln!(\"  # Remove remastered suffixes:\");\n        eprintln!(\"  cargo run --example clean_artist_tracks -- \\\"The Beatles\\\" \\\" - Remastered( \\\\d{{4}})?$\\\"\");\n        eprintln!(\"  # Remove live suffixes:\");\n        eprintln!(\"  cargo run --example clean_artist_tracks -- \\\"Pink Floyd\\\" \\\" \\\\(Live\\\\)$\\\"\");\n        eprintln!(\"  # Remove explicit tags:\");\n        eprintln!(\"  cargo run --example clean_artist_tracks -- \\\"Eminem\\\" \\\" \\\\(Explicit\\\\)$\\\"\");\n        std::process::exit(1);\n    }\n\n    let artist = \u0026args[1];\n    let pattern = \u0026args[2];\n\n    let regex = match Regex::new(pattern) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            eprintln!(\"âŒ Invalid regex pattern '{pattern}': {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let client = common::setup_client().await?;\n\n    println!(\"=== Artist Catalog Cleanup Tool ===\\n\");\n    println!(\"ğŸ¨ ARTIST: {artist}\");\n    println!(\"ğŸ” PATTERN: {pattern}\");\n    println!(\"ğŸ“ This will clean track names by removing text matching the regex pattern\");\n    println!(\"\\nğŸš€ Starting catalog scan...\\n\");\n\n    // Track statistics\n    let mut total_tracks_scanned = 0;\n    let mut matching_tracks_found = 0;\n    let mut tracks_successfully_cleaned = 0;\n    let mut tracks_failed_to_clean = 0;\n    let mut already_cleaned_tracks = HashSet::new();\n\n    // Step 1: Collect all matching tracks first\n    println!(\"ğŸ” Step 1: Scanning entire {artist} catalog for matching tracks...\");\n    let mut all_matching_tracks = Vec::new();\n    let mut page = 1;\n\n    loop {\n        match client.get_artist_tracks_page(artist, page).await {\n            Ok(track_page) =\u003e {\n                if track_page.tracks.is_empty() {\n                    println!(\n                        \"ğŸ“š Reached end of {artist} catalog - scanned {total_tracks_scanned} tracks total\"\n                    );\n                    break;\n                }\n\n                for track in track_page.tracks {\n                    total_tracks_scanned += 1;\n\n                    // Print progress every 50 tracks\n                    if total_tracks_scanned % 50 == 0 {\n                        println!(\"ğŸ“– Scanned {total_tracks_scanned} tracks so far...\");\n                    }\n\n                    // Check if this track matches our pattern\n                    if regex.is_match(\u0026track.name) {\n                        let base_name = regex.replace(\u0026track.name, \"\").to_string();\n                        if !already_cleaned_tracks.contains(\u0026base_name) {\n                            all_matching_tracks.push(track);\n                            already_cleaned_tracks.insert(base_name);\n                            matching_tracks_found += 1;\n                        }\n                    }\n                }\n\n                if !track_page.has_next_page {\n                    println!(\n                        \"ğŸ“š Reached end of {artist} catalog - scanned {total_tracks_scanned} tracks total\"\n                    );\n                    break;\n                }\n\n                page += 1;\n            }\n            Err(e) =\u003e {\n                println!(\"âŒ Error fetching tracks page {page}: {e}\");\n                break;\n            }\n        }\n    }\n\n    // Step 2: Process all found matching tracks\n    if all_matching_tracks.is_empty() {\n        println!(\"\\nğŸ‰ No matching tracks found! Your {artist} catalog is already clean.\");\n        return Ok(());\n    }\n\n    println!(\n        \"\\nğŸ¯ Step 2: Processing {} matching tracks...\",\n        all_matching_tracks.len()\n    );\n    already_cleaned_tracks.clear(); // Reset for actual processing\n\n    for (index, track) in all_matching_tracks.iter().enumerate() {\n        let clean_name = regex.replace(\u0026track.name, \"\").to_string();\n\n        println!(\n            \"\\nğŸµ [{}/{}] Cleaning: '{}' â†’ '{}'\",\n            index + 1,\n            all_matching_tracks.len(),\n            track.name,\n            clean_name\n        );\n\n        // Skip if we've already processed this track name in this session\n        if already_cleaned_tracks.contains(\u0026clean_name) {\n            println!(\"   â­ï¸  Skipping - already processed in this session\");\n            continue;\n        }\n\n        // Load real edit form values from the track page\n        let edit_template = lastfm_edit::ScrobbleEdit::from_track_and_artist(\u0026track.name, artist);\n        match client\n            .discover_scrobble_edit_variations(\u0026edit_template)\n            .await\n        {\n            Ok(exact_edit_vec) =\u003e {\n                if let Some(exact_edit) = exact_edit_vec.into_iter().next() {\n                    let mut edit_data = exact_edit.to_scrobble_edit();\n                    println!(\n                        \"   ğŸ“‹ Loaded edit form data - Album: '{}'\",\n                        edit_data\n                            .album_name_original\n                            .as_deref()\n                            .unwrap_or(\"unknown\")\n                    );\n\n                    // Update the track name to the cleaned version\n                    edit_data.track_name = Some(clean_name.clone());\n\n                    println!(\"   ğŸ”§ Submitting edit...\");\n\n                    // Perform the edit\n                    match client.edit_scrobble(\u0026edit_data).await {\n                        Ok(_response) =\u003e {\n                            println!(\"   âœ… Successfully cleaned: '{clean_name}'\");\n                            tracks_successfully_cleaned += 1;\n                            already_cleaned_tracks.insert(clean_name);\n                        }\n                        Err(e) =\u003e {\n                            println!(\"   âŒ Error editing '{}': {}\", track.name, e);\n                            tracks_failed_to_clean += 1;\n                        }\n                    }\n                } else {\n                    println!(\"   âš ï¸  No edit data found for track\");\n                    tracks_failed_to_clean += 1;\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"   âš ï¸  Couldn't load edit form for '{}': {}\", track.name, e);\n                println!(\"      This track might not be in your recent scrobbles\");\n                tracks_failed_to_clean += 1;\n            }\n        }\n\n        // Add a small delay to be respectful to Last.fm servers\n        println!(\"   â³ Waiting 1.2s before next track...\");\n        tokio::time::sleep(tokio::time::Duration::from_millis(1200)).await;\n    }\n\n    // Print final statistics\n    println!(\"\\n{}\", \"=\".repeat(60));\n    println!(\"ğŸ¼ {} CATALOG CLEANUP COMPLETE\", artist.to_uppercase());\n    println!(\"{}\", \"=\".repeat(60));\n    println!(\"ğŸ“Š STATISTICS:\");\n    println!(\"   â€¢ Total tracks scanned: {total_tracks_scanned}\");\n    println!(\"   â€¢ Matching tracks found: {matching_tracks_found}\");\n    println!(\"   â€¢ Tracks successfully cleaned: {tracks_successfully_cleaned}\");\n    println!(\"   â€¢ Tracks failed to clean: {tracks_failed_to_clean}\");\n\n    if tracks_successfully_cleaned \u003e 0 {\n        println!(\n            \"\\nâœ¨ Your {artist} catalog is now cleaner! Pattern '{pattern}' has been removed from track names.\"\n        );\n    }\n\n    if tracks_failed_to_clean \u003e 0 {\n        println!(\"\\nâš ï¸  Some tracks couldn't be cleaned. This usually happens when:\");\n        println!(\"   â€¢ The track hasn't been scrobbled recently\");\n        println!(\"   â€¢ The track data isn't in your listening history\");\n        println!(\"   â€¢ There were temporary server issues\");\n        println!(\"\\nğŸ’¡ You can re-run this script later to try cleaning the remaining tracks.\");\n    }\n\n    println!(\"\\nğŸµ {artist} catalog cleanup completed!\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","custom_session_manager.rs"],"content":"/// Example demonstrating how to use SessionManager with custom app names.\n///\n/// This example shows how other libraries can use SessionManager to store\n/// Last.fm sessions with their own application prefix in XDG directories.\n///\n/// Usage:\n///   direnv exec . cargo run --example custom_session_manager\nuse lastfm_edit::{LastFmEditClientImpl, SessionManager};\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    env_logger::init();\n\n    println!(\"ğŸµ Custom SessionManager Example\");\n    println!(\"=================================\\n\");\n\n    // Create a custom session manager for your application\n    let session_manager = SessionManager::new(\"my-music-app\");\n    println!(\"ğŸ“ Using app name: '{}'\", session_manager.app_name());\n    println!(\"ğŸ“‚ Sessions will be stored in: ~/.local/share/my-music-app/users/{{username}}/session.json\\n\");\n\n    let username = env::var(\"LASTFM_EDIT_USERNAME\")\n        .expect(\"LASTFM_EDIT_USERNAME environment variable not set\");\n    let password = env::var(\"LASTFM_EDIT_PASSWORD\")\n        .expect(\"LASTFM_EDIT_PASSWORD environment variable not set\");\n\n    // Check if we have a saved session with our custom manager\n    if session_manager.session_exists(\u0026username) {\n        println!(\"ğŸ“ Found existing session for user '{username}', attempting to restore...\");\n\n        match session_manager.load_session(\u0026username) {\n            Ok(session) =\u003e {\n                println!(\"ğŸ“¥ Session loaded successfully\");\n\n                // Create client with loaded session\n                let http_client = http_client::native::NativeClient::new();\n                let client = LastFmEditClientImpl::from_session(Box::new(http_client), session);\n\n                // Validate the session\n                println!(\"ğŸ” Validating session...\");\n                if client.validate_session().await {\n                    println!(\"âœ… Session is valid, using saved session\");\n\n                    // Test the session by fetching recent tracks\n                    println!(\"ğŸ§ Testing session by fetching recent tracks...\");\n                    let tracks = client.get_recent_scrobbles(1).await?;\n                    let recent_tracks: Vec\u003c_\u003e = tracks.into_iter().take(3).collect();\n                    println!(\"ğŸ“Š Found {} recent tracks:\", recent_tracks.len());\n\n                    for track in recent_tracks {\n                        println!(\"   ğŸµ {} - {}\", track.artist, track.name);\n                    }\n\n                    return Ok(());\n                } else {\n                    println!(\"âŒ Session is invalid or expired\");\n                    // Remove invalid session file\n                    let _ = session_manager.remove_session(\u0026username);\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"âŒ Failed to load session: {e}\");\n                // Remove corrupted session file\n                let _ = session_manager.remove_session(\u0026username);\n            }\n        }\n    }\n\n    // No valid session found, perform fresh login\n    println!(\"ğŸ” No valid session found, performing fresh login...\");\n    let http_client = http_client::native::NativeClient::new();\n    let client =\n        LastFmEditClientImpl::login_with_credentials(Box::new(http_client), \u0026username, \u0026password)\n            .await?;\n\n    // Save the new session with our custom manager\n    println!(\"ğŸ’¾ Saving session with custom session manager...\");\n    let session = client.get_session();\n    if let Err(e) = session_manager.save_session(\u0026session) {\n        println!(\"âš ï¸  Warning: Failed to save session: {e}\");\n        println!(\"   (You'll need to login again next time)\");\n    } else {\n        println!(\"âœ… Session saved to custom location\");\n\n        // Show the session path\n        let session_path = session_manager.get_session_path(\u0026username)?;\n        println!(\"ğŸ“‚ Session saved to: {}\", session_path.display());\n    }\n\n    // Test the new session\n    println!(\"ğŸ§ Testing session by fetching recent tracks...\");\n    let tracks = client.get_recent_scrobbles(1).await?;\n    let recent_tracks: Vec\u003c_\u003e = tracks.into_iter().take(3).collect();\n    println!(\"ğŸ“Š Found {} recent tracks:\", recent_tracks.len());\n\n    for track in recent_tracks {\n        println!(\"   ğŸµ {} - {}\", track.artist, track.name);\n    }\n\n    // Demonstrate listing saved users\n    println!(\"\\nğŸ‘¥ Listing all saved users for this app:\");\n    let saved_users = session_manager.list_saved_users()?;\n    if saved_users.is_empty() {\n        println!(\"   No saved users found\");\n    } else {\n        for user in saved_users {\n            println!(\"   - {user}\");\n        }\n    }\n\n    println!(\"\\nğŸ‰ Example completed!\");\n    println!(\"ğŸ’¡ Your custom session is saved separately from the default lastfm-edit sessions.\");\n    println!(\n        \"ğŸ’¡ Other apps using SessionManager with different names won't interfere with each other.\"\n    );\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","debug_album_url.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::Result;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    let artist = \"Radiohead\";\n    let album = \"In Rainbows\";\n\n    println!(\"=== Debug Album URL Test ===\\n\");\n    println!(\"ğŸ” Testing URL construction for album tracks...\");\n    println!(\"Artist: {artist}\");\n    println!(\"Album: {album}\\n\");\n\n    // First, let's see if the artist has albums at all\n    println!(\"1. Testing artist albums page...\");\n    match client.get_artist_albums_page(artist, 1).await {\n        Ok(albums_page) =\u003e {\n            println!(\"âœ… Found {} albums for {artist}\", albums_page.albums.len());\n            for (i, album_item) in albums_page.albums.iter().enumerate().take(5) {\n                println!(\n                    \"   [{i}] '{}' ({} plays)\",\n                    album_item.name, album_item.playcount\n                );\n            }\n        }\n        Err(e) =\u003e {\n            println!(\"âŒ Error getting albums: {e}\");\n            return Ok(());\n        }\n    }\n\n    println!(\"\\n2. Testing album tracks page...\");\n    match client.get_album_tracks_page(album, artist, 1).await {\n        Ok(tracks_page) =\u003e {\n            println!(\n                \"âœ… Album tracks page returned {} tracks\",\n                tracks_page.tracks.len()\n            );\n            println!(\"   Has next page: {}\", tracks_page.has_next_page);\n            println!(\"   Total pages: {:?}\", tracks_page.total_pages);\n            for (i, track) in tracks_page.tracks.iter().enumerate().take(10) {\n                println!(\n                    \"   [{i}] '{}' - Album: '{}'\",\n                    track.name,\n                    track.album.as_deref().unwrap_or(\"(none)\")\n                );\n            }\n        }\n        Err(e) =\u003e {\n            println!(\"âŒ Error getting album tracks: {e}\");\n        }\n    }\n\n    // Let's also test with an album we know exists from the albums list\n    println!(\"\\n3. Testing with first album from albums list...\");\n    match client.get_artist_albums_page(artist, 1).await {\n        Ok(albums_page) =\u003e {\n            if let Some(first_album) = albums_page.albums.first() {\n                println!(\"Testing with album: '{}'\", first_album.name);\n                match client\n                    .get_album_tracks_page(\u0026first_album.name, artist, 1)\n                    .await\n                {\n                    Ok(tracks_page) =\u003e {\n                        println!(\n                            \"âœ… Found {} tracks for '{}'\",\n                            tracks_page.tracks.len(),\n                            first_album.name\n                        );\n                        for (i, track) in tracks_page.tracks.iter().enumerate().take(5) {\n                            println!(\"   [{i}] '{}'\", track.name);\n                        }\n                    }\n                    Err(e) =\u003e {\n                        println!(\"âŒ Error: {e}\");\n                    }\n                }\n            } else {\n                println!(\"No albums found in list\");\n            }\n        }\n        Err(e) =\u003e {\n            println!(\"âŒ Error getting albums: {e}\");\n        }\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","list_artist_tracks.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    let artist = std::env::args()\n        .nth(1)\n        .unwrap_or_else(|| \"Queen\".to_string());\n\n    println!(\"=== Artist Tracks Listing (using Iterator) ===\\n\");\n    println!(\"ğŸµ Listing all tracks for artist: {artist}\\n\");\n\n    // Use the iterator the same way as Case 4: Artist-specific discovery\n    let mut tracks_iterator = client.artist_tracks(\u0026artist);\n    let mut track_count = 0;\n\n    println!(\"ğŸ” Fetching tracks using iterator...\\n\");\n\n    while let Some(track) = tracks_iterator.next().await? {\n        track_count += 1;\n        println!(\n            \"[{:4}] '{}' | Album: '{}' | Plays: {} | Timestamp: {:?}\",\n            track_count,\n            track.name,\n            track.album.as_deref().unwrap_or(\"(no album)\"),\n            track.playcount,\n            track.timestamp\n        );\n\n        // Limit output for testing to avoid overwhelming output\n        if track_count \u003e= 50 {\n            println!(\"\\nâš ï¸  Limiting output to first 50 tracks for testing...\");\n            break;\n        }\n    }\n\n    println!(\"\\n=== Summary ===\");\n    println!(\"ğŸ“Š Total tracks displayed: {track_count}\");\n\n    if let Some(total_pages) = tracks_iterator.total_pages() {\n        println!(\"ğŸ“„ Total pages available: {total_pages}\");\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","list_recent_tracks.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    // Parse command line arguments\n    let args: Vec\u003cString\u003e = env::args().collect();\n    let num_tracks: usize = args.get(1).and_then(|s| s.parse().ok()).unwrap_or(20);\n    let starting_page: u32 = args.get(2).and_then(|s| s.parse().ok()).unwrap_or(1);\n\n    println!(\"Fetching {num_tracks} recent tracks starting from page {starting_page}...\");\n    println!();\n\n    // Create iterator starting from the specified page\n    let mut recent_tracks = client.recent_tracks_from_page(starting_page);\n    let mut count = 0;\n\n    // Use the iterator to fetch tracks\n    while count \u003c num_tracks {\n        match recent_tracks.next().await? {\n            Some(track) =\u003e {\n                let timestamp_str = if let Some(ts) = track.timestamp {\n                    format!(\n                        \" ({})\",\n                        chrono::DateTime::from_timestamp(ts as i64, 0)\n                            .map(|dt| dt.format(\"%Y-%m-%d %H:%M:%S\").to_string())\n                            .unwrap_or_else(|| format!(\"timestamp: {ts}\"))\n                    )\n                } else {\n                    \" (no timestamp)\".to_string()\n                };\n\n                let album_str = if let Some(album) = \u0026track.album {\n                    format!(\" [{album}]\")\n                } else {\n                    \"\".to_string()\n                };\n\n                println!(\n                    \"{}. {} - {}{}{}\",\n                    count + 1,\n                    track.artist,\n                    track.name,\n                    album_str,\n                    timestamp_str\n                );\n\n                count += 1;\n            }\n            None =\u003e {\n                println!(\"No more tracks available.\");\n                break;\n            }\n        }\n    }\n\n    println!();\n    println!(\"Fetched {count} tracks total.\");\n\n    println!();\n    println!(\"Usage: cargo run --example list_recent_tracks [num_tracks] [starting_page]\");\n    println!(\"  num_tracks    - Number of tracks to fetch (default: 20)\");\n    println!(\"  starting_page - Page number to start from (default: 1)\");\n    println!();\n    println!(\"Examples:\");\n    println!(\"  cargo run --example list_recent_tracks 50     # Fetch 50 tracks from page 1\");\n    println!(\n        \"  cargo run --example list_recent_tracks 20 5   # Fetch 20 tracks starting from page 5\"\n    );\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","rate_limit_monitoring.rs"],"content":"use lastfm_edit::{ClientEvent, LastFmEditClientImpl};\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    env_logger::init();\n\n    let username =\n        env::var(\"LASTFM_EDIT_USERNAME\").expect(\"Set LASTFM_EDIT_USERNAME environment variable\");\n    let password =\n        env::var(\"LASTFM_EDIT_PASSWORD\").expect(\"Set LASTFM_EDIT_PASSWORD environment variable\");\n\n    // Login and create client\n    let http_client = http_client::native::NativeClient::new();\n    println!(\"Logging in as {username}...\");\n    let client =\n        LastFmEditClientImpl::login_with_credentials(Box::new(http_client), \u0026username, \u0026password)\n            .await?;\n\n    // Subscribe to client events before any operations\n    let mut events = client.subscribe();\n\n    // Spawn a background task to monitor events\n    let event_monitor = tokio::spawn(async move {\n        println!(\"ğŸ” Monitoring client events...\");\n        while let Ok(event) = events.recv().await {\n            match event {\n                ClientEvent::RequestStarted { request } =\u003e {\n                    println!(\"ğŸš€ Starting request: {}\", request.short_description());\n                }\n                ClientEvent::RequestCompleted {\n                    request,\n                    status_code,\n                    duration_ms,\n                } =\u003e {\n                    println!(\n                        \"âœ… Completed request: {} - {} ({} ms)\",\n                        request.short_description(),\n                        status_code,\n                        duration_ms\n                    );\n                }\n                ClientEvent::RateLimited {\n                    delay_seconds,\n                    request,\n                    rate_limit_type,\n                    rate_limit_timestamp,\n                } =\u003e {\n                    let req_desc = request\n                        .as_ref()\n                        .map(|r| r.short_description())\n                        .unwrap_or_else(|| \"unknown request\".to_string());\n                    println!(\n                        \"â³ Rate limited ({rate_limit_type:?})! {req_desc} - Waiting {delay_seconds} seconds (at timestamp {rate_limit_timestamp})\"\n                    );\n                }\n                ClientEvent::RateLimitEnded {\n                    request,\n                    rate_limit_type,\n                    total_rate_limit_duration_seconds,\n                } =\u003e {\n                    println!(\n                        \"ğŸ‰ Rate limiting ended ({rate_limit_type:?}) after {total_rate_limit_duration_seconds} seconds - {}\",\n                        request.short_description()\n                    );\n                }\n                ClientEvent::EditAttempted {\n                    edit,\n                    success,\n                    error_message,\n                    duration_ms,\n                } =\u003e {\n                    if success {\n                        println!(\n                            \"âœ… Edit succeeded: '{}' -\u003e '{}' ({duration_ms} ms)\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    } else {\n                        let error_msg = error_message\n                            .as_ref()\n                            .map(|s| format!(\" - {s}\"))\n                            .unwrap_or_default();\n                        println!(\n                            \"âŒ Edit failed: '{}' -\u003e '{}' ({duration_ms} ms){error_msg}\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    }\n                }\n            }\n        }\n    });\n\n    println!(\"âœ… Successfully logged in as: {}\", client.username());\n\n    // Check latest event after login\n    if let Some(event) = client.latest_event() {\n        match event {\n            ClientEvent::RequestStarted { request } =\u003e {\n                println!(\n                    \"ğŸ“Š Latest event: Started request {}\",\n                    request.short_description()\n                );\n            }\n            ClientEvent::RequestCompleted {\n                request,\n                status_code,\n                duration_ms,\n            } =\u003e {\n                println!(\n                    \"ğŸ“Š Latest event: Completed request {} - {} ({} ms)\",\n                    request.short_description(),\n                    status_code,\n                    duration_ms\n                );\n            }\n            ClientEvent::RateLimited {\n                delay_seconds,\n                request,\n                rate_limit_type,\n                rate_limit_timestamp,\n            } =\u003e {\n                let req_desc = request\n                    .as_ref()\n                    .map(|r| r.short_description())\n                    .unwrap_or_else(|| \"unknown request\".to_string());\n                println!(\n                    \"ğŸ“Š Latest event: Rate limited ({rate_limit_type:?}) for {delay_seconds} seconds - {req_desc} (at timestamp {rate_limit_timestamp})\"\n                );\n            }\n            ClientEvent::RateLimitEnded {\n                request,\n                rate_limit_type,\n                total_rate_limit_duration_seconds,\n            } =\u003e {\n                println!(\n                    \"ğŸ“Š Latest event: Rate limiting ended ({rate_limit_type:?}) after {total_rate_limit_duration_seconds} seconds - {}\",\n                    request.short_description()\n                );\n            }\n            ClientEvent::EditAttempted {\n                edit,\n                success,\n                error_message,\n                duration_ms,\n            } =\u003e {\n                if success {\n                    println!(\n                        \"ğŸ“Š Latest event: Edit succeeded '{}' -\u003e '{}' ({duration_ms} ms)\",\n                        edit.track_name_original, edit.track_name\n                    );\n                } else {\n                    let error_msg = error_message\n                        .as_ref()\n                        .map(|s| format!(\" - {s}\"))\n                        .unwrap_or_default();\n                    println!(\n                        \"ğŸ“Š Latest event: Edit failed '{}' -\u003e '{}' ({duration_ms} ms){error_msg}\",\n                        edit.track_name_original, edit.track_name\n                    );\n                }\n            }\n        }\n    } else {\n        println!(\"ğŸ“Š No events have occurred yet\");\n    }\n\n    // Make some requests that might trigger rate limiting\n    println!(\"ğŸµ Fetching recent tracks to potentially trigger rate limiting...\");\n\n    for page in 1..=3 {\n        println!(\"ğŸ“„ Fetching page {page}...\");\n        match client.get_recent_scrobbles(page).await {\n            Ok(tracks) =\u003e {\n                println!(\"âœ… Got {} tracks from page {page}\", tracks.len());\n            }\n            Err(e) =\u003e {\n                println!(\"âŒ Error on page {page}: {e}\");\n            }\n        }\n\n        // Check if we're currently rate limited\n        if let Some(ClientEvent::RateLimited { delay_seconds, .. }) = client.latest_event() {\n            println!(\n                \"ğŸ›‘ Currently rate limited for {delay_seconds} seconds according to latest event\"\n            );\n        }\n\n        // Small delay between requests\n        tokio::time::sleep(std::time::Duration::from_millis(500)).await;\n    }\n\n    println!(\"ğŸ Done! Event monitor will continue running...\");\n\n    // Let the event monitor run for a bit longer to catch any final events\n    tokio::time::sleep(std::time::Duration::from_secs(2)).await;\n\n    // Cancel the event monitor\n    event_monitor.abort();\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","remove_remaster.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\nuse regex::Regex;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    println!(\"=== Remaster \u0026 Year Removal Tool ===\\n\");\n    println!(\"ğŸ¯ This will remove 'remastered' text and year suffixes from track names\");\n    println!(\"ğŸ“ Patterns include: '- 2009', '(2009)', '[2009]', '- Remaster', etc.\\n\");\n\n    let artist = std::env::args()\n        .nth(1)\n        .unwrap_or_else(|| \"The Beatles\".to_string());\n\n    println!(\"ğŸµ Processing tracks for artist: {artist}\\n\");\n\n    // Regex patterns to clean up remaster text and year suffixes\n    // Note: Order matters! More specific patterns should come first\n    let remaster_patterns = vec![\n        // Patterns with \"remaster\" word (most specific)\n        // \"Track Name - 2009 Remaster\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*-\\s*\\d{4}\\s*remaster(ed)?.*$\").unwrap(),\n        // \"Track Name - Remaster\" or \"Track Name - Remastered\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*-\\s*remaster(ed)?.*$\").unwrap(),\n        // \"Track Name (2009 Remaster)\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*\\(\\d{4}\\s*remaster(ed)?.*\\)\\s*$\").unwrap(),\n        // \"Track Name (Remaster)\" or \"Track Name (Remastered)\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*\\(remaster(ed)?.*\\)\\s*$\").unwrap(),\n        // \"Track Name [2009 Remaster]\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*\\[\\d{4}\\s*remaster(ed)?.*\\]\\s*$\").unwrap(),\n        // \"Track Name [Remaster]\" or \"Track Name [Remastered]\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*\\[remaster(ed)?.*\\]\\s*$\").unwrap(),\n        // \"Track Name Remastered\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*remaster(ed)?\\s*(\\d{4})?\\s*$\").unwrap(),\n        // Years that are likely remaster years (1980-2030) - be more conservative\n        // \"Track Name - 2009\" -\u003e \"Track Name\" (only for likely remaster years)\n        Regex::new(r\"(?i)\\s*-\\s*(19[8-9]\\d|20[0-3]\\d)\\s*$\").unwrap(),\n        // \"Track Name (2009)\" -\u003e \"Track Name\" (only for likely remaster years)\n        Regex::new(r\"(?i)\\s*\\((19[8-9]\\d|20[0-3]\\d)\\)\\s*$\").unwrap(),\n        // \"Track Name [2009]\" -\u003e \"Track Name\" (only for likely remaster years)\n        Regex::new(r\"(?i)\\s*\\[(19[8-9]\\d|20[0-3]\\d)\\]\\s*$\").unwrap(),\n        // Other common suffixes that should be removed\n        // \"Track Name - 2019 Mix\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*-\\s*\\d{4}\\s*mix.*$\").unwrap(),\n        // \"Track Name - Mix\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*-\\s*mix.*$\").unwrap(),\n    ];\n\n    // First, collect some tracks to process\n    let mut tracks_to_process = Vec::new();\n    let mut fetched_count = 0;\n    let mut page = 1;\n\n    loop {\n        match client.get_artist_tracks_page(\u0026artist, page).await {\n            Ok(track_page) =\u003e {\n                if track_page.tracks.is_empty() {\n                    println!(\"\\nğŸ“š Fetched all {fetched_count} tracks for {artist}\");\n                    break;\n                }\n\n                for track in track_page.tracks {\n                    fetched_count += 1;\n                    println!(\"ğŸ” [{:3}] Found track: '{}'\", fetched_count, track.name);\n\n                    // Check if track name contains remaster text\n                    let mut cleaned_name = track.name.clone();\n                    let mut needs_cleaning = false;\n\n                    for pattern in \u0026remaster_patterns {\n                        if pattern.is_match(\u0026cleaned_name) {\n                            cleaned_name = pattern.replace(\u0026cleaned_name, \"\").trim().to_string();\n                            needs_cleaning = true;\n                        }\n                    }\n\n                    if needs_cleaning \u0026\u0026 !cleaned_name.is_empty() {\n                        tracks_to_process.push((track, cleaned_name));\n                    }\n                }\n\n                if !track_page.has_next_page {\n                    println!(\"\\nğŸ“š Fetched all {fetched_count} tracks for {artist}\");\n                    break;\n                }\n\n                page += 1;\n            }\n            Err(e) =\u003e {\n                println!(\"âŒ Error fetching tracks page {page}: {e}\");\n                break;\n            }\n        }\n    }\n\n    println!(\n        \"\\nğŸ§¹ Starting remaster removal on {} tracks...\\n\",\n        tracks_to_process.len()\n    );\n\n    let mut processed_count = 0;\n    let mut edits_made = 0;\n    let mut rate_limit_hits = 0;\n\n    // Now process the collected tracks\n    for (track, cleaned_name) in tracks_to_process {\n        processed_count += 1;\n        println!(\n            \"ğŸ”§ [{:3}] Processing: '{}' -\u003e '{}'\",\n            processed_count, track.name, cleaned_name\n        );\n        println!(\"   ğŸ”„ Applying change...\");\n\n        // Load edit form - this makes an HTTP request\n        let edit_template =\n            lastfm_edit::ScrobbleEdit::from_track_and_artist(\u0026track.name, \u0026track.artist);\n        match client\n            .discover_scrobble_edit_variations(\u0026edit_template)\n            .await\n        {\n            Ok(exact_edit_vec) =\u003e {\n                if let Some(exact_edit) = exact_edit_vec.into_iter().next() {\n                    let mut edit_data = exact_edit.to_scrobble_edit();\n                    // Update track name\n                    edit_data.track_name = Some(cleaned_name.clone());\n\n                    // Submit edit - another HTTP request\n                    match client.edit_scrobble(\u0026edit_data).await {\n                        Ok(_) =\u003e {\n                            edits_made += 1;\n                            println!(\"   âœ… Successfully cleaned track\");\n                        }\n                        Err(e) =\u003e {\n                            println!(\"   âŒ Error editing track: {e}\");\n                            if e.to_string().contains(\"RateLimit\") {\n                                rate_limit_hits += 1;\n                                log::info!(\"Rate limit encountered during edit operation for track '{}' by '{}'\", track.name, track.artist);\n                                println!(\"   ğŸš¨ RATE LIMIT DETECTED during edit operation!\");\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    println!(\"   âš ï¸  No edit data found for track\");\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"   âš ï¸  Couldn't load edit form: {e}\");\n                if e.to_string().contains(\"RateLimit\") {\n                    rate_limit_hits += 1;\n                    log::info!(\n                        \"Rate limit encountered during form load for track '{}' by '{}'\",\n                        track.name,\n                        track.artist\n                    );\n                    println!(\"   ğŸš¨ RATE LIMIT DETECTED during form load!\");\n                    break;\n                }\n            }\n        }\n    }\n\n    println!(\"\\n=== Summary ===\");\n    println!(\"ğŸ“Š Tracks processed: {processed_count}\");\n    println!(\"âœï¸  Edits made: {edits_made}\");\n    println!(\"ğŸš¨ Rate limit hits: {rate_limit_hits}\");\n\n    if rate_limit_hits \u003e 0 {\n        println!(\"\\nğŸ¯ Rate limiting was triggered.\");\n    } else {\n        println!(\"\\nâœ¨ All changes completed successfully!\");\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","rename_album.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let args: Vec\u003cString\u003e = env::args().collect();\n\n    if args.len() != 4 {\n        eprintln!(\"Usage: cargo run --example rename_album -- \\\"Old Album Name\\\" \\\"New Album Name\\\" \\\"Artist Name\\\"\");\n        eprintln!(\"Example: cargo run --example rename_album -- \\\"Abbey Road - Remastered 2019\\\" \\\"Abbey Road\\\" \\\"The Beatles\\\"\");\n        std::process::exit(1);\n    }\n\n    let old_album_name = \u0026args[1];\n    let new_album_name = \u0026args[2];\n    let artist_name = \u0026args[3];\n\n    let client = common::setup_client().await?;\n\n    println!(\"=== Album Rename Tool ===\\n\");\n    println!(\"ğŸ¨ Artist: {artist_name}\");\n    println!(\"ğŸ’¿ Renaming: '{old_album_name}' â†’ '{new_album_name}'\");\n    println!();\n\n    println!(\"ğŸ” Loading album edit form data...\");\n    match client\n        .edit_album(old_album_name, new_album_name, artist_name)\n        .await\n    {\n        Ok(_response) =\u003e {\n            println!(\"âœ… Successfully renamed album!\");\n            println!(\"   From: '{old_album_name}'\");\n            println!(\"   To:   '{new_album_name}'\");\n            println!(\"   Artist: {artist_name}\");\n            println!(\n                \"\\nğŸ’¡ All scrobbles from this album have been updated with the new album name.\"\n            );\n        }\n        Err(e) =\u003e {\n            println!(\"âŒ Failed to rename album: {e}\");\n            println!(\"\\nThis might happen if:\");\n            println!(\"   â€¢ The album hasn't been scrobbled recently\");\n            println!(\"   â€¢ The album name doesn't match exactly\");\n            println!(\"   â€¢ There are temporary server issues\");\n        }\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","rename_artist.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::Result;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let mut client = common::setup_client().await?;\n\n    let args: Vec\u003cString\u003e = std::env::args().collect();\n    if args.len() \u003c 4 {\n        eprintln!(\"Usage:\");\n        eprintln!(\"  {} all \u003cold_artist\u003e \u003cnew_artist\u003e\", args[0]);\n        eprintln!(\"  {} track \u003ctrack_name\u003e \u003cold_artist\u003e \u003cnew_artist\u003e\", args[0]);\n        eprintln!(\"  {} album \u003calbum_name\u003e \u003cold_artist\u003e \u003cnew_artist\u003e\", args[0]);\n        eprintln!();\n        eprintln!(\"Examples:\");\n        eprintln!(\"  {} all \\\"The Beatles\\\" \\\"Beatles\\\"\", args[0]);\n        eprintln!(\n            \"  {} track \\\"Hey Jude\\\" \\\"The Beatles\\\" \\\"Beatles\\\"\",\n            args[0]\n        );\n        eprintln!(\n            \"  {} album \\\"Abbey Road\\\" \\\"The Beatles\\\" \\\"Beatles\\\"\",\n            args[0]\n        );\n        std::process::exit(1);\n    }\n\n    let mode = \u0026args[1];\n\n    match mode.as_str() {\n        \"all\" =\u003e {\n            if args.len() != 4 {\n                eprintln!(\"Usage: {} all \u003cold_artist\u003e \u003cnew_artist\u003e\", args[0]);\n                std::process::exit(1);\n            }\n            let old_artist = \u0026args[2];\n            let new_artist = \u0026args[3];\n            rename_all_tracks(\u0026mut client, old_artist, new_artist).await\n        }\n        \"track\" =\u003e {\n            if args.len() != 5 {\n                eprintln!(\n                    \"Usage: {} track \u003ctrack_name\u003e \u003cold_artist\u003e \u003cnew_artist\u003e\",\n                    args[0]\n                );\n                std::process::exit(1);\n            }\n            let track_name = \u0026args[2];\n            let old_artist = \u0026args[3];\n            let new_artist = \u0026args[4];\n            rename_single_track(\u0026mut client, track_name, old_artist, new_artist).await\n        }\n        \"album\" =\u003e {\n            if args.len() != 5 {\n                eprintln!(\n                    \"Usage: {} album \u003calbum_name\u003e \u003cold_artist\u003e \u003cnew_artist\u003e\",\n                    args[0]\n                );\n                std::process::exit(1);\n            }\n            let album_name = \u0026args[2];\n            let old_artist = \u0026args[3];\n            let new_artist = \u0026args[4];\n            rename_album_tracks(\u0026mut client, album_name, old_artist, new_artist).await\n        }\n        _ =\u003e {\n            eprintln!(\"Invalid mode '{mode}'. Use 'all', 'track', or 'album'\");\n            std::process::exit(1);\n        }\n    }\n}\n\nasync fn rename_all_tracks(\n    client: \u0026mut dyn lastfm_edit::LastFmEditClient,\n    old_artist: \u0026str,\n    new_artist: \u0026str,\n) -\u003e Result\u003c()\u003e {\n    println!(\"=== Artist Rename Tool - All Tracks ===\\n\");\n    println!(\"ğŸ¯ This will rename ALL tracks from one artist to another\");\n    println!(\"ğŸ“ Old artist: '{old_artist}'\");\n    println!(\"ğŸ“ New artist: '{new_artist}'\");\n    println!(\"âš ï¸  This will edit ALL tracks that are found in your recent scrobbles!\\n\");\n\n    if !confirm_operation()? {\n        return Ok(());\n    }\n\n    println!(\"\\nğŸ” Starting artist rename operation...\\n\");\n\n    match client.edit_artist(old_artist, new_artist).await {\n        Ok(response) =\u003e print_result(response),\n        Err(e) =\u003e println!(\"âŒ Error during artist rename: {e}\"),\n    }\n\n    Ok(())\n}\n\nasync fn rename_single_track(\n    client: \u0026mut dyn lastfm_edit::LastFmEditClient,\n    track_name: \u0026str,\n    old_artist: \u0026str,\n    new_artist: \u0026str,\n) -\u003e Result\u003c()\u003e {\n    println!(\"=== Artist Rename Tool - Single Track ===\\n\");\n    println!(\"ğŸ¯ This will rename the artist for a specific track\");\n    println!(\"ğŸµ Track: '{track_name}'\");\n    println!(\"ğŸ“ Old artist: '{old_artist}'\");\n    println!(\"ğŸ“ New artist: '{new_artist}'\");\n    println!(\"âš ï¸  This will only edit this specific track if found in recent scrobbles!\\n\");\n\n    if !confirm_operation()? {\n        return Ok(());\n    }\n\n    println!(\"\\nğŸ” Starting track artist rename...\\n\");\n\n    match client\n        .edit_artist_for_track(track_name, old_artist, new_artist)\n        .await\n    {\n        Ok(response) =\u003e print_result(response),\n        Err(e) =\u003e println!(\"âŒ Error during track artist rename: {e}\"),\n    }\n\n    Ok(())\n}\n\nasync fn rename_album_tracks(\n    client: \u0026mut dyn lastfm_edit::LastFmEditClient,\n    album_name: \u0026str,\n    old_artist: \u0026str,\n    new_artist: \u0026str,\n) -\u003e Result\u003c()\u003e {\n    println!(\"=== Artist Rename Tool - Album Tracks ===\\n\");\n    println!(\"ğŸ¯ This will rename the artist for all tracks in a specific album\");\n    println!(\"ğŸ’¿ Album: '{album_name}'\");\n    println!(\"ğŸ“ Old artist: '{old_artist}'\");\n    println!(\"ğŸ“ New artist: '{new_artist}'\");\n    println!(\"âš ï¸  This will edit all tracks in this album that are found in recent scrobbles!\\n\");\n\n    if !confirm_operation()? {\n        return Ok(());\n    }\n\n    println!(\"\\nğŸ” Starting album artist rename...\\n\");\n\n    match client\n        .edit_artist_for_album(album_name, old_artist, new_artist)\n        .await\n    {\n        Ok(response) =\u003e print_result(response),\n        Err(e) =\u003e println!(\"âŒ Error during album artist rename: {e}\"),\n    }\n\n    Ok(())\n}\n\nfn confirm_operation() -\u003e Result\u003cbool\u003e {\n    print!(\"Are you sure you want to continue? [y/N]: \");\n    std::io::Write::flush(\u0026mut std::io::stdout()).unwrap();\n\n    let mut input = String::new();\n    std::io::stdin().read_line(\u0026mut input).unwrap();\n    let response = input.trim().to_lowercase();\n\n    if response != \"y\" \u0026\u0026 response != \"yes\" {\n        println!(\"Operation cancelled.\");\n        return Ok(false);\n    }\n\n    Ok(true)\n}\n\nfn print_result(response: lastfm_edit::EditResponse) {\n    if response.success() {\n        println!(\"âœ… Success!\");\n        if let Some(message) = response.message() {\n            println!(\"ğŸ“‹ {message}\");\n        }\n    } else {\n        println!(\"âŒ Operation failed\");\n        if let Some(message) = response.message() {\n            println!(\"ğŸ“‹ {message}\");\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","save_album_response.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::Result;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    // Test the URL construction manually to see what's wrong\n    let artist = \"Radiohead\";\n    let album = \"In Rainbows\";\n\n    // Get the session details to construct URLs manually\n    let session = client.get_session();\n    println!(\"Username: {}\", session.username);\n    println!(\"Base URL: {}\", session.base_url);\n\n    // Construct the URL we're using\n    let url = format!(\n        \"{}/user/{}/library/music/{}/{}/+tracks?page=1\u0026ajax=true\",\n        session.base_url,\n        session.username,\n        artist.replace(\" \", \"+\"),\n        album.replace(\" \", \"+\")\n    );\n\n    println!(\"Constructed URL: {url}\");\n\n    // Let's also try some variations (manually encoded):\n    let artist_encoded = artist.replace(\" \", \"%20\");\n    let album_encoded = album.replace(\" \", \"%20\");\n    let url_encoded = format!(\n        \"{}/user/{}/library/music/{}/{}/+tracks?page=1\u0026ajax=true\",\n        session.base_url, session.username, artist_encoded, album_encoded\n    );\n\n    println!(\"URL encoded version: {url_encoded}\");\n\n    // Test with a manually constructed HTTP client to see what we get\n    println!(\"\\nMaking direct HTTP request to see response...\");\n\n    // Make the request using the client's internal HTTP client\n    // We'll access this by making the client call directly and examining response\n    match client.get_album_tracks_page(album, artist, 1).await {\n        Ok(tracks_page) =\u003e {\n            println!(\"Success: {} tracks\", tracks_page.tracks.len());\n        }\n        Err(e) =\u003e {\n            println!(\"Error: {e}\");\n        }\n    }\n\n    // Let's also check what a working artist tracks URL looks like for comparison\n    let artist_tracks_url = format!(\n        \"{}/user/{}/library/music/{}/+tracks?page=1\u0026ajax=true\",\n        session.base_url,\n        session.username,\n        artist.replace(\" \", \"+\")\n    );\n    println!(\"Artist tracks URL (working): {artist_tracks_url}\");\n\n    // And albums URL\n    let artist_albums_url = format!(\n        \"{}/user/{}/library/music/{}/+albums?page=1\u0026ajax=true\",\n        session.base_url,\n        session.username,\n        artist.replace(\" \", \"+\")\n    );\n    println!(\"Artist albums URL (working): {artist_albums_url}\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","session_event_sharing.rs"],"content":"use lastfm_edit::{ClientEvent, LastFmEditClientImpl};\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    env_logger::init();\n\n    let username =\n        env::var(\"LASTFM_EDIT_USERNAME\").expect(\"Set LASTFM_EDIT_USERNAME environment variable\");\n    let password =\n        env::var(\"LASTFM_EDIT_PASSWORD\").expect(\"Set LASTFM_EDIT_PASSWORD environment variable\");\n\n    println!(\"ğŸ”§ Demonstrating shared event broadcasting between clients...\");\n\n    // Create HTTP client and login to create first client\n    let http_client = http_client::native::NativeClient::new();\n    println!(\"ğŸ” Logging in with client1...\");\n    let client1 =\n        LastFmEditClientImpl::login_with_credentials(Box::new(http_client), \u0026username, \u0026password)\n            .await?;\n    println!(\"âœ… Successfully logged in as: {}\", client1.username());\n\n    // Create a second client that shares the broadcaster with client1\n    let http_client2 = http_client::native::NativeClient::new();\n    let client2 = client1.with_shared_broadcaster(Box::new(http_client2));\n    println!(\"ğŸ”„ Created client2 with shared broadcaster from client1\");\n\n    // Subscribe to events from both clients\n    let mut events1 = client1.subscribe();\n    let mut events2 = client2.subscribe();\n    println!(\"ğŸ“¡ Subscribed to events from both clients\");\n\n    // Spawn background tasks to monitor events from each client\n    let monitor1 = tokio::spawn(async move {\n        println!(\"ğŸ” Client1 monitor started\");\n        while let Ok(event) = events1.recv().await {\n            match event {\n                ClientEvent::RequestStarted { request } =\u003e {\n                    println!(\n                        \"ğŸš€ Client1 monitor: Started request {}\",\n                        request.short_description()\n                    );\n                }\n                ClientEvent::RequestCompleted {\n                    request,\n                    status_code,\n                    duration_ms,\n                } =\u003e {\n                    println!(\n                        \"âœ… Client1 monitor: Completed {} - {} ({} ms)\",\n                        request.short_description(),\n                        status_code,\n                        duration_ms\n                    );\n                }\n                ClientEvent::RateLimited {\n                    delay_seconds,\n                    request,\n                    rate_limit_type,\n                    rate_limit_timestamp,\n                } =\u003e {\n                    let req_desc = request\n                        .as_ref()\n                        .map(|r| r.short_description())\n                        .unwrap_or_else(|| \"unknown request\".to_string());\n                    println!(\n                        \"â³ Client1 monitor: Rate limited ({rate_limit_type:?}) for {delay_seconds} seconds - {req_desc} (at timestamp {rate_limit_timestamp})\"\n                    );\n                }\n                ClientEvent::RateLimitEnded {\n                    request,\n                    rate_limit_type,\n                    total_rate_limit_duration_seconds,\n                } =\u003e {\n                    println!(\n                        \"ğŸ‰ Client1 monitor: Rate limiting ended ({rate_limit_type:?}) after {total_rate_limit_duration_seconds} seconds - {}\",\n                        request.short_description()\n                    );\n                }\n                ClientEvent::EditAttempted {\n                    edit,\n                    success,\n                    error_message,\n                    duration_ms,\n                } =\u003e {\n                    if success {\n                        println!(\n                            \"âœ… Client1 monitor: Edit succeeded '{}' -\u003e '{}' ({duration_ms} ms)\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    } else {\n                        let error_msg = error_message\n                            .as_ref()\n                            .map(|s| format!(\" - {s}\"))\n                            .unwrap_or_default();\n                        println!(\n                            \"âŒ Client1 monitor: Edit failed '{}' -\u003e '{}' ({duration_ms} ms){error_msg}\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    }\n                }\n            }\n        }\n    });\n\n    let monitor2 = tokio::spawn(async move {\n        println!(\"ğŸ” Client2 monitor started\");\n        while let Ok(event) = events2.recv().await {\n            match event {\n                ClientEvent::RequestStarted { request } =\u003e {\n                    println!(\n                        \"ğŸš€ Client2 monitor: Started request {}\",\n                        request.short_description()\n                    );\n                }\n                ClientEvent::RequestCompleted {\n                    request,\n                    status_code,\n                    duration_ms,\n                } =\u003e {\n                    println!(\n                        \"âœ… Client2 monitor: Completed {} - {} ({} ms)\",\n                        request.short_description(),\n                        status_code,\n                        duration_ms\n                    );\n                }\n                ClientEvent::RateLimited {\n                    delay_seconds,\n                    request,\n                    rate_limit_type,\n                    rate_limit_timestamp,\n                } =\u003e {\n                    let req_desc = request\n                        .as_ref()\n                        .map(|r| r.short_description())\n                        .unwrap_or_else(|| \"unknown request\".to_string());\n                    println!(\n                        \"â³ Client2 monitor: Rate limited ({rate_limit_type:?}) for {delay_seconds} seconds - {req_desc} (at timestamp {rate_limit_timestamp})\"\n                    );\n                }\n                ClientEvent::RateLimitEnded {\n                    request,\n                    rate_limit_type,\n                    total_rate_limit_duration_seconds,\n                } =\u003e {\n                    println!(\n                        \"ğŸ‰ Client2 monitor: Rate limiting ended ({rate_limit_type:?}) after {total_rate_limit_duration_seconds} seconds - {}\",\n                        request.short_description()\n                    );\n                }\n                ClientEvent::EditAttempted {\n                    edit,\n                    success,\n                    error_message,\n                    duration_ms,\n                } =\u003e {\n                    if success {\n                        println!(\n                            \"âœ… Client2 monitor: Edit succeeded '{}' -\u003e '{}' ({duration_ms} ms)\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    } else {\n                        let error_msg = error_message\n                            .as_ref()\n                            .map(|s| format!(\" - {s}\"))\n                            .unwrap_or_default();\n                        println!(\n                            \"âŒ Client2 monitor: Edit failed '{}' -\u003e '{}' ({duration_ms} ms){error_msg}\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    }\n                }\n            }\n        }\n    });\n\n    // Make a request with client1 that might trigger rate limiting\n    println!(\"ğŸ“¡ Making request with client1...\");\n    match client1.get_recent_scrobbles(1).await {\n        Ok(tracks) =\u003e {\n            println!(\"âœ… Client1 got {} tracks\", tracks.len());\n        }\n        Err(e) =\u003e {\n            println!(\"âš ï¸ Client1 error: {e}\");\n        }\n    }\n\n    // Check latest event from both clients (should be the same due to shared broadcaster)\n    let event1 = client1.latest_event();\n    let event2 = client2.latest_event();\n\n    match (event1, event2) {\n        (\n            Some(ClientEvent::RateLimited {\n                delay_seconds: delay1,\n                ..\n            }),\n            Some(ClientEvent::RateLimited {\n                delay_seconds: delay2,\n                ..\n            }),\n        ) =\u003e {\n            println!(\"ğŸ¯ Both clients show rate limiting: {delay1}s and {delay2}s\");\n            if delay1 == delay2 {\n                println!(\n                    \"âœ… SUCCESS: Both clients report the same delay (shared broadcaster working!)\"\n                );\n            } else {\n                println!(\"âŒ UNEXPECTED: Different delays reported\");\n            }\n        }\n        (\n            Some(ClientEvent::RequestCompleted { .. }),\n            Some(ClientEvent::RequestCompleted { .. }),\n        ) =\u003e {\n            println!(\"âœ… Both clients show completed requests (shared broadcaster working!)\");\n        }\n        (\n            Some(ClientEvent::EditAttempted {\n                success: success1, ..\n            }),\n            Some(ClientEvent::EditAttempted {\n                success: success2, ..\n            }),\n        ) =\u003e {\n            if success1 == success2 {\n                println!(\"âœ… Both clients show same edit result (shared broadcaster working!)\");\n            } else {\n                println!(\"âŒ UNEXPECTED: Different edit results reported\");\n            }\n        }\n        (None, None) =\u003e {\n            println!(\"ğŸ“Š No events occurred yet - this is normal\");\n            println!(\"    In real usage, both clients would see the same events when they occur\");\n        }\n        _ =\u003e {\n            println!(\"ğŸ“Š Different event states between clients (could be due to timing)\");\n        }\n    }\n\n    // Let monitors run for a bit\n    tokio::time::sleep(std::time::Duration::from_secs(1)).await;\n\n    // Clean up\n    monitor1.abort();\n    monitor2.abort();\n\n    println!(\"ğŸ Demo completed!\");\n\n    println!(\"\\nğŸ“„ Key Points:\");\n    println!(\"  â€¢ client1.with_shared_broadcaster() creates clients that share event broadcasting\");\n    println!(\"  â€¢ When any shared client encounters rate limiting, all see the same events\");\n    println!(\"  â€¢ Use this pattern when you need multiple HTTP clients but want unified rate limit handling\");\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","session_management.rs"],"content":"/// Example demonstrating both login and session restore initialization methods.\n///\n/// This example shows how to:\n/// 1. Initialize a client with username/password login\n/// 2. Save the session state to a file\n/// 3. Restore the session from the saved file\n/// 4. Use both initialization patterns\n///\n/// Usage:\n///   # First run - will prompt for credentials and save session\n///   direnv exec . cargo run --example session_management\n///\n///   # Subsequent runs - will use saved session\n///   direnv exec . cargo run --example session_management\nuse lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, Result};\nuse std::env;\nuse std::fs;\nuse std::io::{self, Write};\nuse std::path::Path;\n\nconst SESSION_FILE: \u0026str = \"session.json\";\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    env_logger::init();\n\n    println!(\"ğŸµ Last.fm Session Management Example\");\n    println!(\"=====================================\\n\");\n\n    // Try to load existing session first\n    if Path::new(SESSION_FILE).exists() {\n        println!(\"ğŸ“ Found existing session file, attempting to restore...\");\n        match restore_from_session().await {\n            Ok(client) =\u003e {\n                println!(\"âœ… Session restored successfully!\");\n                println!(\"ğŸ‘¤ Logged in as: {}\", client.username());\n\n                // Test the restored session by fetching recent tracks\n                println!(\"ğŸ§ Testing session by fetching recent tracks...\");\n                let tracks = client.get_recent_scrobbles(1).await?;\n                let recent_tracks: Vec\u003c_\u003e = tracks.into_iter().take(3).collect();\n                println!(\"ğŸ“Š Found {} recent tracks:\", recent_tracks.len());\n\n                for track in recent_tracks {\n                    println!(\"   ğŸµ {} - {}\", track.artist, track.name);\n                }\n\n                return Ok(());\n            }\n            Err(e) =\u003e {\n                println!(\"âŒ Failed to restore session: {e}\");\n                println!(\"ğŸ”„ Falling back to fresh login...\\n\");\n                // Remove invalid session file\n                let _ = fs::remove_file(SESSION_FILE);\n            }\n        }\n    }\n\n    // No valid session found, perform fresh login\n    println!(\"ğŸ”‘ No valid session found, performing fresh login...\");\n    let client = login_with_credentials().await?;\n    println!(\"âœ… Login successful!\");\n    println!(\"ğŸ‘¤ Logged in as: {}\", client.username());\n\n    // Save session for future use\n    println!(\"ğŸ’¾ Saving session to {SESSION_FILE}...\");\n    save_session(\u0026client)?;\n    println!(\"âœ… Session saved!\");\n\n    // Test the new session\n    println!(\"ğŸ§ Testing session by fetching recent tracks...\");\n    let tracks = client.get_recent_scrobbles(1).await?;\n    let recent_tracks: Vec\u003c_\u003e = tracks.into_iter().take(3).collect();\n    println!(\"ğŸ“Š Found {} recent tracks:\", recent_tracks.len());\n\n    for track in recent_tracks {\n        println!(\"   ğŸµ {} - {}\", track.artist, track.name);\n    }\n\n    println!(\"\\nğŸ‰ Example completed!\");\n    println!(\"ğŸ’¡ Next time you run this example, it will use the saved session automatically.\");\n\n    Ok(())\n}\n\n/// Restore client from saved session file\nasync fn restore_from_session() -\u003e Result\u003cLastFmEditClientImpl\u003e {\n    let session_json = fs::read_to_string(SESSION_FILE)\n        .map_err(|e| lastfm_edit::LastFmError::Http(format!(\"Failed to read session file: {e}\")))?;\n\n    let session = LastFmEditSession::from_json(\u0026session_json)\n        .map_err(|e| lastfm_edit::LastFmError::Http(format!(\"Failed to parse session: {e}\")))?;\n\n    if !session.is_valid() {\n        return Err(lastfm_edit::LastFmError::Auth(\n            \"Invalid session data\".to_string(),\n        ));\n    }\n\n    let http_client = http_client::native::NativeClient::new();\n    Ok(LastFmEditClientImpl::from_session(\n        Box::new(http_client),\n        session,\n    ))\n}\n\n/// Perform fresh login with credentials\nasync fn login_with_credentials() -\u003e Result\u003cLastFmEditClientImpl\u003e {\n    println!(\"ğŸ”§ Using login with credentials pattern...\");\n    let username = get_username();\n    let password = get_password();\n\n    let http_client = http_client::native::NativeClient::new();\n    LastFmEditClientImpl::login_with_credentials(Box::new(http_client), \u0026username, \u0026password).await\n}\n\n/// Save current session to file\nfn save_session(client: \u0026dyn LastFmEditClient) -\u003e Result\u003c()\u003e {\n    let session = client.get_session();\n    let session_json = session\n        .to_json()\n        .map_err(|e| lastfm_edit::LastFmError::Http(format!(\"Failed to serialize session: {e}\")))?;\n\n    fs::write(SESSION_FILE, session_json).map_err(|e| {\n        lastfm_edit::LastFmError::Http(format!(\"Failed to write session file: {e}\"))\n    })?;\n\n    Ok(())\n}\n\n/// Get username from environment variable or prompt\nfn get_username() -\u003e String {\n    env::var(\"LASTFM_EDIT_USERNAME\").unwrap_or_else(|_| {\n        print!(\"Last.fm username: \");\n        io::stdout().flush().unwrap();\n        let mut input = String::new();\n        io::stdin().read_line(\u0026mut input).unwrap();\n        input.trim().to_string()\n    })\n}\n\n/// Get password from environment variable or prompt\nfn get_password() -\u003e String {\n    env::var(\"LASTFM_EDIT_PASSWORD\").unwrap_or_else(|_| {\n        print!(\"Last.fm password: \");\n        io::stdout().flush().unwrap();\n        let mut input = String::new();\n        io::stdin().read_line(\u0026mut input).unwrap();\n        input.trim().to_string()\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","shared","common.rs"],"content":"use lastfm_edit::{LastFmEditClientImpl, Result};\nuse std::env;\n\npub async fn setup_client() -\u003e Result\u003cLastFmEditClientImpl\u003e {\n    // Initialize logger to handle log::debug! calls\n    env_logger::init();\n\n    let username = env::var(\"LASTFM_EDIT_USERNAME\")\n        .expect(\"LASTFM_EDIT_USERNAME environment variable not set\");\n    let password = env::var(\"LASTFM_EDIT_PASSWORD\")\n        .expect(\"LASTFM_EDIT_PASSWORD environment variable not set\");\n\n    // Login and create client\n    let http_client = http_client::native::NativeClient::new();\n    println!(\"Logging in as {username}...\");\n    let client =\n        LastFmEditClientImpl::login_with_credentials(Box::new(http_client), \u0026username, \u0026password)\n            .await?;\n    println!(\"âœ“ Logged in successfully\");\n\n    Ok(client)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","smart_scrobble_display.rs"],"content":"use lastfm_edit::{ExactScrobbleEdit, ScrobbleEdit};\n\nfn main() {\n    println!(\"=== Smart ScrobbleEdit Display Examples ===\\n\");\n\n    // Example 1: Only changing the artist name\n    let edit1 = ScrobbleEdit {\n        artist_name_original: \"The Beatles\".to_string(),\n        track_name_original: Some(\"Yesterday\".to_string()),\n        album_name_original: Some(\"Help!\".to_string()),\n        album_artist_name_original: None,\n\n        artist_name: \"Beatles, The\".to_string(),   // Changed\n        track_name: Some(\"Yesterday\".to_string()), // Same\n        album_name: Some(\"Help!\".to_string()),     // Same\n        album_artist_name: None,                   // Same\n\n        timestamp: None,\n        edit_all: false,\n    };\n    println!(\"ğŸ“ Artist name change:\");\n    println!(\"   {edit1}\");\n\n    // Example 2: Changing track and album names\n    let edit2 = ScrobbleEdit {\n        artist_name_original: \"Pink Floyd\".to_string(),\n        track_name_original: Some(\"Shine on You Crazy Diamond\".to_string()),\n        album_name_original: Some(\"Wish You Were Here\".to_string()),\n        album_artist_name_original: None,\n\n        artist_name: \"Pink Floyd\".to_string(), // Same\n        track_name: Some(\"Shine On You Crazy Diamond\".to_string()), // Changed\n        album_name: Some(\"Wish You Were Here (Remastered)\".to_string()), // Changed\n        album_artist_name: None,               // Same\n\n        timestamp: Some(1640995200),\n        edit_all: true,\n    };\n    println!(\"\\nğŸ“ Track and album changes:\");\n    println!(\"   {edit2}\");\n\n    // Example 3: Adding album artist information\n    let edit3 = ScrobbleEdit {\n        artist_name_original: \"Various Artists\".to_string(),\n        track_name_original: Some(\"Hotel California\".to_string()),\n        album_name_original: Some(\"Greatest Hits Collection\".to_string()),\n        album_artist_name_original: None,\n\n        artist_name: \"Eagles\".to_string(),                // Changed\n        track_name: Some(\"Hotel California\".to_string()), // Same\n        album_name: Some(\"Hotel California\".to_string()), // Changed\n        album_artist_name: Some(\"Eagles\".to_string()),    // Added\n\n        timestamp: None,\n        edit_all: false,\n    };\n    println!(\"\\nğŸ“ Multiple changes including adding album artist:\");\n    println!(\"   {edit3}\");\n\n    // Example 4: No changes (should show \"No changes\")\n    let edit4 = ScrobbleEdit {\n        artist_name_original: \"Radiohead\".to_string(),\n        track_name_original: Some(\"Paranoid Android\".to_string()),\n        album_name_original: Some(\"OK Computer\".to_string()),\n        album_artist_name_original: Some(\"Radiohead\".to_string()),\n\n        artist_name: \"Radiohead\".to_string(),             // Same\n        track_name: Some(\"Paranoid Android\".to_string()), // Same\n        album_name: Some(\"OK Computer\".to_string()),      // Same\n        album_artist_name: Some(\"Radiohead\".to_string()), // Same\n\n        timestamp: None,\n        edit_all: false,\n    };\n    println!(\"\\nğŸ“ No changes:\");\n    println!(\"   {edit4}\");\n\n    // Example 5: ExactScrobbleEdit (all fields required)\n    let exact_edit = ExactScrobbleEdit {\n        artist_name_original: \"Led Zeppelin\".to_string(),\n        track_name_original: \"Stairway to Heaven\".to_string(),\n        album_name_original: \"Led Zeppelin IV\".to_string(),\n        album_artist_name_original: \"Led Zeppelin\".to_string(),\n\n        artist_name: \"Led Zeppelin\".to_string(),      // Same\n        track_name: \"Stairway To Heaven\".to_string(), // Changed (capitalization)\n        album_name: \"Led Zeppelin IV (Remaster)\".to_string(), // Changed\n        album_artist_name: \"Led Zeppelin\".to_string(), // Same\n\n        timestamp: 1640995200,\n        edit_all: true,\n    };\n    println!(\"\\nğŸ“ ExactScrobbleEdit changes:\");\n    println!(\"   {exact_edit}\");\n\n    println!(\"\\nâœ¨ Features demonstrated:\");\n    println!(\"   â€¢ Only shows fields that are actually changing\");\n    println!(\"   â€¢ Uses â†’ arrow to show old â†’ new values\");\n    println!(\"   â€¢ Handles optional fields (None to Some transitions)\");\n    println!(\"   â€¢ Shows scope with '(all instances)' when edit_all is true\");\n    println!(\"   â€¢ Shows 'No changes' when nothing is being modified\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","test_album_tracks.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    let artist = std::env::args()\n        .nth(1)\n        .unwrap_or_else(|| \"The Beatles\".to_string());\n    let album = std::env::args()\n        .nth(2)\n        .unwrap_or_else(|| \"Abbey Road\".to_string());\n\n    println!(\"=== Album Tracks Test ===\\n\");\n    println!(\"ğŸµ Testing get_album_tracks() with: '{album}' by '{artist}'\\n\");\n\n    // Test the fixed get_album_tracks method\n    match client.get_album_tracks(\u0026album, \u0026artist).await {\n        Ok(tracks) =\u003e {\n            println!(\"âœ… SUCCESS: Got {} tracks\", tracks.len());\n            if tracks.is_empty() {\n                println!(\"   (Album not found in your library, but no crash!)\");\n            } else {\n                println!(\"   Tracks:\");\n                for (i, track) in tracks.iter().enumerate().take(10) {\n                    println!(\"   [{:2}] {}\", i + 1, track.name);\n                }\n                if tracks.len() \u003e 10 {\n                    println!(\"   ... and {} more tracks\", tracks.len() - 10);\n                }\n            }\n        }\n        Err(e) =\u003e {\n            println!(\"âŒ ERROR: {e}\");\n        }\n    }\n\n    // Also test the iterator directly\n    println!(\"\\n=== Album Tracks Iterator Test ===\");\n    let mut tracks_iterator = client.album_tracks(\u0026album, \u0026artist);\n    let mut count = 0;\n\n    println!(\"ğŸ” Testing iterator...\");\n    while let Some(track) = tracks_iterator.next().await? {\n        count += 1;\n        if count \u003c= 5 {\n            println!(\"   [{count}] {}\", track.name);\n        }\n        if count \u003e= 5 {\n            break;\n        }\n    }\n\n    if count == 0 {\n        println!(\"   No tracks found via iterator (album not in library)\");\n    } else {\n        println!(\"   Iterator works - got {count} tracks\");\n    }\n\n    println!(\"\\nğŸ‰ Both methods completed without crashing!\");\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","test_artist_tracks_with_albums.rs"],"content":"use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    println!(\"=== Testing Artist Tracks with Album Information ===\\n\");\n\n    // Create a test session (this won't work without real credentials)\n    let test_session = LastFmEditSession::new(\n        \"test\".to_string(),\n        vec![\"sessionid=.test123\".to_string()],\n        Some(\"csrf\".to_string()),\n        \"https://www.last.fm\".to_string(),\n    );\n\n    let client = LastFmEditClientImpl::from_session(\n        Box::new(http_client::native::NativeClient::new()),\n        test_session,\n    );\n\n    println!(\"ğŸµ Testing artist tracks iteration (album-based approach)\");\n    println!(\"   This will get tracks by iterating through albums first\");\n    println!(\"   Each track should now have album information populated\");\n\n    let mut tracks_iterator = client.artist_tracks(\"The Beatles\");\n\n    // Get first 5 tracks\n    for i in 0..5 {\n        match tracks_iterator.next().await {\n            Ok(Some(track)) =\u003e {\n                let album_info = track.album.as_deref().unwrap_or(\"No album info\");\n                let album_artist_info = track\n                    .album_artist\n                    .as_deref()\n                    .unwrap_or(\"Same as track artist\");\n\n                println!(\n                    \"  [{:2}] {} - {} [{}]\",\n                    i + 1,\n                    track.artist,\n                    track.name,\n                    album_info\n                );\n                println!(\n                    \"       Album Artist: {} | Play Count: {}\",\n                    album_artist_info, track.playcount\n                );\n\n                if let Some(timestamp) = track.timestamp {\n                    println!(\"       Last Played: {timestamp}\");\n                }\n                println!();\n            }\n            Ok(None) =\u003e {\n                println!(\"  No more tracks found\");\n                break;\n            }\n            Err(e) =\u003e {\n                println!(\"  âŒ Error: {e}\");\n                break;\n            }\n        }\n    }\n\n    println!(\"âœ¨ Key improvements:\");\n    println!(\"   â€¢ Tracks now include complete album information\");\n    println!(\"   â€¢ Album artist information is available when different from track artist\");\n    println!(\"   â€¢ Implementation iterates through albums first, then gets tracks per album\");\n    println!(\"   â€¢ This provides richer metadata compared to the previous direct track approach\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","commands","delete.rs"],"content":"use super::utils::parse_range;\nuse lastfm_edit::LastFmEditClientImpl;\n\n/// Handle deletion of scrobbles from recent pages\npub async fn handle_delete_recent_pages(\n    client: \u0026LastFmEditClientImpl,\n    pages_range: \u0026str,\n    dry_run: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let (start_page, end_page) = parse_range(pages_range, \"pages\")?;\n\n    println!(\"ğŸ—‘ï¸  Delete recent scrobbles from pages {start_page}-{end_page}\");\n    if dry_run {\n        println!(\"ğŸ” DRY RUN - No actual deletions will be performed\");\n    }\n\n    let mut total_scrobbles = 0;\n    let mut successful_deletions = 0;\n    let mut failed_deletions = 0;\n    let mut scrobbles_to_delete = Vec::new();\n\n    // Collect scrobbles from the specified pages\n    for page in start_page..=end_page {\n        println!(\"\\nğŸ“„ Processing page {page}...\");\n\n        match client.get_recent_scrobbles(page.try_into().unwrap()).await {\n            Ok(scrobbles) =\u003e {\n                if scrobbles.is_empty() {\n                    println!(\"  No scrobbles found on page {page}\");\n                    break; // No more pages\n                }\n\n                println!(\"  Found {} scrobbles on page {page}\", scrobbles.len());\n                total_scrobbles += scrobbles.len();\n\n                for scrobble in scrobbles {\n                    if let Some(timestamp) = scrobble.timestamp {\n                        scrobbles_to_delete.push((\n                            scrobble.artist.clone(),\n                            scrobble.name.clone(),\n                            timestamp,\n                        ));\n\n                        if dry_run {\n                            println!(\n                                \"    Would delete: '{}' by '{}' ({})\",\n                                scrobble.name, scrobble.artist, timestamp\n                            );\n                        }\n                    } else {\n                        println!(\n                            \"    âš ï¸  Skipping scrobble without timestamp: '{}' by '{}'\",\n                            scrobble.name, scrobble.artist\n                        );\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"  âŒ Error fetching page {page}: {e}\");\n                break;\n            }\n        }\n    }\n\n    if scrobbles_to_delete.is_empty() {\n        println!(\"\\nâŒ No scrobbles with timestamps found in the specified page range\");\n        return Ok(());\n    }\n\n    println!(\"\\nğŸ“Š Summary:\");\n    println!(\"  Total scrobbles found: {total_scrobbles}\");\n    println!(\"  Scrobbles with timestamps: {}\", scrobbles_to_delete.len());\n\n    if dry_run {\n        println!(\"\\nğŸ” DRY RUN - No actual deletions performed\");\n        println!(\"Use --apply to execute these deletions\");\n        return Ok(());\n    }\n\n    // Actually delete the scrobbles\n    println!(\"\\nğŸ—‘ï¸  Deleting scrobbles...\");\n\n    for (i, (artist, track, timestamp)) in scrobbles_to_delete.iter().enumerate() {\n        println!(\n            \"  {}/{}: Deleting '{}' by '{}'\",\n            i + 1,\n            scrobbles_to_delete.len(),\n            track,\n            artist\n        );\n\n        match client.delete_scrobble(artist, track, *timestamp).await {\n            Ok(true) =\u003e {\n                successful_deletions += 1;\n                println!(\"    âœ… Deleted successfully\");\n            }\n            Ok(false) =\u003e {\n                failed_deletions += 1;\n                println!(\"    âŒ Deletion failed\");\n            }\n            Err(e) =\u003e {\n                failed_deletions += 1;\n                println!(\"    âŒ Error: {e}\");\n            }\n        }\n\n        // Add delay between deletions to be respectful to the server\n        if i \u003c scrobbles_to_delete.len() - 1 {\n            tokio::time::sleep(std::time::Duration::from_millis(1000)).await;\n        }\n    }\n\n    println!(\"\\nğŸ“Š Final Summary:\");\n    println!(\"  Successful deletions: {successful_deletions}\");\n    println!(\"  Failed deletions: {failed_deletions}\");\n\n    if successful_deletions \u003e 0 {\n        println!(\"\\nâœ… Deletion session completed!\");\n    } else if failed_deletions \u003e 0 {\n        println!(\"\\nâŒ All deletions failed!\");\n    }\n\n    Ok(())\n}\n\n/// Handle deletion of scrobbles from timestamp range\npub async fn handle_delete_timestamp_range(\n    client: \u0026LastFmEditClientImpl,\n    timestamp_range: \u0026str,\n    dry_run: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let (start_ts, end_ts) = parse_range(timestamp_range, \"timestamp\")?;\n\n    println!(\"ğŸ—‘ï¸  Delete scrobbles from timestamp range {start_ts}-{end_ts}\");\n    if dry_run {\n        println!(\"ğŸ” DRY RUN - No actual deletions will be performed\");\n    }\n\n    let mut successful_deletions = 0;\n    let mut failed_deletions = 0;\n    let mut scrobbles_to_delete = Vec::new();\n\n    // Search through recent scrobbles to find ones in the timestamp range\n    let max_pages = 20; // Search up to 20 pages of recent scrobbles\n\n    for page in 1..=max_pages {\n        println!(\"ğŸ“„ Searching page {page} for scrobbles in timestamp range...\");\n\n        match client.get_recent_scrobbles(page).await {\n            Ok(scrobbles) =\u003e {\n                if scrobbles.is_empty() {\n                    println!(\"  No more scrobbles found, stopping search\");\n                    break;\n                }\n\n                let mut found_in_range = 0;\n                for scrobble in scrobbles {\n                    if let Some(timestamp) = scrobble.timestamp {\n                        if timestamp \u003e= start_ts \u0026\u0026 timestamp \u003c= end_ts {\n                            found_in_range += 1;\n                            scrobbles_to_delete.push((\n                                scrobble.artist.clone(),\n                                scrobble.name.clone(),\n                                timestamp,\n                            ));\n\n                            if dry_run {\n                                println!(\n                                    \"    Would delete: '{}' by '{}' ({})\",\n                                    scrobble.name, scrobble.artist, timestamp\n                                );\n                            }\n                        }\n                    }\n                }\n\n                if found_in_range \u003e 0 {\n                    println!(\"  Found {found_in_range} scrobbles in range on page {page}\");\n                } else {\n                    println!(\"  No scrobbles in range on page {page}\");\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"  âŒ Error fetching page {page}: {e}\");\n                break;\n            }\n        }\n    }\n\n    if scrobbles_to_delete.is_empty() {\n        println!(\"\\nâŒ No scrobbles found in the specified timestamp range\");\n        return Ok(());\n    }\n\n    println!(\"\\nğŸ“Š Summary:\");\n    println!(\n        \"  Scrobbles in timestamp range: {}\",\n        scrobbles_to_delete.len()\n    );\n\n    if dry_run {\n        println!(\"\\nğŸ” DRY RUN - No actual deletions performed\");\n        println!(\"Use --apply to execute these deletions\");\n        return Ok(());\n    }\n\n    // Actually delete the scrobbles\n    println!(\"\\nğŸ—‘ï¸  Deleting scrobbles...\");\n\n    for (i, (artist, track, timestamp)) in scrobbles_to_delete.iter().enumerate() {\n        println!(\n            \"  {}/{}: Deleting '{}' by '{}'\",\n            i + 1,\n            scrobbles_to_delete.len(),\n            track,\n            artist\n        );\n\n        match client.delete_scrobble(artist, track, *timestamp).await {\n            Ok(true) =\u003e {\n                successful_deletions += 1;\n                println!(\"    âœ… Deleted successfully\");\n            }\n            Ok(false) =\u003e {\n                failed_deletions += 1;\n                println!(\"    âŒ Deletion failed\");\n            }\n            Err(e) =\u003e {\n                failed_deletions += 1;\n                println!(\"    âŒ Error: {e}\");\n            }\n        }\n\n        // Add delay between deletions to be respectful to the server\n        if i \u003c scrobbles_to_delete.len() - 1 {\n            tokio::time::sleep(std::time::Duration::from_millis(1000)).await;\n        }\n    }\n\n    println!(\"\\nğŸ“Š Final Summary:\");\n    println!(\"  Successful deletions: {successful_deletions}\");\n    println!(\"  Failed deletions: {failed_deletions}\");\n\n    if successful_deletions \u003e 0 {\n        println!(\"\\nâœ… Deletion session completed!\");\n    } else if failed_deletions \u003e 0 {\n        println!(\"\\nâŒ All deletions failed!\");\n    }\n\n    Ok(())\n}\n\n/// Handle deletion of scrobbles by offset from most recent\npub async fn handle_delete_recent_offset(\n    client: \u0026LastFmEditClientImpl,\n    offset_range: \u0026str,\n    dry_run: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let (start_offset, end_offset) = parse_range(offset_range, \"offset\")?;\n\n    // Offsets are already 0-based, so use directly\n    let start_index = start_offset;\n    let end_index = end_offset;\n\n    println!(\"ğŸ—‘ï¸  Delete scrobbles by offset: {start_offset}-{end_offset} ({start_offset}th to {end_offset}th most recent, 0-indexed)\");\n    if dry_run {\n        println!(\"ğŸ” DRY RUN - No actual deletions will be performed\");\n    }\n\n    let mut all_scrobbles = Vec::new();\n    let mut successful_deletions = 0;\n    let mut failed_deletions = 0;\n\n    // Collect scrobbles until we have enough to cover the offset range\n    let mut page = 1;\n    let needed_scrobbles = (end_offset + 1) as usize; // +1 because 0-indexed\n\n    println!(\"\\nğŸ“„ Collecting recent scrobbles to reach offset {end_offset}...\");\n\n    while all_scrobbles.len() \u003c needed_scrobbles {\n        match client.get_recent_scrobbles(page.try_into().unwrap()).await {\n            Ok(scrobbles) =\u003e {\n                if scrobbles.is_empty() {\n                    println!(\"  No more scrobbles found on page {page}\");\n                    break;\n                }\n\n                println!(\n                    \"  Page {page}: Found {} scrobbles (total: {})\",\n                    scrobbles.len(),\n                    all_scrobbles.len() + scrobbles.len()\n                );\n                all_scrobbles.extend(scrobbles);\n                page += 1;\n\n                // Stop if we've collected enough\n                if all_scrobbles.len() \u003e= needed_scrobbles {\n                    break;\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"  âŒ Error fetching page {page}: {e}\");\n                break;\n            }\n        }\n    }\n\n    if all_scrobbles.len() \u003c= start_offset as usize {\n        println!(\"\\nâŒ Not enough recent scrobbles found. You have {} scrobbles, but requested offset starts at {} (0-indexed)\", all_scrobbles.len(), start_offset);\n        return Ok(());\n    }\n\n    // Extract the scrobbles in the specified offset range\n    let actual_end_index = std::cmp::min(end_index as usize, all_scrobbles.len() - 1);\n    let scrobbles_in_range = \u0026all_scrobbles[start_index as usize..=actual_end_index];\n\n    println!(\"\\nğŸ“Š Summary:\");\n    println!(\n        \"  Total recent scrobbles collected: {}\",\n        all_scrobbles.len()\n    );\n    println!(\n        \"  Scrobbles in offset range {}-{}: {}\",\n        start_offset,\n        std::cmp::min(end_offset, (all_scrobbles.len() as u64).saturating_sub(1)),\n        scrobbles_in_range.len()\n    );\n\n    if dry_run {\n        println!(\"\\nğŸ” Scrobbles that would be deleted:\");\n        for (i, scrobble) in scrobbles_in_range.iter().enumerate() {\n            let offset_number = start_offset + i as u64;\n            if let Some(timestamp) = scrobble.timestamp {\n                println!(\n                    \"    {}: '{}' by '{}' ({})\",\n                    offset_number, scrobble.name, scrobble.artist, timestamp\n                );\n            } else {\n                println!(\n                    \"    {}: '{}' by '{}' (no timestamp - cannot delete)\",\n                    offset_number, scrobble.name, scrobble.artist\n                );\n            }\n        }\n\n        println!(\"\\nğŸ” DRY RUN - No actual deletions performed\");\n        println!(\"Use --apply to execute these deletions\");\n        return Ok(());\n    }\n\n    // Actually delete the scrobbles\n    println!(\"\\nğŸ—‘ï¸  Deleting scrobbles by offset...\");\n\n    for (i, scrobble) in scrobbles_in_range.iter().enumerate() {\n        let offset_number = start_offset + i as u64;\n\n        if let Some(timestamp) = scrobble.timestamp {\n            println!(\n                \"  {}/{}: Deleting offset {} - '{}' by '{}'\",\n                i + 1,\n                scrobbles_in_range.len(),\n                offset_number,\n                scrobble.name,\n                scrobble.artist\n            );\n\n            match client\n                .delete_scrobble(\u0026scrobble.artist, \u0026scrobble.name, timestamp)\n                .await\n            {\n                Ok(true) =\u003e {\n                    successful_deletions += 1;\n                    println!(\"    âœ… Deleted successfully\");\n                }\n                Ok(false) =\u003e {\n                    failed_deletions += 1;\n                    println!(\"    âŒ Deletion failed\");\n                }\n                Err(e) =\u003e {\n                    failed_deletions += 1;\n                    println!(\"    âŒ Error: {e}\");\n                }\n            }\n        } else {\n            failed_deletions += 1;\n            println!(\n                \"  {}/{}: Skipping offset {} - '{}' by '{}' (no timestamp)\",\n                i + 1,\n                scrobbles_in_range.len(),\n                offset_number,\n                scrobble.name,\n                scrobble.artist\n            );\n        }\n\n        // Add delay between deletions to be respectful to the server\n        if i \u003c scrobbles_in_range.len() - 1 {\n            tokio::time::sleep(std::time::Duration::from_millis(1000)).await;\n        }\n    }\n\n    println!(\"\\nğŸ“Š Final Summary:\");\n    println!(\"  Successful deletions: {successful_deletions}\");\n    println!(\"  Failed deletions: {failed_deletions}\");\n\n    if successful_deletions \u003e 0 {\n        println!(\"\\nâœ… Deletion session completed!\");\n    } else if failed_deletions \u003e 0 {\n        println!(\"\\nâŒ All deletions failed!\");\n    }\n\n    Ok(())\n}\n","traces":[{"line":5,"address":[3581968],"length":1,"stats":{"Line":0}},{"line":10,"address":[3630280,3630462,3631094],"length":1,"stats":{"Line":0}},{"line":12,"address":[3630604],"length":1,"stats":{"Line":0}},{"line":13,"address":[3630751],"length":1,"stats":{"Line":0}},{"line":14,"address":[3630839],"length":1,"stats":{"Line":0}},{"line":17,"address":[3630768],"length":1,"stats":{"Line":0}},{"line":18,"address":[3630784],"length":1,"stats":{"Line":0}},{"line":19,"address":[3630802],"length":1,"stats":{"Line":0}},{"line":20,"address":[3630820],"length":1,"stats":{"Line":0}},{"line":23,"address":[3630886,3632309,3630977],"length":1,"stats":{"Line":0}},{"line":24,"address":[3632383,3632446],"length":1,"stats":{"Line":0}},{"line":26,"address":[3165906],"length":1,"stats":{"Line":0}},{"line":27,"address":[3631555],"length":1,"stats":{"Line":0}},{"line":28,"address":[3631595,3631669],"length":1,"stats":{"Line":0}},{"line":29,"address":[3631702,3633369],"length":1,"stats":{"Line":0}},{"line":33,"address":[3631747,3631675],"length":1,"stats":{"Line":0}},{"line":34,"address":[3632050,3631901],"length":1,"stats":{"Line":0}},{"line":36,"address":[3631983,3632070,3632205],"length":1,"stats":{"Line":0}},{"line":37,"address":[3632705,3632259],"length":1,"stats":{"Line":0}},{"line":38,"address":[3632918,3632721],"length":1,"stats":{"Line":0}},{"line":39,"address":[3632741],"length":1,"stats":{"Line":0}},{"line":40,"address":[3632842],"length":1,"stats":{"Line":0}},{"line":44,"address":[3633020],"length":1,"stats":{"Line":0}},{"line":45,"address":[3633059],"length":1,"stats":{"Line":0}},{"line":51,"address":[3632768,3633252],"length":1,"stats":{"Line":0}},{"line":58,"address":[3631486],"length":1,"stats":{"Line":0}},{"line":59,"address":[3631518,3633568],"length":1,"stats":{"Line":0}},{"line":65,"address":[3632417,3633709],"length":1,"stats":{"Line":0}},{"line":66,"address":[3633741,3634427],"length":1,"stats":{"Line":0}},{"line":67,"address":[3634446],"length":1,"stats":{"Line":0}},{"line":70,"address":[3633770,3633715],"length":1,"stats":{"Line":0}},{"line":71,"address":[3633789],"length":1,"stats":{"Line":0}},{"line":72,"address":[3633889],"length":1,"stats":{"Line":0}},{"line":74,"address":[3634028],"length":1,"stats":{"Line":0}},{"line":75,"address":[3634071,3634329],"length":1,"stats":{"Line":0}},{"line":76,"address":[3634348],"length":1,"stats":{"Line":0}},{"line":77,"address":[3634393],"length":1,"stats":{"Line":0}},{"line":81,"address":[3634045,3634100],"length":1,"stats":{"Line":0}},{"line":83,"address":[3634727,3634291,3634119],"length":1,"stats":{"Line":0}},{"line":84,"address":[3634870,3635328,3635363],"length":1,"stats":{"Line":0}},{"line":92,"address":[3165928],"length":1,"stats":{"Line":0}},{"line":94,"address":[3636430,3636231,3636390],"length":1,"stats":{"Line":0}},{"line":95,"address":[3636404,3636451],"length":1,"stats":{"Line":0}},{"line":98,"address":[3636268,3636308,3636202],"length":1,"stats":{"Line":0}},{"line":99,"address":[3636282,3636329],"length":1,"stats":{"Line":0}},{"line":101,"address":[3636092],"length":1,"stats":{"Line":0}},{"line":102,"address":[3636156,3636517,3636476],"length":1,"stats":{"Line":0}},{"line":103,"address":[3636490,3636582],"length":1,"stats":{"Line":0}},{"line":108,"address":[3636350,3636678],"length":1,"stats":{"Line":0}},{"line":109,"address":[3165950],"length":1,"stats":{"Line":0}},{"line":113,"address":[3634908],"length":1,"stats":{"Line":0}},{"line":114,"address":[3634953],"length":1,"stats":{"Line":0}},{"line":115,"address":[3635053],"length":1,"stats":{"Line":0}},{"line":117,"address":[3635156],"length":1,"stats":{"Line":0}},{"line":118,"address":[3635299,3635192],"length":1,"stats":{"Line":0}},{"line":119,"address":[3635173],"length":1,"stats":{"Line":0}},{"line":120,"address":[3635252],"length":1,"stats":{"Line":0}},{"line":123,"address":[3635218],"length":1,"stats":{"Line":0}},{"line":127,"address":[3582064],"length":1,"stats":{"Line":0}},{"line":132,"address":[3637886,3637107,3637289],"length":1,"stats":{"Line":0}},{"line":134,"address":[3637431],"length":1,"stats":{"Line":0}},{"line":135,"address":[3637578],"length":1,"stats":{"Line":0}},{"line":136,"address":[3637644],"length":1,"stats":{"Line":0}},{"line":139,"address":[3637595],"length":1,"stats":{"Line":0}},{"line":140,"address":[3637610],"length":1,"stats":{"Line":0}},{"line":141,"address":[3637625],"length":1,"stats":{"Line":0}},{"line":144,"address":[3636956],"length":1,"stats":{"Line":0}},{"line":146,"address":[3637691,3638955,3639098,3637764],"length":1,"stats":{"Line":0}},{"line":147,"address":[3639211,3639148],"length":1,"stats":{"Line":0}},{"line":149,"address":[3166594],"length":1,"stats":{"Line":0}},{"line":150,"address":[3638347],"length":1,"stats":{"Line":0}},{"line":151,"address":[3638461,3638387],"length":1,"stats":{"Line":0}},{"line":152,"address":[3638545,3640002],"length":1,"stats":{"Line":0}},{"line":156,"address":[3638467],"length":1,"stats":{"Line":0}},{"line":157,"address":[3638709,3638574,3638478],"length":1,"stats":{"Line":0}},{"line":158,"address":[3638763,3639382],"length":1,"stats":{"Line":0}},{"line":159,"address":[3639442,3639398],"length":1,"stats":{"Line":0}},{"line":160,"address":[3639546,3639464],"length":1,"stats":{"Line":0}},{"line":161,"address":[3639499,3639686],"length":1,"stats":{"Line":0}},{"line":162,"address":[3639519],"length":1,"stats":{"Line":0}},{"line":163,"address":[3639610],"length":1,"stats":{"Line":0}},{"line":167,"address":[3639788],"length":1,"stats":{"Line":0}},{"line":168,"address":[3639809],"length":1,"stats":{"Line":0}},{"line":177,"address":[3638805],"length":1,"stats":{"Line":0}},{"line":178,"address":[3638849,3638960],"length":1,"stats":{"Line":0}},{"line":180,"address":[3638815,3638876],"length":1,"stats":{"Line":0}},{"line":183,"address":[3638278],"length":1,"stats":{"Line":0}},{"line":184,"address":[3638310,3640151],"length":1,"stats":{"Line":0}},{"line":190,"address":[3639182,3640292],"length":1,"stats":{"Line":0}},{"line":191,"address":[3640910,3640324],"length":1,"stats":{"Line":0}},{"line":192,"address":[3640929],"length":1,"stats":{"Line":0}},{"line":195,"address":[3640298,3640353],"length":1,"stats":{"Line":0}},{"line":196,"address":[3640415],"length":1,"stats":{"Line":0}},{"line":201,"address":[3640511],"length":1,"stats":{"Line":0}},{"line":202,"address":[3640812,3640554],"length":1,"stats":{"Line":0}},{"line":203,"address":[3640831],"length":1,"stats":{"Line":0}},{"line":204,"address":[3640876],"length":1,"stats":{"Line":0}},{"line":208,"address":[3640583,3640528],"length":1,"stats":{"Line":0}},{"line":210,"address":[3641210,3640602,3640774],"length":1,"stats":{"Line":0}},{"line":211,"address":[3641901,3641810],"length":1,"stats":{"Line":0}},{"line":219,"address":[3166616],"length":1,"stats":{"Line":0}},{"line":221,"address":[3642699,3642889,3642852],"length":1,"stats":{"Line":0}},{"line":222,"address":[3642910,3642863],"length":1,"stats":{"Line":0}},{"line":225,"address":[3642770,3642673,3642733],"length":1,"stats":{"Line":0}},{"line":226,"address":[3642744,3642791],"length":1,"stats":{"Line":0}},{"line":228,"address":[3642566],"length":1,"stats":{"Line":0}},{"line":229,"address":[3642630,3642935,3642973],"length":1,"stats":{"Line":0}},{"line":230,"address":[3642946,3643038],"length":1,"stats":{"Line":0}},{"line":235,"address":[3643134,3642812],"length":1,"stats":{"Line":0}},{"line":236,"address":[3641014,3643198,3637210,3640980],"length":1,"stats":{"Line":0}},{"line":240,"address":[3641391],"length":1,"stats":{"Line":0}},{"line":241,"address":[3641436],"length":1,"stats":{"Line":0}},{"line":242,"address":[3641536],"length":1,"stats":{"Line":0}},{"line":244,"address":[3641636],"length":1,"stats":{"Line":0}},{"line":245,"address":[3641666,3641773],"length":1,"stats":{"Line":0}},{"line":246,"address":[3641650],"length":1,"stats":{"Line":0}},{"line":247,"address":[3641726],"length":1,"stats":{"Line":0}},{"line":250,"address":[3641692],"length":1,"stats":{"Line":0}},{"line":254,"address":[3582160],"length":1,"stats":{"Line":0}},{"line":259,"address":[3643564,3643746,3644508],"length":1,"stats":{"Line":0}},{"line":262,"address":[3643888],"length":1,"stats":{"Line":0}},{"line":263,"address":[3643904],"length":1,"stats":{"Line":0}},{"line":265,"address":[3643920],"length":1,"stats":{"Line":0}},{"line":266,"address":[3644098],"length":1,"stats":{"Line":0}},{"line":267,"address":[3644138],"length":1,"stats":{"Line":0}},{"line":270,"address":[3644115],"length":1,"stats":{"Line":0}},{"line":271,"address":[3644185],"length":1,"stats":{"Line":0}},{"line":272,"address":[3644203],"length":1,"stats":{"Line":0}},{"line":275,"address":[3644221],"length":1,"stats":{"Line":0}},{"line":276,"address":[3644319,3644239],"length":1,"stats":{"Line":0}},{"line":278,"address":[3644288,3644387],"length":1,"stats":{"Line":0}},{"line":280,"address":[3645739,3644458,3645771],"length":1,"stats":{"Line":0}},{"line":281,"address":[3166258],"length":1,"stats":{"Line":0}},{"line":282,"address":[3644969],"length":1,"stats":{"Line":0}},{"line":283,"address":[3645009,3645083],"length":1,"stats":{"Line":0}},{"line":284,"address":[3646008,3645116],"length":1,"stats":{"Line":0}},{"line":288,"address":[3645089,3645161],"length":1,"stats":{"Line":0}},{"line":293,"address":[3645532],"length":1,"stats":{"Line":0}},{"line":294,"address":[3645606,3645688],"length":1,"stats":{"Line":0}},{"line":297,"address":[3645657,3645717],"length":1,"stats":{"Line":0}},{"line":301,"address":[3644900],"length":1,"stats":{"Line":0}},{"line":302,"address":[3644932,3646218],"length":1,"stats":{"Line":0}},{"line":308,"address":[3645785,3646360],"length":1,"stats":{"Line":0}},{"line":309,"address":[3646417,3648447],"length":1,"stats":{"Line":0}},{"line":310,"address":[3648598],"length":1,"stats":{"Line":0}},{"line":314,"address":[3646459,3646374],"length":1,"stats":{"Line":0}},{"line":315,"address":[3646552],"length":1,"stats":{"Line":0}},{"line":317,"address":[3646675],"length":1,"stats":{"Line":0}},{"line":318,"address":[3646720],"length":1,"stats":{"Line":0}},{"line":322,"address":[3647043],"length":1,"stats":{"Line":0}},{"line":329,"address":[3647191],"length":1,"stats":{"Line":0}},{"line":330,"address":[3647234,3647464],"length":1,"stats":{"Line":0}},{"line":331,"address":[3647483],"length":1,"stats":{"Line":0}},{"line":332,"address":[3647962,3647943,3647765],"length":1,"stats":{"Line":0}},{"line":333,"address":[3647951,3647991],"length":1,"stats":{"Line":0}},{"line":334,"address":[3648003,3648068],"length":1,"stats":{"Line":0}},{"line":339,"address":[3648279,3648030],"length":1,"stats":{"Line":0}},{"line":346,"address":[3647799],"length":1,"stats":{"Line":0}},{"line":347,"address":[3647844],"length":1,"stats":{"Line":0}},{"line":348,"address":[3647889],"length":1,"stats":{"Line":0}},{"line":352,"address":[3647263,3647208],"length":1,"stats":{"Line":0}},{"line":354,"address":[3647282,3647422,3648882],"length":1,"stats":{"Line":0}},{"line":355,"address":[3649460,3648976,3649486],"length":1,"stats":{"Line":0}},{"line":357,"address":[3649475,3649515],"length":1,"stats":{"Line":0}},{"line":358,"address":[3649672],"length":1,"stats":{"Line":0}},{"line":367,"address":[3649956,3650326,3650128,3650076,3650512,3650384],"length":1,"stats":{"Line":0}},{"line":368,"address":[3649973],"length":1,"stats":{"Line":0}},{"line":369,"address":[3166280],"length":1,"stats":{"Line":0}},{"line":372,"address":[3650551,3650776,3650736],"length":1,"stats":{"Line":0}},{"line":373,"address":[3650750,3650797],"length":1,"stats":{"Line":0}},{"line":376,"address":[3650591,3650631,3650522],"length":1,"stats":{"Line":0}},{"line":377,"address":[3650652,3650605],"length":1,"stats":{"Line":0}},{"line":379,"address":[3650412],"length":1,"stats":{"Line":0}},{"line":380,"address":[3650476,3650825,3650866],"length":1,"stats":{"Line":0}},{"line":381,"address":[3650839,3650931],"length":1,"stats":{"Line":0}},{"line":385,"address":[3651029,3651074,3649569],"length":1,"stats":{"Line":0}},{"line":386,"address":[3651108,3651176],"length":1,"stats":{"Line":0}},{"line":397,"address":[3651447,3650673],"length":1,"stats":{"Line":0}},{"line":398,"address":[3166302],"length":1,"stats":{"Line":0}},{"line":402,"address":[3649025],"length":1,"stats":{"Line":0}},{"line":403,"address":[3649070],"length":1,"stats":{"Line":0}},{"line":404,"address":[3649173],"length":1,"stats":{"Line":0}},{"line":406,"address":[3649276],"length":1,"stats":{"Line":0}},{"line":407,"address":[3649423,3649312],"length":1,"stats":{"Line":0}},{"line":408,"address":[3649293],"length":1,"stats":{"Line":0}},{"line":409,"address":[3649376],"length":1,"stats":{"Line":0}},{"line":412,"address":[3649338],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":187},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","commands","edit.rs"],"content":"use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, ScrobbleEdit};\n\n/// Create a ScrobbleEdit from command line arguments\n#[allow(clippy::too_many_arguments)]\npub fn create_scrobble_edit_from_args(\n    artist: \u0026str,\n    track: Option\u003c\u0026str\u003e,\n    album: Option\u003c\u0026str\u003e,\n    album_artist: Option\u003c\u0026str\u003e,\n    new_track: Option\u003c\u0026str\u003e,\n    new_album: Option\u003c\u0026str\u003e,\n    new_artist: Option\u003c\u0026str\u003e,\n    new_album_artist: Option\u003c\u0026str\u003e,\n    timestamp: Option\u003cu64\u003e,\n    edit_all: bool,\n) -\u003e ScrobbleEdit {\n    // Determine the new artist name (use provided new_artist or original artist)\n    let new_artist = new_artist.unwrap_or(artist);\n\n    ScrobbleEdit::new(\n        track.map(|s| s.to_string()),\n        album.map(|s| s.to_string()),\n        artist.to_string(),\n        album_artist.map(|s| s.to_string()),\n        new_track.map(|s| s.to_string()),\n        new_album.map(|s| s.to_string()),\n        new_artist.to_string(),\n        new_album_artist.map(|s| s.to_string()),\n        timestamp,\n        edit_all,\n    )\n}\n\n/// Handle the edit command\npub async fn handle_edit_command(\n    client: \u0026LastFmEditClientImpl,\n    edit: \u0026ScrobbleEdit,\n    dry_run: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Show the ScrobbleEdit that will be sent\n    println!(\"\\nğŸ“¦ ScrobbleEdit to be sent:\");\n    println!(\"{edit:#?}\");\n\n    // Discover and apply/show variations\n    discover_and_handle_edits(client, edit, dry_run).await\n}\n\nasync fn discover_and_handle_edits(\n    client: \u0026LastFmEditClientImpl,\n    edit: \u0026ScrobbleEdit,\n    dry_run: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    println!(\"\\nğŸ” Discovering scrobble edit variations...\");\n\n    // Use the discovery iterator for incremental results\n    let mut discovery_iterator = client.discover_scrobbles(edit.clone());\n    let mut discovered_edits = Vec::new();\n    let mut edit_results = Vec::new();\n    let mut count = 0;\n    let mut successful_edits = 0;\n    let mut failed_edits = 0;\n\n    // Process results incrementally\n    while let Some(discovered_edit) = discovery_iterator.next().await? {\n        count += 1;\n        println!(\"\\n  {count}. Found scrobble:\");\n        println!(\"     Track: '{}'\", discovered_edit.track_name_original);\n        println!(\"     Album: '{}'\", discovered_edit.album_name_original);\n        println!(\"     Artist: '{}'\", discovered_edit.artist_name_original);\n        println!(\n            \"     Album Artist: '{}'\",\n            discovered_edit.album_artist_name_original\n        );\n        println!(\"     Timestamp: {}\", discovered_edit.timestamp);\n\n        // Show what this would change to\n        println!(\"     Would change to:\");\n        println!(\"       Track: '{}'\", discovered_edit.track_name);\n        println!(\"       Album: '{}'\", discovered_edit.album_name);\n        println!(\"       Artist: '{}'\", discovered_edit.artist_name);\n        println!(\n            \"       Album Artist: '{}'\",\n            discovered_edit.album_artist_name\n        );\n\n        if dry_run {\n            println!(\"     DRY RUN - proceeding without submitting edit\");\n            discovered_edits.push(discovered_edit);\n        } else {\n            // Apply edit immediately\n            println!(\"     ğŸ”„ Applying edit...\");\n\n            // Apply the user's changes to create the final exact edit\n            let mut final_edit = discovered_edit.clone();\n            if let Some(new_track_name) = \u0026edit.track_name {\n                final_edit.track_name = new_track_name.clone();\n            }\n            if let Some(new_album_name) = \u0026edit.album_name {\n                final_edit.album_name = new_album_name.clone();\n            }\n            final_edit.artist_name = edit.artist_name.clone();\n            if let Some(new_album_artist_name) = \u0026edit.album_artist_name {\n                final_edit.album_artist_name = new_album_artist_name.clone();\n            }\n            final_edit.edit_all = edit.edit_all;\n\n            match client.edit_scrobble_single(\u0026final_edit, 3).await {\n                Ok(response) =\u003e {\n                    if response.all_successful() {\n                        successful_edits += 1;\n                        println!(\"     âœ… Edit applied successfully!\");\n                    } else {\n                        failed_edits += 1;\n                        println!(\"     âŒ Edit failed: {}\", response.summary_message());\n                    }\n                    edit_results.push(response);\n                }\n                Err(e) =\u003e {\n                    failed_edits += 1;\n                    println!(\"     âŒ Error applying edit: {e}\");\n                }\n            }\n        }\n    }\n\n    if count == 0 {\n        println!(\"No matching scrobbles found. This might mean:\");\n        println!(\"  - The specified metadata is not in your recent scrobbles\");\n        println!(\"  - The names don't match exactly\");\n        println!(\"  - There's a network or parsing issue\");\n        return Ok(());\n    }\n\n    println!(\"\\nğŸ“Š Summary:\");\n    println!(\"  Total variations found: {count}\");\n\n    if dry_run {\n        // Group by unique original metadata combinations for dry run summary\n        let mut unique_tracks = std::collections::HashSet::new();\n        let mut unique_albums = std::collections::HashSet::new();\n\n        for edit in \u0026discovered_edits {\n            unique_tracks.insert(\u0026edit.track_name_original);\n            unique_albums.insert(\u0026edit.album_name_original);\n        }\n\n        println!(\"  Unique tracks: {}\", unique_tracks.len());\n        println!(\"  Unique albums: {}\", unique_albums.len());\n        println!(\"\\nğŸ” DRY RUN - No actual edits performed\");\n        println!(\"Use --apply to execute these edits\");\n    } else {\n        println!(\"  Successful edits: {successful_edits}\");\n        println!(\"  Failed edits: {failed_edits}\");\n\n        if successful_edits \u003e 0 {\n            println!(\"\\nâœ… Edit session completed!\");\n        } else if failed_edits \u003e 0 {\n            println!(\"\\nâŒ All edits failed!\");\n        }\n\n        if failed_edits \u003e 0 {\n            println!(\"\\nâš ï¸  Failed edit details:\");\n            for (i, response) in edit_results.iter().enumerate() {\n                if !response.all_successful() {\n                    println!(\"    {}: {}\", i + 1, response.summary_message());\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":5,"address":[3576372,3576488,3574960],"length":1,"stats":{"Line":0}},{"line":18,"address":[3575417],"length":1,"stats":{"Line":0}},{"line":21,"address":[3575542],"length":1,"stats":{"Line":0}},{"line":22,"address":[3197078,3197056],"length":1,"stats":{"Line":0}},{"line":23,"address":[3575659,3575726],"length":1,"stats":{"Line":0}},{"line":24,"address":[3197104,3197126],"length":1,"stats":{"Line":0}},{"line":25,"address":[3197152,3197174],"length":1,"stats":{"Line":0}},{"line":26,"address":[3197200,3197222],"length":1,"stats":{"Line":0}},{"line":27,"address":[3575953,3576020],"length":1,"stats":{"Line":0}},{"line":28,"address":[3197248,3197270],"length":1,"stats":{"Line":0}},{"line":35,"address":[3576528],"length":1,"stats":{"Line":0}},{"line":41,"address":[3197586,3197476],"length":1,"stats":{"Line":0}},{"line":42,"address":[3197602],"length":1,"stats":{"Line":0}},{"line":45,"address":[3197526,3197731,3197857],"length":1,"stats":{"Line":0}},{"line":48,"address":[3576592],"length":1,"stats":{"Line":0}},{"line":53,"address":[3198301,3198438],"length":1,"stats":{"Line":0}},{"line":56,"address":[3198457],"length":1,"stats":{"Line":0}},{"line":57,"address":[3198586],"length":1,"stats":{"Line":0}},{"line":58,"address":[3198653],"length":1,"stats":{"Line":0}},{"line":59,"address":[3198717],"length":1,"stats":{"Line":0}},{"line":60,"address":[3198732],"length":1,"stats":{"Line":0}},{"line":61,"address":[3198747],"length":1,"stats":{"Line":0}},{"line":64,"address":[3205829,3198357,3198762,3200247,3200374,3200438,3198830],"length":1,"stats":{"Line":0}},{"line":65,"address":[3200973,3201038,3201080],"length":1,"stats":{"Line":0}},{"line":66,"address":[3201049,3201101],"length":1,"stats":{"Line":0}},{"line":67,"address":[3201170],"length":1,"stats":{"Line":0}},{"line":68,"address":[3201273],"length":1,"stats":{"Line":0}},{"line":69,"address":[3201376],"length":1,"stats":{"Line":0}},{"line":70,"address":[3201479],"length":1,"stats":{"Line":0}},{"line":74,"address":[3201582],"length":1,"stats":{"Line":0}},{"line":77,"address":[3201685],"length":1,"stats":{"Line":0}},{"line":78,"address":[3201730],"length":1,"stats":{"Line":0}},{"line":79,"address":[3201833],"length":1,"stats":{"Line":0}},{"line":80,"address":[3201936],"length":1,"stats":{"Line":0}},{"line":81,"address":[3202039],"length":1,"stats":{"Line":0}},{"line":86,"address":[3202142],"length":1,"stats":{"Line":0}},{"line":87,"address":[3202182,3203494],"length":1,"stats":{"Line":0}},{"line":88,"address":[3203513],"length":1,"stats":{"Line":0}},{"line":91,"address":[3202211,3202156],"length":1,"stats":{"Line":0}},{"line":94,"address":[3202230],"length":1,"stats":{"Line":0}},{"line":95,"address":[3202646,3202262],"length":1,"stats":{"Line":0}},{"line":96,"address":[3202343,3202487,3202513],"length":1,"stats":{"Line":0}},{"line":98,"address":[3202362,3202883,3202659],"length":1,"stats":{"Line":0}},{"line":99,"address":[3202667,3202724,3202750],"length":1,"stats":{"Line":0}},{"line":101,"address":[3202888,3202914,3202686],"length":1,"stats":{"Line":0}},{"line":102,"address":[3203376,3203047],"length":1,"stats":{"Line":0}},{"line":103,"address":[3203217,3203243,3203128],"length":1,"stats":{"Line":0}},{"line":105,"address":[3203147],"length":1,"stats":{"Line":0}},{"line":107,"address":[3199155,3198864,3203171,3198378,3198895,3203432],"length":1,"stats":{"Line":0}},{"line":108,"address":[3199283],"length":1,"stats":{"Line":0}},{"line":109,"address":[3199323,3199397],"length":1,"stats":{"Line":0}},{"line":110,"address":[3199816,3199432,3199779],"length":1,"stats":{"Line":0}},{"line":111,"address":[3199790,3199837],"length":1,"stats":{"Line":0}},{"line":113,"address":[3199475,3199403,3199513],"length":1,"stats":{"Line":0}},{"line":114,"address":[3199533,3199486],"length":1,"stats":{"Line":0}},{"line":116,"address":[3199692],"length":1,"stats":{"Line":0}},{"line":118,"address":[3199183],"length":1,"stats":{"Line":0}},{"line":119,"address":[3199247,3199963,3200001],"length":1,"stats":{"Line":0}},{"line":120,"address":[3199974,3200063],"length":1,"stats":{"Line":0}},{"line":126,"address":[3203624],"length":1,"stats":{"Line":0}},{"line":127,"address":[3203693,3203638],"length":1,"stats":{"Line":0}},{"line":128,"address":[3203712],"length":1,"stats":{"Line":0}},{"line":129,"address":[3203757],"length":1,"stats":{"Line":0}},{"line":130,"address":[3203802],"length":1,"stats":{"Line":0}},{"line":131,"address":[3203847],"length":1,"stats":{"Line":0}},{"line":134,"address":[3203881,3203664],"length":1,"stats":{"Line":0}},{"line":135,"address":[3203900],"length":1,"stats":{"Line":0}},{"line":137,"address":[3204000],"length":1,"stats":{"Line":0}},{"line":139,"address":[3204053],"length":1,"stats":{"Line":0}},{"line":140,"address":[3205050],"length":1,"stats":{"Line":0}},{"line":142,"address":[3205097,3205173],"length":1,"stats":{"Line":0}},{"line":143,"address":[3205286],"length":1,"stats":{"Line":0}},{"line":144,"address":[3205789],"length":1,"stats":{"Line":0}},{"line":147,"address":[3205304],"length":1,"stats":{"Line":0}},{"line":148,"address":[3205433],"length":1,"stats":{"Line":0}},{"line":149,"address":[3205552],"length":1,"stats":{"Line":0}},{"line":150,"address":[3205597],"length":1,"stats":{"Line":0}},{"line":152,"address":[3204063,3204014],"length":1,"stats":{"Line":0}},{"line":153,"address":[3204132],"length":1,"stats":{"Line":0}},{"line":155,"address":[3204232],"length":1,"stats":{"Line":0}},{"line":156,"address":[3204262,3204351],"length":1,"stats":{"Line":0}},{"line":157,"address":[3204246],"length":1,"stats":{"Line":0}},{"line":158,"address":[3204304],"length":1,"stats":{"Line":0}},{"line":161,"address":[3204288],"length":1,"stats":{"Line":0}},{"line":162,"address":[3204406],"length":1,"stats":{"Line":0}},{"line":163,"address":[3204451],"length":1,"stats":{"Line":0}},{"line":164,"address":[3204731],"length":1,"stats":{"Line":0}},{"line":165,"address":[3204765],"length":1,"stats":{"Line":0}},{"line":171,"address":[3204372],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":89},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","commands","list.rs"],"content":"use super::list_output::{HumanReadableListHandler, JsonListHandler, ListEvent, ListOutputHandler};\nuse lastfm_edit::{LastFmEditClient, LastFmEditClientImpl};\n\n/// Handle the list artists command\npub async fn handle_list_artists(\n    client: \u0026LastFmEditClientImpl,\n    limit: usize,\n    verbose: bool,\n    format: bool,\n    json_output: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create appropriate handler based on output format\n    let mut handler: Box\u003cdyn ListOutputHandler\u003e = if json_output {\n        Box::new(JsonListHandler::new())\n    } else {\n        Box::new(HumanReadableListHandler::new(verbose, format))\n    };\n\n    // Emit start event\n    handler.handle_event(ListEvent::Started {\n        command: \"artists\".to_string(),\n        artist: None,\n        album: None,\n    });\n\n    let mut artists_iterator = client.artists();\n    let mut count = 0;\n\n    while let Some(artist) = artists_iterator.next().await? {\n        count += 1;\n\n        // Emit artist found event\n        handler.handle_event(ListEvent::ArtistFound {\n            index: count,\n            artist,\n        });\n\n        if limit \u003e 0 \u0026\u0026 count \u003e= limit {\n            break;\n        }\n    }\n\n    // Emit summary event\n    handler.handle_event(ListEvent::Summary {\n        command: \"artists\".to_string(),\n        total_items: count,\n        artist: None,\n        album: None,\n    });\n\n    Ok(())\n}\n\n/// Handle the list albums command\npub async fn handle_list_albums(\n    client: \u0026LastFmEditClientImpl,\n    artist: \u0026str,\n    limit: usize,\n    verbose: bool,\n    format: bool,\n    json_output: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create appropriate handler based on output format\n    let mut handler: Box\u003cdyn ListOutputHandler\u003e = if json_output {\n        Box::new(JsonListHandler::new())\n    } else {\n        Box::new(HumanReadableListHandler::new(verbose, format))\n    };\n\n    // Emit start event\n    handler.handle_event(ListEvent::Started {\n        command: \"albums\".to_string(),\n        artist: Some(artist.to_string()),\n        album: None,\n    });\n\n    let mut albums_iterator = client.artist_albums(artist);\n    let mut count = 0;\n\n    while let Some(album) = albums_iterator.next().await? {\n        count += 1;\n\n        // Emit album found event\n        handler.handle_event(ListEvent::AlbumFound {\n            index: count,\n            album,\n        });\n\n        if limit \u003e 0 \u0026\u0026 count \u003e= limit {\n            break;\n        }\n    }\n\n    // Emit summary event\n    handler.handle_event(ListEvent::Summary {\n        command: \"albums\".to_string(),\n        total_items: count,\n        artist: Some(artist.to_string()),\n        album: None,\n    });\n\n    Ok(())\n}\n\n/// Handle the list tracks by album command\npub async fn handle_list_tracks_by_album(\n    client: \u0026LastFmEditClientImpl,\n    artist: \u0026str,\n    limit: usize,\n    verbose: bool,\n    format: bool,\n    json_output: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create appropriate handler based on output format\n    let mut handler: Box\u003cdyn ListOutputHandler\u003e = if json_output {\n        Box::new(JsonListHandler::new())\n    } else {\n        Box::new(HumanReadableListHandler::new(verbose, format))\n    };\n\n    // Emit start event\n    handler.handle_event(ListEvent::Started {\n        command: \"tracks-by-album\".to_string(),\n        artist: Some(artist.to_string()),\n        album: None,\n    });\n\n    let mut albums_iterator = client.artist_albums(artist);\n    let mut album_count = 0;\n\n    while let Some(album) = albums_iterator.next().await? {\n        album_count += 1;\n\n        // Emit album section event\n        handler.handle_event(ListEvent::AlbumSection {\n            album_index: album_count,\n            album: album.clone(),\n        });\n\n        // Get tracks for this album\n        match client.get_album_tracks(\u0026album.name, artist).await {\n            Ok(tracks) =\u003e {\n                if tracks.is_empty() {\n                    handler.handle_event(ListEvent::Error {\n                        message: \"No tracks found in your library for this album\".to_string(),\n                    });\n                } else {\n                    for (track_idx, track) in tracks.iter().enumerate() {\n                        handler.handle_event(ListEvent::AlbumTrackFound {\n                            album_index: album_count,\n                            track_index: track_idx + 1,\n                            track: track.clone(),\n                        });\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                handler.handle_event(ListEvent::Error {\n                    message: format!(\"Error getting tracks: {e}\"),\n                });\n            }\n        }\n\n        if limit \u003e 0 \u0026\u0026 album_count \u003e= limit {\n            break;\n        }\n    }\n\n    // Emit summary event\n    handler.handle_event(ListEvent::Summary {\n        command: \"tracks-by-album\".to_string(),\n        total_items: album_count,\n        artist: Some(artist.to_string()),\n        album: None,\n    });\n\n    Ok(())\n}\n\n/// Handle the list tracks command\npub async fn handle_list_tracks(\n    client: \u0026LastFmEditClientImpl,\n    artist: \u0026str,\n    limit: usize,\n    verbose: bool,\n    format: bool,\n    json_output: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create appropriate handler based on output format\n    let mut handler: Box\u003cdyn ListOutputHandler\u003e = if json_output {\n        Box::new(JsonListHandler::new())\n    } else {\n        Box::new(HumanReadableListHandler::new(verbose, format))\n    };\n\n    // Emit start event\n    handler.handle_event(ListEvent::Started {\n        command: \"tracks\".to_string(),\n        artist: Some(artist.to_string()),\n        album: None,\n    });\n\n    let mut tracks_iterator = client.artist_tracks(artist);\n    let mut count = 0;\n\n    while let Some(track) = tracks_iterator.next().await? {\n        count += 1;\n\n        // Emit track found event\n        handler.handle_event(ListEvent::TrackFound {\n            index: count,\n            track,\n        });\n\n        if limit \u003e 0 \u0026\u0026 count \u003e= limit {\n            break;\n        }\n    }\n\n    // Emit summary event\n    handler.handle_event(ListEvent::Summary {\n        command: \"tracks\".to_string(),\n        total_items: count,\n        artist: Some(artist.to_string()),\n        album: None,\n    });\n\n    Ok(())\n}\n\n/// Handle the list tracks direct command\npub async fn handle_list_tracks_direct(\n    client: \u0026LastFmEditClientImpl,\n    artist: \u0026str,\n    limit: usize,\n    verbose: bool,\n    format: bool,\n    json_output: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create appropriate handler based on output format\n    let mut handler: Box\u003cdyn ListOutputHandler\u003e = if json_output {\n        Box::new(JsonListHandler::new())\n    } else {\n        Box::new(HumanReadableListHandler::new(verbose, format))\n    };\n\n    // Emit start event\n    handler.handle_event(ListEvent::Started {\n        command: \"tracks-direct\".to_string(),\n        artist: Some(artist.to_string()),\n        album: None,\n    });\n\n    let mut tracks_iterator = client.artist_tracks_direct(artist);\n    let mut count = 0;\n\n    while let Some(track) = tracks_iterator.next().await? {\n        count += 1;\n\n        // Emit track found event\n        handler.handle_event(ListEvent::TrackFound {\n            index: count,\n            track,\n        });\n\n        if limit \u003e 0 \u0026\u0026 count \u003e= limit {\n            break;\n        }\n    }\n\n    // Emit summary event\n    handler.handle_event(ListEvent::Summary {\n        command: \"tracks-direct\".to_string(),\n        total_items: count,\n        artist: Some(artist.to_string()),\n        album: None,\n    });\n\n    Ok(())\n}\n\n/// Handle the list album tracks command\npub async fn handle_list_album_tracks(\n    client: \u0026LastFmEditClientImpl,\n    album: \u0026str,\n    artist: \u0026str,\n    details: bool,\n    format: bool,\n    json_output: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create appropriate handler based on output format\n    let mut handler: Box\u003cdyn ListOutputHandler\u003e = if json_output {\n        Box::new(JsonListHandler::new())\n    } else {\n        Box::new(HumanReadableListHandler::new(details, format))\n    };\n\n    // Emit start event\n    handler.handle_event(ListEvent::Started {\n        command: \"album-tracks\".to_string(),\n        artist: Some(artist.to_string()),\n        album: Some(album.to_string()),\n    });\n\n    let mut tracks_iterator = client.album_tracks(album, artist);\n    let mut count = 0;\n\n    while let Some(track) = tracks_iterator.next().await? {\n        count += 1;\n\n        // Emit track found event\n        handler.handle_event(ListEvent::TrackFound {\n            index: count,\n            track,\n        });\n    }\n\n    // Emit summary event\n    handler.handle_event(ListEvent::Summary {\n        command: \"album-tracks\".to_string(),\n        total_items: count,\n        artist: Some(artist.to_string()),\n        album: Some(album.to_string()),\n    });\n\n    Ok(())\n}\n","traces":[{"line":5,"address":[3205936],"length":1,"stats":{"Line":0}},{"line":13,"address":[3459889,3459534,3459759],"length":1,"stats":{"Line":0}},{"line":14,"address":[3459630,3459849],"length":1,"stats":{"Line":0}},{"line":16,"address":[3459597,3459701],"length":1,"stats":{"Line":0}},{"line":20,"address":[3459973,3459790],"length":1,"stats":{"Line":0}},{"line":21,"address":[3459818],"length":1,"stats":{"Line":0}},{"line":22,"address":[3459957],"length":1,"stats":{"Line":0}},{"line":23,"address":[3459965],"length":1,"stats":{"Line":0}},{"line":26,"address":[3460105],"length":1,"stats":{"Line":0}},{"line":27,"address":[3460165],"length":1,"stats":{"Line":0}},{"line":29,"address":[3460272,3461120,3460529,3459570,3461704,3461174,3460244,3460181],"length":1,"stats":{"Line":0}},{"line":30,"address":[3460857,3461028,3460781],"length":1,"stats":{"Line":0}},{"line":33,"address":[3460869,3460944],"length":1,"stats":{"Line":0}},{"line":34,"address":[3460884],"length":1,"stats":{"Line":0}},{"line":35,"address":[3460888],"length":1,"stats":{"Line":0}},{"line":38,"address":[3461089,3461125],"length":1,"stats":{"Line":0}},{"line":44,"address":[3461282,3461449],"length":1,"stats":{"Line":0}},{"line":45,"address":[3461307],"length":1,"stats":{"Line":0}},{"line":46,"address":[3461411],"length":1,"stats":{"Line":0}},{"line":47,"address":[3461433],"length":1,"stats":{"Line":0}},{"line":48,"address":[3461441],"length":1,"stats":{"Line":0}},{"line":51,"address":[3461581],"length":1,"stats":{"Line":0}},{"line":55,"address":[3206048],"length":1,"stats":{"Line":0}},{"line":64,"address":[3462418,3462061,3462286],"length":1,"stats":{"Line":0}},{"line":65,"address":[3462378,3462157],"length":1,"stats":{"Line":0}},{"line":67,"address":[3462228,3462124],"length":1,"stats":{"Line":0}},{"line":71,"address":[3462605,3462318],"length":1,"stats":{"Line":0}},{"line":72,"address":[3462347],"length":1,"stats":{"Line":0}},{"line":73,"address":[3462467,3462555],"length":1,"stats":{"Line":0}},{"line":74,"address":[3462597],"length":1,"stats":{"Line":0}},{"line":77,"address":[3462737],"length":1,"stats":{"Line":0}},{"line":78,"address":[3462804],"length":1,"stats":{"Line":0}},{"line":80,"address":[3178388],"length":1,"stats":{"Line":0}},{"line":81,"address":[3463458,3463534,3463770],"length":1,"stats":{"Line":0}},{"line":84,"address":[3463546,3463654],"length":1,"stats":{"Line":0}},{"line":85,"address":[3463562],"length":1,"stats":{"Line":0}},{"line":86,"address":[3463566],"length":1,"stats":{"Line":0}},{"line":89,"address":[3463867,3463831],"length":1,"stats":{"Line":0}},{"line":95,"address":[3464285,3464018],"length":1,"stats":{"Line":0}},{"line":96,"address":[3464044],"length":1,"stats":{"Line":0}},{"line":97,"address":[3464138],"length":1,"stats":{"Line":0}},{"line":98,"address":[3464235,3464154],"length":1,"stats":{"Line":0}},{"line":99,"address":[3464277],"length":1,"stats":{"Line":0}},{"line":102,"address":[3464417],"length":1,"stats":{"Line":0}},{"line":106,"address":[3206176],"length":1,"stats":{"Line":0}},{"line":115,"address":[3465288,3465147,3464901],"length":1,"stats":{"Line":0}},{"line":116,"address":[3465018,3465242],"length":1,"stats":{"Line":0}},{"line":118,"address":[3464985,3465089],"length":1,"stats":{"Line":0}},{"line":122,"address":[3465179,3465478],"length":1,"stats":{"Line":0}},{"line":123,"address":[3465211],"length":1,"stats":{"Line":0}},{"line":124,"address":[3465337,3465428],"length":1,"stats":{"Line":0}},{"line":125,"address":[3465470],"length":1,"stats":{"Line":0}},{"line":128,"address":[3465602],"length":1,"stats":{"Line":0}},{"line":129,"address":[3465691],"length":1,"stats":{"Line":0}},{"line":131,"address":[3465707,3464937,3467549,3465782,3467634,3468662],"length":1,"stats":{"Line":0}},{"line":132,"address":[3468192,3468337,3468268],"length":1,"stats":{"Line":0}},{"line":135,"address":[3468280,3468373],"length":1,"stats":{"Line":0}},{"line":136,"address":[3468306],"length":1,"stats":{"Line":0}},{"line":137,"address":[3468315],"length":1,"stats":{"Line":0}},{"line":141,"address":[3466116,3464958,3465850,3468489,3465816],"length":1,"stats":{"Line":0}},{"line":142,"address":[3466238],"length":1,"stats":{"Line":0}},{"line":143,"address":[3466347,3466270],"length":1,"stats":{"Line":0}},{"line":144,"address":[3467086,3466388],"length":1,"stats":{"Line":0}},{"line":145,"address":[3466420],"length":1,"stats":{"Line":0}},{"line":148,"address":[3466470,3466353],"length":1,"stats":{"Line":0}},{"line":149,"address":[3466905,3466737],"length":1,"stats":{"Line":0}},{"line":150,"address":[3466769],"length":1,"stats":{"Line":0}},{"line":151,"address":[3466853,3466789],"length":1,"stats":{"Line":0}},{"line":152,"address":[3466846],"length":1,"stats":{"Line":0}},{"line":157,"address":[3466144],"length":1,"stats":{"Line":0}},{"line":158,"address":[3466176,3467335],"length":1,"stats":{"Line":0}},{"line":159,"address":[3467219,3466208],"length":1,"stats":{"Line":0}},{"line":164,"address":[3467151,3467443],"length":1,"stats":{"Line":0}},{"line":170,"address":[3469094,3468821],"length":1,"stats":{"Line":0}},{"line":171,"address":[3468847],"length":1,"stats":{"Line":0}},{"line":172,"address":[3468945],"length":1,"stats":{"Line":0}},{"line":173,"address":[3468962,3469044],"length":1,"stats":{"Line":0}},{"line":174,"address":[3469086],"length":1,"stats":{"Line":0}},{"line":177,"address":[3469226],"length":1,"stats":{"Line":0}},{"line":181,"address":[3206304],"length":1,"stats":{"Line":0}},{"line":190,"address":[3469565,3469922,3469790],"length":1,"stats":{"Line":0}},{"line":191,"address":[3469661,3469882],"length":1,"stats":{"Line":0}},{"line":193,"address":[3469732,3469628],"length":1,"stats":{"Line":0}},{"line":197,"address":[3469822,3470109],"length":1,"stats":{"Line":0}},{"line":198,"address":[3469851],"length":1,"stats":{"Line":0}},{"line":199,"address":[3469971,3470059],"length":1,"stats":{"Line":0}},{"line":200,"address":[3470101],"length":1,"stats":{"Line":0}},{"line":203,"address":[3470241],"length":1,"stats":{"Line":0}},{"line":204,"address":[3470308],"length":1,"stats":{"Line":0}},{"line":206,"address":[3178628],"length":1,"stats":{"Line":0}},{"line":207,"address":[3471010,3471086,3471418],"length":1,"stats":{"Line":0}},{"line":210,"address":[3471254,3471098],"length":1,"stats":{"Line":0}},{"line":211,"address":[3471114],"length":1,"stats":{"Line":0}},{"line":212,"address":[3471118],"length":1,"stats":{"Line":0}},{"line":215,"address":[3471515,3471479],"length":1,"stats":{"Line":0}},{"line":221,"address":[3471937,3471666],"length":1,"stats":{"Line":0}},{"line":222,"address":[3471692],"length":1,"stats":{"Line":0}},{"line":223,"address":[3471790],"length":1,"stats":{"Line":0}},{"line":224,"address":[3471887,3471806],"length":1,"stats":{"Line":0}},{"line":225,"address":[3471929],"length":1,"stats":{"Line":0}},{"line":228,"address":[3472069],"length":1,"stats":{"Line":0}},{"line":232,"address":[3206432],"length":1,"stats":{"Line":0}},{"line":241,"address":[3472782,3472914,3472557],"length":1,"stats":{"Line":0}},{"line":242,"address":[3472653,3472874],"length":1,"stats":{"Line":0}},{"line":244,"address":[3472620,3472724],"length":1,"stats":{"Line":0}},{"line":248,"address":[3473101,3472814],"length":1,"stats":{"Line":0}},{"line":249,"address":[3472843],"length":1,"stats":{"Line":0}},{"line":250,"address":[3472963,3473051],"length":1,"stats":{"Line":0}},{"line":251,"address":[3473093],"length":1,"stats":{"Line":0}},{"line":254,"address":[3473233],"length":1,"stats":{"Line":0}},{"line":255,"address":[3473300],"length":1,"stats":{"Line":0}},{"line":257,"address":[3164788],"length":1,"stats":{"Line":0}},{"line":258,"address":[3474002,3474078,3474410],"length":1,"stats":{"Line":0}},{"line":261,"address":[3474090,3474246],"length":1,"stats":{"Line":0}},{"line":262,"address":[3474106],"length":1,"stats":{"Line":0}},{"line":263,"address":[3474110],"length":1,"stats":{"Line":0}},{"line":266,"address":[3474507,3474471],"length":1,"stats":{"Line":0}},{"line":272,"address":[3474929,3474658],"length":1,"stats":{"Line":0}},{"line":273,"address":[3474684],"length":1,"stats":{"Line":0}},{"line":274,"address":[3474782],"length":1,"stats":{"Line":0}},{"line":275,"address":[3474798,3474879],"length":1,"stats":{"Line":0}},{"line":276,"address":[3474921],"length":1,"stats":{"Line":0}},{"line":279,"address":[3475061],"length":1,"stats":{"Line":0}},{"line":283,"address":[3206560],"length":1,"stats":{"Line":0}},{"line":292,"address":[3475789,3475921,3475561],"length":1,"stats":{"Line":0}},{"line":293,"address":[3475881,3475657],"length":1,"stats":{"Line":0}},{"line":295,"address":[3475731,3475624],"length":1,"stats":{"Line":0}},{"line":299,"address":[3475821,3476198],"length":1,"stats":{"Line":0}},{"line":300,"address":[3475850],"length":1,"stats":{"Line":0}},{"line":301,"address":[3476046,3475970],"length":1,"stats":{"Line":0}},{"line":302,"address":[3476078,3476166],"length":1,"stats":{"Line":0}},{"line":305,"address":[3476330],"length":1,"stats":{"Line":0}},{"line":306,"address":[3476405],"length":1,"stats":{"Line":0}},{"line":308,"address":[3163879],"length":1,"stats":{"Line":0}},{"line":309,"address":[3477107,3477168,3477500],"length":1,"stats":{"Line":0}},{"line":312,"address":[3477336,3477180],"length":1,"stats":{"Line":0}},{"line":313,"address":[3477196],"length":1,"stats":{"Line":0}},{"line":314,"address":[3477200],"length":1,"stats":{"Line":0}},{"line":319,"address":[3477661,3477961],"length":1,"stats":{"Line":0}},{"line":320,"address":[3477687],"length":1,"stats":{"Line":0}},{"line":321,"address":[3477718],"length":1,"stats":{"Line":0}},{"line":322,"address":[3477734,3477805],"length":1,"stats":{"Line":0}},{"line":323,"address":[3477929,3477837],"length":1,"stats":{"Line":0}},{"line":326,"address":[3478093],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":144},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","commands","list_output.rs"],"content":"use lastfm_edit::{Album, Artist, Track};\nuse serde::{Deserialize, Serialize};\n\n/// Events emitted by list commands\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(tag = \"type\")]\npub enum ListEvent {\n    /// Starting to list items\n    Started {\n        command: String,\n        artist: Option\u003cString\u003e,\n        album: Option\u003cString\u003e,\n    },\n    /// Found an artist\n    ArtistFound { index: usize, artist: Artist },\n    /// Found an album\n    AlbumFound { index: usize, album: Album },\n    /// Found a track\n    TrackFound { index: usize, track: Track },\n    /// Starting a new album section (for tracks-by-album)\n    AlbumSection { album_index: usize, album: Album },\n    /// Found a track within an album section\n    AlbumTrackFound {\n        album_index: usize,\n        track_index: usize,\n        track: Track,\n    },\n    /// Command completed with summary\n    Summary {\n        command: String,\n        total_items: usize,\n        artist: Option\u003cString\u003e,\n        album: Option\u003cString\u003e,\n    },\n    /// Error occurred\n    Error { message: String },\n}\n\n/// Trait for handling list command output\npub trait ListOutputHandler {\n    fn handle_event(\u0026mut self, event: ListEvent);\n}\n\n/// Human-readable output handler for list commands\npub struct HumanReadableListHandler {\n    verbose: bool,\n    format: bool,\n}\n\nimpl HumanReadableListHandler {\n    pub fn new(verbose: bool, format: bool) -\u003e Self {\n        Self { verbose, format }\n    }\n}\n\nimpl ListOutputHandler for HumanReadableListHandler {\n    fn handle_event(\u0026mut self, event: ListEvent) {\n        match event {\n            ListEvent::Started {\n                command,\n                artist,\n                album,\n            } =\u003e match command.as_str() {\n                \"artists\" =\u003e println!(\"ğŸµ Listing artists in your library\"),\n                \"albums\" =\u003e {\n                    if let Some(artist) = artist {\n                        println!(\"ğŸµ Listing albums for artist: '{artist}'\");\n                    }\n                }\n                \"tracks\" =\u003e {\n                    if let Some(artist) = artist {\n                        println!(\"ğŸµ Listing tracks for artist: '{artist}'\");\n                        println!(\"   (with complete album information)\");\n                    }\n                }\n                \"tracks-by-album\" =\u003e {\n                    if let Some(artist) = artist {\n                        println!(\"ğŸµ Listing tracks by album for artist: '{artist}'\");\n                    }\n                }\n                \"album-tracks\" =\u003e {\n                    if let (Some(album), Some(artist)) = (album, artist) {\n                        println!(\"ğŸµ Listing tracks for album: '{album}' by '{artist}'\");\n                    }\n                }\n                _ =\u003e {}\n            },\n            ListEvent::ArtistFound { index, artist } =\u003e {\n                if self.format {\n                    if self.verbose {\n                        println!(\"  [{index:3}] {artist} ({} plays)\", artist.playcount);\n                    } else {\n                        println!(\"  [{index:3}] {artist}\");\n                    }\n                } else if self.verbose {\n                    println!(\"  [{index:3}] {} ({} plays)\", artist.name, artist.playcount);\n                } else {\n                    println!(\"  [{index:3}] {}\", artist.name);\n                }\n            }\n            ListEvent::AlbumFound { index, album } =\u003e {\n                if self.format {\n                    if self.verbose {\n                        println!(\"  [{index:3}] {album} ({} plays)\", album.playcount);\n                    } else {\n                        println!(\"  [{index:3}] {album}\");\n                    }\n                } else if self.verbose {\n                    println!(\"  [{index:3}] {} ({} plays)\", album.name, album.playcount);\n                } else {\n                    println!(\"  [{index:3}] {}\", album.name);\n                }\n            }\n            ListEvent::TrackFound { index, track } =\u003e {\n                if self.format {\n                    if self.verbose {\n                        let album_artist_info = track\n                            .album_artist\n                            .as_deref()\n                            .unwrap_or(\"Same as track artist\");\n                        println!(\"  [{index:3}] {track} ({} plays)\", track.playcount);\n                        println!(\"       Album Artist: {album_artist_info}\");\n                        if let Some(timestamp) = track.timestamp {\n                            println!(\"       Last Played: {timestamp}\");\n                        }\n                    } else {\n                        println!(\"  [{index:3}] {track}\");\n                    }\n                } else if self.verbose {\n                    let album_info = track.album.as_deref().unwrap_or(\"Unknown Album\");\n                    let album_artist_info = track\n                        .album_artist\n                        .as_deref()\n                        .unwrap_or(\"Same as track artist\");\n                    println!(\"  [{index:3}] {} ({} plays)\", track.name, track.playcount);\n                    println!(\"       Album: {album_info}\");\n                    println!(\"       Album Artist: {album_artist_info}\");\n                    if let Some(timestamp) = track.timestamp {\n                        println!(\"       Last Played: {timestamp}\");\n                    }\n                } else {\n                    let album_info = track.album.as_deref().unwrap_or(\"Unknown Album\");\n                    println!(\"  [{index:3}] {} [{}]\", track.name, album_info);\n                }\n\n                if self.verbose {\n                    println!();\n                }\n            }\n            ListEvent::AlbumSection { album_index, album } =\u003e {\n                if self.verbose {\n                    println!(\n                        \"\\nğŸ“€ Album {}: {} ({} plays)\",\n                        album_index, album.name, album.playcount\n                    );\n                } else {\n                    println!(\"\\nğŸ“€ Album {}: {}\", album_index, album.name);\n                }\n            }\n            ListEvent::AlbumTrackFound {\n                track_index, track, ..\n            } =\u003e {\n                if self.format {\n                    if self.verbose {\n                        println!(\n                            \"    [{:2}] {track} ({} plays)\",\n                            track_index, track.playcount\n                        );\n                        if let Some(timestamp) = track.timestamp {\n                            println!(\"         Last Played: {timestamp}\");\n                        }\n                    } else {\n                        println!(\"    [{track_index:2}] {track}\");\n                    }\n                } else if self.verbose {\n                    println!(\n                        \"    [{:2}] {} ({} plays)\",\n                        track_index, track.name, track.playcount\n                    );\n                    if let Some(timestamp) = track.timestamp {\n                        println!(\"         Last Played: {timestamp}\");\n                    }\n                } else {\n                    println!(\"    [{:2}] {}\", track_index, track.name);\n                }\n            }\n            ListEvent::Summary {\n                command,\n                total_items,\n                artist,\n                ..\n            } =\u003e match command.as_str() {\n                \"artists\" =\u003e {\n                    if total_items == 0 {\n                        println!(\"  No artists found in your library.\");\n                    } else {\n                        println!(\n                            \"\\nFound {} artist{} in your library\",\n                            total_items,\n                            if total_items == 1 { \"\" } else { \"s\" }\n                        );\n                    }\n                }\n                \"albums\" =\u003e {\n                    if let Some(artist) = artist {\n                        if total_items == 0 {\n                            println!(\"  No albums found for this artist.\");\n                        } else {\n                            println!(\n                                \"\\nFound {} album{} for '{artist}'\",\n                                total_items,\n                                if total_items == 1 { \"\" } else { \"s\" }\n                            );\n                        }\n                    }\n                }\n                \"tracks\" =\u003e {\n                    if let Some(artist) = artist {\n                        if total_items == 0 {\n                            println!(\"  No tracks found for this artist.\");\n                        } else {\n                            println!(\n                                \"\\nFound {} track{} for '{artist}'\",\n                                total_items,\n                                if total_items == 1 { \"\" } else { \"s\" }\n                            );\n                        }\n                    }\n                }\n                \"tracks-by-album\" =\u003e {\n                    if let Some(artist) = artist {\n                        if total_items == 0 {\n                            println!(\"  No albums found for this artist.\");\n                        } else {\n                            println!(\n                                \"\\nListed {} album{} for '{artist}'\",\n                                total_items,\n                                if total_items == 1 { \"\" } else { \"s\" }\n                            );\n                        }\n                    }\n                }\n                \"album-tracks\" =\u003e {\n                    if total_items == 0 {\n                        println!(\"  No tracks found for this album.\");\n                    }\n                }\n                _ =\u003e {}\n            },\n            ListEvent::Error { message } =\u003e {\n                println!(\"    âŒ Error: {message}\");\n            }\n        }\n    }\n}\n\n/// JSON output handler for list commands (JSONL format)\npub struct JsonListHandler;\n\nimpl JsonListHandler {\n    pub fn new() -\u003e Self {\n        Self\n    }\n}\n\nimpl ListOutputHandler for JsonListHandler {\n    fn handle_event(\u0026mut self, event: ListEvent) {\n        // Output each event as a single line of JSON\n        if let Ok(json) = serde_json::to_string(\u0026event) {\n            println!(\"{json}\");\n        } else {\n            eprintln!(\"âŒ Failed to serialize event to JSON\");\n        }\n    }\n}\n","traces":[{"line":51,"address":[3503360],"length":1,"stats":{"Line":0}},{"line":57,"address":[3503392,3505397,3514881],"length":1,"stats":{"Line":0}},{"line":58,"address":[3503438],"length":1,"stats":{"Line":0}},{"line":59,"address":[3503575],"length":1,"stats":{"Line":0}},{"line":64,"address":[3504258,3504339,3506270],"length":1,"stats":{"Line":0}},{"line":65,"address":[3504375,3504313],"length":1,"stats":{"Line":0}},{"line":66,"address":[3504423,3506068],"length":1,"stats":{"Line":0}},{"line":67,"address":[3506108,3506179],"length":1,"stats":{"Line":0}},{"line":70,"address":[3504397,3504476],"length":1,"stats":{"Line":0}},{"line":71,"address":[3505821,3504524],"length":1,"stats":{"Line":0}},{"line":72,"address":[3505932,3505861],"length":1,"stats":{"Line":0}},{"line":73,"address":[3506001],"length":1,"stats":{"Line":0}},{"line":76,"address":[3504498,3504574],"length":1,"stats":{"Line":0}},{"line":77,"address":[3505619,3504622],"length":1,"stats":{"Line":0}},{"line":78,"address":[3505730,3505659],"length":1,"stats":{"Line":0}},{"line":81,"address":[3504596,3504672],"length":1,"stats":{"Line":0}},{"line":82,"address":[3504697,3505049],"length":1,"stats":{"Line":0}},{"line":83,"address":[3505129,3505200],"length":1,"stats":{"Line":0}},{"line":88,"address":[3503689],"length":1,"stats":{"Line":0}},{"line":89,"address":[3503731],"length":1,"stats":{"Line":0}},{"line":90,"address":[3506755],"length":1,"stats":{"Line":0}},{"line":91,"address":[3507335,3507557],"length":1,"stats":{"Line":0}},{"line":93,"address":[3507429,3507308],"length":1,"stats":{"Line":0}},{"line":95,"address":[3506740],"length":1,"stats":{"Line":0}},{"line":96,"address":[3507117,3506828],"length":1,"stats":{"Line":0}},{"line":98,"address":[3506950,3506769],"length":1,"stats":{"Line":0}},{"line":101,"address":[3503754],"length":1,"stats":{"Line":0}},{"line":102,"address":[3503796],"length":1,"stats":{"Line":0}},{"line":103,"address":[3507767],"length":1,"stats":{"Line":0}},{"line":104,"address":[3508347,3508569],"length":1,"stats":{"Line":0}},{"line":106,"address":[3508320,3508441],"length":1,"stats":{"Line":0}},{"line":108,"address":[3507752],"length":1,"stats":{"Line":0}},{"line":109,"address":[3507840,3508129],"length":1,"stats":{"Line":0}},{"line":111,"address":[3507781,3507962],"length":1,"stats":{"Line":0}},{"line":114,"address":[3503819],"length":1,"stats":{"Line":0}},{"line":115,"address":[3503864],"length":1,"stats":{"Line":0}},{"line":116,"address":[3508779],"length":1,"stats":{"Line":0}},{"line":117,"address":[3510250,3510064],"length":1,"stats":{"Line":0}},{"line":121,"address":[3510309],"length":1,"stats":{"Line":0}},{"line":122,"address":[3510566],"length":1,"stats":{"Line":0}},{"line":123,"address":[3510662],"length":1,"stats":{"Line":0}},{"line":124,"address":[3510696],"length":1,"stats":{"Line":0}},{"line":127,"address":[3510037,3510112],"length":1,"stats":{"Line":0}},{"line":129,"address":[3508764],"length":1,"stats":{"Line":0}},{"line":130,"address":[3509292,3508828],"length":1,"stats":{"Line":0}},{"line":131,"address":[3509351],"length":1,"stats":{"Line":0}},{"line":135,"address":[3509449],"length":1,"stats":{"Line":0}},{"line":136,"address":[3509710],"length":1,"stats":{"Line":0}},{"line":137,"address":[3509806],"length":1,"stats":{"Line":0}},{"line":138,"address":[3509902],"length":1,"stats":{"Line":0}},{"line":139,"address":[3509936],"length":1,"stats":{"Line":0}},{"line":142,"address":[3508793,3508926],"length":1,"stats":{"Line":0}},{"line":143,"address":[3508991],"length":1,"stats":{"Line":0}},{"line":146,"address":[3509262],"length":1,"stats":{"Line":0}},{"line":147,"address":[3510819],"length":1,"stats":{"Line":0}},{"line":150,"address":[3503887],"length":1,"stats":{"Line":0}},{"line":151,"address":[3503929],"length":1,"stats":{"Line":0}},{"line":152,"address":[3511103,3510893],"length":1,"stats":{"Line":0}},{"line":157,"address":[3510967,3510866],"length":1,"stats":{"Line":0}},{"line":160,"address":[3503951],"length":1,"stats":{"Line":0}},{"line":163,"address":[3503992],"length":1,"stats":{"Line":0}},{"line":164,"address":[3511286],"length":1,"stats":{"Line":0}},{"line":165,"address":[3511916,3512138],"length":1,"stats":{"Line":0}},{"line":169,"address":[3512320],"length":1,"stats":{"Line":0}},{"line":170,"address":[3512354],"length":1,"stats":{"Line":0}},{"line":173,"address":[3511889,3512010],"length":1,"stats":{"Line":0}},{"line":175,"address":[3511271],"length":1,"stats":{"Line":0}},{"line":176,"address":[3511327,3511568],"length":1,"stats":{"Line":0}},{"line":180,"address":[3511754],"length":1,"stats":{"Line":0}},{"line":181,"address":[3511788],"length":1,"stats":{"Line":0}},{"line":184,"address":[3511300,3511401],"length":1,"stats":{"Line":0}},{"line":187,"address":[3504039],"length":1,"stats":{"Line":0}},{"line":193,"address":[3512553],"length":1,"stats":{"Line":0}},{"line":194,"address":[3512619],"length":1,"stats":{"Line":0}},{"line":195,"address":[3514359,3514306],"length":1,"stats":{"Line":0}},{"line":197,"address":[3514383],"length":1,"stats":{"Line":0}},{"line":204,"address":[3512643,3512596],"length":1,"stats":{"Line":0}},{"line":205,"address":[3512682,3513874],"length":1,"stats":{"Line":0}},{"line":206,"address":[3513930],"length":1,"stats":{"Line":0}},{"line":207,"address":[3514038,3513941],"length":1,"stats":{"Line":0}},{"line":209,"address":[3514081],"length":1,"stats":{"Line":0}},{"line":217,"address":[3512732,3512659],"length":1,"stats":{"Line":0}},{"line":218,"address":[3513442,3512771],"length":1,"stats":{"Line":0}},{"line":219,"address":[3513498],"length":1,"stats":{"Line":0}},{"line":220,"address":[3513509,3513606],"length":1,"stats":{"Line":0}},{"line":222,"address":[3513535,3513714],"length":1,"stats":{"Line":0}},{"line":230,"address":[3512748,3512818],"length":1,"stats":{"Line":0}},{"line":231,"address":[3512857,3513010],"length":1,"stats":{"Line":0}},{"line":232,"address":[3513066],"length":1,"stats":{"Line":0}},{"line":233,"address":[3513077,3513174],"length":1,"stats":{"Line":0}},{"line":235,"address":[3513103,3513282],"length":1,"stats":{"Line":0}},{"line":243,"address":[3512900,3512834],"length":1,"stats":{"Line":0}},{"line":244,"address":[3512952],"length":1,"stats":{"Line":0}},{"line":245,"address":[3512963],"length":1,"stats":{"Line":0}},{"line":250,"address":[3504125],"length":1,"stats":{"Line":0}},{"line":251,"address":[3504149,3514741],"length":1,"stats":{"Line":0}},{"line":267,"address":[3514912,3515320,3515467],"length":1,"stats":{"Line":0}},{"line":269,"address":[3514987,3514931,3515058],"length":1,"stats":{"Line":0}},{"line":270,"address":[3515086,3515148],"length":1,"stats":{"Line":0}},{"line":272,"address":[3515326,3515029],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":100},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","commands","mod.rs"],"content":"pub mod delete;\npub mod edit;\npub mod list;\npub mod list_output;\npub mod search;\npub mod search_output;\npub mod show;\npub mod show_output;\npub mod utils;\n\nuse clap::{arg, Subcommand, ValueEnum};\nuse lastfm_edit::LastFmEditClientImpl;\n\n#[derive(ValueEnum, Clone)]\npub enum SearchType {\n    /// Search for tracks\n    Tracks,\n    /// Search for albums\n    Albums,\n}\n\n#[derive(Subcommand)]\npub enum ListCommands {\n    /// List all artists in your library\n    ///\n    /// This command lists all artists in your Last.fm library, sorted by play count\n    /// (highest first). Shows artist names and scrobble counts.\n    ///\n    /// Usage examples:\n    /// # List all artists\n    /// lastfm-edit list artists\n    ///\n    /// # List first 20 artists with play counts\n    /// lastfm-edit list artists --limit 20 --details\n    ///\n    /// # List artists with formatted display\n    /// lastfm-edit list artists --format\n    Artists {\n        /// Maximum number of artists to show (0 for no limit)\n        #[arg(long, default_value = \"0\")]\n        limit: usize,\n\n        /// Show additional details like play counts\n        #[arg(long)]\n        details: bool,\n\n        /// Show formatted output\n        #[arg(long)]\n        format: bool,\n    },\n\n    /// List albums for an artist\n    ///\n    /// This command lists all albums in your library for a specified artist.\n    /// The albums are sorted by play count (highest first).\n    ///\n    /// Usage examples:\n    /// # List all albums for The Beatles\n    /// lastfm-edit list albums \"The Beatles\"\n    ///\n    /// # List first 10 albums with play counts\n    /// lastfm-edit list albums \"Radiohead\" --limit 10 --details\n    ///\n    /// # List albums with formatted display (Artist - Album Name)\n    /// lastfm-edit list albums \"The Beatles\" --format\n    Albums {\n        /// Artist name\n        artist: String,\n\n        /// Maximum number of albums to show (0 for no limit)\n        #[arg(long, default_value = \"0\")]\n        limit: usize,\n\n        /// Show additional details like play counts\n        #[arg(long)]\n        details: bool,\n\n        /// Show formatted output (Artist - Album/Track Name [Album Name])\n        #[arg(long)]\n        format: bool,\n    },\n\n    /// List all tracks for an artist with album information (album-based iteration)\n    ///\n    /// This command lists all tracks in your library for a specified artist,\n    /// with complete album information included. Unlike tracks-by-album, this\n    /// shows tracks in a flat list with album details for each track.\n    /// Note: This uses album-based iteration, so tracks without album metadata may be missed.\n    ///\n    /// Usage examples:\n    /// # List all tracks for The Beatles with album info\n    /// lastfm-edit list tracks \"The Beatles\"\n    ///\n    /// # List first 20 tracks with play counts and details\n    /// lastfm-edit list tracks \"Radiohead\" --limit 20 --details\n    ///\n    /// # List tracks with formatted display (Artist - Track Name [Album Name])\n    /// lastfm-edit list tracks \"The Beatles\" --format\n    Tracks {\n        /// Artist name\n        artist: String,\n\n        /// Maximum number of tracks to show (0 for no limit)\n        #[arg(long, default_value = \"0\")]\n        limit: usize,\n\n        /// Show additional details like play counts and album artist\n        #[arg(long)]\n        details: bool,\n\n        /// Show formatted output (Artist - Track Name [Album Name])\n        #[arg(long)]\n        format: bool,\n    },\n\n    /// List all tracks for an artist using direct track iteration\n    ///\n    /// This command lists all tracks in your library for a specified artist using\n    /// direct track iteration. This approach finds ALL tracks, including those\n    /// without album metadata (singles, B-sides, etc.) that may be missed by the\n    /// regular tracks command.\n    ///\n    /// Usage examples:\n    /// # List all tracks including those without albums\n    /// lastfm-edit list tracks-direct \"The Beatles\"\n    ///\n    /// # Compare with regular tracks command to find missing tracks\n    /// lastfm-edit list tracks-direct \"The Beatles\" --limit 20 --details\n    TracksDirect {\n        /// Artist name\n        artist: String,\n\n        /// Maximum number of tracks to show (0 for no limit)\n        #[arg(long, default_value = \"0\")]\n        limit: usize,\n\n        /// Show additional details like play counts and album artist\n        #[arg(long)]\n        details: bool,\n\n        /// Show formatted output (Artist - Track Name [Album Name])\n        #[arg(long)]\n        format: bool,\n    },\n\n    /// List tracks organized by album for an artist\n    ///\n    /// This command lists all tracks in your library for a specified artist,\n    /// organized by album. For each album, it shows all tracks from that album.\n    ///\n    /// Usage examples:\n    /// # List all tracks by album for The Beatles\n    /// lastfm-edit list tracks-by-album \"The Beatles\"\n    ///\n    /// # List tracks for first 5 albums with play counts\n    /// lastfm-edit list tracks-by-album \"Pink Floyd\" --limit 5 --details\n    ///\n    /// # List tracks with formatted display (Artist - Track Name [Album Name])\n    /// lastfm-edit list tracks-by-album \"The Beatles\" --format\n    TracksByAlbum {\n        /// Artist name\n        artist: String,\n\n        /// Maximum number of albums to show (0 for no limit)\n        #[arg(long, default_value = \"0\")]\n        limit: usize,\n\n        /// Show additional details like play counts\n        #[arg(long)]\n        details: bool,\n\n        /// Show formatted output (Artist - Album/Track Name [Album Name])\n        #[arg(long)]\n        format: bool,\n    },\n\n    /// List tracks for a specific album\n    ///\n    /// This command lists all tracks for a specific album by a specific artist.\n    /// This is useful for albums with special characters like slashes in their names.\n    ///\n    /// Usage examples:\n    /// # List all tracks for AC/DC's \"Back in Black\" album\n    /// lastfm-edit list album-tracks \"Back in Black\" \"AC/DC\"\n    ///\n    /// # List tracks with details and formatted output\n    /// lastfm-edit list album-tracks \"The Dark Side of the Moon\" \"Pink Floyd\" --details --format\n    AlbumTracks {\n        /// Album name\n        album: String,\n\n        /// Artist name\n        artist: String,\n\n        /// Show additional details like play counts\n        #[arg(long)]\n        details: bool,\n\n        /// Show formatted output (Artist - Track Name [Album Name])\n        #[arg(long)]\n        format: bool,\n    },\n}\n\n#[derive(Subcommand)]\npub enum Commands {\n    /// Edit scrobble metadata\n    ///\n    /// This command allows you to edit scrobble metadata by specifying what to search for\n    /// and what to change it to. You can specify any combination of fields to search for,\n    /// and any combination of new values to change them to.\n    ///\n    /// Usage examples:\n    /// # Discover variations for an artist (dry run by default)\n    /// lastfm-edit edit --artist \"Jimi Hendrix\"\n    ///\n    /// # Discover variations with optional track name\n    /// lastfm-edit edit --artist \"Radiohead\" --track \"Creep\"\n    ///\n    /// # Actually apply edits (change artist name)\n    /// lastfm-edit edit --artist \"The Beatles\" --new-artist \"Beatles, The\" --apply\n    ///\n    /// # Change track name for specific track\n    /// lastfm-edit edit --artist \"Jimi Hendrix\" --track \"Lover Man\" --new-track \"Lover Man (Live)\" --apply\n    Edit {\n        /// Artist name (required)\n        #[arg(long)]\n        artist: String,\n\n        /// Track name (optional)\n        #[arg(long)]\n        track: Option\u003cString\u003e,\n\n        /// Album name (optional)\n        #[arg(long)]\n        album: Option\u003cString\u003e,\n\n        /// Album artist name (optional)\n        #[arg(long)]\n        album_artist: Option\u003cString\u003e,\n\n        /// New track name (optional)\n        #[arg(long)]\n        new_track: Option\u003cString\u003e,\n\n        /// New album name (optional)\n        #[arg(long)]\n        new_album: Option\u003cString\u003e,\n\n        /// New artist name (optional)\n        #[arg(long)]\n        new_artist: Option\u003cString\u003e,\n\n        /// New album artist name (optional)\n        #[arg(long)]\n        new_album_artist: Option\u003cString\u003e,\n\n        /// Timestamp for specific scrobble (optional)\n        #[arg(long)]\n        timestamp: Option\u003cu64\u003e,\n\n        /// Disable editing all instances (edit only specific scrobble, defaults to editing all)\n        #[arg(long)]\n        no_edit_all: bool,\n\n        /// Actually apply the edits (default is dry-run mode)\n        #[arg(long)]\n        apply: bool,\n\n        /// Perform a dry run without actually submitting edits (default behavior)\n        #[arg(long)]\n        dry_run: bool,\n    },\n    /// Delete scrobbles in a range\n    ///\n    /// This command allows you to delete scrobbles from your library. You can specify\n    /// timestamp ranges, delete recent scrobbles from specific pages, or use offsets\n    /// from the most recent scrobble.\n    ///\n    /// Usage examples:\n    /// # Show recent scrobbles that would be deleted (dry run)\n    /// lastfm-edit delete --recent-pages 1-3\n    ///\n    /// # Delete scrobbles from timestamp range\n    /// lastfm-edit delete --timestamp-range 1640995200-1641000000 --apply\n    ///\n    /// # Delete scrobbles by offset from most recent (0-indexed)\n    /// lastfm-edit delete --recent-offset 0-4 --apply\n    Delete {\n        /// Delete scrobbles from recent pages (format: start-end, 0-indexed)\n        #[arg(long, conflicts_with_all = [\"timestamp_range\", \"recent_offset\"])]\n        recent_pages: Option\u003cString\u003e,\n\n        /// Delete scrobbles from timestamp range (format: start_ts-end_ts)\n        #[arg(long, conflicts_with_all = [\"recent_pages\", \"recent_offset\"])]\n        timestamp_range: Option\u003cString\u003e,\n\n        /// Delete scrobbles by offset from most recent (format: start-end, 0-indexed)\n        #[arg(long, conflicts_with_all = [\"recent_pages\", \"timestamp_range\"])]\n        recent_offset: Option\u003cString\u003e,\n\n        /// Actually perform the deletions (default is dry-run mode)\n        #[arg(long)]\n        apply: bool,\n\n        /// Perform a dry run without actually deleting (default behavior)\n        #[arg(long)]\n        dry_run: bool,\n    },\n    /// Search tracks and albums in your library\n    ///\n    /// This command allows you to search through your Last.fm library for tracks or albums\n    /// that match a specific query. You can limit the number of results and specify whether\n    /// to search for tracks or albums.\n    ///\n    /// Usage examples:\n    /// # Search for tracks containing \"remaster\"\n    /// lastfm-edit search tracks \"remaster\"\n    ///\n    /// # Search for first 20 albums containing \"deluxe\"\n    /// lastfm-edit search albums \"deluxe\" --limit 20\n    ///\n    /// # Search for tracks with unlimited results\n    /// lastfm-edit search tracks \"live\" --limit 0\n    ///\n    /// # Skip first 10 results and show next 20\n    /// lastfm-edit search tracks \"live\" --offset 10 --limit 20\n    Search {\n        /// Type of search: tracks or albums\n        #[arg(value_enum)]\n        search_type: SearchType,\n\n        /// Search query\n        query: String,\n\n        /// Maximum number of results to show (0 for no limit)\n        #[arg(long, default_value = \"50\")]\n        limit: usize,\n\n        /// Number of results to skip from the beginning (0-indexed)\n        #[arg(long, default_value = \"0\")]\n        offset: usize,\n\n        /// Show additional details like play counts\n        #[arg(long)]\n        details: bool,\n    },\n\n    /// Show scrobble details for specific offsets\n    ///\n    /// This command displays detailed information for scrobbles at the specified\n    /// offsets from your most recent scrobbles.\n    ///\n    /// Usage examples:\n    /// # Show details for the most recent scrobble (offset 0)\n    /// lastfm-edit show 0\n    ///\n    /// # Show details for multiple scrobbles (0-indexed)\n    /// lastfm-edit show 0 1 2 5 10\n    Show {\n        /// Offsets of scrobbles to show (0-indexed, 0 = most recent)\n        offsets: Vec\u003cu64\u003e,\n    },\n\n    /// List artists, albums, and tracks from your library\n    ///\n    /// This command allows you to browse your Last.fm library by listing artists,\n    /// albums, and tracks.\n    ///\n    /// Usage examples:\n    /// # List all artists in your library\n    /// lastfm-edit list artists --limit 20 --details\n    ///\n    /// # List all albums for The Beatles\n    /// lastfm-edit list albums \"The Beatles\"\n    ///\n    /// # List all tracks with album information\n    /// lastfm-edit list tracks \"Radiohead\" --limit 20 --details\n    ///\n    /// # List tracks organized by album\n    /// lastfm-edit list tracks-by-album \"Pink Floyd\" --limit 5 --details\n    List {\n        #[command(subcommand)]\n        command: ListCommands,\n    },\n}\n\n/// Execute the appropriate command handler based on the parsed command\npub async fn execute_command(\n    command: Commands,\n    client: \u0026LastFmEditClientImpl,\n    json_output: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    match command {\n        Commands::Edit {\n            artist,\n            track,\n            album,\n            album_artist,\n            new_track,\n            new_album,\n            new_artist,\n            new_album_artist,\n            timestamp,\n            no_edit_all,\n            apply,\n            dry_run,\n        } =\u003e {\n            // Determine whether this is a dry run or actual edit\n            let is_dry_run = dry_run || !apply;\n\n            let edit = edit::create_scrobble_edit_from_args(\n                \u0026artist,\n                track.as_deref(),\n                album.as_deref(),\n                album_artist.as_deref(),\n                new_track.as_deref(),\n                new_album.as_deref(),\n                new_artist.as_deref(),\n                new_album_artist.as_deref(),\n                timestamp,\n                !no_edit_all, // edit_all is true by default, false only if --no-edit-all is provided\n            );\n\n            edit::handle_edit_command(client, \u0026edit, is_dry_run).await\n        }\n\n        Commands::Delete {\n            recent_pages,\n            timestamp_range,\n            recent_offset,\n            apply,\n            dry_run,\n        } =\u003e {\n            // Determine whether this is a dry run or actual deletion\n            let is_dry_run = dry_run || !apply;\n\n            if let Some(pages_range) = recent_pages {\n                delete::handle_delete_recent_pages(client, \u0026pages_range, is_dry_run).await\n            } else if let Some(ts_range) = timestamp_range {\n                delete::handle_delete_timestamp_range(client, \u0026ts_range, is_dry_run).await\n            } else if let Some(offset_range) = recent_offset {\n                delete::handle_delete_recent_offset(client, \u0026offset_range, is_dry_run).await\n            } else {\n                Err(\n                    \"Must specify one of: --recent-pages, --timestamp-range, or --recent-offset\"\n                        .into(),\n                )\n            }\n        }\n\n        Commands::Search {\n            search_type,\n            query,\n            limit,\n            offset,\n            details,\n        } =\u003e {\n            search::handle_search_command(\n                client,\n                search_type,\n                \u0026query,\n                limit,\n                offset,\n                details,\n                json_output,\n            )\n            .await\n        }\n\n        Commands::Show { offsets } =\u003e {\n            if offsets.is_empty() {\n                return Err(\"Must specify at least one offset to show\".into());\n            }\n\n            show::handle_show_scrobbles(client, \u0026offsets, json_output).await\n        }\n\n        Commands::List { command } =\u003e match command {\n            ListCommands::Artists {\n                limit,\n                details,\n                format,\n            } =\u003e list::handle_list_artists(client, limit, details, format, json_output).await,\n            ListCommands::Albums {\n                artist,\n                limit,\n                details,\n                format,\n            } =\u003e {\n                list::handle_list_albums(client, \u0026artist, limit, details, format, json_output).await\n            }\n            ListCommands::Tracks {\n                artist,\n                limit,\n                details,\n                format,\n            } =\u003e {\n                list::handle_list_tracks(client, \u0026artist, limit, details, format, json_output).await\n            }\n            ListCommands::TracksDirect {\n                artist,\n                limit,\n                details,\n                format,\n            } =\u003e {\n                list::handle_list_tracks_direct(\n                    client,\n                    \u0026artist,\n                    limit,\n                    details,\n                    format,\n                    json_output,\n                )\n                .await\n            }\n            ListCommands::TracksByAlbum {\n                artist,\n                limit,\n                details,\n                format,\n            } =\u003e {\n                list::handle_list_tracks_by_album(\n                    client,\n                    \u0026artist,\n                    limit,\n                    details,\n                    format,\n                    json_output,\n                )\n                .await\n            }\n            ListCommands::AlbumTracks {\n                album,\n                artist,\n                details,\n                format,\n            } =\u003e {\n                list::handle_list_album_tracks(\n                    client,\n                    \u0026album,\n                    \u0026artist,\n                    details,\n                    format,\n                    json_output,\n                )\n                .await\n            }\n        },\n    }\n}\n","traces":[{"line":389,"address":[3240144],"length":1,"stats":{"Line":0}},{"line":394,"address":[3405936],"length":1,"stats":{"Line":0}},{"line":395,"address":[3406567],"length":1,"stats":{"Line":0}},{"line":410,"address":[3407600,3406881],"length":1,"stats":{"Line":0}},{"line":413,"address":[3407621],"length":1,"stats":{"Line":0}},{"line":414,"address":[3407742],"length":1,"stats":{"Line":0}},{"line":415,"address":[3407816],"length":1,"stats":{"Line":0}},{"line":416,"address":[3407890],"length":1,"stats":{"Line":0}},{"line":417,"address":[3407964],"length":1,"stats":{"Line":0}},{"line":418,"address":[3408038],"length":1,"stats":{"Line":0}},{"line":419,"address":[3408112],"length":1,"stats":{"Line":0}},{"line":420,"address":[3408186],"length":1,"stats":{"Line":0}},{"line":422,"address":[3408331],"length":1,"stats":{"Line":0}},{"line":425,"address":[3174542],"length":1,"stats":{"Line":0}},{"line":428,"address":[3406967],"length":1,"stats":{"Line":0}},{"line":436,"address":[3407169,3408673],"length":1,"stats":{"Line":0}},{"line":438,"address":[3408694],"length":1,"stats":{"Line":0}},{"line":439,"address":[3174564],"length":1,"stats":{"Line":0}},{"line":440,"address":[3175557,3175596],"length":1,"stats":{"Line":0}},{"line":441,"address":[3174586],"length":1,"stats":{"Line":0}},{"line":442,"address":[3175774,3175735],"length":1,"stats":{"Line":0}},{"line":443,"address":[3174608],"length":1,"stats":{"Line":0}},{"line":446,"address":[3409487],"length":1,"stats":{"Line":0}},{"line":452,"address":[3407277],"length":1,"stats":{"Line":0}},{"line":462,"address":[3407336],"length":1,"stats":{"Line":0}},{"line":468,"address":[3174630],"length":1,"stats":{"Line":0}},{"line":471,"address":[3407377],"length":1,"stats":{"Line":0}},{"line":472,"address":[3410185,3407413],"length":1,"stats":{"Line":0}},{"line":473,"address":[3410433,3410229],"length":1,"stats":{"Line":0}},{"line":476,"address":[3415424,3406138,3410305,3410191],"length":1,"stats":{"Line":0}},{"line":479,"address":[3407445],"length":1,"stats":{"Line":0}},{"line":480,"address":[3174674],"length":1,"stats":{"Line":0}},{"line":485,"address":[3410813],"length":1,"stats":{"Line":0}},{"line":491,"address":[3410841,3406180,3411738,3415888],"length":1,"stats":{"Line":0}},{"line":493,"address":[3410918],"length":1,"stats":{"Line":0}},{"line":499,"address":[3174718],"length":1,"stats":{"Line":0}},{"line":501,"address":[3411082],"length":1,"stats":{"Line":0}},{"line":509,"address":[3411169],"length":1,"stats":{"Line":0}},{"line":515,"address":[3416382,3412291,3416578,3406222,3412331],"length":1,"stats":{"Line":0}},{"line":517,"address":[3411305],"length":1,"stats":{"Line":0}},{"line":525,"address":[3411333],"length":1,"stats":{"Line":0}},{"line":531,"address":[3174762],"length":1,"stats":{"Line":0}},{"line":533,"address":[3411374],"length":1,"stats":{"Line":0}},{"line":541,"address":[3411502],"length":1,"stats":{"Line":0}},{"line":542,"address":[3412688],"length":1,"stats":{"Line":0}},{"line":547,"address":[3174784],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","commands","search.rs"],"content":"use super::search_output::{\n    HumanReadableSearchHandler, JsonSearchHandler, SearchEvent, SearchOutputHandler,\n};\nuse super::SearchType;\nuse lastfm_edit::{LastFmEditClient, LastFmEditClientImpl};\n\n/// Number of items per page in Last.fm search results\nconst ITEMS_PER_PAGE: usize = 30;\n\n/// Handle the search command for tracks or albums in the user's library\npub async fn handle_search_command(\n    client: \u0026LastFmEditClientImpl,\n    search_type: SearchType,\n    query: \u0026str,\n    limit: usize,\n    offset: usize,\n    details: bool,\n    json_output: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create appropriate handler based on output format\n    let mut handler: Box\u003cdyn SearchOutputHandler\u003e = if json_output {\n        Box::new(JsonSearchHandler::new())\n    } else {\n        Box::new(HumanReadableSearchHandler::new(details))\n    };\n\n    let search_type_str = match search_type {\n        SearchType::Tracks =\u003e \"tracks\",\n        SearchType::Albums =\u003e \"albums\",\n    };\n\n    // Emit start event\n    handler.handle_event(SearchEvent::Started {\n        search_type: search_type_str.to_string(),\n        query: query.to_string(),\n        offset,\n        limit,\n    });\n\n    // Calculate starting page and within-page offset\n    let starting_page = if offset \u003e 0 {\n        (offset / ITEMS_PER_PAGE) + 1\n    } else {\n        1\n    };\n    let within_page_offset = offset % ITEMS_PER_PAGE;\n\n    match search_type {\n        SearchType::Tracks =\u003e {\n            // Create iterator starting from the calculated page\n            let mut search_iterator = if starting_page \u003e 1 {\n                Box::new(lastfm_edit::SearchTracksIterator::with_starting_page(\n                    client.clone(),\n                    query.to_string(),\n                    starting_page as u32,\n                ))\n            } else {\n                client.search_tracks(query)\n            };\n\n            let mut total_count = 0;\n            let mut displayed_count = 0;\n            let should_limit = limit \u003e 0;\n\n            // Process results incrementally\n            while let Some(track) = search_iterator.next().await? {\n                total_count += 1;\n\n                // Skip items until we reach the desired within-page offset\n                if total_count \u003c= within_page_offset {\n                    continue;\n                }\n\n                displayed_count += 1;\n                let display_number = offset + displayed_count;\n\n                // Emit track found event\n                handler.handle_event(SearchEvent::TrackFound {\n                    index: display_number,\n                    track,\n                });\n\n                if should_limit \u0026\u0026 displayed_count \u003e= limit {\n                    break;\n                }\n            }\n\n            if displayed_count == 0 {\n                handler.handle_event(SearchEvent::NoResults {\n                    search_type: search_type_str.to_string(),\n                    query: query.to_string(),\n                });\n            } else {\n                handler.handle_event(SearchEvent::Summary {\n                    search_type: search_type_str.to_string(),\n                    query: query.to_string(),\n                    total_displayed: displayed_count,\n                    offset,\n                    limit,\n                });\n            }\n        }\n\n        SearchType::Albums =\u003e {\n            // Create iterator starting from the calculated page\n            let mut search_iterator = if starting_page \u003e 1 {\n                Box::new(lastfm_edit::SearchAlbumsIterator::with_starting_page(\n                    client.clone(),\n                    query.to_string(),\n                    starting_page as u32,\n                ))\n            } else {\n                client.search_albums(query)\n            };\n\n            let mut total_count = 0;\n            let mut displayed_count = 0;\n            let should_limit = limit \u003e 0;\n\n            // Process results incrementally\n            while let Some(album) = search_iterator.next().await? {\n                total_count += 1;\n\n                // Skip items until we reach the desired within-page offset\n                if total_count \u003c= within_page_offset {\n                    continue;\n                }\n\n                displayed_count += 1;\n                let display_number = offset + displayed_count;\n\n                // Emit album found event\n                handler.handle_event(SearchEvent::AlbumFound {\n                    index: display_number,\n                    album,\n                });\n\n                if should_limit \u0026\u0026 displayed_count \u003e= limit {\n                    break;\n                }\n            }\n\n            if displayed_count == 0 {\n                handler.handle_event(SearchEvent::NoResults {\n                    search_type: search_type_str.to_string(),\n                    query: query.to_string(),\n                });\n            } else {\n                handler.handle_event(SearchEvent::Summary {\n                    search_type: search_type_str.to_string(),\n                    query: query.to_string(),\n                    total_displayed: displayed_count,\n                    offset,\n                    limit,\n                });\n            }\n        }\n    }\n\n    // Emit finished event\n    handler.handle_event(SearchEvent::Finished {\n        search_type: search_type_str.to_string(),\n        query: query.to_string(),\n    });\n\n    Ok(())\n}\n","traces":[{"line":11,"address":[3571568],"length":1,"stats":{"Line":0}},{"line":21,"address":[3583125,3582885,3583218],"length":1,"stats":{"Line":0}},{"line":22,"address":[3583172,3582989],"length":1,"stats":{"Line":0}},{"line":24,"address":[3583060,3582962],"length":1,"stats":{"Line":0}},{"line":27,"address":[3583157],"length":1,"stats":{"Line":0}},{"line":28,"address":[3583249],"length":1,"stats":{"Line":0}},{"line":29,"address":[3583220],"length":1,"stats":{"Line":0}},{"line":33,"address":[3583486,3583276],"length":1,"stats":{"Line":0}},{"line":34,"address":[3583308],"length":1,"stats":{"Line":0}},{"line":35,"address":[3583379],"length":1,"stats":{"Line":0}},{"line":36,"address":[3583470,3583482],"length":1,"stats":{"Line":0}},{"line":37,"address":[3583478],"length":1,"stats":{"Line":0}},{"line":41,"address":[3583621,3583718,3583594],"length":1,"stats":{"Line":0}},{"line":42,"address":[3583675,3583720,3583623],"length":1,"stats":{"Line":0}},{"line":44,"address":[3583609],"length":1,"stats":{"Line":0}},{"line":46,"address":[3583748,3583645],"length":1,"stats":{"Line":0}},{"line":48,"address":[3583777],"length":1,"stats":{"Line":0}},{"line":51,"address":[3583810,3584251],"length":1,"stats":{"Line":0}},{"line":52,"address":[3584187,3584140],"length":1,"stats":{"Line":0}},{"line":53,"address":[3583901,3584053],"length":1,"stats":{"Line":0}},{"line":54,"address":[3584061],"length":1,"stats":{"Line":0}},{"line":55,"address":[3584133],"length":1,"stats":{"Line":0}},{"line":58,"address":[3583829,3583935],"length":1,"stats":{"Line":0}},{"line":61,"address":[3583942],"length":1,"stats":{"Line":0}},{"line":62,"address":[3583961],"length":1,"stats":{"Line":0}},{"line":63,"address":[3583980],"length":1,"stats":{"Line":0}},{"line":66,"address":[3163409],"length":1,"stats":{"Line":0}},{"line":67,"address":[3585503,3585584,3585630],"length":1,"stats":{"Line":0}},{"line":70,"address":[3585599],"length":1,"stats":{"Line":0}},{"line":74,"address":[3585758,3585819,3585692],"length":1,"stats":{"Line":0}},{"line":75,"address":[3586160,3585848,3585773],"length":1,"stats":{"Line":0}},{"line":78,"address":[3585856,3586008],"length":1,"stats":{"Line":0}},{"line":80,"address":[3585872],"length":1,"stats":{"Line":0}},{"line":83,"address":[3586181,3586216],"length":1,"stats":{"Line":0}},{"line":88,"address":[3586440],"length":1,"stats":{"Line":0}},{"line":89,"address":[3586736,3586479],"length":1,"stats":{"Line":0}},{"line":90,"address":[3586511],"length":1,"stats":{"Line":0}},{"line":91,"address":[3586645],"length":1,"stats":{"Line":0}},{"line":94,"address":[3586970,3586538],"length":1,"stats":{"Line":0}},{"line":95,"address":[3586564],"length":1,"stats":{"Line":0}},{"line":96,"address":[3586859],"length":1,"stats":{"Line":0}},{"line":97,"address":[3586947],"length":1,"stats":{"Line":0}},{"line":98,"address":[3586966],"length":1,"stats":{"Line":0}},{"line":99,"address":[3586962],"length":1,"stats":{"Line":0}},{"line":106,"address":[3583790,3584763],"length":1,"stats":{"Line":0}},{"line":107,"address":[3584652,3584699],"length":1,"stats":{"Line":0}},{"line":108,"address":[3584413,3584565],"length":1,"stats":{"Line":0}},{"line":109,"address":[3584573],"length":1,"stats":{"Line":0}},{"line":110,"address":[3584645],"length":1,"stats":{"Line":0}},{"line":113,"address":[3584447,3584341],"length":1,"stats":{"Line":0}},{"line":116,"address":[3584454],"length":1,"stats":{"Line":0}},{"line":117,"address":[3584473],"length":1,"stats":{"Line":0}},{"line":118,"address":[3584492],"length":1,"stats":{"Line":0}},{"line":121,"address":[3163432],"length":1,"stats":{"Line":0}},{"line":122,"address":[3587813,3587934,3587888],"length":1,"stats":{"Line":0}},{"line":125,"address":[3587903],"length":1,"stats":{"Line":0}},{"line":129,"address":[3588114,3587996,3588056],"length":1,"stats":{"Line":0}},{"line":130,"address":[3588071,3588140,3588368],"length":1,"stats":{"Line":0}},{"line":133,"address":[3588148,3588252],"length":1,"stats":{"Line":0}},{"line":135,"address":[3588164],"length":1,"stats":{"Line":0}},{"line":138,"address":[3588424,3588389],"length":1,"stats":{"Line":0}},{"line":143,"address":[3588636],"length":1,"stats":{"Line":0}},{"line":144,"address":[3588675,3588915],"length":1,"stats":{"Line":0}},{"line":145,"address":[3588701],"length":1,"stats":{"Line":0}},{"line":146,"address":[3588830],"length":1,"stats":{"Line":0}},{"line":149,"address":[3588728,3589144],"length":1,"stats":{"Line":0}},{"line":150,"address":[3588753],"length":1,"stats":{"Line":0}},{"line":151,"address":[3589034],"length":1,"stats":{"Line":0}},{"line":152,"address":[3589121],"length":1,"stats":{"Line":0}},{"line":153,"address":[3589140],"length":1,"stats":{"Line":0}},{"line":154,"address":[3589136],"length":1,"stats":{"Line":0}},{"line":161,"address":[3589353,3587091],"length":1,"stats":{"Line":0}},{"line":162,"address":[3587117],"length":1,"stats":{"Line":0}},{"line":163,"address":[3589265],"length":1,"stats":{"Line":0}},{"line":166,"address":[3589445],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":75},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","commands","search_output.rs"],"content":"use lastfm_edit::{Album, Track};\nuse serde::{Deserialize, Serialize};\n\n/// Events emitted by search commands\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(tag = \"type\")]\npub enum SearchEvent {\n    /// Starting to search for items\n    Started {\n        search_type: String, // \"tracks\" or \"albums\"\n        query: String,\n        offset: usize,\n        limit: usize,\n    },\n    /// Found a track in search results\n    TrackFound { index: usize, track: Track },\n    /// Found an album in search results\n    AlbumFound { index: usize, album: Album },\n    /// Search completed with summary\n    Summary {\n        search_type: String,\n        query: String,\n        total_displayed: usize,\n        offset: usize,\n        limit: usize,\n    },\n    /// No results found\n    NoResults { search_type: String, query: String },\n    /// Search command finished\n    Finished { search_type: String, query: String },\n}\n\n/// Trait for handling search command output\npub trait SearchOutputHandler {\n    fn handle_event(\u0026mut self, event: SearchEvent);\n}\n\n/// Human-readable output handler for search commands\npub struct HumanReadableSearchHandler {\n    details: bool,\n    found_any: bool,\n}\n\nimpl HumanReadableSearchHandler {\n    pub fn new(details: bool) -\u003e Self {\n        Self {\n            details,\n            found_any: false,\n        }\n    }\n}\n\nimpl SearchOutputHandler for HumanReadableSearchHandler {\n    fn handle_event(\u0026mut self, event: SearchEvent) {\n        match event {\n            SearchEvent::Started {\n                search_type,\n                query,\n                offset,\n                ..\n            } =\u003e {\n                if offset \u003e 0 {\n                    println!(\n                        \"ğŸ” Searching for {} containing '{}' (starting from #{})...\",\n                        search_type,\n                        query,\n                        offset + 1\n                    );\n                } else {\n                    println!(\"ğŸ” Searching for {search_type} containing '{query}'...\");\n                }\n            }\n            SearchEvent::TrackFound { index, track } =\u003e {\n                // Add blank line before first result\n                if !self.found_any {\n                    self.found_any = true;\n                    println!();\n                }\n\n                if self.details {\n                    println!(\n                        \"{}. {} - {} (played {} time{})\",\n                        index,\n                        track.artist,\n                        track.name,\n                        track.playcount,\n                        if track.playcount == 1 { \"\" } else { \"s\" }\n                    );\n\n                    if let Some(album) = \u0026track.album {\n                        println!(\"   Album: {album}\");\n                    }\n\n                    if let Some(album_artist) = \u0026track.album_artist {\n                        if album_artist != \u0026track.artist {\n                            println!(\"   Album Artist: {album_artist}\");\n                        }\n                    }\n                    println!(); // Blank line between verbose entries\n                } else {\n                    println!(\"{}. {} - {}\", index, track.artist, track.name);\n                }\n            }\n            SearchEvent::AlbumFound { index, album } =\u003e {\n                // Add blank line before first result\n                if !self.found_any {\n                    self.found_any = true;\n                    println!();\n                }\n\n                if self.details {\n                    println!(\n                        \"{}. {} - {} (played {} time{})\",\n                        index,\n                        album.artist,\n                        album.name,\n                        album.playcount,\n                        if album.playcount == 1 { \"\" } else { \"s\" }\n                    );\n                    println!(); // Blank line between verbose entries\n                } else {\n                    println!(\"{}. {} - {}\", index, album.artist, album.name);\n                }\n            }\n            SearchEvent::Summary {\n                total_displayed,\n                offset,\n                limit,\n                ..\n            } =\u003e {\n                println!(\n                    \"âœ… Displayed {} result{}\",\n                    total_displayed,\n                    if total_displayed == 1 { \"\" } else { \"s\" }\n                );\n\n                if offset \u003e 0 {\n                    println!(\"   (Starting from result #{})\", offset + 1);\n                }\n                if limit \u003e 0 \u0026\u0026 total_displayed \u003e= limit {\n                    println!(\"   (Limited to {limit} results)\");\n                }\n            }\n            SearchEvent::NoResults { query, .. } =\u003e {\n                println!(\"âŒ No results found matching '{query}'\");\n            }\n            SearchEvent::Finished { .. } =\u003e {\n                // Nothing needed for human-readable output - summary already printed\n            }\n        }\n    }\n}\n\n/// JSON output handler for search commands (JSONL format)\npub struct JsonSearchHandler;\n\nimpl JsonSearchHandler {\n    pub fn new() -\u003e Self {\n        Self\n    }\n}\n\nimpl SearchOutputHandler for JsonSearchHandler {\n    fn handle_event(\u0026mut self, event: SearchEvent) {\n        // Output each event as a single line of JSON\n        if let Ok(json) = serde_json::to_string(\u0026event) {\n            println!(\"{json}\");\n        } else {\n            eprintln!(\"âŒ Failed to serialize event to JSON\");\n        }\n    }\n}\n","traces":[{"line":45,"address":[3135744],"length":1,"stats":{"Line":0}},{"line":54,"address":[3136838,3139278,3135776],"length":1,"stats":{"Line":0}},{"line":55,"address":[3135801],"length":1,"stats":{"Line":0}},{"line":56,"address":[3135884],"length":1,"stats":{"Line":0}},{"line":62,"address":[3135934],"length":1,"stats":{"Line":0}},{"line":63,"address":[3136514,3136568],"length":1,"stats":{"Line":0}},{"line":70,"address":[3136263,3136355],"length":1,"stats":{"Line":0}},{"line":73,"address":[3135954],"length":1,"stats":{"Line":0}},{"line":75,"address":[3135989],"length":1,"stats":{"Line":0}},{"line":76,"address":[3136849],"length":1,"stats":{"Line":0}},{"line":77,"address":[3136853,3136935],"length":1,"stats":{"Line":0}},{"line":80,"address":[3136884],"length":1,"stats":{"Line":0}},{"line":81,"address":[3137273],"length":1,"stats":{"Line":0}},{"line":90,"address":[3137497],"length":1,"stats":{"Line":0}},{"line":91,"address":[3137650,3137564],"length":1,"stats":{"Line":0}},{"line":94,"address":[3137729,3137591],"length":1,"stats":{"Line":0}},{"line":95,"address":[3137814,3137737],"length":1,"stats":{"Line":0}},{"line":96,"address":[3137820],"length":1,"stats":{"Line":0}},{"line":99,"address":[3137784,3137921],"length":1,"stats":{"Line":0}},{"line":101,"address":[3136956,3137013],"length":1,"stats":{"Line":0}},{"line":104,"address":[3136009],"length":1,"stats":{"Line":0}},{"line":106,"address":[3136048],"length":1,"stats":{"Line":0}},{"line":107,"address":[3137950],"length":1,"stats":{"Line":0}},{"line":108,"address":[3138036,3137954],"length":1,"stats":{"Line":0}},{"line":111,"address":[3137985],"length":1,"stats":{"Line":0}},{"line":112,"address":[3138293,3138438,3138084],"length":1,"stats":{"Line":0}},{"line":120,"address":[3138598],"length":1,"stats":{"Line":0}},{"line":122,"address":[3138114,3138057],"length":1,"stats":{"Line":0}},{"line":125,"address":[3136097],"length":1,"stats":{"Line":0}},{"line":131,"address":[3138648],"length":1,"stats":{"Line":0}},{"line":137,"address":[3138830],"length":1,"stats":{"Line":0}},{"line":138,"address":[3138861],"length":1,"stats":{"Line":0}},{"line":140,"address":[3138836,3139008],"length":1,"stats":{"Line":0}},{"line":141,"address":[3139030],"length":1,"stats":{"Line":0}},{"line":144,"address":[3136144],"length":1,"stats":{"Line":0}},{"line":145,"address":[3139175,3136168],"length":1,"stats":{"Line":0}},{"line":164,"address":[3139376,3139784,3139931],"length":1,"stats":{"Line":0}},{"line":166,"address":[3139522,3139451,3139395],"length":1,"stats":{"Line":0}},{"line":167,"address":[3139550,3139612],"length":1,"stats":{"Line":0}},{"line":169,"address":[3139493,3139790],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":40},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","commands","show.rs"],"content":"use super::show_output::{HumanReadableShowHandler, JsonShowHandler, ShowEvent, ShowOutputHandler};\nuse lastfm_edit::LastFmEditClientImpl;\n\n/// Handle showing details for specific scrobbles by offset\npub async fn handle_show_scrobbles(\n    client: \u0026LastFmEditClientImpl,\n    offsets: \u0026[u64],\n    json_output: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // No validation needed for 0-based indexing - all u64 values are valid\n\n    // Create appropriate handler based on output format\n    let mut handler: Box\u003cdyn ShowOutputHandler\u003e = if json_output {\n        Box::new(JsonShowHandler::new())\n    } else {\n        Box::new(HumanReadableShowHandler::new())\n    };\n\n    let max_offset = *offsets.iter().max().unwrap();\n\n    // Emit start event\n    handler.handle_event(ShowEvent::Started {\n        offsets: offsets.to_vec(),\n        max_offset,\n    });\n\n    // Sort offsets for better output organization\n    let mut sorted_offsets = offsets.to_vec();\n    sorted_offsets.sort_unstable();\n\n    let mut all_scrobbles = Vec::new();\n\n    // Collect scrobbles until we have enough to cover the maximum offset\n    let mut page = 1u32;\n    let needed_scrobbles = (max_offset + 1) as usize; // +1 because 0-indexed\n\n    while all_scrobbles.len() \u003c needed_scrobbles {\n        match client.get_recent_scrobbles(page).await {\n            Ok(scrobbles) =\u003e {\n                let scrobbles_found = scrobbles.len();\n                if scrobbles_found == 0 {\n                    handler.handle_event(ShowEvent::CollectingPage {\n                        page,\n                        scrobbles_found: 0,\n                        total_collected: all_scrobbles.len(),\n                    });\n                    break;\n                }\n\n                all_scrobbles.extend(scrobbles);\n                handler.handle_event(ShowEvent::CollectingPage {\n                    page,\n                    scrobbles_found,\n                    total_collected: all_scrobbles.len(),\n                });\n                page += 1;\n\n                // Stop if we've collected enough\n                if all_scrobbles.len() \u003e= needed_scrobbles {\n                    break;\n                }\n            }\n            Err(_e) =\u003e {\n                handler.handle_event(ShowEvent::CollectingPage {\n                    page,\n                    scrobbles_found: 0,\n                    total_collected: all_scrobbles.len(),\n                });\n                break;\n            }\n        }\n    }\n\n    // Check if we have enough scrobbles for all requested offsets\n    let unavailable_offsets: Vec\u003cu64\u003e = offsets\n        .iter()\n        .filter(|\u0026\u0026offset| offset \u003e= all_scrobbles.len() as u64)\n        .copied()\n        .collect();\n\n    // Emit collection complete event\n    handler.handle_event(ShowEvent::CollectionComplete {\n        total_scrobbles: all_scrobbles.len(),\n        unavailable_offsets: unavailable_offsets.clone(),\n    });\n\n    let mut shown_count = 0;\n\n    // Show details for each requested offset\n    for \u0026offset in \u0026sorted_offsets {\n        if offset \u003c all_scrobbles.len() as u64 {\n            let scrobble = \u0026all_scrobbles[offset as usize];\n            handler.handle_event(ShowEvent::ScrobbleDetails {\n                offset,\n                scrobble: scrobble.clone(),\n            });\n            shown_count += 1;\n        }\n    }\n\n    // Emit finished event\n    handler.handle_event(ShowEvent::Finished {\n        total_shown: shown_count,\n        unavailable_count: unavailable_offsets.len(),\n    });\n\n    Ok(())\n}\n","traces":[{"line":5,"address":[3424832],"length":1,"stats":{"Line":0}},{"line":13,"address":[3144518,3144356,3144638],"length":1,"stats":{"Line":0}},{"line":14,"address":[3144592,3144412],"length":1,"stats":{"Line":0}},{"line":16,"address":[3144405,3144472],"length":1,"stats":{"Line":0}},{"line":19,"address":[3144550,3144700],"length":1,"stats":{"Line":0}},{"line":22,"address":[3144772,3144850],"length":1,"stats":{"Line":0}},{"line":23,"address":[3144804],"length":1,"stats":{"Line":0}},{"line":28,"address":[3144918],"length":1,"stats":{"Line":0}},{"line":29,"address":[3144947,3145048],"length":1,"stats":{"Line":0}},{"line":31,"address":[3145055],"length":1,"stats":{"Line":0}},{"line":34,"address":[3145089],"length":1,"stats":{"Line":0}},{"line":35,"address":[3145107,3145149],"length":1,"stats":{"Line":0}},{"line":37,"address":[3145220,3146350,3145147],"length":1,"stats":{"Line":0}},{"line":38,"address":[3145283,3146425,3144392,3145314],"length":1,"stats":{"Line":0}},{"line":39,"address":[3145660],"length":1,"stats":{"Line":0}},{"line":40,"address":[3145700,3145776],"length":1,"stats":{"Line":0}},{"line":41,"address":[3145784],"length":1,"stats":{"Line":0}},{"line":42,"address":[3145969,3145790],"length":1,"stats":{"Line":0}},{"line":43,"address":[3145822],"length":1,"stats":{"Line":0}},{"line":45,"address":[3145835],"length":1,"stats":{"Line":0}},{"line":50,"address":[3145861],"length":1,"stats":{"Line":0}},{"line":51,"address":[3146155,3146045],"length":1,"stats":{"Line":0}},{"line":52,"address":[3146077],"length":1,"stats":{"Line":0}},{"line":54,"address":[3146090],"length":1,"stats":{"Line":0}},{"line":56,"address":[3146206,3146292],"length":1,"stats":{"Line":0}},{"line":59,"address":[3146258,3146321],"length":1,"stats":{"Line":0}},{"line":63,"address":[3145554],"length":1,"stats":{"Line":0}},{"line":64,"address":[3145586,3146694],"length":1,"stats":{"Line":0}},{"line":65,"address":[3145618],"length":1,"stats":{"Line":0}},{"line":67,"address":[3145631],"length":1,"stats":{"Line":0}},{"line":75,"address":[3146810,3146380],"length":1,"stats":{"Line":0}},{"line":77,"address":[3147904,3146787,3147918],"length":1,"stats":{"Line":0}},{"line":82,"address":[3147003,3146863],"length":1,"stats":{"Line":0}},{"line":83,"address":[3146889],"length":1,"stats":{"Line":0}},{"line":84,"address":[3146955],"length":1,"stats":{"Line":0}},{"line":87,"address":[3147071],"length":1,"stats":{"Line":0}},{"line":90,"address":[3147083],"length":1,"stats":{"Line":0}},{"line":91,"address":[3147233,3147872,3147564],"length":1,"stats":{"Line":0}},{"line":92,"address":[3147578],"length":1,"stats":{"Line":0}},{"line":93,"address":[3147629,3147685],"length":1,"stats":{"Line":0}},{"line":95,"address":[3147663],"length":1,"stats":{"Line":0}},{"line":97,"address":[3147877,3147837],"length":1,"stats":{"Line":0}},{"line":102,"address":[3147267,3147346],"length":1,"stats":{"Line":0}},{"line":103,"address":[3147293],"length":1,"stats":{"Line":0}},{"line":104,"address":[3147314],"length":1,"stats":{"Line":0}},{"line":107,"address":[3147390],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","commands","show_output.rs"],"content":"use lastfm_edit::Track;\nuse serde::{Deserialize, Serialize};\n\n/// Events emitted by show commands\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(tag = \"type\")]\npub enum ShowEvent {\n    /// Starting to collect scrobbles for the requested offsets\n    Started { offsets: Vec\u003cu64\u003e, max_offset: u64 },\n    /// Collecting scrobbles from a specific page\n    CollectingPage {\n        page: u32,\n        scrobbles_found: usize,\n        total_collected: usize,\n    },\n    /// Finished collecting, showing summary\n    CollectionComplete {\n        total_scrobbles: usize,\n        unavailable_offsets: Vec\u003cu64\u003e,\n    },\n    /// Showing details for a specific scrobble\n    ScrobbleDetails { offset: u64, scrobble: Track },\n    /// Requested offset is not available (beyond available scrobbles)\n    OffsetUnavailable { offset: u64, total_available: usize },\n    /// Show command finished\n    Finished {\n        total_shown: usize,\n        unavailable_count: usize,\n    },\n}\n\n/// Trait for handling show command output\npub trait ShowOutputHandler {\n    fn handle_event(\u0026mut self, event: ShowEvent);\n}\n\n/// Human-readable output handler for show commands\npub struct HumanReadableShowHandler;\n\nimpl HumanReadableShowHandler {\n    pub fn new() -\u003e Self {\n        Self\n    }\n}\n\nimpl ShowOutputHandler for HumanReadableShowHandler {\n    fn handle_event(\u0026mut self, event: ShowEvent) {\n        match event {\n            ShowEvent::Started {\n                offsets,\n                max_offset,\n            } =\u003e {\n                println!(\n                    \"ğŸ“‹ Showing details for scrobbles at offsets: {}\",\n                    offsets\n                        .iter()\n                        .map(|n| n.to_string())\n                        .collect::\u003cVec\u003c_\u003e\u003e()\n                        .join(\", \")\n                );\n                println!(\"\\nğŸ“„ Collecting recent scrobbles to reach offset {max_offset}...\");\n            }\n            ShowEvent::CollectingPage {\n                page,\n                scrobbles_found,\n                total_collected,\n            } =\u003e {\n                if scrobbles_found \u003e 0 {\n                    println!(\n                        \"  Page {page}: Found {scrobbles_found} scrobbles (total: {total_collected})\"\n                    );\n                } else {\n                    println!(\"  No more scrobbles found on page {page}\");\n                }\n            }\n            ShowEvent::CollectionComplete {\n                total_scrobbles,\n                unavailable_offsets,\n            } =\u003e {\n                println!(\"\\nğŸ“Š Total scrobbles collected: {total_scrobbles}\");\n\n                if !unavailable_offsets.is_empty() {\n                    println!(\n                        \"\\nâš ï¸  The following offsets are not available (you only have {total_scrobbles} scrobbles):\"\n                    );\n                    for offset in \u0026unavailable_offsets {\n                        println!(\"    - Offset {offset}\");\n                    }\n                    println!();\n                }\n\n                println!(\"ğŸµ Scrobble Details:\");\n                println!(\"{}\", \"=\".repeat(80));\n            }\n            ShowEvent::ScrobbleDetails { offset, scrobble } =\u003e {\n                println!(\n                    \"\\nğŸ“ Offset {offset} ({}{})\",\n                    offset,\n                    match offset {\n                        0 =\u003e \"st most recent (index 0)\",\n                        1 =\u003e \"nd most recent (index 1)\",\n                        2 =\u003e \"rd most recent (index 2)\",\n                        _ =\u003e \"th most recent\",\n                    }\n                );\n\n                println!(\"   ğŸ¤ Artist: {}\", scrobble.artist);\n                println!(\"   ğŸµ Track:  {}\", scrobble.name);\n                println!(\"   ğŸ”¢ Play Count: {}\", scrobble.playcount);\n\n                if let Some(album) = \u0026scrobble.album {\n                    println!(\"   ğŸ’¿ Album:  {album}\");\n                } else {\n                    println!(\"   ğŸ’¿ Album:  (no album info)\");\n                }\n\n                if let Some(album_artist) = \u0026scrobble.album_artist {\n                    if album_artist != \u0026scrobble.artist {\n                        println!(\"   ğŸ‘¥ Album Artist: {album_artist}\");\n                    }\n                }\n\n                if let Some(timestamp) = scrobble.timestamp {\n                    use super::utils::format_timestamp;\n                    println!(\n                        \"   ğŸ• Timestamp: {} ({})\",\n                        timestamp,\n                        format_timestamp(timestamp)\n                    );\n                } else {\n                    println!(\"   ğŸ• Timestamp: (no timestamp)\");\n                }\n            }\n            ShowEvent::OffsetUnavailable { .. } =\u003e {\n                // This is handled in CollectionComplete for better grouping\n            }\n            ShowEvent::Finished {\n                unavailable_count, ..\n            } =\u003e {\n                if unavailable_count \u003e 0 {\n                    println!(\n                        \"\\nâŒ Could not show {unavailable_count} offset(s) due to insufficient scrobbles\"\n                    );\n                }\n                println!(\"\\nâœ… Finished showing scrobble details\");\n            }\n        }\n    }\n}\n\n/// JSON output handler for show commands (JSONL format)\npub struct JsonShowHandler;\n\nimpl JsonShowHandler {\n    pub fn new() -\u003e Self {\n        Self\n    }\n}\n\nimpl ShowOutputHandler for JsonShowHandler {\n    fn handle_event(\u0026mut self, event: ShowEvent) {\n        // Output each event as a single line of JSON\n        if let Ok(json) = serde_json::to_string(\u0026event) {\n            println!(\"{json}\");\n        } else {\n            eprintln!(\"âŒ Failed to serialize event to JSON\");\n        }\n    }\n}\n","traces":[{"line":47,"address":[3430016,3431058],"length":1,"stats":{"Line":0}},{"line":48,"address":[3430039],"length":1,"stats":{"Line":0}},{"line":49,"address":[3430128],"length":1,"stats":{"Line":0}},{"line":53,"address":[3430148,3430734,3430578],"length":1,"stats":{"Line":0}},{"line":61,"address":[3430944],"length":1,"stats":{"Line":0}},{"line":63,"address":[3430198],"length":1,"stats":{"Line":0}},{"line":68,"address":[3430210],"length":1,"stats":{"Line":0}},{"line":69,"address":[3431179],"length":1,"stats":{"Line":0}},{"line":73,"address":[3431077],"length":1,"stats":{"Line":0}},{"line":76,"address":[3430250],"length":1,"stats":{"Line":0}},{"line":80,"address":[3430274,3431429],"length":1,"stats":{"Line":0}},{"line":82,"address":[3431506],"length":1,"stats":{"Line":0}},{"line":83,"address":[3431527,3431583],"length":1,"stats":{"Line":0}},{"line":86,"address":[3431660],"length":1,"stats":{"Line":0}},{"line":87,"address":[3431787,3431864],"length":1,"stats":{"Line":0}},{"line":89,"address":[3431814],"length":1,"stats":{"Line":0}},{"line":92,"address":[3431554,3431938],"length":1,"stats":{"Line":0}},{"line":93,"address":[3431957],"length":1,"stats":{"Line":0}},{"line":95,"address":[3430312],"length":1,"stats":{"Line":0}},{"line":96,"address":[3432288,3432391],"length":1,"stats":{"Line":0}},{"line":107,"address":[3432546],"length":1,"stats":{"Line":0}},{"line":108,"address":[3432642],"length":1,"stats":{"Line":0}},{"line":109,"address":[3432738],"length":1,"stats":{"Line":0}},{"line":111,"address":[3432834],"length":1,"stats":{"Line":0}},{"line":112,"address":[3432901,3432954],"length":1,"stats":{"Line":0}},{"line":114,"address":[3433081,3432928],"length":1,"stats":{"Line":0}},{"line":117,"address":[3433025,3433107],"length":1,"stats":{"Line":0}},{"line":118,"address":[3433185,3433115],"length":1,"stats":{"Line":0}},{"line":119,"address":[3433191],"length":1,"stats":{"Line":0}},{"line":123,"address":[3433289,3433162],"length":1,"stats":{"Line":0}},{"line":125,"address":[3433384,3433305],"length":1,"stats":{"Line":0}},{"line":131,"address":[3433578,3433332],"length":1,"stats":{"Line":0}},{"line":137,"address":[3430496],"length":1,"stats":{"Line":0}},{"line":140,"address":[3430508],"length":1,"stats":{"Line":0}},{"line":141,"address":[3433639],"length":1,"stats":{"Line":0}},{"line":145,"address":[3433599],"length":1,"stats":{"Line":0}},{"line":161,"address":[3433760,3434315,3434168],"length":1,"stats":{"Line":0}},{"line":163,"address":[3433779,3433835,3433906],"length":1,"stats":{"Line":0}},{"line":164,"address":[3433996,3433934],"length":1,"stats":{"Line":0}},{"line":166,"address":[3433877,3434174],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":40},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","commands","utils.rs"],"content":"use lastfm_edit::{LastFmEditClientImpl, SessionPersistence};\nuse std::env;\nuse std::io::{self, Write};\n\n/// Print to stdout in normal mode, suppress in JSON mode\nfn output_message(json_mode: bool, message: \u0026str) {\n    if !json_mode {\n        println!(\"{message}\");\n    }\n    // In JSON mode, suppress all session messages completely\n}\n\n/// Load existing session or create a new client with fresh login.\n///\n/// This function implements the session management logic:\n/// 1. Try to load a saved session from XDG directory\n/// 2. Validate the loaded session\n/// 3. If session is invalid or doesn't exist, perform fresh login\n/// 4. Save the new session for future use\npub async fn load_or_create_client(\n    username: \u0026str,\n    password: \u0026str,\n    json_mode: bool,\n) -\u003e Result\u003cLastFmEditClientImpl, Box\u003cdyn std::error::Error\u003e\u003e {\n    // Check if we have a saved session\n    if SessionPersistence::session_exists(username) {\n        output_message(\n            json_mode,\n            \u0026format!(\"ğŸ“ Found existing session for user '{username}', attempting to restore...\"),\n        );\n\n        match SessionPersistence::load_session(username) {\n            Ok(session) =\u003e {\n                output_message(json_mode, \"ğŸ“¥ Session loaded successfully\");\n\n                // Create client with loaded session\n                let http_client = http_client::native::NativeClient::new();\n                let client = LastFmEditClientImpl::from_session(Box::new(http_client), session);\n\n                // Validate the session\n                output_message(json_mode, \"ğŸ” Validating session...\");\n                if client.validate_session().await {\n                    output_message(json_mode, \"âœ… Session is valid, using saved session\");\n                    return Ok(client);\n                } else {\n                    output_message(json_mode, \"âŒ Session is invalid or expired\");\n                    // Remove invalid session file\n                    let _ = SessionPersistence::remove_session(username);\n                }\n            }\n            Err(e) =\u003e {\n                output_message(json_mode, \u0026format!(\"âŒ Failed to load session: {e}\"));\n                // Remove corrupted session file\n                let _ = SessionPersistence::remove_session(username);\n            }\n        }\n    }\n\n    // No valid session found, perform fresh login\n    output_message(\n        json_mode,\n        \"ğŸ” No valid session found, performing fresh login...\",\n    );\n    let http_client = http_client::native::NativeClient::new();\n    let client =\n        LastFmEditClientImpl::login_with_credentials(Box::new(http_client), username, password)\n            .await?;\n\n    // Save the new session\n    output_message(json_mode, \"ğŸ’¾ Saving session for future use...\");\n    let session = client.get_session();\n    if let Err(e) = SessionPersistence::save_session(\u0026session) {\n        output_message(\n            json_mode,\n            \u0026format!(\"âš ï¸  Warning: Failed to save session: {e}\"),\n        );\n        output_message(json_mode, \"   (You'll need to login again next time)\");\n    } else {\n        output_message(json_mode, \"âœ… Session saved successfully\");\n    }\n\n    Ok(client)\n}\n\n/// Get username and password from environment variables\npub fn get_credentials() -\u003e Result\u003c(String, String), Box\u003cdyn std::error::Error\u003e\u003e {\n    let username = env::var(\"LASTFM_EDIT_USERNAME\")\n        .map_err(|_| \"LASTFM_EDIT_USERNAME environment variable not set\")?;\n    let password = env::var(\"LASTFM_EDIT_PASSWORD\")\n        .map_err(|_| \"LASTFM_EDIT_PASSWORD environment variable not set\")?;\n    Ok((username, password))\n}\n\n/// Format a Unix timestamp into a human-readable string\npub fn format_timestamp(timestamp: u64) -\u003e String {\n    // This is a simple formatter - in a full implementation you might want to use chrono\n    // For now, just show it as \"X seconds ago\" or the raw timestamp\n    let now = std::time::SystemTime::now()\n        .duration_since(std::time::UNIX_EPOCH)\n        .unwrap()\n        .as_secs();\n\n    if timestamp \u003c= now {\n        let ago = now - timestamp;\n        if ago \u003c 60 {\n            format!(\"{ago} seconds ago\")\n        } else if ago \u003c 3600 {\n            format!(\"{} minutes ago\", ago / 60)\n        } else if ago \u003c 86400 {\n            format!(\"{} hours ago\", ago / 3600)\n        } else {\n            format!(\"{} days ago\", ago / 86400)\n        }\n    } else {\n        format!(\"{timestamp} (future timestamp)\")\n    }\n}\n\n/// Parse a range string like \"1-3\" or \"1640995200-1641000000\"\npub fn parse_range(\n    range_str: \u0026str,\n    range_type: \u0026str,\n) -\u003e Result\u003c(u64, u64), Box\u003cdyn std::error::Error\u003e\u003e {\n    let parts: Vec\u003c\u0026str\u003e = range_str.split('-').collect();\n    if parts.len() != 2 {\n        return Err(format!(\n            \"Invalid {range_type} range format. Expected 'start-end', got '{range_str}'\"\n        )\n        .into());\n    }\n\n    let start: u64 = parts[0]\n        .parse()\n        .map_err(|_| format!(\"Invalid start {range_type}: '{}'\", parts[0]))?;\n    let end: u64 = parts[1]\n        .parse()\n        .map_err(|_| format!(\"Invalid end {range_type}: '{}'\", parts[1]))?;\n\n    if start \u003e end {\n        return Err(format!(\n            \"Start {range_type} ({start}) cannot be greater than end {range_type} ({end})\"\n        )\n        .into());\n    }\n\n    Ok((start, end))\n}\n\n/// Try to restore the most recent session from available saved sessions.\n///\n/// This function looks for all saved sessions and attempts to restore the most recent valid one.\n/// Returns Some(client) if a valid session was found and restored, None otherwise.\npub async fn try_restore_most_recent_session(json_mode: bool) -\u003e Option\u003cLastFmEditClientImpl\u003e {\n    // Get list of all saved users\n    let saved_users = match SessionPersistence::list_saved_users() {\n        Ok(users) =\u003e users,\n        Err(_) =\u003e return None,\n    };\n\n    if saved_users.is_empty() {\n        return None;\n    }\n\n    // Try each saved user session, starting with the first one found\n    // In a more sophisticated implementation, we could sort by last modified time\n    for username in saved_users {\n        output_message(\n            json_mode,\n            \u0026format!(\"ğŸ“ Attempting to restore session for user '{username}'...\"),\n        );\n\n        match SessionPersistence::load_session(\u0026username) {\n            Ok(session) =\u003e {\n                output_message(json_mode, \"ğŸ“¥ Session loaded successfully\");\n\n                // Create client with loaded session\n                let http_client = http_client::native::NativeClient::new();\n                let client = LastFmEditClientImpl::from_session(Box::new(http_client), session);\n\n                // Validate the session\n                output_message(json_mode, \"ğŸ” Validating session...\");\n                if client.validate_session().await {\n                    output_message(\n                        json_mode,\n                        \u0026format!(\"âœ… Session is valid for user '{username}'\"),\n                    );\n                    return Some(client);\n                } else {\n                    output_message(\n                        json_mode,\n                        \u0026format!(\"âŒ Session is invalid or expired for user '{username}'\"),\n                    );\n                    // Remove invalid session file\n                    let _ = SessionPersistence::remove_session(\u0026username);\n                }\n            }\n            Err(e) =\u003e {\n                output_message(\n                    json_mode,\n                    \u0026format!(\"âŒ Failed to load session for user '{username}': {e}\"),\n                );\n                // Remove corrupted session file\n                let _ = SessionPersistence::remove_session(\u0026username);\n            }\n        }\n    }\n\n    None\n}\n\n/// Prompt the user for their Last.fm credentials interactively.\n///\n/// This function prompts for username and password via stdin, hiding password input.\n/// Returns (username, password) tuple.\npub fn prompt_for_credentials() -\u003e (String, String) {\n    print!(\"Last.fm username: \");\n    io::stdout().flush().unwrap();\n\n    let mut username = String::new();\n    io::stdin().read_line(\u0026mut username).unwrap();\n    let username = username.trim().to_string();\n\n    // For password, we'll use a simple prompt for now\n    // In a more sophisticated implementation, we could use a crate like `rpassword` to hide input\n    print!(\"Last.fm password: \");\n    io::stdout().flush().unwrap();\n\n    let mut password = String::new();\n    io::stdin().read_line(\u0026mut password).unwrap();\n    let password = password.trim().to_string();\n\n    (username, password)\n}\n","traces":[{"line":6,"address":[3600960],"length":1,"stats":{"Line":0}},{"line":7,"address":[3600985],"length":1,"stats":{"Line":0}},{"line":8,"address":[3600989],"length":1,"stats":{"Line":0}},{"line":20,"address":[3601072],"length":1,"stats":{"Line":0}},{"line":26,"address":[3619307,3619446],"length":1,"stats":{"Line":0}},{"line":28,"address":[3619486],"length":1,"stats":{"Line":0}},{"line":29,"address":[3619501],"length":1,"stats":{"Line":0}},{"line":32,"address":[3619735],"length":1,"stats":{"Line":0}},{"line":33,"address":[3619895],"length":1,"stats":{"Line":0}},{"line":34,"address":[3620005],"length":1,"stats":{"Line":0}},{"line":37,"address":[3620081],"length":1,"stats":{"Line":0}},{"line":38,"address":[3620108],"length":1,"stats":{"Line":0}},{"line":41,"address":[3620274],"length":1,"stats":{"Line":0}},{"line":42,"address":[3162975],"length":1,"stats":{"Line":0}},{"line":43,"address":[3621085],"length":1,"stats":{"Line":0}},{"line":44,"address":[3621425],"length":1,"stats":{"Line":0}},{"line":46,"address":[3621054],"length":1,"stats":{"Line":0}},{"line":48,"address":[3621119],"length":1,"stats":{"Line":0}},{"line":51,"address":[3619812],"length":1,"stats":{"Line":0}},{"line":52,"address":[3619850,3620522],"length":1,"stats":{"Line":0}},{"line":54,"address":[3620737],"length":1,"stats":{"Line":0}},{"line":61,"address":[3619452],"length":1,"stats":{"Line":0}},{"line":64,"address":[3621211],"length":1,"stats":{"Line":0}},{"line":65,"address":[3621290,3621238,3621368,3621748,3621911,3621987],"length":1,"stats":{"Line":0}},{"line":67,"address":[3162994],"length":1,"stats":{"Line":0}},{"line":70,"address":[3622284],"length":1,"stats":{"Line":0}},{"line":71,"address":[3622356],"length":1,"stats":{"Line":0}},{"line":72,"address":[3622459,3622383],"length":1,"stats":{"Line":0}},{"line":74,"address":[3622535],"length":1,"stats":{"Line":0}},{"line":75,"address":[3622550,3622655],"length":1,"stats":{"Line":0}},{"line":77,"address":[3622870],"length":1,"stats":{"Line":0}},{"line":79,"address":[3622577,3623007],"length":1,"stats":{"Line":0}},{"line":82,"address":[3623031],"length":1,"stats":{"Line":0}},{"line":86,"address":[3601815,3601809,3601168],"length":1,"stats":{"Line":0}},{"line":87,"address":[3601184,3601301],"length":1,"stats":{"Line":0}},{"line":88,"address":[3601275],"length":1,"stats":{"Line":0}},{"line":89,"address":[3601561,3601370,3601458],"length":1,"stats":{"Line":0}},{"line":90,"address":[3601529],"length":1,"stats":{"Line":0}},{"line":91,"address":[3601630],"length":1,"stats":{"Line":0}},{"line":95,"address":[3601840],"length":1,"stats":{"Line":0}},{"line":98,"address":[3601862],"length":1,"stats":{"Line":0}},{"line":103,"address":[3601948],"length":1,"stats":{"Line":0}},{"line":104,"address":[3602138,3602082,3602123],"length":1,"stats":{"Line":0}},{"line":105,"address":[3602128],"length":1,"stats":{"Line":0}},{"line":106,"address":[3602168],"length":1,"stats":{"Line":0}},{"line":107,"address":[3602151],"length":1,"stats":{"Line":0}},{"line":108,"address":[3602307],"length":1,"stats":{"Line":0}},{"line":109,"address":[3602287],"length":1,"stats":{"Line":0}},{"line":110,"address":[3602609],"length":1,"stats":{"Line":0}},{"line":112,"address":[3602458],"length":1,"stats":{"Line":0}},{"line":115,"address":[3601955],"length":1,"stats":{"Line":0}},{"line":120,"address":[3604171,3602768,3604165],"length":1,"stats":{"Line":0}},{"line":124,"address":[3602805],"length":1,"stats":{"Line":0}},{"line":125,"address":[3602874,3602939],"length":1,"stats":{"Line":0}},{"line":126,"address":[3602980,3603958],"length":1,"stats":{"Line":0}},{"line":132,"address":[3603956,3602945,3603012,3603171],"length":1,"stats":{"Line":0}},{"line":134,"address":[3623524,3623488],"length":1,"stats":{"Line":0}},{"line":135,"address":[3603228,3603428,3603954],"length":1,"stats":{"Line":0}},{"line":137,"address":[3623744,3623780],"length":1,"stats":{"Line":0}},{"line":139,"address":[3603485],"length":1,"stats":{"Line":0}},{"line":140,"address":[3603619,3603656],"length":1,"stats":{"Line":0}},{"line":146,"address":[3603540],"length":1,"stats":{"Line":0}},{"line":153,"address":[3604192,3604207],"length":1,"stats":{"Line":0}},{"line":155,"address":[3624289,3624162],"length":1,"stats":{"Line":0}},{"line":156,"address":[3624372],"length":1,"stats":{"Line":0}},{"line":157,"address":[3624317],"length":1,"stats":{"Line":0}},{"line":160,"address":[3624531,3624619],"length":1,"stats":{"Line":0}},{"line":161,"address":[3624705],"length":1,"stats":{"Line":0}},{"line":166,"address":[3624793,3624625,3624725,3625797],"length":1,"stats":{"Line":0}},{"line":168,"address":[3625877],"length":1,"stats":{"Line":0}},{"line":169,"address":[3625895,3626088],"length":1,"stats":{"Line":0}},{"line":172,"address":[3626303],"length":1,"stats":{"Line":0}},{"line":173,"address":[3626500],"length":1,"stats":{"Line":0}},{"line":174,"address":[3626613],"length":1,"stats":{"Line":0}},{"line":177,"address":[3626647],"length":1,"stats":{"Line":0}},{"line":178,"address":[3626674],"length":1,"stats":{"Line":0}},{"line":181,"address":[3626836],"length":1,"stats":{"Line":0}},{"line":182,"address":[3167063],"length":1,"stats":{"Line":0}},{"line":184,"address":[3625276],"length":1,"stats":{"Line":0}},{"line":185,"address":[3627368,3625297],"length":1,"stats":{"Line":0}},{"line":187,"address":[3627586],"length":1,"stats":{"Line":0}},{"line":190,"address":[3625229],"length":1,"stats":{"Line":0}},{"line":191,"address":[3625250,3625326],"length":1,"stats":{"Line":0}},{"line":194,"address":[3625556],"length":1,"stats":{"Line":0}},{"line":197,"address":[3626415],"length":1,"stats":{"Line":0}},{"line":199,"address":[3626453],"length":1,"stats":{"Line":0}},{"line":200,"address":[3626471,3627006],"length":1,"stats":{"Line":0}},{"line":203,"address":[3627264],"length":1,"stats":{"Line":0}},{"line":208,"address":[3625947],"length":1,"stats":{"Line":0}},{"line":215,"address":[3605143,3604224,3605171],"length":1,"stats":{"Line":0}},{"line":216,"address":[3604247],"length":1,"stats":{"Line":0}},{"line":217,"address":[3604304],"length":1,"stats":{"Line":0}},{"line":219,"address":[3604365],"length":1,"stats":{"Line":0}},{"line":220,"address":[3604370,3604441],"length":1,"stats":{"Line":0}},{"line":221,"address":[3604518],"length":1,"stats":{"Line":0}},{"line":225,"address":[3604599,3604666],"length":1,"stats":{"Line":0}},{"line":226,"address":[3604685],"length":1,"stats":{"Line":0}},{"line":228,"address":[3604769],"length":1,"stats":{"Line":0}},{"line":229,"address":[3604841,3604776],"length":1,"stats":{"Line":0}},{"line":230,"address":[3604918],"length":1,"stats":{"Line":0}},{"line":232,"address":[3604999],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":101},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","lastfm-edit.rs"],"content":"use clap::Parser;\nuse log::LevelFilter;\n\nmod commands;\nuse commands::{\n    execute_command, utils::get_credentials, utils::load_or_create_client,\n    utils::prompt_for_credentials, utils::try_restore_most_recent_session, Commands,\n};\n\n/// Last.fm scrobble metadata editor\n#[derive(Parser)]\n#[command(\n    name = \"lastfm-edit\",\n    about = \"Last.fm scrobble metadata editor\",\n    long_about = None\n)]\nstruct Cli {\n    /// Increase verbosity level (use multiple times for more verbose output)\n    /// -v: info for lastfm-edit, -vv: debug for lastfm-edit, -vvv: trace for lastfm-edit\n    /// -vvvv: trace for lastfm-edit + info for all, -vvvvv: trace for lastfm-edit + debug for all, -vvvvvv: trace for all\n    #[arg(short, long, action = clap::ArgAction::Count, global = true)]\n    verbose: u8,\n\n    /// Last.fm username (overrides LASTFM_EDIT_USERNAME environment variable)\n    #[arg(short, long, global = true)]\n    username: Option\u003cString\u003e,\n\n    /// Last.fm password (overrides LASTFM_EDIT_PASSWORD environment variable)\n    #[arg(short, long, global = true)]\n    password: Option\u003cString\u003e,\n\n    /// Output results in JSON format instead of human-readable text\n    #[arg(long, global = true)]\n    json: bool,\n\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let args = Cli::parse();\n\n    // Configure logging based on verbosity level (cumulative)\n    let mut builder = env_logger::Builder::from_default_env();\n    builder.filter_level(LevelFilter::Off); // Start with everything off\n\n    match args.verbose {\n        0 =\u003e {\n            // Default: only warnings and errors for all\n            builder.filter_level(LevelFilter::Warn);\n        }\n        1 =\u003e {\n            // Info for lastfm-edit\n            builder.filter_module(\"lastfm_edit\", LevelFilter::Info);\n        }\n        2 =\u003e {\n            // Info + Debug for lastfm-edit\n            builder.filter_module(\"lastfm_edit\", LevelFilter::Debug);\n        }\n        3 =\u003e {\n            // Info + Debug + Trace for lastfm-edit\n            builder.filter_module(\"lastfm_edit\", LevelFilter::Trace);\n        }\n        4 =\u003e {\n            // Trace for lastfm-edit + Info for all others\n            builder.filter_module(\"lastfm_edit\", LevelFilter::Trace);\n            builder.filter_level(LevelFilter::Info);\n        }\n        5 =\u003e {\n            // Trace for lastfm-edit + Debug for all others\n            builder.filter_module(\"lastfm_edit\", LevelFilter::Trace);\n            builder.filter_level(LevelFilter::Debug);\n        }\n        _ =\u003e {\n            // Trace for everything (6+)\n            builder.filter_level(LevelFilter::Trace);\n        }\n    }\n\n    builder.init();\n\n    if args.verbose \u003e 0 {\n        log::info!(\"ğŸ” Verbose mode enabled (level {})\", args.verbose);\n    }\n\n    // Try to get credentials from command line args or environment first\n    let (username, password) = if let (Some(u), Some(p)) = (\u0026args.username, \u0026args.password) {\n        (Some(u.clone()), Some(p.clone()))\n    } else if args.username.is_some() || args.password.is_some() {\n        eprintln!(\"âŒ Error: Both username and password must be provided together\");\n        eprintln!(\"Either provide both --username and --password, or set environment variables\");\n        std::process::exit(1);\n    } else {\n        match get_credentials() {\n            Ok((u, p)) =\u003e (Some(u), Some(p)),\n            Err(_) =\u003e (None, None), // No credentials provided\n        }\n    };\n\n    // First, try to restore the most recent session if no credentials were provided\n    let client = if username.is_none() \u0026\u0026 password.is_none() {\n        match try_restore_most_recent_session(args.json).await {\n            Some(client) =\u003e {\n                if !args.json {\n                    println!(\"âœ… Restored most recent session\");\n                }\n                client\n            }\n            None =\u003e {\n                // No valid session found, prompt for credentials\n                if !args.json {\n                    println!(\"ğŸ” No valid saved session found. Please provide credentials:\");\n                }\n                let (prompted_username, prompted_password) = prompt_for_credentials();\n                log::info!(\"ğŸ” Using username: {prompted_username}\");\n\n                match load_or_create_client(\u0026prompted_username, \u0026prompted_password, args.json).await\n                {\n                    Ok(client) =\u003e client,\n                    Err(e) =\u003e {\n                        eprintln!(\"âŒ Failed to create client: {e}\");\n                        std::process::exit(1);\n                    }\n                }\n            }\n        }\n    } else {\n        // Credentials were provided, use them directly\n        let username = username.unwrap();\n        let password = password.unwrap();\n        log::info!(\"ğŸ” Using username: {username}\");\n\n        match load_or_create_client(\u0026username, \u0026password, args.json).await {\n            Ok(client) =\u003e client,\n            Err(e) =\u003e {\n                eprintln!(\"âŒ Failed to create client: {e}\");\n                std::process::exit(1);\n            }\n        }\n    };\n\n    log::info!(\"âœ… Client ready\");\n\n    // Execute the command\n    if let Err(e) = execute_command(args.command, \u0026client, args.json).await {\n        eprintln!(\"âŒ Command failed: {e}\");\n        std::process::exit(1);\n    }\n\n    Ok(())\n}\n","traces":[{"line":41,"address":[3550048,3550517,3550523],"length":1,"stats":{"Line":0}},{"line":42,"address":[3384858],"length":1,"stats":{"Line":0}},{"line":45,"address":[3385099],"length":1,"stats":{"Line":0}},{"line":46,"address":[3385191],"length":1,"stats":{"Line":0}},{"line":48,"address":[3385285],"length":1,"stats":{"Line":0}},{"line":51,"address":[3385387,3385735],"length":1,"stats":{"Line":0}},{"line":55,"address":[3385436,3385763],"length":1,"stats":{"Line":0}},{"line":59,"address":[3385765,3385497],"length":1,"stats":{"Line":0}},{"line":63,"address":[3385558,3385767],"length":1,"stats":{"Line":0}},{"line":67,"address":[3385619],"length":1,"stats":{"Line":0}},{"line":68,"address":[3385769],"length":1,"stats":{"Line":0}},{"line":72,"address":[3385677],"length":1,"stats":{"Line":0}},{"line":73,"address":[3385817],"length":1,"stats":{"Line":0}},{"line":77,"address":[3385865,3385338],"length":1,"stats":{"Line":0}},{"line":81,"address":[3385737],"length":1,"stats":{"Line":0}},{"line":83,"address":[3385870],"length":1,"stats":{"Line":0}},{"line":84,"address":[3385994],"length":1,"stats":{"Line":0}},{"line":88,"address":[3385887,3386425,3386349,3386731],"length":1,"stats":{"Line":0}},{"line":89,"address":[3386465],"length":1,"stats":{"Line":0}},{"line":90,"address":[3386886,3386389,3386961],"length":1,"stats":{"Line":0}},{"line":91,"address":[3386925,3388798],"length":1,"stats":{"Line":0}},{"line":92,"address":[3388817],"length":1,"stats":{"Line":0}},{"line":93,"address":[3388862],"length":1,"stats":{"Line":0}},{"line":95,"address":[3386975],"length":1,"stats":{"Line":0}},{"line":96,"address":[3387160],"length":1,"stats":{"Line":0}},{"line":97,"address":[3387023],"length":1,"stats":{"Line":0}},{"line":102,"address":[3387562,3386837,3387662],"length":1,"stats":{"Line":0}},{"line":103,"address":[3384958,3387711,3388725,3388906],"length":1,"stats":{"Line":0}},{"line":104,"address":[3389397],"length":1,"stats":{"Line":0}},{"line":105,"address":[3389430],"length":1,"stats":{"Line":0}},{"line":106,"address":[3390418,3390516],"length":1,"stats":{"Line":0}},{"line":108,"address":[3390444],"length":1,"stats":{"Line":0}},{"line":112,"address":[3389456],"length":1,"stats":{"Line":0}},{"line":113,"address":[3389473,3389514],"length":1,"stats":{"Line":0}},{"line":115,"address":[3389535,3389507],"length":1,"stats":{"Line":0}},{"line":116,"address":[3389611,3389761,3389714],"length":1,"stats":{"Line":0}},{"line":118,"address":[3389720,3390111,3390214,3384979,3390582,3390941],"length":1,"stats":{"Line":0}},{"line":120,"address":[3391040],"length":1,"stats":{"Line":0}},{"line":121,"address":[3390978],"length":1,"stats":{"Line":0}},{"line":122,"address":[3391010,3391423],"length":1,"stats":{"Line":0}},{"line":123,"address":[3391492],"length":1,"stats":{"Line":0}},{"line":130,"address":[3387568],"length":1,"stats":{"Line":0}},{"line":131,"address":[3387744],"length":1,"stats":{"Line":0}},{"line":132,"address":[3388036,3387989,3387889],"length":1,"stats":{"Line":0}},{"line":134,"address":[3172010],"length":1,"stats":{"Line":0}},{"line":135,"address":[3392030],"length":1,"stats":{"Line":0}},{"line":136,"address":[3391968],"length":1,"stats":{"Line":0}},{"line":137,"address":[3392000,3392865],"length":1,"stats":{"Line":0}},{"line":138,"address":[3392934],"length":1,"stats":{"Line":0}},{"line":143,"address":[3392420,3390537,3392521],"length":1,"stats":{"Line":0}},{"line":146,"address":[3172032],"length":1,"stats":{"Line":0}},{"line":147,"address":[3393367,3393278],"length":1,"stats":{"Line":0}},{"line":148,"address":[3393436],"length":1,"stats":{"Line":0}},{"line":151,"address":[3393455],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":54},{"path":["/","home","imalison","Projects","lastfm-edit","src","client.rs"],"content":"use crate::edit_analysis;\nuse crate::headers;\nuse crate::login::extract_cookies_from_response;\nuse crate::parsing::LastFmParser;\nuse crate::r#trait::LastFmEditClient;\nuse crate::retry;\nuse crate::types::{\n    AlbumPage, ClientConfig, ClientEvent, ClientEventReceiver, EditResponse, ExactScrobbleEdit,\n    LastFmEditSession, LastFmError, OperationalDelayConfig, RateLimitConfig, RateLimitType,\n    RequestInfo, RetryConfig, ScrobbleEdit, SharedEventBroadcaster, SingleEditResponse, Track,\n    TrackPage,\n};\nuse crate::Result;\nuse async_trait::async_trait;\nuse http_client::{HttpClient, Request, Response};\nuse http_types::{Method, Url};\nuse scraper::{Html, Selector};\nuse std::sync::{Arc, Mutex};\n\n#[derive(Clone)]\npub struct LastFmEditClientImpl {\n    client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n    session: Arc\u003cMutex\u003cLastFmEditSession\u003e\u003e,\n    parser: LastFmParser,\n    broadcaster: Arc\u003cSharedEventBroadcaster\u003e,\n    config: ClientConfig,\n}\n\nimpl LastFmEditClientImpl {\n    /// Custom URL encoding for Last.fm paths\n    fn lastfm_encode(\u0026self, input: \u0026str) -\u003e String {\n        urlencoding::encode(input).to_string()\n    }\n\n    /// Detect if the response content indicates a login redirect\n    fn is_login_redirect(\u0026self, content: \u0026str) -\u003e bool {\n        // Check for common login redirect indicators\n        content.contains(\"login\") \n            || content.contains(\"sign in\") \n            || content.contains(\"signin\")\n            || content.contains(\"Log in to Last.fm\")\n            || content.contains(\"Please sign in\")\n            // Check for login form elements\n            || (content.contains(\"\u003cform\") \u0026\u0026 content.contains(\"password\"))\n            // Check for authentication-related classes or IDs\n            || content.contains(\"auth-form\")\n            || content.contains(\"login-form\")\n    }\n\n    /// Check if a specific endpoint requires authentication that our session doesn't provide\n    pub async fn validate_endpoint_access(\u0026self, url: \u0026str) -\u003e Result\u003cbool\u003e {\n        let mut response = self.get(url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        Ok(!self.is_login_redirect(\u0026content))\n    }\n    pub fn from_session(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n    ) -\u003e Self {\n        Self::from_session_with_arc(Arc::from(client), session)\n    }\n\n    fn from_session_with_arc(\n        client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n    ) -\u003e Self {\n        Self::from_session_with_broadcaster_arc(\n            client,\n            session,\n            Arc::new(SharedEventBroadcaster::new()),\n        )\n    }\n\n    pub fn from_session_with_rate_limit_patterns(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        rate_limit_patterns: Vec\u003cString\u003e,\n    ) -\u003e Self {\n        let config = ClientConfig::default()\n            .with_rate_limit_config(RateLimitConfig::default().with_patterns(rate_limit_patterns));\n        Self::from_session_with_client_config(client, session, config)\n    }\n\n    pub async fn login_with_credentials(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        username: \u0026str,\n        password: \u0026str,\n    ) -\u003e Result\u003cSelf\u003e {\n        let client_arc: Arc\u003cdyn HttpClient + Send + Sync\u003e = Arc::from(client);\n        let login_manager =\n            crate::login::LoginManager::new(client_arc.clone(), \"https://www.last.fm\".to_string());\n        let session = login_manager.login(username, password).await?;\n        Ok(Self::from_session_with_arc(client_arc, session))\n    }\n\n    pub fn from_session_with_client_config(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        config: ClientConfig,\n    ) -\u003e Self {\n        Self::from_session_with_client_config_arc(Arc::from(client), session, config)\n    }\n\n    pub async fn login_with_credentials_and_client_config(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        username: \u0026str,\n        password: \u0026str,\n        config: ClientConfig,\n    ) -\u003e Result\u003cSelf\u003e {\n        let client_arc: Arc\u003cdyn HttpClient + Send + Sync\u003e = Arc::from(client);\n        let login_manager =\n            crate::login::LoginManager::new(client_arc.clone(), \"https://www.last.fm\".to_string());\n        let session = login_manager.login(username, password).await?;\n        Ok(Self::from_session_with_client_config_arc(\n            client_arc, session, config,\n        ))\n    }\n\n    pub fn from_session_with_config(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        retry_config: RetryConfig,\n        rate_limit_config: RateLimitConfig,\n    ) -\u003e Self {\n        Self::from_session_with_config_arc(\n            Arc::from(client),\n            session,\n            retry_config,\n            rate_limit_config,\n        )\n    }\n\n    pub async fn login_with_credentials_and_config(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        username: \u0026str,\n        password: \u0026str,\n        retry_config: RetryConfig,\n        rate_limit_config: RateLimitConfig,\n    ) -\u003e Result\u003cSelf\u003e {\n        let client_arc: Arc\u003cdyn HttpClient + Send + Sync\u003e = Arc::from(client);\n        let login_manager =\n            crate::login::LoginManager::new(client_arc.clone(), \"https://www.last.fm\".to_string());\n        let session = login_manager.login(username, password).await?;\n        Ok(Self::from_session_with_config_arc(\n            client_arc,\n            session,\n            retry_config,\n            rate_limit_config,\n        ))\n    }\n\n    fn from_session_with_broadcaster(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        broadcaster: Arc\u003cSharedEventBroadcaster\u003e,\n    ) -\u003e Self {\n        Self::from_session_with_broadcaster_arc(Arc::from(client), session, broadcaster)\n    }\n\n    fn from_session_with_client_config_arc(\n        client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        config: ClientConfig,\n    ) -\u003e Self {\n        Self::from_session_with_client_config_and_broadcaster_arc(\n            client,\n            session,\n            config,\n            Arc::new(SharedEventBroadcaster::new()),\n        )\n    }\n\n    fn from_session_with_config_arc(\n        client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        retry_config: RetryConfig,\n        rate_limit_config: RateLimitConfig,\n    ) -\u003e Self {\n        let config = ClientConfig {\n            retry: retry_config,\n            rate_limit: rate_limit_config,\n            operational_delays: OperationalDelayConfig::default(),\n        };\n        Self::from_session_with_client_config_arc(client, session, config)\n    }\n\n    fn from_session_with_broadcaster_arc(\n        client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        broadcaster: Arc\u003cSharedEventBroadcaster\u003e,\n    ) -\u003e Self {\n        Self::from_session_with_client_config_and_broadcaster_arc(\n            client,\n            session,\n            ClientConfig::default(),\n            broadcaster,\n        )\n    }\n\n    fn from_session_with_client_config_and_broadcaster_arc(\n        client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        config: ClientConfig,\n        broadcaster: Arc\u003cSharedEventBroadcaster\u003e,\n    ) -\u003e Self {\n        Self {\n            client,\n            session: Arc::new(Mutex::new(session)),\n            parser: LastFmParser::new(),\n            broadcaster,\n            config,\n        }\n    }\n\n    pub fn get_session(\u0026self) -\u003e LastFmEditSession {\n        self.session.lock().unwrap().clone()\n    }\n\n    pub fn restore_session(\u0026self, session: LastFmEditSession) {\n        *self.session.lock().unwrap() = session;\n    }\n\n    pub fn with_shared_broadcaster(\u0026self, client: Box\u003cdyn HttpClient + Send + Sync\u003e) -\u003e Self {\n        let session = self.get_session();\n        Self::from_session_with_broadcaster(client, session, self.broadcaster.clone())\n    }\n\n    pub fn username(\u0026self) -\u003e String {\n        self.session.lock().unwrap().username.clone()\n    }\n\n    pub async fn validate_session(\u0026self) -\u003e bool {\n        let test_url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/settings/subscription/automatic-edits/tracks\",\n                session.base_url\n            )\n        };\n\n        let mut request = Request::new(Method::Get, test_url.parse::\u003cUrl\u003e().unwrap());\n\n        {\n            let session = self.session.lock().unwrap();\n            headers::add_cookies(\u0026mut request, \u0026session.cookies);\n        }\n\n        headers::add_get_headers(\u0026mut request, false, None);\n\n        match self.client.send(request).await {\n            Ok(response) =\u003e {\n                if response.status() == 302 || response.status() == 301 {\n                    if let Some(location) = response.header(\"location\") {\n                        if let Some(redirect_url) = location.get(0) {\n                            let redirect_url_str = redirect_url.as_str();\n                            let is_valid = !redirect_url_str.contains(\"/login\");\n\n                            return is_valid;\n                        }\n                    }\n                }\n                true\n            }\n            Err(_e) =\u003e false,\n        }\n    }\n\n    pub async fn delete_scrobble(\n        \u0026self,\n        artist_name: \u0026str,\n        track_name: \u0026str,\n        timestamp: u64,\n    ) -\u003e Result\u003cbool\u003e {\n        let config = RetryConfig {\n            max_retries: 3,\n            base_delay: 5,\n            max_delay: 300,\n            enabled: true,\n        };\n\n        let artist_name = artist_name.to_string();\n        let track_name = track_name.to_string();\n        let client = self.clone();\n\n        match retry::retry_with_backoff(\n            config,\n            \"Delete scrobble\",\n            || client.delete_scrobble_impl(\u0026artist_name, \u0026track_name, timestamp),\n            |delay, rate_limit_timestamp, operation_name| {\n                self.broadcast_event(ClientEvent::RateLimited {\n                    delay_seconds: delay,\n                    request: None,\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    rate_limit_timestamp,\n                });\n                log::debug!(\"{operation_name} rate limited, waiting {delay} seconds\");\n            },\n            |total_duration, _operation_name| {\n                self.broadcast_event(ClientEvent::RateLimitEnded {\n                    request: crate::types::RequestInfo::from_url_and_method(\n                        \u0026format!(\"delete_scrobble/{artist_name}/{track_name}/{timestamp}\"),\n                        \"POST\",\n                    ),\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    total_rate_limit_duration_seconds: total_duration,\n                });\n            },\n        )\n        .await\n        {\n            Ok(retry_result) =\u003e Ok(retry_result.result),\n            Err(_) =\u003e Ok(false),\n        }\n    }\n\n    async fn delete_scrobble_impl(\n        \u0026self,\n        artist_name: \u0026str,\n        track_name: \u0026str,\n        timestamp: u64,\n    ) -\u003e Result\u003cbool\u003e {\n        let delete_url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/delete\",\n                session.base_url, session.username\n            )\n        };\n\n        log::debug!(\"Getting fresh CSRF token for delete\");\n        let library_url = {\n            let session = self.session.lock().unwrap();\n            format!(\"{}/user/{}/library\", session.base_url, session.username)\n        };\n\n        let mut response = self.get(\u0026library_url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        let document = Html::parse_document(\u0026content);\n        let fresh_csrf_token = self.extract_csrf_token(\u0026document)?;\n\n        log::debug!(\"Submitting delete request with fresh token\");\n\n        let mut request = Request::new(Method::Post, delete_url.parse::\u003cUrl\u003e().unwrap());\n\n        let referer_url = {\n            let session = self.session.lock().unwrap();\n            headers::add_cookies(\u0026mut request, \u0026session.cookies);\n            format!(\"{}/user/{}\", session.base_url, session.username)\n        };\n\n        headers::add_edit_headers(\u0026mut request, \u0026referer_url);\n\n        let form_data = [\n            (\"csrfmiddlewaretoken\", fresh_csrf_token.as_str()),\n            (\"artist_name\", artist_name),\n            (\"track_name\", track_name),\n            (\"timestamp\", \u0026timestamp.to_string()),\n            (\"ajax\", \"1\"),\n        ];\n\n        let form_string: String = form_data\n            .iter()\n            .map(|(k, v)| format!(\"{}={}\", urlencoding::encode(k), urlencoding::encode(v)))\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\u0026\");\n\n        request.set_body(form_string);\n\n        log::debug!(\n            \"Deleting scrobble: '{track_name}' by '{artist_name}' with timestamp {timestamp}\"\n        );\n\n        let request_info = RequestInfo::from_url_and_method(\u0026delete_url, \"POST\");\n        let request_start = std::time::Instant::now();\n\n        self.broadcast_event(ClientEvent::RequestStarted {\n            request: request_info.clone(),\n        });\n\n        let mut response = self\n            .client\n            .send(request)\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        self.broadcast_event(ClientEvent::RequestCompleted {\n            request: request_info.clone(),\n            status_code: response.status().into(),\n            duration_ms: request_start.elapsed().as_millis() as u64,\n        });\n\n        log::debug!(\"Delete response status: {}\", response.status());\n\n        let response_text = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        let success = response.status().is_success();\n\n        if success {\n            log::debug!(\"Successfully deleted scrobble\");\n        } else {\n            log::debug!(\"Delete failed with response: {response_text}\");\n        }\n\n        Ok(success)\n    }\n\n    pub fn subscribe(\u0026self) -\u003e ClientEventReceiver {\n        self.broadcaster.subscribe()\n    }\n\n    pub fn latest_event(\u0026self) -\u003e Option\u003cClientEvent\u003e {\n        self.broadcaster.latest_event()\n    }\n\n    fn broadcast_event(\u0026self, event: ClientEvent) {\n        self.broadcaster.broadcast_event(event);\n    }\n\n    pub async fn get_recent_scrobbles(\u0026self, page: u32) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library?page={}\",\n                session.base_url, session.username, page\n            )\n        };\n\n        log::debug!(\"Fetching recent scrobbles page {page}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"Recent scrobbles response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        let document = Html::parse_document(\u0026content);\n        self.parser.parse_recent_scrobbles(\u0026document)\n    }\n\n    pub async fn get_recent_tracks_page(\u0026self, page: u32) -\u003e Result\u003cTrackPage\u003e {\n        let tracks = self.get_recent_scrobbles(page).await?;\n\n        let has_next_page = !tracks.is_empty();\n\n        Ok(TrackPage {\n            tracks,\n            page_number: page,\n            has_next_page,\n            total_pages: None,\n        })\n    }\n\n    pub async fn find_recent_scrobble_for_track(\n        \u0026self,\n        track_name: \u0026str,\n        artist_name: \u0026str,\n        max_pages: u32,\n    ) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        log::debug!(\"Searching for recent scrobble: '{track_name}' by '{artist_name}'\");\n\n        for page in 1..=max_pages {\n            let scrobbles = self.get_recent_scrobbles(page).await?;\n\n            for scrobble in scrobbles {\n                if scrobble.name == track_name \u0026\u0026 scrobble.artist == artist_name {\n                    log::debug!(\n                        \"Found recent scrobble: '{}' with timestamp {:?}\",\n                        scrobble.name,\n                        scrobble.timestamp\n                    );\n                    return Ok(Some(scrobble));\n                }\n            }\n        }\n\n        log::debug!(\n            \"No recent scrobble found for '{track_name}' by '{artist_name}' in {max_pages} pages\"\n        );\n        Ok(None)\n    }\n\n    pub async fn edit_scrobble(\u0026self, edit: \u0026ScrobbleEdit) -\u003e Result\u003cEditResponse\u003e {\n        let discovered_edits = self.discover_scrobble_edit_variations(edit).await?;\n\n        if discovered_edits.is_empty() {\n            let context = match (\u0026edit.track_name_original, \u0026edit.album_name_original) {\n                (Some(track_name), _) =\u003e {\n                    format!(\"track '{}' by '{}'\", track_name, edit.artist_name_original)\n                }\n                (None, Some(album_name)) =\u003e {\n                    format!(\"album '{}' by '{}'\", album_name, edit.artist_name_original)\n                }\n                (None, None) =\u003e format!(\"artist '{}'\", edit.artist_name_original),\n            };\n            return Err(LastFmError::Parse(format!(\n                \"No scrobbles found for {context}. Make sure the names are correct and that you have scrobbled recently.\"\n            )));\n        }\n\n        log::info!(\n            \"Discovered {} scrobble instances to edit\",\n            discovered_edits.len()\n        );\n\n        let mut all_results = Vec::new();\n\n        for (index, discovered_edit) in discovered_edits.iter().enumerate() {\n            log::debug!(\n                \"Processing scrobble {}/{}: '{}' from '{}'\",\n                index + 1,\n                discovered_edits.len(),\n                discovered_edit.track_name_original,\n                discovered_edit.album_name_original\n            );\n\n            let mut modified_exact_edit = discovered_edit.clone();\n\n            if let Some(new_track_name) = \u0026edit.track_name {\n                modified_exact_edit.track_name = new_track_name.clone();\n            }\n            if let Some(new_album_name) = \u0026edit.album_name {\n                modified_exact_edit.album_name = new_album_name.clone();\n            }\n            modified_exact_edit.artist_name = edit.artist_name.clone();\n            if let Some(new_album_artist_name) = \u0026edit.album_artist_name {\n                modified_exact_edit.album_artist_name = new_album_artist_name.clone();\n            }\n            modified_exact_edit.edit_all = edit.edit_all;\n\n            let album_info = format!(\n                \"{} by {}\",\n                modified_exact_edit.album_name_original,\n                modified_exact_edit.album_artist_name_original\n            );\n\n            let single_response = self.edit_scrobble_single(\u0026modified_exact_edit, 3).await?;\n            let success = single_response.success();\n            let message = single_response.message();\n\n            all_results.push(SingleEditResponse {\n                success,\n                message,\n                album_info: Some(album_info),\n                exact_scrobble_edit: modified_exact_edit.clone(),\n            });\n\n            if index \u003c discovered_edits.len() - 1\n                \u0026\u0026 self.config.operational_delays.edit_delay_ms \u003e 0\n            {\n                tokio::time::sleep(std::time::Duration::from_millis(\n                    self.config.operational_delays.edit_delay_ms,\n                ))\n                .await;\n            }\n        }\n\n        Ok(EditResponse::from_results(all_results))\n    }\n\n    pub async fn edit_scrobble_single(\n        \u0026self,\n        exact_edit: \u0026ExactScrobbleEdit,\n        max_retries: u32,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        let config = RetryConfig {\n            max_retries,\n            base_delay: 5,\n            max_delay: 300,\n            enabled: true,\n        };\n\n        let edit_clone = exact_edit.clone();\n        let client = self.clone();\n\n        match retry::retry_with_backoff(\n            config,\n            \"Edit scrobble\",\n            || client.edit_scrobble_impl(\u0026edit_clone),\n            |delay, rate_limit_timestamp, operation_name| {\n                self.broadcast_event(ClientEvent::RateLimited {\n                    delay_seconds: delay,\n                    request: None, // No specific request context in retry callback\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    rate_limit_timestamp,\n                });\n                log::debug!(\"{operation_name} rate limited, waiting {delay} seconds\");\n            },\n            |total_duration, _operation_name| {\n                self.broadcast_event(ClientEvent::RateLimitEnded {\n                    request: crate::types::RequestInfo::from_url_and_method(\n                        \u0026format!(\n                            \"edit_scrobble/{}/{}\",\n                            edit_clone.artist_name, edit_clone.track_name\n                        ),\n                        \"POST\",\n                    ),\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    total_rate_limit_duration_seconds: total_duration,\n                });\n            },\n        )\n        .await\n        {\n            Ok(retry_result) =\u003e Ok(EditResponse::single(\n                retry_result.result,\n                None,\n                None,\n                exact_edit.clone(),\n            )),\n            Err(LastFmError::RateLimit { .. }) =\u003e Ok(EditResponse::single(\n                false,\n                Some(format!(\"Rate limit exceeded after {max_retries} retries\")),\n                None,\n                exact_edit.clone(),\n            )),\n            Err(other_error) =\u003e Ok(EditResponse::single(\n                false,\n                Some(other_error.to_string()),\n                None,\n                exact_edit.clone(),\n            )),\n        }\n    }\n\n    async fn edit_scrobble_impl(\u0026self, exact_edit: \u0026ExactScrobbleEdit) -\u003e Result\u003cbool\u003e {\n        let start_time = std::time::Instant::now();\n        let result = self.edit_scrobble_impl_internal(exact_edit).await;\n        let duration_ms = start_time.elapsed().as_millis() as u64;\n\n        match \u0026result {\n            Ok(success) =\u003e {\n                self.broadcast_event(ClientEvent::EditAttempted {\n                    edit: exact_edit.clone(),\n                    success: *success,\n                    error_message: None,\n                    duration_ms,\n                });\n            }\n            Err(error) =\u003e {\n                self.broadcast_event(ClientEvent::EditAttempted {\n                    edit: exact_edit.clone(),\n                    success: false,\n                    error_message: Some(error.to_string()),\n                    duration_ms,\n                });\n            }\n        }\n\n        result\n    }\n\n    async fn edit_scrobble_impl_internal(\u0026self, exact_edit: \u0026ExactScrobbleEdit) -\u003e Result\u003cbool\u003e {\n        let edit_url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/edit?edited-variation=library-track-scrobble\",\n                session.base_url, session.username\n            )\n        };\n\n        log::debug!(\"Getting fresh CSRF token for edit\");\n        let form_html = self.get_edit_form_html(\u0026edit_url).await?;\n\n        let form_document = Html::parse_document(\u0026form_html);\n        let fresh_csrf_token = self.extract_csrf_token(\u0026form_document)?;\n\n        log::debug!(\"Submitting edit with fresh token\");\n\n        let form_data = exact_edit.build_form_data(\u0026fresh_csrf_token);\n\n        log::debug!(\n            \"Editing scrobble: '{}' -\u003e '{}'\",\n            exact_edit.track_name_original,\n            exact_edit.track_name\n        );\n        {\n            let session = self.session.lock().unwrap();\n            log::trace!(\"Session cookies count: {}\", session.cookies.len());\n        }\n\n        let mut request = Request::new(Method::Post, edit_url.parse::\u003cUrl\u003e().unwrap());\n\n        let referer_url = {\n            let session = self.session.lock().unwrap();\n            headers::add_cookies(\u0026mut request, \u0026session.cookies);\n            format!(\"{}/user/{}/library\", session.base_url, session.username)\n        };\n\n        headers::add_edit_headers(\u0026mut request, \u0026referer_url);\n\n        let form_string: String = form_data\n            .iter()\n            .map(|(k, v)| format!(\"{}={}\", urlencoding::encode(k), urlencoding::encode(v)))\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\u0026\");\n\n        request.set_body(form_string);\n\n        let request_info = RequestInfo::from_url_and_method(\u0026edit_url, \"POST\");\n        let request_start = std::time::Instant::now();\n\n        self.broadcast_event(ClientEvent::RequestStarted {\n            request: request_info.clone(),\n        });\n\n        let mut response = self\n            .client\n            .send(request)\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        self.broadcast_event(ClientEvent::RequestCompleted {\n            request: request_info.clone(),\n            status_code: response.status().into(),\n            duration_ms: request_start.elapsed().as_millis() as u64,\n        });\n\n        log::debug!(\"Edit response status: {}\", response.status());\n\n        let response_text = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        let analysis = edit_analysis::analyze_edit_response(\u0026response_text, response.status());\n\n        Ok(analysis.success)\n    }\n\n    async fn get_edit_form_html(\u0026self, edit_url: \u0026str) -\u003e Result\u003cString\u003e {\n        let mut form_response = self.get(edit_url).await?;\n        let form_html = form_response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\"Edit form response status: {}\", form_response.status());\n        Ok(form_html)\n    }\n\n    pub async fn load_edit_form_values_internal(\n        \u0026self,\n        track_name: \u0026str,\n        artist_name: \u0026str,\n    ) -\u003e Result\u003cVec\u003cExactScrobbleEdit\u003e\u003e {\n        log::debug!(\"Loading edit form values for '{track_name}' by '{artist_name}'\");\n\n        let base_track_url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/music/+noredirect/{}/_/{}\",\n                session.base_url,\n                session.username,\n                urlencoding::encode(artist_name),\n                urlencoding::encode(track_name)\n            )\n        };\n\n        log::debug!(\"Fetching track page: {base_track_url}\");\n\n        let mut response = self.get(\u0026base_track_url).await?;\n        let html = response\n            .body_string()\n            .await\n            .map_err(|e| crate::LastFmError::Http(e.to_string()))?;\n\n        let document = Html::parse_document(\u0026html);\n\n        let mut all_scrobble_edits = Vec::new();\n        let mut unique_albums = std::collections::HashSet::new();\n        let max_pages = 5;\n\n        let page_edits = self.extract_scrobble_edits_from_page(\n            \u0026document,\n            track_name,\n            artist_name,\n            \u0026mut unique_albums,\n        )?;\n        all_scrobble_edits.extend(page_edits);\n\n        log::debug!(\n            \"Page 1: found {} unique album variations\",\n            all_scrobble_edits.len()\n        );\n\n        let pagination_selector = Selector::parse(\".pagination .pagination-next\").unwrap();\n        let mut has_next_page = document.select(\u0026pagination_selector).next().is_some();\n        let mut page = 2;\n\n        while has_next_page \u0026\u0026 page \u003c= max_pages {\n            let page_url = {\n                let session = self.session.lock().unwrap();\n                format!(\n                    \"{}/user/{}/library/music/{}/_/{}?page={page}\",\n                    session.base_url,\n                    session.username,\n                    urlencoding::encode(artist_name),\n                    urlencoding::encode(track_name)\n                )\n            };\n\n            log::debug!(\"Fetching page {page} for additional album variations\");\n\n            let mut response = self.get(\u0026page_url).await?;\n            let html = response\n                .body_string()\n                .await\n                .map_err(|e| crate::LastFmError::Http(e.to_string()))?;\n\n            let document = Html::parse_document(\u0026html);\n\n            let page_edits = self.extract_scrobble_edits_from_page(\n                \u0026document,\n                track_name,\n                artist_name,\n                \u0026mut unique_albums,\n            )?;\n\n            let initial_count = all_scrobble_edits.len();\n            all_scrobble_edits.extend(page_edits);\n            let found_new_unique_albums = all_scrobble_edits.len() \u003e initial_count;\n\n            has_next_page = document.select(\u0026pagination_selector).next().is_some();\n\n            log::debug!(\n                \"Page {page}: found {} total unique albums ({})\",\n                all_scrobble_edits.len(),\n                if found_new_unique_albums {\n                    \"new albums found\"\n                } else {\n                    \"no new unique albums\"\n                }\n            );\n\n            page += 1;\n        }\n\n        if all_scrobble_edits.is_empty() {\n            return Err(crate::LastFmError::Parse(format!(\n                \"No scrobble forms found for track '{track_name}' by '{artist_name}'\"\n            )));\n        }\n\n        log::debug!(\n            \"Final result: found {} unique album variations for '{track_name}' by '{artist_name}'\",\n            all_scrobble_edits.len(),\n        );\n\n        Ok(all_scrobble_edits)\n    }\n\n    fn extract_scrobble_edits_from_page(\n        \u0026self,\n        document: \u0026Html,\n        expected_track: \u0026str,\n        expected_artist: \u0026str,\n        unique_albums: \u0026mut std::collections::HashSet\u003c(String, String)\u003e,\n    ) -\u003e Result\u003cVec\u003cExactScrobbleEdit\u003e\u003e {\n        let mut scrobble_edits = Vec::new();\n        let table_selector =\n            Selector::parse(\"table.chartlist:not(.chartlist__placeholder)\").unwrap();\n        let table = document.select(\u0026table_selector).next().ok_or_else(|| {\n            crate::LastFmError::Parse(\"No chartlist table found on track page\".to_string())\n        })?;\n\n        let row_selector = Selector::parse(\"tr\").unwrap();\n        for row in table.select(\u0026row_selector) {\n            let count_bar_link_selector = Selector::parse(\".chartlist-count-bar-link\").unwrap();\n            if row.select(\u0026count_bar_link_selector).next().is_some() {\n                log::debug!(\"Found count bar link, skipping aggregated row\");\n                continue;\n            }\n\n            let form_selector = Selector::parse(\"form[data-edit-scrobble]\").unwrap();\n            if let Some(form) = row.select(\u0026form_selector).next() {\n                let extract_form_value = |name: \u0026str| -\u003e Option\u003cString\u003e {\n                    let selector = Selector::parse(\u0026format!(\"input[name='{name}']\")).unwrap();\n                    form.select(\u0026selector)\n                        .next()\n                        .and_then(|input| input.value().attr(\"value\"))\n                        .map(|s| s.to_string())\n                };\n\n                let form_track = extract_form_value(\"track_name\").unwrap_or_default();\n                let form_artist = extract_form_value(\"artist_name\").unwrap_or_default();\n                let form_album = extract_form_value(\"album_name\").unwrap_or_default();\n                let form_album_artist =\n                    extract_form_value(\"album_artist_name\").unwrap_or_else(|| form_artist.clone());\n                let form_timestamp = extract_form_value(\"timestamp\").unwrap_or_default();\n\n                if form_track == expected_track \u0026\u0026 form_artist == expected_artist {\n                    let album_key = (form_album.clone(), form_album_artist.clone());\n                    if unique_albums.insert(album_key) {\n                        let timestamp = if form_timestamp.is_empty() {\n                            None\n                        } else {\n                            form_timestamp.parse::\u003cu64\u003e().ok()\n                        };\n\n                        if let Some(timestamp) = timestamp {\n                            let scrobble_edit = ExactScrobbleEdit::new(\n                                form_track.clone(),\n                                form_album.clone(),\n                                form_artist.clone(),\n                                form_album_artist.clone(),\n                                form_track,\n                                form_album,\n                                form_artist,\n                                form_album_artist,\n                                timestamp,\n                                true,\n                            );\n                            scrobble_edits.push(scrobble_edit);\n                        } else {\n                            log::warn!(\n                                \"âš ï¸ Skipping form without valid timestamp: '{form_album}' by '{form_album_artist}'\"\n                            );\n                        }\n                    }\n                }\n            }\n        }\n\n        Ok(scrobble_edits)\n    }\n\n    pub async fn get_artist_tracks_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003cTrackPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/music/{}/+tracks?page={}\u0026ajax=true\",\n                session.base_url,\n                session.username,\n                urlencoding::encode(artist),\n                page\n            )\n        };\n\n        log::debug!(\"Fetching tracks page {page} for artist: {artist}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"AJAX response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        log::debug!(\"Parsing HTML response from AJAX endpoint\");\n        let document = Html::parse_document(\u0026content);\n        self.parser.parse_tracks_page(\u0026document, page, artist, None)\n    }\n\n    pub fn extract_tracks_from_document(\n        \u0026self,\n        document: \u0026Html,\n        artist: \u0026str,\n        album: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        self.parser\n            .extract_tracks_from_document(document, artist, album)\n    }\n\n    pub fn parse_tracks_page(\n        \u0026self,\n        document: \u0026Html,\n        page_number: u32,\n        artist: \u0026str,\n        album: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cTrackPage\u003e {\n        self.parser\n            .parse_tracks_page(document, page_number, artist, album)\n    }\n\n    pub fn parse_recent_scrobbles(\u0026self, document: \u0026Html) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        self.parser.parse_recent_scrobbles(document)\n    }\n\n    fn extract_csrf_token(\u0026self, document: \u0026Html) -\u003e Result\u003cString\u003e {\n        let csrf_selector = Selector::parse(\"input[name=\\\"csrfmiddlewaretoken\\\"]\").unwrap();\n\n        document\n            .select(\u0026csrf_selector)\n            .next()\n            .and_then(|input| input.value().attr(\"value\"))\n            .map(|token| token.to_string())\n            .ok_or(LastFmError::CsrfNotFound)\n    }\n\n    pub async fn get(\u0026self, url: \u0026str) -\u003e Result\u003cResponse\u003e {\n        self.get_with_retry(url).await\n    }\n\n    async fn get_with_retry(\u0026self, url: \u0026str) -\u003e Result\u003cResponse\u003e {\n        let config = self.config.retry.clone();\n\n        let url_string = url.to_string();\n        let client = self.clone();\n\n        let retry_result = retry::retry_with_backoff(\n            config,\n            \u0026format!(\"GET {url}\"),\n            || async {\n                let mut response = client.get_with_redirects(\u0026url_string, 0).await?;\n\n                let body = client\n                    .extract_response_body(\u0026url_string, \u0026mut response)\n                    .await?;\n\n                if response.status().is_success() \u0026\u0026 client.is_rate_limit_response(\u0026body) {\n                    log::debug!(\"Response body contains rate limit patterns\");\n                    return Err(LastFmError::RateLimit { retry_after: 60 });\n                }\n\n                let mut new_response = http_types::Response::new(response.status());\n                for (name, values) in response.iter() {\n                    for value in values {\n                        let _ = new_response.insert_header(name.clone(), value.clone());\n                    }\n                }\n                new_response.set_body(body);\n\n                Ok(new_response)\n            },\n            |delay, rate_limit_timestamp, operation_name| {\n                self.broadcast_event(ClientEvent::RateLimited {\n                    delay_seconds: delay,\n                    request: None, // No specific request context in retry callback\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    rate_limit_timestamp,\n                });\n                log::debug!(\"{operation_name} rate limited, waiting {delay} seconds\");\n            },\n            |total_duration, _operation_name| {\n                self.broadcast_event(ClientEvent::RateLimitEnded {\n                    request: crate::types::RequestInfo::from_url_and_method(\u0026url_string, \"GET\"),\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    total_rate_limit_duration_seconds: total_duration,\n                });\n            },\n        )\n        .await?;\n\n        Ok(retry_result.result)\n    }\n\n    async fn get_with_redirects(\u0026self, url: \u0026str, redirect_count: u32) -\u003e Result\u003cResponse\u003e {\n        if redirect_count \u003e 5 {\n            return Err(LastFmError::Http(\"Too many redirects\".to_string()));\n        }\n\n        let mut request = Request::new(Method::Get, url.parse::\u003cUrl\u003e().unwrap());\n\n        {\n            let session = self.session.lock().unwrap();\n            headers::add_cookies(\u0026mut request, \u0026session.cookies);\n            if session.cookies.is_empty() \u0026\u0026 url.contains(\"page=\") {\n                log::debug!(\"No cookies available for paginated request!\");\n            }\n        }\n\n        let is_ajax = url.contains(\"ajax=true\");\n        let referer_url = if url.contains(\"page=\") {\n            Some(url.split('?').next().unwrap_or(url))\n        } else {\n            None\n        };\n\n        headers::add_get_headers(\u0026mut request, is_ajax, referer_url);\n\n        let request_info = RequestInfo::from_url_and_method(url, \"GET\");\n        let request_start = std::time::Instant::now();\n\n        self.broadcast_event(ClientEvent::RequestStarted {\n            request: request_info.clone(),\n        });\n\n        let response = self\n            .client\n            .send(request)\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        self.broadcast_event(ClientEvent::RequestCompleted {\n            request: request_info.clone(),\n            status_code: response.status().into(),\n            duration_ms: request_start.elapsed().as_millis() as u64,\n        });\n\n        self.extract_cookies(\u0026response);\n\n        if response.status() == 302 || response.status() == 301 {\n            if let Some(location) = response.header(\"location\") {\n                if let Some(redirect_url) = location.get(0) {\n                    let redirect_url_str = redirect_url.as_str();\n                    if url.contains(\"page=\") {\n                        log::debug!(\"Following redirect from {url} to {redirect_url_str}\");\n\n                        if redirect_url_str.contains(\"/login\") {\n                            log::debug!(\"Redirect to login page - authentication failed for paginated request\");\n                            return Err(LastFmError::Auth(\n                                \"Session expired or invalid for paginated request\".to_string(),\n                            ));\n                        }\n                    }\n\n                    let full_redirect_url = if redirect_url_str.starts_with('/') {\n                        let base_url = self.session.lock().unwrap().base_url.clone();\n                        format!(\"{base_url}{redirect_url_str}\")\n                    } else if redirect_url_str.starts_with(\"http\") {\n                        redirect_url_str.to_string()\n                    } else {\n                        let base_url = url\n                            .rsplit('/')\n                            .skip(1)\n                            .collect::\u003cVec\u003c_\u003e\u003e()\n                            .into_iter()\n                            .rev()\n                            .collect::\u003cVec\u003c_\u003e\u003e()\n                            .join(\"/\");\n                        format!(\"{base_url}/{redirect_url_str}\")\n                    };\n\n                    return Box::pin(\n                        self.get_with_redirects(\u0026full_redirect_url, redirect_count + 1),\n                    )\n                    .await;\n                }\n            }\n        }\n\n        if self.config.rate_limit.detect_by_status \u0026\u0026 response.status() == 429 {\n            let retry_after = response\n                .header(\"retry-after\")\n                .and_then(|h| h.get(0))\n                .and_then(|v| v.as_str().parse::\u003cu64\u003e().ok())\n                .unwrap_or(60);\n            self.broadcast_event(ClientEvent::RateLimited {\n                delay_seconds: retry_after,\n                request: Some(request_info.clone()),\n                rate_limit_type: RateLimitType::Http429,\n                rate_limit_timestamp: std::time::SystemTime::now()\n                    .duration_since(std::time::UNIX_EPOCH)\n                    .unwrap_or_default()\n                    .as_secs(),\n            });\n            return Err(LastFmError::RateLimit { retry_after });\n        }\n\n        if self.config.rate_limit.detect_by_status \u0026\u0026 response.status() == 403 {\n            log::debug!(\"Got 403 response, checking if it's a rate limit\");\n            {\n                let session = self.session.lock().unwrap();\n                if !session.cookies.is_empty() {\n                    log::debug!(\"403 on authenticated request - likely rate limit\");\n                    self.broadcast_event(ClientEvent::RateLimited {\n                        delay_seconds: 60,\n                        request: Some(request_info.clone()),\n                        rate_limit_type: RateLimitType::Http403,\n                        rate_limit_timestamp: std::time::SystemTime::now()\n                            .duration_since(std::time::UNIX_EPOCH)\n                            .unwrap_or_default()\n                            .as_secs(),\n                    });\n                    return Err(LastFmError::RateLimit { retry_after: 60 });\n                }\n            }\n        }\n\n        Ok(response)\n    }\n\n    fn is_rate_limit_response(\u0026self, response_body: \u0026str) -\u003e bool {\n        let rate_limit_config = \u0026self.config.rate_limit;\n\n        if !rate_limit_config.detect_by_patterns \u0026\u0026 rate_limit_config.custom_patterns.is_empty() {\n            return false;\n        }\n\n        let body_lower = response_body.to_lowercase();\n\n        for pattern in \u0026rate_limit_config.custom_patterns {\n            if body_lower.contains(\u0026pattern.to_lowercase()) {\n                log::debug!(\"Rate limit detected (custom pattern: '{pattern}')\");\n                return true;\n            }\n        }\n\n        if rate_limit_config.detect_by_patterns {\n            for pattern in \u0026rate_limit_config.patterns {\n                let pattern_lower = pattern.to_lowercase();\n                if body_lower.contains(\u0026pattern_lower) {\n                    log::debug!(\"Rate limit detected (pattern: '{pattern}')\");\n                    return true;\n                }\n            }\n        }\n\n        false\n    }\n\n    fn extract_cookies(\u0026self, response: \u0026Response) {\n        let mut session = self.session.lock().unwrap();\n        extract_cookies_from_response(response, \u0026mut session.cookies);\n    }\n\n    async fn extract_response_body(\u0026self, _url: \u0026str, response: \u0026mut Response) -\u003e Result\u003cString\u003e {\n        let body = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        Ok(body)\n    }\n\n    pub async fn get_artists_page(\u0026self, page: u32) -\u003e Result\u003ccrate::ArtistPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/artists?page={}\",\n                session.base_url, session.username, page\n            )\n        };\n\n        log::debug!(\"Fetching artists page {page}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"Artist library response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        log::debug!(\"Parsing HTML response from artist library endpoint\");\n        let document = Html::parse_document(\u0026content);\n        self.parser.parse_artists_page(\u0026document, page)\n    }\n\n    pub async fn get_artist_albums_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003cAlbumPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/music/{}/+albums?page={}\u0026ajax=true\",\n                session.base_url,\n                session.username,\n                urlencoding::encode(artist),\n                page\n            )\n        };\n\n        log::debug!(\"Fetching albums page {page} for artist: {artist}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"AJAX response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        log::debug!(\"Parsing HTML response from AJAX endpoint\");\n        let document = Html::parse_document(\u0026content);\n        self.parser.parse_albums_page(\u0026document, page, artist)\n    }\n\n    pub async fn get_album_tracks_page(\n        \u0026self,\n        album_name: \u0026str,\n        artist_name: \u0026str,\n        page: u32,\n    ) -\u003e Result\u003cTrackPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/music/{}/{}?page={}\u0026ajax=true\",\n                session.base_url,\n                session.username,\n                self.lastfm_encode(artist_name),\n                self.lastfm_encode(album_name),\n                page\n            )\n        };\n\n        log::debug!(\"Fetching tracks page {page} for album '{album_name}' by '{artist_name}'\");\n        log::debug!(\"ğŸ”— Album URL: {url}\");\n\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"AJAX response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        log::debug!(\"Parsing HTML response from AJAX endpoint\");\n        let document = Html::parse_document(\u0026content);\n        let result =\n            self.parser\n                .parse_tracks_page(\u0026document, page, artist_name, Some(album_name))?;\n\n        // Debug logging for albums that return 0 tracks\n        if result.tracks.is_empty() {\n            if content.contains(\"404\") || content.contains(\"Not Found\") {\n                log::warn!(\"ğŸš¨ 404 ERROR for album '{album_name}' by '{artist_name}': {url}\");\n            } else if content.contains(\"no tracks\") || content.contains(\"no music\") {\n                log::debug!(\"â„¹ï¸  Album '{album_name}' by '{artist_name}' explicitly has no tracks in user's library\");\n            } else {\n                log::warn!(\n                    \"ğŸš¨ UNKNOWN EMPTY RESPONSE for album '{album_name}' by '{artist_name}': {url}\"\n                );\n                log::debug!(\"ğŸ” Response length: {} chars\", content.len());\n                log::debug!(\n                    \"ğŸ” Response preview (first 200 chars): {}\",\n                    \u0026content.chars().take(200).collect::\u003cString\u003e()\n                );\n            }\n        } else {\n            log::debug!(\n                \"âœ… SUCCESS: Album '{album_name}' by '{artist_name}' returned {} tracks\",\n                result.tracks.len()\n            );\n        }\n\n        Ok(result)\n    }\n\n    pub async fn search_tracks_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003cTrackPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/tracks/search?page={}\u0026query={}\u0026ajax=1\",\n                session.base_url,\n                session.username,\n                page,\n                urlencoding::encode(query)\n            )\n        };\n\n        log::debug!(\"Searching tracks for query '{query}' on page {page}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"Track search response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        let document = Html::parse_document(\u0026content);\n        let tracks = self.parser.parse_track_search_results(\u0026document)?;\n\n        // For search results, we need to determine pagination differently\n        // since we don't have the same pagination structure as regular library pages\n        let (has_next_page, total_pages) = self.parser.parse_pagination(\u0026document, page)?;\n\n        Ok(TrackPage {\n            tracks,\n            page_number: page,\n            has_next_page,\n            total_pages,\n        })\n    }\n\n    pub async fn search_albums_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003cAlbumPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/albums/search?page={}\u0026query={}\u0026ajax=1\",\n                session.base_url,\n                session.username,\n                page,\n                urlencoding::encode(query)\n            )\n        };\n\n        log::debug!(\"Searching albums for query '{query}' on page {page}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"Album search response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        let document = Html::parse_document(\u0026content);\n        let albums = self.parser.parse_album_search_results(\u0026document)?;\n\n        // For search results, we need to determine pagination differently\n        let (has_next_page, total_pages) = self.parser.parse_pagination(\u0026document, page)?;\n\n        Ok(AlbumPage {\n            albums,\n            page_number: page,\n            has_next_page,\n            total_pages,\n        })\n    }\n\n    /// Expose the inner HTTP client for advanced use cases like VCR cassette management\n    pub fn inner_client(\u0026self) -\u003e Arc\u003cdyn HttpClient + Send + Sync\u003e {\n        self.client.clone()\n    }\n}\n\n#[async_trait(?Send)]\nimpl LastFmEditClient for LastFmEditClientImpl {\n    fn username(\u0026self) -\u003e String {\n        self.username()\n    }\n\n    async fn get_recent_scrobbles(\u0026self, page: u32) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        self.get_recent_scrobbles(page).await\n    }\n\n    async fn find_recent_scrobble_for_track(\n        \u0026self,\n        track_name: \u0026str,\n        artist_name: \u0026str,\n        max_pages: u32,\n    ) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        self.find_recent_scrobble_for_track(track_name, artist_name, max_pages)\n            .await\n    }\n\n    async fn edit_scrobble(\u0026self, edit: \u0026ScrobbleEdit) -\u003e Result\u003cEditResponse\u003e {\n        self.edit_scrobble(edit).await\n    }\n\n    async fn edit_scrobble_single(\n        \u0026self,\n        exact_edit: \u0026ExactScrobbleEdit,\n        max_retries: u32,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        self.edit_scrobble_single(exact_edit, max_retries).await\n    }\n\n    fn get_session(\u0026self) -\u003e LastFmEditSession {\n        self.get_session()\n    }\n\n    fn restore_session(\u0026self, session: LastFmEditSession) {\n        self.restore_session(session)\n    }\n\n    fn subscribe(\u0026self) -\u003e ClientEventReceiver {\n        self.subscribe()\n    }\n\n    fn latest_event(\u0026self) -\u003e Option\u003cClientEvent\u003e {\n        self.latest_event()\n    }\n\n    fn discover_scrobbles(\n        \u0026self,\n        edit: ScrobbleEdit,\n    ) -\u003e Box\u003cdyn crate::AsyncDiscoveryIterator\u003ccrate::ExactScrobbleEdit\u003e\u003e {\n        let track_name = edit.track_name_original.clone();\n        let album_name = edit.album_name_original.clone();\n\n        match (\u0026track_name, \u0026album_name) {\n            (Some(track_name), Some(album_name)) =\u003e Box::new(crate::ExactMatchDiscovery::new(\n                self.clone(),\n                edit,\n                track_name.clone(),\n                album_name.clone(),\n            )),\n\n            (Some(track_name), None) =\u003e Box::new(crate::TrackVariationsDiscovery::new(\n                self.clone(),\n                edit,\n                track_name.clone(),\n            )),\n\n            (None, Some(album_name)) =\u003e Box::new(crate::AlbumTracksDiscovery::new(\n                self.clone(),\n                edit,\n                album_name.clone(),\n            )),\n\n            (None, None) =\u003e Box::new(crate::ArtistTracksDiscovery::new(self.clone(), edit)),\n        }\n    }\n\n    async fn get_artists_page(\u0026self, page: u32) -\u003e Result\u003ccrate::ArtistPage\u003e {\n        self.get_artists_page(page).await\n    }\n\n    async fn get_artist_tracks_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003cTrackPage\u003e {\n        self.get_artist_tracks_page(artist, page).await\n    }\n\n    async fn get_artist_albums_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003cAlbumPage\u003e {\n        self.get_artist_albums_page(artist, page).await\n    }\n\n    async fn get_album_tracks_page(\n        \u0026self,\n        album_name: \u0026str,\n        artist_name: \u0026str,\n        page: u32,\n    ) -\u003e Result\u003cTrackPage\u003e {\n        self.get_album_tracks_page(album_name, artist_name, page)\n            .await\n    }\n\n    fn artists(\u0026self) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003ccrate::Artist\u003e\u003e {\n        Box::new(crate::iterator::ArtistsIterator::new(self.clone()))\n    }\n\n    fn artist_tracks(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::ArtistTracksIterator::new(\n            self.clone(),\n            artist.to_string(),\n        ))\n    }\n\n    fn artist_tracks_direct(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::iterator::ArtistTracksDirectIterator::new(\n            self.clone(),\n            artist.to_string(),\n        ))\n    }\n\n    fn artist_albums(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003ccrate::Album\u003e\u003e {\n        Box::new(crate::ArtistAlbumsIterator::new(\n            self.clone(),\n            artist.to_string(),\n        ))\n    }\n\n    fn album_tracks(\n        \u0026self,\n        album_name: \u0026str,\n        artist_name: \u0026str,\n    ) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::AlbumTracksIterator::new(\n            self.clone(),\n            album_name.to_string(),\n            artist_name.to_string(),\n        ))\n    }\n\n    fn recent_tracks(\u0026self) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::RecentTracksIterator::new(self.clone()))\n    }\n\n    fn recent_tracks_from_page(\n        \u0026self,\n        starting_page: u32,\n    ) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::RecentTracksIterator::with_starting_page(\n            self.clone(),\n            starting_page,\n        ))\n    }\n\n    fn search_tracks(\u0026self, query: \u0026str) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::SearchTracksIterator::new(\n            self.clone(),\n            query.to_string(),\n        ))\n    }\n\n    fn search_albums(\u0026self, query: \u0026str) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003ccrate::Album\u003e\u003e {\n        Box::new(crate::SearchAlbumsIterator::new(\n            self.clone(),\n            query.to_string(),\n        ))\n    }\n\n    async fn search_tracks_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003ccrate::TrackPage\u003e {\n        self.search_tracks_page(query, page).await\n    }\n\n    async fn search_albums_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003ccrate::AlbumPage\u003e {\n        self.search_albums_page(query, page).await\n    }\n\n    async fn validate_session(\u0026self) -\u003e bool {\n        self.validate_session().await\n    }\n\n    async fn delete_scrobble(\n        \u0026self,\n        artist_name: \u0026str,\n        track_name: \u0026str,\n        timestamp: u64,\n    ) -\u003e Result\u003cbool\u003e {\n        self.delete_scrobble(artist_name, track_name, timestamp)\n            .await\n    }\n}\n","traces":[{"line":31,"address":[5953524,5953376,5953518],"length":1,"stats":{"Line":1}},{"line":32,"address":[5953439],"length":1,"stats":{"Line":1}},{"line":36,"address":[5579200],"length":1,"stats":{"Line":0}},{"line":38,"address":[5247423,5247367],"length":1,"stats":{"Line":0}},{"line":39,"address":[5404711],"length":1,"stats":{"Line":0}},{"line":40,"address":[20747328],"length":1,"stats":{"Line":0}},{"line":41,"address":[18505953],"length":1,"stats":{"Line":0}},{"line":42,"address":[5404819],"length":1,"stats":{"Line":0}},{"line":44,"address":[5579497,5579427],"length":1,"stats":{"Line":0}},{"line":46,"address":[20818111],"length":1,"stats":{"Line":0}},{"line":47,"address":[5247647],"length":1,"stats":{"Line":0}},{"line":51,"address":[5702400,5702418],"length":1,"stats":{"Line":0}},{"line":52,"address":[5520412,5520285,5520340,5520517,5521053],"length":1,"stats":{"Line":0}},{"line":53,"address":[2934868,2934797,2934512,2934412,2934958],"length":1,"stats":{"Line":0}},{"line":55,"address":[2934655,2933903,2934485,2934829,2934542],"length":1,"stats":{"Line":0}},{"line":56,"address":[5773328,5773346,5772934],"length":1,"stats":{"Line":0}},{"line":58,"address":[5401146,5401051],"length":1,"stats":{"Line":0}},{"line":60,"address":[5702735,5702706,5702448],"length":1,"stats":{"Line":8}},{"line":64,"address":[5579696,5579794],"length":1,"stats":{"Line":13}},{"line":67,"address":[3565000,3564688],"length":1,"stats":{"Line":7}},{"line":72,"address":[5248081],"length":1,"stats":{"Line":7}},{"line":73,"address":[5248115],"length":1,"stats":{"Line":7}},{"line":74,"address":[5954475,5954406],"length":1,"stats":{"Line":14}},{"line":78,"address":[5248416,5248974,5248913],"length":1,"stats":{"Line":0}},{"line":83,"address":[3565315,3565076],"length":1,"stats":{"Line":0}},{"line":84,"address":[5580779,5580452,5580637],"length":1,"stats":{"Line":0}},{"line":85,"address":[5406069],"length":1,"stats":{"Line":0}},{"line":88,"address":[20595896],"length":1,"stats":{"Line":1}},{"line":93,"address":[5522359,5522208],"length":1,"stats":{"Line":0}},{"line":94,"address":[5773898,5773931,5774303,5774028],"length":1,"stats":{"Line":0}},{"line":96,"address":[5774149,5773792,5774384,5774233],"length":1,"stats":{"Line":0}},{"line":97,"address":[5850453,5850656],"length":1,"stats":{"Line":1}},{"line":100,"address":[21063184],"length":1,"stats":{"Line":4}},{"line":105,"address":[5249204,5249322],"length":1,"stats":{"Line":7}},{"line":108,"address":[5955792],"length":1,"stats":{"Line":1}},{"line":114,"address":[5851394,5851552],"length":1,"stats":{"Line":2}},{"line":115,"address":[20651518],"length":1,"stats":{"Line":2}},{"line":117,"address":[5704234,5704141,5704415,5703765],"length":1,"stats":{"Line":2}},{"line":118,"address":[5853062,5852986],"length":1,"stats":{"Line":2}},{"line":119,"address":[5525740],"length":1,"stats":{"Line":1}},{"line":123,"address":[5956308,5955920],"length":1,"stats":{"Line":0}},{"line":130,"address":[3566346],"length":1,"stats":{"Line":0}},{"line":131,"address":[5249894],"length":1,"stats":{"Line":0}},{"line":133,"address":[5249964],"length":1,"stats":{"Line":0}},{"line":137,"address":[5407440],"length":1,"stats":{"Line":0}},{"line":144,"address":[5778658,5778500],"length":1,"stats":{"Line":0}},{"line":145,"address":[5779130,5778680,5778716,5778816],"length":1,"stats":{"Line":0}},{"line":147,"address":[5706719,5706343,5706993,5706812],"length":1,"stats":{"Line":0}},{"line":148,"address":[5780100,5780184],"length":1,"stats":{"Line":0}},{"line":149,"address":[5707614],"length":1,"stats":{"Line":0}},{"line":150,"address":[5528355],"length":1,"stats":{"Line":0}},{"line":151,"address":[5528459],"length":1,"stats":{"Line":0}},{"line":152,"address":[5707793],"length":1,"stats":{"Line":0}},{"line":156,"address":[3567154,3566848],"length":1,"stats":{"Line":3}},{"line":161,"address":[5407781,5407668],"length":1,"stats":{"Line":6}},{"line":164,"address":[3567619,3567649,3567184],"length":1,"stats":{"Line":3}},{"line":170,"address":[18506858,18506783],"length":1,"stats":{"Line":5}},{"line":171,"address":[5582603],"length":1,"stats":{"Line":8}},{"line":172,"address":[5957006],"length":1,"stats":{"Line":7}},{"line":173,"address":[5705571,5705643],"length":1,"stats":{"Line":5}},{"line":177,"address":[3568161,3567680,3568131],"length":1,"stats":{"Line":0}},{"line":186,"address":[5705974],"length":1,"stats":{"Line":0}},{"line":188,"address":[5251447],"length":1,"stats":{"Line":0}},{"line":191,"address":[5408992,5409318,5409352],"length":1,"stats":{"Line":7}},{"line":197,"address":[5409030],"length":1,"stats":{"Line":7}},{"line":198,"address":[5583656],"length":1,"stats":{"Line":7}},{"line":199,"address":[5409152],"length":1,"stats":{"Line":7}},{"line":200,"address":[5706594],"length":1,"stats":{"Line":7}},{"line":204,"address":[5409736,5409698,5409392],"length":1,"stats":{"Line":11}},{"line":212,"address":[20596928,20597088],"length":1,"stats":{"Line":21}},{"line":213,"address":[5584122],"length":1,"stats":{"Line":11}},{"line":219,"address":[5409949,5409955,5409760],"length":1,"stats":{"Line":3}},{"line":220,"address":[5252478,5252609],"length":1,"stats":{"Line":7}},{"line":223,"address":[5410420,5409968],"length":1,"stats":{"Line":0}},{"line":224,"address":[5409983,5410385],"length":1,"stats":{"Line":0}},{"line":227,"address":[5708277,5708305,5707840],"length":1,"stats":{"Line":1}},{"line":228,"address":[20819344,20819532],"length":1,"stats":{"Line":1}},{"line":229,"address":[20597133,20597221],"length":1,"stats":{"Line":3}},{"line":232,"address":[5585713,5585719,5585520],"length":1,"stats":{"Line":1}},{"line":233,"address":[5708366,5708497],"length":1,"stats":{"Line":2}},{"line":236,"address":[2943923,2942464,2942657,2942495,2942614],"length":1,"stats":{"Line":4}},{"line":238,"address":[5856323,5856447],"length":1,"stats":{"Line":2}},{"line":239,"address":[5529626],"length":1,"stats":{"Line":1}},{"line":241,"address":[5856539],"length":1,"stats":{"Line":1}},{"line":245,"address":[5709068,5709183],"length":1,"stats":{"Line":2}},{"line":248,"address":[5529995,5530074],"length":1,"stats":{"Line":2}},{"line":249,"address":[20597377],"length":1,"stats":{"Line":2}},{"line":252,"address":[5857342],"length":1,"stats":{"Line":1}},{"line":254,"address":[5285415],"length":1,"stats":{"Line":3}},{"line":255,"address":[5782659],"length":1,"stats":{"Line":1}},{"line":256,"address":[5531146,5531211,5531324],"length":1,"stats":{"Line":3}},{"line":257,"address":[5782803,5782927],"length":1,"stats":{"Line":0}},{"line":258,"address":[5710758],"length":1,"stats":{"Line":0}},{"line":259,"address":[5858538],"length":1,"stats":{"Line":0}},{"line":260,"address":[5858585],"length":1,"stats":{"Line":0}},{"line":262,"address":[5858627],"length":1,"stats":{"Line":0}},{"line":266,"address":[5710668],"length":1,"stats":{"Line":1}},{"line":268,"address":[2944244],"length":1,"stats":{"Line":0}},{"line":272,"address":[5253888],"length":1,"stats":{"Line":1}},{"line":285,"address":[5711372],"length":1,"stats":{"Line":1}},{"line":286,"address":[5711489],"length":1,"stats":{"Line":1}},{"line":287,"address":[2945444],"length":1,"stats":{"Line":1}},{"line":289,"address":[5412510,5411976,5412103,5412381],"length":1,"stats":{"Line":4}},{"line":292,"address":[5533488,5532323,5533512],"length":1,"stats":{"Line":3}},{"line":293,"address":[5785136],"length":1,"stats":{"Line":0}},{"line":294,"address":[5712955,5712989],"length":1,"stats":{"Line":0}},{"line":296,"address":[5785187],"length":1,"stats":{"Line":0}},{"line":297,"address":[5860677],"length":1,"stats":{"Line":0}},{"line":300,"address":[2946987,2946942],"length":1,"stats":{"Line":0}},{"line":302,"address":[2947832,2947826,2945601,2947280],"length":1,"stats":{"Line":1}},{"line":303,"address":[5713472,5713816],"length":1,"stats":{"Line":0}},{"line":304,"address":[5713767],"length":1,"stats":{"Line":0}},{"line":305,"address":[5413688],"length":1,"stats":{"Line":0}},{"line":308,"address":[2947660],"length":1,"stats":{"Line":0}},{"line":313,"address":[5452039],"length":1,"stats":{"Line":3}},{"line":315,"address":[20749172],"length":1,"stats":{"Line":1}},{"line":316,"address":[5860023],"length":1,"stats":{"Line":0}},{"line":320,"address":[5411296],"length":1,"stats":{"Line":1}},{"line":327,"address":[5414511,5414716],"length":1,"stats":{"Line":2}},{"line":328,"address":[5862433,5862375],"length":1,"stats":{"Line":2}},{"line":330,"address":[5862398,5862296],"length":1,"stats":{"Line":2}},{"line":334,"address":[5787225,5787272,5787122],"length":1,"stats":{"Line":3}},{"line":336,"address":[5862985,5862703],"length":1,"stats":{"Line":2}},{"line":337,"address":[5715381,5715460],"length":1,"stats":{"Line":2}},{"line":340,"address":[5786598,5787903,5788790,5788176,5788031],"length":1,"stats":{"Line":2}},{"line":341,"address":[5789153,5788611,5793194,5789039,5788981,5788723],"length":1,"stats":{"Line":4}},{"line":343,"address":[5416740,5414603,5416680,5416805,5416997],"length":1,"stats":{"Line":3}},{"line":344,"address":[5417105,5424530,5424512],"length":1,"stats":{"Line":0}},{"line":346,"address":[5417244,5417349],"length":1,"stats":{"Line":2}},{"line":347,"address":[5417467,5417375,5421147],"length":1,"stats":{"Line":2}},{"line":349,"address":[5417764,5417819,5417661],"length":1,"stats":{"Line":3}},{"line":351,"address":[2951646,2951306],"length":1,"stats":{"Line":2}},{"line":354,"address":[5790236,5790330],"length":1,"stats":{"Line":2}},{"line":355,"address":[5790523,5790422],"length":1,"stats":{"Line":2}},{"line":356,"address":[5718365],"length":1,"stats":{"Line":1}},{"line":359,"address":[5866315,5866445],"length":1,"stats":{"Line":2}},{"line":361,"address":[5866921],"length":1,"stats":{"Line":1}},{"line":362,"address":[5866456],"length":1,"stats":{"Line":1}},{"line":363,"address":[5419065],"length":1,"stats":{"Line":1}},{"line":364,"address":[2952622],"length":1,"stats":{"Line":1}},{"line":365,"address":[5539691,5539832],"length":1,"stats":{"Line":2}},{"line":366,"address":[5791395],"length":1,"stats":{"Line":1}},{"line":369,"address":[5540070,5540325,5540168],"length":1,"stats":{"Line":3}},{"line":371,"address":[5424689,5424656],"length":1,"stats":{"Line":2}},{"line":375,"address":[5719735],"length":1,"stats":{"Line":1}},{"line":377,"address":[5719910,5719811],"length":1,"stats":{"Line":2}},{"line":381,"address":[5541021,5540573],"length":1,"stats":{"Line":2}},{"line":382,"address":[5720356,5720478],"length":1,"stats":{"Line":2}},{"line":384,"address":[5792708,5792761],"length":1,"stats":{"Line":2}},{"line":385,"address":[5541211],"length":1,"stats":{"Line":1}},{"line":388,"address":[5868913,5869027,5870138,5868366,5868885,5868579,5868496],"length":1,"stats":{"Line":5}},{"line":390,"address":[5792940],"length":1,"stats":{"Line":1}},{"line":391,"address":[5454961],"length":1,"stats":{"Line":3}},{"line":392,"address":[2958519,2954963,2958496],"length":1,"stats":{"Line":0}},{"line":394,"address":[5421671,5422011],"length":1,"stats":{"Line":2}},{"line":395,"address":[5542190],"length":1,"stats":{"Line":1}},{"line":396,"address":[2955219,2955292],"length":1,"stats":{"Line":2}},{"line":397,"address":[5869446,5869358],"length":1,"stats":{"Line":2}},{"line":400,"address":[2955689,2955600],"length":1,"stats":{"Line":2}},{"line":402,"address":[5543506,5542708,5543392,5543082,5543334],"length":1,"stats":{"Line":4}},{"line":404,"address":[5454986],"length":1,"stats":{"Line":3}},{"line":405,"address":[5872722,5872704,5870466],"length":1,"stats":{"Line":0}},{"line":407,"address":[5870599,5870679],"length":1,"stats":{"Line":2}},{"line":409,"address":[5423238],"length":1,"stats":{"Line":1}},{"line":410,"address":[5544152,5543780],"length":1,"stats":{"Line":2}},{"line":412,"address":[5870874,5870730,5870821],"length":1,"stats":{"Line":0}},{"line":415,"address":[2956763],"length":1,"stats":{"Line":1}},{"line":418,"address":[5960320],"length":1,"stats":{"Line":2}},{"line":419,"address":[3570469],"length":1,"stats":{"Line":1}},{"line":422,"address":[5960352],"length":1,"stats":{"Line":1}},{"line":423,"address":[5708864],"length":1,"stats":{"Line":1}},{"line":426,"address":[3570733,3570708,3570560],"length":1,"stats":{"Line":9}},{"line":427,"address":[5708932,5709007],"length":1,"stats":{"Line":20}},{"line":430,"address":[5709104,5709116],"length":1,"stats":{"Line":6}},{"line":432,"address":[2959095,2958937],"length":1,"stats":{"Line":2}},{"line":433,"address":[5873384,5873326],"length":1,"stats":{"Line":2}},{"line":435,"address":[2959179,2959273],"length":1,"stats":{"Line":2}},{"line":439,"address":[20820508,20821306,20819840],"length":1,"stats":{"Line":6}},{"line":440,"address":[20597627],"length":1,"stats":{"Line":6}},{"line":441,"address":[5427441,5427499,5427613,5427089,5427195],"length":1,"stats":{"Line":9}},{"line":443,"address":[5288722],"length":1,"stats":{"Line":8}},{"line":444,"address":[5876160,5876178,5875069],"length":1,"stats":{"Line":0}},{"line":446,"address":[2961313,2961156,2961066,2961190,2961353],"length":1,"stats":{"Line":0}},{"line":452,"address":[5427818,5428231],"length":1,"stats":{"Line":5}},{"line":453,"address":[20820162],"length":1,"stats":{"Line":3}},{"line":456,"address":[5801842,5801020,5800832,5800867,5800983,5801146],"length":1,"stats":{"Line":0}},{"line":457,"address":[5728843,5728786,5728729,5728948,5729624],"length":1,"stats":{"Line":0}},{"line":459,"address":[21065506,21065607,21066343,21065182],"length":1,"stats":{"Line":2}},{"line":461,"address":[5429660],"length":1,"stats":{"Line":0}},{"line":462,"address":[18509916,18508535,18509904],"length":1,"stats":{"Line":0}},{"line":463,"address":[21065707],"length":1,"stats":{"Line":1}},{"line":464,"address":[21065775],"length":1,"stats":{"Line":1}},{"line":465,"address":[21065838],"length":1,"stats":{"Line":1}},{"line":469,"address":[5960688],"length":1,"stats":{"Line":1}},{"line":475,"address":[5802251,5802204,5802068],"length":1,"stats":{"Line":3}},{"line":477,"address":[5803626,5802568,5802210],"length":1,"stats":{"Line":2}},{"line":478,"address":[5878438,5877609,5878166,5879154,5879707,5880701,5878194],"length":1,"stats":{"Line":4}},{"line":480,"address":[5551750,5551885,5551642],"length":1,"stats":{"Line":4}},{"line":481,"address":[20653813],"length":1,"stats":{"Line":4}},{"line":482,"address":[20749461,20750695,20750502,20750567,20750737],"length":1,"stats":{"Line":3}},{"line":487,"address":[5732246],"length":1,"stats":{"Line":1}},{"line":492,"address":[5879188,5879283],"length":1,"stats":{"Line":0}},{"line":495,"address":[5879240],"length":1,"stats":{"Line":0}},{"line":498,"address":[21068385,21068773,21067605,21069184,21067095,21068513,21068009,21069717,21069465,21069062,21069317,21067872,21068645,21069593,21067473,21068263,21067345,21067753,21068137,21068921,21067223],"length":1,"stats":{"Line":4}},{"line":499,"address":[20751622,20752152,20753044,20753531,20753716,20753812,20751571,20753461,20753940,20752611,20751744,20752784,20751494,20752732,20753664,20753583,20751820,20752662,20753120,20753864,20752271,20752536,20753172,20753409,20753320,20752912,20752860,20752004,20751443,20752484,20752992,20752219,20754064,20753268,20752356,20751692,20751952,20752100,20751872,20752408,20754116,20753992],"length":1,"stats":{"Line":2}},{"line":501,"address":[5806279,5806188],"length":1,"stats":{"Line":2}},{"line":502,"address":[5554810,5555682],"length":1,"stats":{"Line":0}},{"line":503,"address":[5734932],"length":1,"stats":{"Line":0}},{"line":504,"address":[5807617,5807172],"length":1,"stats":{"Line":0}},{"line":506,"address":[5807242],"length":1,"stats":{"Line":0}},{"line":507,"address":[5555938,5555738],"length":1,"stats":{"Line":0}},{"line":509,"address":[5882760],"length":1,"stats":{"Line":0}},{"line":511,"address":[5555908,5556300],"length":1,"stats":{"Line":0}},{"line":516,"address":[5434537],"length":1,"stats":{"Line":4}},{"line":521,"address":[5734222],"length":1,"stats":{"Line":1}},{"line":523,"address":[2968149,2968279,2968035,2969698],"length":1,"stats":{"Line":4}},{"line":524,"address":[5437005,5436859,5437096,5436891,5436636],"length":1,"stats":{"Line":0}},{"line":532,"address":[5808889],"length":1,"stats":{"Line":1}},{"line":534,"address":[5558248,5557898],"length":1,"stats":{"Line":2}},{"line":535,"address":[5809656,5809496,5809633],"length":1,"stats":{"Line":2}},{"line":537,"address":[5737554,5737291,5737772],"length":1,"stats":{"Line":3}},{"line":538,"address":[5885258,5885318,5885341],"length":1,"stats":{"Line":2}},{"line":540,"address":[5885277,5885473,5885499],"length":1,"stats":{"Line":2}},{"line":541,"address":[5738253,5737936],"length":1,"stats":{"Line":2}},{"line":542,"address":[5558798,5558824,5558718],"length":1,"stats":{"Line":2}},{"line":544,"address":[5738033],"length":1,"stats":{"Line":1}},{"line":546,"address":[5810284,5810524],"length":1,"stats":{"Line":2}},{"line":552,"address":[5554031,5559277,5556615,5559173],"length":1,"stats":{"Line":2}},{"line":553,"address":[2972305],"length":1,"stats":{"Line":1}},{"line":554,"address":[5739028],"length":1,"stats":{"Line":1}},{"line":556,"address":[2972374,2972581],"length":1,"stats":{"Line":2}},{"line":558,"address":[5439289],"length":1,"stats":{"Line":1}},{"line":559,"address":[5559817],"length":1,"stats":{"Line":1}},{"line":560,"address":[5811422],"length":1,"stats":{"Line":1}},{"line":563,"address":[2972713],"length":1,"stats":{"Line":1}},{"line":564,"address":[5739512],"length":1,"stats":{"Line":1}},{"line":566,"address":[5811859,5811781],"length":1,"stats":{"Line":0}},{"line":567,"address":[2972842],"length":1,"stats":{"Line":0}},{"line":569,"address":[5439816,5433556,5439876,5436156,5436190],"length":1,"stats":{"Line":0}},{"line":573,"address":[5808700],"length":1,"stats":{"Line":1}},{"line":576,"address":[5709312],"length":1,"stats":{"Line":1}},{"line":588,"address":[5560824],"length":1,"stats":{"Line":1}},{"line":589,"address":[2973512],"length":1,"stats":{"Line":1}},{"line":591,"address":[5740517,5740785,5740925,5740391],"length":1,"stats":{"Line":4}},{"line":594,"address":[5890404,5887994,5890384],"length":1,"stats":{"Line":3}},{"line":595,"address":[2975920],"length":1,"stats":{"Line":0}},{"line":596,"address":[5742813,5742779],"length":1,"stats":{"Line":0}},{"line":597,"address":[20616091,20616080],"length":1,"stats":{"Line":0}},{"line":598,"address":[5890483],"length":1,"stats":{"Line":0}},{"line":599,"address":[21083317],"length":1,"stats":{"Line":0}},{"line":602,"address":[5742911,5742956],"length":1,"stats":{"Line":0}},{"line":604,"address":[2973625,2976432,2976942,2976936],"length":1,"stats":{"Line":1}},{"line":605,"address":[5815822,5815520],"length":1,"stats":{"Line":0}},{"line":606,"address":[5443757],"length":1,"stats":{"Line":0}},{"line":607,"address":[5891000],"length":1,"stats":{"Line":0}},{"line":613,"address":[5564294],"length":1,"stats":{"Line":0}},{"line":618,"address":[6006679],"length":1,"stats":{"Line":3}},{"line":620,"address":[5441175,5441310,5441391],"length":1,"stats":{"Line":3}},{"line":621,"address":[5888676],"length":1,"stats":{"Line":1}},{"line":622,"address":[5888687],"length":1,"stats":{"Line":1}},{"line":623,"address":[5741017],"length":1,"stats":{"Line":1}},{"line":624,"address":[20824832],"length":1,"stats":{"Line":2}},{"line":626,"address":[18512806],"length":1,"stats":{"Line":1}},{"line":628,"address":[2974591,2974717],"length":1,"stats":{"Line":0}},{"line":629,"address":[5889332],"length":1,"stats":{"Line":0}},{"line":630,"address":[2974883],"length":1,"stats":{"Line":0}},{"line":632,"address":[5889889,5889090,5889812],"length":1,"stats":{"Line":0}},{"line":633,"address":[20657632,20657637],"length":1,"stats":{"Line":0}},{"line":634,"address":[5442193,5441639],"length":1,"stats":{"Line":0}},{"line":635,"address":[20657617],"length":1,"stats":{"Line":0}},{"line":636,"address":[20754270],"length":1,"stats":{"Line":0}},{"line":641,"address":[21069954],"length":1,"stats":{"Line":4}},{"line":642,"address":[5744085,5743944],"length":1,"stats":{"Line":2}},{"line":643,"address":[6003879],"length":1,"stats":{"Line":1}},{"line":644,"address":[5444686,5444771],"length":1,"stats":{"Line":2}},{"line":646,"address":[5444824],"length":1,"stats":{"Line":1}},{"line":647,"address":[5892395],"length":1,"stats":{"Line":1}},{"line":648,"address":[5744818,5744720],"length":1,"stats":{"Line":2}},{"line":649,"address":[5744737],"length":1,"stats":{"Line":1}},{"line":650,"address":[2977901],"length":1,"stats":{"Line":1}},{"line":651,"address":[2977917],"length":1,"stats":{"Line":1}},{"line":655,"address":[5744652],"length":1,"stats":{"Line":0}},{"line":656,"address":[5445393,5444868],"length":1,"stats":{"Line":0}},{"line":657,"address":[2977817],"length":1,"stats":{"Line":0}},{"line":659,"address":[2978201,2978248],"length":1,"stats":{"Line":0}},{"line":665,"address":[5817139],"length":1,"stats":{"Line":1}},{"line":668,"address":[5445565,5445488,5445745,5446816,5445830],"length":1,"stats":{"Line":4}},{"line":670,"address":[5893192,5893376],"length":1,"stats":{"Line":2}},{"line":671,"address":[5745851,5745909],"length":1,"stats":{"Line":2}},{"line":673,"address":[5566476,5566578],"length":1,"stats":{"Line":2}},{"line":677,"address":[5893869,5893766,5893931],"length":1,"stats":{"Line":3}},{"line":678,"address":[5458978],"length":1,"stats":{"Line":2}},{"line":680,"address":[2980112,2980217],"length":1,"stats":{"Line":2}},{"line":681,"address":[5898716,5894971,5894879],"length":1,"stats":{"Line":2}},{"line":683,"address":[5895330,5895165,5895268],"length":1,"stats":{"Line":3}},{"line":685,"address":[5819802,5820118],"length":1,"stats":{"Line":2}},{"line":687,"address":[2980961,2981100,2981057],"length":1,"stats":{"Line":3}},{"line":693,"address":[2981461,2981063],"length":1,"stats":{"Line":2}},{"line":694,"address":[5569309,5569337,5569213],"length":1,"stats":{"Line":3}},{"line":697,"address":[5896687,5896791],"length":1,"stats":{"Line":2}},{"line":700,"address":[5749299,5749205],"length":1,"stats":{"Line":2}},{"line":701,"address":[5821716,5821615],"length":1,"stats":{"Line":2}},{"line":702,"address":[5570262],"length":1,"stats":{"Line":1}},{"line":705,"address":[5450020,5450150],"length":1,"stats":{"Line":2}},{"line":707,"address":[5750175,5749953,5750026],"length":1,"stats":{"Line":3}},{"line":709,"address":[5901424,5901470],"length":1,"stats":{"Line":2}},{"line":713,"address":[5450497],"length":1,"stats":{"Line":1}},{"line":715,"address":[5750365],"length":1,"stats":{"Line":1}},{"line":716,"address":[5898262,5898147],"length":1,"stats":{"Line":2}},{"line":718,"address":[2983521,2983567],"length":1,"stats":{"Line":2}},{"line":719,"address":[5822827],"length":1,"stats":{"Line":1}},{"line":722,"address":[5750751,5750964,5750881,5751270,5751298,5751412,5752510],"length":1,"stats":{"Line":5}},{"line":724,"address":[5898493],"length":1,"stats":{"Line":1}},{"line":725,"address":[6009864],"length":1,"stats":{"Line":3}},{"line":726,"address":[5826418,5823604,5826400],"length":1,"stats":{"Line":0}},{"line":728,"address":[5824095,5823762],"length":1,"stats":{"Line":2}},{"line":729,"address":[5572273],"length":1,"stats":{"Line":1}},{"line":730,"address":[5899323,5899400],"length":1,"stats":{"Line":2}},{"line":731,"address":[2984739,2984655],"length":1,"stats":{"Line":2}},{"line":734,"address":[5899805,5899716],"length":1,"stats":{"Line":2}},{"line":736,"address":[2985764,2985359,2985600,2985674,2984989],"length":1,"stats":{"Line":4}},{"line":738,"address":[5445817,5452687,5452627,5452742,5452931],"length":1,"stats":{"Line":3}},{"line":739,"address":[5573535,5575042,5575024],"length":1,"stats":{"Line":0}},{"line":741,"address":[5453180,5453261],"length":1,"stats":{"Line":2}},{"line":743,"address":[5753121],"length":1,"stats":{"Line":1}},{"line":746,"address":[5454836,5454722,5455014,5454891,5455652,5454672],"length":1,"stats":{"Line":4}},{"line":747,"address":[6003999],"length":1,"stats":{"Line":2}},{"line":748,"address":[2988440,2988511,2988155,2988055,2988601],"length":1,"stats":{"Line":4}},{"line":750,"address":[5453154],"length":1,"stats":{"Line":3}},{"line":751,"address":[2989255,2988569,2989232],"length":1,"stats":{"Line":0}},{"line":753,"address":[5828176,5828086,5828281],"length":1,"stats":{"Line":3}},{"line":754,"address":[5456166],"length":1,"stats":{"Line":1}},{"line":757,"address":[5961008],"length":1,"stats":{"Line":1}},{"line":762,"address":[5904501,5904712,5904756],"length":1,"stats":{"Line":4}},{"line":765,"address":[5829623,5829246],"length":1,"stats":{"Line":3}},{"line":766,"address":[5578332,5578382,5578483,5578274],"length":1,"stats":{"Line":4}},{"line":768,"address":[5457699],"length":1,"stats":{"Line":2}},{"line":769,"address":[5578297],"length":1,"stats":{"Line":2}},{"line":770,"address":[5457855],"length":1,"stats":{"Line":2}},{"line":771,"address":[5757749],"length":1,"stats":{"Line":2}},{"line":775,"address":[5905852,5905752,5905908],"length":1,"stats":{"Line":5}},{"line":777,"address":[5459826],"length":1,"stats":{"Line":4}},{"line":778,"address":[2992407,2991876,2994062,2992317,2991988,2992243],"length":1,"stats":{"Line":4}},{"line":780,"address":[5633880],"length":1,"stats":{"Line":3}},{"line":781,"address":[5907307,5914560,5914578],"length":1,"stats":{"Line":0}},{"line":783,"address":[5907551,5907446],"length":1,"stats":{"Line":2}},{"line":785,"address":[2992641],"length":1,"stats":{"Line":1}},{"line":786,"address":[5460181],"length":1,"stats":{"Line":1}},{"line":787,"address":[5832280],"length":1,"stats":{"Line":1}},{"line":789,"address":[5832339,5832431,5832518,5832298,5833527],"length":1,"stats":{"Line":3}},{"line":790,"address":[5580790],"length":1,"stats":{"Line":1}},{"line":791,"address":[5907792],"length":1,"stats":{"Line":1}},{"line":792,"address":[5580807],"length":1,"stats":{"Line":1}},{"line":793,"address":[5760111],"length":1,"stats":{"Line":1}},{"line":795,"address":[5581114],"length":1,"stats":{"Line":1}},{"line":797,"address":[5760711],"length":1,"stats":{"Line":0}},{"line":802,"address":[5581671,5581303],"length":1,"stats":{"Line":2}},{"line":803,"address":[2993861,2993766],"length":1,"stats":{"Line":2}},{"line":804,"address":[2993986],"length":1,"stats":{"Line":1}},{"line":806,"address":[5761284,5763639],"length":1,"stats":{"Line":2}},{"line":808,"address":[2996333,2997573],"length":1,"stats":{"Line":2}},{"line":809,"address":[5765066,5765118,5765269,5765168],"length":1,"stats":{"Line":4}},{"line":811,"address":[5764993],"length":1,"stats":{"Line":1}},{"line":812,"address":[5837313],"length":1,"stats":{"Line":1}},{"line":813,"address":[5765137],"length":1,"stats":{"Line":1}},{"line":814,"address":[5765239],"length":1,"stats":{"Line":1}},{"line":818,"address":[5586303,5586399],"length":1,"stats":{"Line":2}},{"line":820,"address":[5838807,5837875,5838207,5829149,5838291,5833601],"length":1,"stats":{"Line":3}},{"line":821,"address":[5466916,5466753,5462039,5461925,5466692,5461816],"length":1,"stats":{"Line":6}},{"line":823,"address":[2999174,2994160,2994352,2989778,2994126,2999114],"length":1,"stats":{"Line":7}},{"line":824,"address":[5467216,5467234,5462007],"length":1,"stats":{"Line":0}},{"line":826,"address":[5462231,5462148],"length":1,"stats":{"Line":4}},{"line":828,"address":[2994941,2994742,2994773,2994874],"length":1,"stats":{"Line":4}},{"line":830,"address":[5834278],"length":1,"stats":{"Line":2}},{"line":831,"address":[5582765],"length":1,"stats":{"Line":1}},{"line":832,"address":[2994769],"length":1,"stats":{"Line":1}},{"line":835,"address":[5910054,5910137],"length":1,"stats":{"Line":4}},{"line":836,"address":[5462657],"length":1,"stats":{"Line":2}},{"line":837,"address":[5834754],"length":1,"stats":{"Line":2}},{"line":839,"address":[5762601],"length":1,"stats":{"Line":2}},{"line":841,"address":[5910703,5910734],"length":1,"stats":{"Line":0}},{"line":851,"address":[5911116,5911157,5910529],"length":1,"stats":{"Line":4}},{"line":854,"address":[5584310,5584418],"length":1,"stats":{"Line":4}},{"line":855,"address":[5584469,5585309],"length":1,"stats":{"Line":0}},{"line":860,"address":[2996679],"length":1,"stats":{"Line":9}},{"line":865,"address":[5464020],"length":1,"stats":{"Line":3}},{"line":868,"address":[5965776,5961072,5964674],"length":1,"stats":{"Line":1}},{"line":875,"address":[5961175],"length":1,"stats":{"Line":1}},{"line":876,"address":[5255040,5255112],"length":1,"stats":{"Line":2}},{"line":878,"address":[2999728],"length":1,"stats":{"Line":3}},{"line":879,"address":[2999742],"length":1,"stats":{"Line":0}},{"line":882,"address":[5412855],"length":1,"stats":{"Line":1}},{"line":883,"address":[5962051,5961848,5961927],"length":1,"stats":{"Line":3}},{"line":884,"address":[5256081,5255887],"length":1,"stats":{"Line":2}},{"line":885,"address":[3572451,3572530],"length":1,"stats":{"Line":2}},{"line":886,"address":[5965496,5965422],"length":1,"stats":{"Line":0}},{"line":890,"address":[3572674],"length":1,"stats":{"Line":1}},{"line":891,"address":[5962663,5962742,5965184,5962813],"length":1,"stats":{"Line":4}},{"line":892,"address":[5468053,5467456,5468047],"length":1,"stats":{"Line":2}},{"line":893,"address":[5587992],"length":1,"stats":{"Line":1}},{"line":894,"address":[3000180,3000280],"length":1,"stats":{"Line":2}},{"line":896,"address":[5588577,5588576],"length":1,"stats":{"Line":2}},{"line":897,"address":[5588646,5588624],"length":1,"stats":{"Line":2}},{"line":900,"address":[5711426,5711369],"length":1,"stats":{"Line":2}},{"line":901,"address":[5414145,5414069],"length":1,"stats":{"Line":2}},{"line":902,"address":[3573261,3573172],"length":1,"stats":{"Line":2}},{"line":903,"address":[5767985,5767968],"length":1,"stats":{"Line":4}},{"line":905,"address":[5711803,5711879],"length":1,"stats":{"Line":2}},{"line":907,"address":[5589212,5589168,5589106],"length":1,"stats":{"Line":3}},{"line":908,"address":[5257351],"length":1,"stats":{"Line":1}},{"line":909,"address":[5257521],"length":1,"stats":{"Line":1}},{"line":910,"address":[3573859,3573929],"length":1,"stats":{"Line":1}},{"line":911,"address":[5414941],"length":1,"stats":{"Line":0}},{"line":913,"address":[5589494,5589547],"length":1,"stats":{"Line":2}},{"line":916,"address":[5963963],"length":1,"stats":{"Line":1}},{"line":918,"address":[5257774,5257846],"length":1,"stats":{"Line":2}},{"line":919,"address":[3574142,3574210],"length":1,"stats":{"Line":2}},{"line":920,"address":[5257930,5257995],"length":1,"stats":{"Line":2}},{"line":921,"address":[3574291],"length":1,"stats":{"Line":1}},{"line":922,"address":[5415385],"length":1,"stats":{"Line":1}},{"line":923,"address":[5415425],"length":1,"stats":{"Line":1}},{"line":924,"address":[5712857],"length":1,"stats":{"Line":1}},{"line":925,"address":[5415505],"length":1,"stats":{"Line":1}},{"line":929,"address":[5713093],"length":1,"stats":{"Line":1}},{"line":931,"address":[5964728,5964025],"length":1,"stats":{"Line":0}},{"line":940,"address":[5413260],"length":1,"stats":{"Line":1}},{"line":943,"address":[5915712,5915924,5917236,5915774,5915988],"length":1,"stats":{"Line":6}},{"line":945,"address":[3000911,3000753],"length":1,"stats":{"Line":2}},{"line":946,"address":[5589222,5589280,5589330],"length":1,"stats":{"Line":3}},{"line":948,"address":[5589143],"length":1,"stats":{"Line":1}},{"line":949,"address":[5468749],"length":1,"stats":{"Line":1}},{"line":950,"address":[5468803],"length":1,"stats":{"Line":1}},{"line":955,"address":[5469282,5469126,5469226],"length":1,"stats":{"Line":3}},{"line":956,"address":[6009039],"length":1,"stats":{"Line":2}},{"line":957,"address":[5470549,5470191,5470607,5470721,5470297],"length":1,"stats":{"Line":4}},{"line":959,"address":[5290818],"length":1,"stats":{"Line":3}},{"line":960,"address":[5842705,5844098,5844080],"length":1,"stats":{"Line":0}},{"line":962,"address":[5770897],"length":1,"stats":{"Line":0}},{"line":968,"address":[5770710,5771142,5771176],"length":1,"stats":{"Line":3}},{"line":969,"address":[5471609,5471364],"length":1,"stats":{"Line":2}},{"line":970,"address":[5471628],"length":1,"stats":{"Line":1}},{"line":973,"address":[5259632],"length":1,"stats":{"Line":0}},{"line":979,"address":[5416991],"length":1,"stats":{"Line":0}},{"line":983,"address":[5965936],"length":1,"stats":{"Line":0}},{"line":990,"address":[5259768],"length":1,"stats":{"Line":0}},{"line":994,"address":[5966032],"length":1,"stats":{"Line":0}},{"line":995,"address":[5259829],"length":1,"stats":{"Line":0}},{"line":998,"address":[3576144,3576538,3576544],"length":1,"stats":{"Line":1}},{"line":999,"address":[5417206],"length":1,"stats":{"Line":1}},{"line":1001,"address":[5714660,5714865,5714793,5714725],"length":1,"stats":{"Line":4}},{"line":1004,"address":[5592705,5592704],"length":1,"stats":{"Line":2}},{"line":1005,"address":[3004550,3004528],"length":1,"stats":{"Line":2}},{"line":1006,"address":[5592037],"length":1,"stats":{"Line":1}},{"line":1009,"address":[5592967,5593004,5592800,5593123,5593388,5592850],"length":1,"stats":{"Line":9}},{"line":1010,"address":[5472498,5472653,5472555,5472452],"length":1,"stats":{"Line":5}},{"line":1013,"address":[5260336,5260354],"length":1,"stats":{"Line":10}},{"line":1014,"address":[5920563],"length":1,"stats":{"Line":3}},{"line":1016,"address":[5845200],"length":1,"stats":{"Line":2}},{"line":1017,"address":[3005460],"length":1,"stats":{"Line":3}},{"line":1020,"address":[21070272,21070048,21070089,21070003,21071064,21071466],"length":1,"stats":{"Line":0}},{"line":1021,"address":[5473360,5473284],"length":1,"stats":{"Line":7}},{"line":1022,"address":[3005801,3006664,3007107,3006656,3007831,3006874,3006938,3006688,3006750],"length":1,"stats":{"Line":21}},{"line":1023,"address":[5474712,5475627,5474620,5474817,5474953],"length":1,"stats":{"Line":12}},{"line":1025,"address":[5475846,5475904,5475991,5477567,5475376,5475514,5475560],"length":1,"stats":{"Line":31}},{"line":1026,"address":[18513411,18513532],"length":1,"stats":{"Line":19}},{"line":1027,"address":[3352446],"length":1,"stats":{"Line":19}},{"line":1029,"address":[3008228,3008386,3008308],"length":1,"stats":{"Line":3}},{"line":1030,"address":[5597693,5596835,5597789],"length":1,"stats":{"Line":3}},{"line":1031,"address":[5597699],"length":1,"stats":{"Line":1}},{"line":1034,"address":[18513627],"length":1,"stats":{"Line":5}},{"line":1035,"address":[3008538,3008613],"length":1,"stats":{"Line":3}},{"line":1036,"address":[20754683,20755206,20755480,20755358],"length":1,"stats":{"Line":5}},{"line":1037,"address":[21070037,21071356,21071494,21070312,21071305,21070923],"length":1,"stats":{"Line":1}},{"line":1040,"address":[5848699],"length":1,"stats":{"Line":4}},{"line":1042,"address":[5476793],"length":1,"stats":{"Line":1}},{"line":1044,"address":[5925072],"length":1,"stats":{"Line":1}},{"line":1045,"address":[5598157,5598123],"length":1,"stats":{"Line":2}},{"line":1047,"address":[5925123],"length":1,"stats":{"Line":1}},{"line":1048,"address":[5777445],"length":1,"stats":{"Line":1}},{"line":1051,"address":[20826723,20826794],"length":1,"stats":{"Line":2}},{"line":1053,"address":[5850112],"length":1,"stats":{"Line":1}},{"line":1054,"address":[5925628,5925683],"length":1,"stats":{"Line":2}},{"line":1055,"address":[5777940],"length":1,"stats":{"Line":1}},{"line":1056,"address":[3010298],"length":1,"stats":{"Line":1}},{"line":1061,"address":[20605422,20605315],"length":1,"stats":{"Line":19}},{"line":1063,"address":[3006456],"length":1,"stats":{"Line":2}},{"line":1066,"address":[5715088,5715111],"length":1,"stats":{"Line":22}},{"line":1067,"address":[5778333],"length":1,"stats":{"Line":6}},{"line":1068,"address":[3010779,3012712],"length":1,"stats":{"Line":0}},{"line":1071,"address":[5478743,5478624],"length":1,"stats":{"Line":12}},{"line":1074,"address":[5599421,5599327],"length":1,"stats":{"Line":13}},{"line":1075,"address":[3011113,3011204],"length":1,"stats":{"Line":13}},{"line":1076,"address":[20757578],"length":1,"stats":{"Line":7}},{"line":1077,"address":[5851349],"length":1,"stats":{"Line":0}},{"line":1081,"address":[5779422],"length":1,"stats":{"Line":7}},{"line":1082,"address":[3012058,3011839,3011768],"length":1,"stats":{"Line":18}},{"line":1083,"address":[5600356,5600261],"length":1,"stats":{"Line":16}},{"line":1085,"address":[5479751],"length":1,"stats":{"Line":1}},{"line":1088,"address":[5600308],"length":1,"stats":{"Line":7}},{"line":1090,"address":[5479991],"length":1,"stats":{"Line":2}},{"line":1091,"address":[21073994],"length":1,"stats":{"Line":20}},{"line":1093,"address":[5852214,5852168],"length":1,"stats":{"Line":22}},{"line":1094,"address":[5779975],"length":1,"stats":{"Line":9}},{"line":1097,"address":[5601701,5600954,5601559,5600827,5608074,5601037,5601587],"length":1,"stats":{"Line":38}},{"line":1099,"address":[5780169],"length":1,"stats":{"Line":9}},{"line":1100,"address":[5627394],"length":1,"stats":{"Line":21}},{"line":1101,"address":[5787728,5787746,5780965],"length":1,"stats":{"Line":3}},{"line":1103,"address":[18516386,18519771,18517086],"length":1,"stats":{"Line":20}},{"line":1104,"address":[20664566,20662004],"length":1,"stats":{"Line":8}},{"line":1105,"address":[5853442,5853525],"length":1,"stats":{"Line":18}},{"line":1106,"address":[5602034,5602134],"length":1,"stats":{"Line":18}},{"line":1109,"address":[5929337],"length":1,"stats":{"Line":8}},{"line":1111,"address":[5481882,5482066],"length":1,"stats":{"Line":16}},{"line":1112,"address":[3014182,3014040],"length":1,"stats":{"Line":2}},{"line":1113,"address":[5854229],"length":1,"stats":{"Line":1}},{"line":1114,"address":[5602799],"length":1,"stats":{"Line":1}},{"line":1115,"address":[5602879],"length":1,"stats":{"Line":1}},{"line":1116,"address":[20759137],"length":1,"stats":{"Line":2}},{"line":1118,"address":[5603447,5603044],"length":1,"stats":{"Line":2}},{"line":1119,"address":[20832048,20832057],"length":1,"stats":{"Line":0}},{"line":1120,"address":[20761492,20761472],"length":1,"stats":{"Line":0}},{"line":1121,"address":[5932038],"length":1,"stats":{"Line":0}},{"line":1126,"address":[5855031,5854458],"length":1,"stats":{"Line":2}},{"line":1127,"address":[5931297,5930561],"length":1,"stats":{"Line":2}},{"line":1128,"address":[5604562],"length":1,"stats":{"Line":1}},{"line":1129,"address":[5931738,5931510,5930609,5930509],"length":1,"stats":{"Line":1}},{"line":1130,"address":[3015187,3015799],"length":1,"stats":{"Line":0}},{"line":1132,"address":[3015449,3015147,3015251],"length":1,"stats":{"Line":0}},{"line":1140,"address":[3015540],"length":1,"stats":{"Line":0}},{"line":1143,"address":[3016453,3019688,3016407],"length":1,"stats":{"Line":3}},{"line":1144,"address":[5783535,5784115],"length":1,"stats":{"Line":2}},{"line":1146,"address":[5850627,5856516,5859618,5859846,5856474],"length":1,"stats":{"Line":3}},{"line":1151,"address":[5482120,5485012],"length":1,"stats":{"Line":17}},{"line":1152,"address":[5857124,5858894],"length":1,"stats":{"Line":0}},{"line":1154,"address":[5787872,5787881],"length":1,"stats":{"Line":0}},{"line":1155,"address":[21076483,21076015],"length":1,"stats":{"Line":0}},{"line":1157,"address":[5934797,5934452],"length":1,"stats":{"Line":0}},{"line":1158,"address":[20663908,20664206,20663713],"length":1,"stats":{"Line":0}},{"line":1159,"address":[5934480],"length":1,"stats":{"Line":0}},{"line":1160,"address":[18519218],"length":1,"stats":{"Line":0}},{"line":1161,"address":[21072239,21076416,21076464,21073744,21076852,21071741,21071644,21076778,21072326,21075540,21076740],"length":1,"stats":{"Line":0}},{"line":1166,"address":[5787269],"length":1,"stats":{"Line":0}},{"line":1169,"address":[5856998,5857290],"length":1,"stats":{"Line":18}},{"line":1170,"address":[20761744,20761946],"length":1,"stats":{"Line":0}},{"line":1172,"address":[5606209,5605927],"length":1,"stats":{"Line":0}},{"line":1173,"address":[21077943,21077641,21077711],"length":1,"stats":{"Line":0}},{"line":1174,"address":[5606536,5606489,5606415],"length":1,"stats":{"Line":0}},{"line":1175,"address":[5934081,5933487],"length":1,"stats":{"Line":0}},{"line":1176,"address":[20762362,20763557,20762186,20762052,20762160],"length":1,"stats":{"Line":0}},{"line":1177,"address":[5606769,5606526],"length":1,"stats":{"Line":0}},{"line":1178,"address":[5933857],"length":1,"stats":{"Line":0}},{"line":1179,"address":[5606873,5606958],"length":1,"stats":{"Line":0}},{"line":1180,"address":[20832994],"length":1,"stats":{"Line":0}},{"line":1184,"address":[5786552],"length":1,"stats":{"Line":0}},{"line":1189,"address":[5857173],"length":1,"stats":{"Line":10}},{"line":1192,"address":[5716297,5715152,5716840],"length":1,"stats":{"Line":1}},{"line":1193,"address":[5715207],"length":1,"stats":{"Line":3}},{"line":1195,"address":[5592399],"length":1,"stats":{"Line":1}},{"line":1196,"address":[5592499],"length":1,"stats":{"Line":0}},{"line":1199,"address":[5260555],"length":1,"stats":{"Line":3}},{"line":1201,"address":[3576968,3576852],"length":1,"stats":{"Line":5}},{"line":1202,"address":[5715514,5716329],"length":1,"stats":{"Line":0}},{"line":1203,"address":[5716511,5716576],"length":1,"stats":{"Line":0}},{"line":1204,"address":[5968083],"length":1,"stats":{"Line":0}},{"line":1208,"address":[5715548],"length":1,"stats":{"Line":3}},{"line":1209,"address":[3577157],"length":1,"stats":{"Line":3}},{"line":1210,"address":[5592926],"length":1,"stats":{"Line":4}},{"line":1211,"address":[3577372,3577451],"length":1,"stats":{"Line":4}},{"line":1212,"address":[3577494,3577576],"length":1,"stats":{"Line":2}},{"line":1213,"address":[20764653],"length":1,"stats":{"Line":1}},{"line":1218,"address":[20835483],"length":1,"stats":{"Line":1}},{"line":1221,"address":[5968565,5968384,5968571],"length":1,"stats":{"Line":10}},{"line":1222,"address":[20668253],"length":1,"stats":{"Line":8}},{"line":1223,"address":[5594135,5594198],"length":1,"stats":{"Line":18}},{"line":1226,"address":[5717072,5717095],"length":1,"stats":{"Line":38}},{"line":1227,"address":[5935814,5935941,5936156,5936304,5936517,5936208],"length":1,"stats":{"Line":24}},{"line":1229,"address":[5756583],"length":1,"stats":{"Line":23}},{"line":1230,"address":[3020670,3020928,3020951],"length":1,"stats":{"Line":0}},{"line":1232,"address":[5788684],"length":1,"stats":{"Line":1}},{"line":1235,"address":[5788976,5789038,5790283,5789164,5789228],"length":1,"stats":{"Line":4}},{"line":1236,"address":[21077231],"length":1,"stats":{"Line":0}},{"line":1237,"address":[5609833,5609987],"length":1,"stats":{"Line":2}},{"line":1238,"address":[5861678,5861736],"length":1,"stats":{"Line":2}},{"line":1240,"address":[5610181,5610079],"length":1,"stats":{"Line":2}},{"line":1244,"address":[5610577,5610421,5610521],"length":1,"stats":{"Line":3}},{"line":1245,"address":[5790893,5790179,5790315,5789194,5789823],"length":1,"stats":{"Line":2}},{"line":1246,"address":[3022759,3023281,3023191,3023117,3022865],"length":1,"stats":{"Line":4}},{"line":1248,"address":[5789215,5791113,5790862,5790921,5790802],"length":1,"stats":{"Line":4}},{"line":1249,"address":[5864768,5863445,5864786],"length":1,"stats":{"Line":0}},{"line":1251,"address":[5491562,5491652,5491870,5491810,5491703],"length":1,"stats":{"Line":0}},{"line":1257,"address":[3023902,3023474,3023936],"length":1,"stats":{"Line":3}},{"line":1258,"address":[18523984,18524014,18523945],"length":1,"stats":{"Line":2}},{"line":1259,"address":[20668766],"length":1,"stats":{"Line":1}},{"line":1262,"address":[5864912,5865188,5864974,5866427,5865124],"length":1,"stats":{"Line":7}},{"line":1264,"address":[3025039,3024881],"length":1,"stats":{"Line":2}},{"line":1265,"address":[5613952,5614002,5613894],"length":1,"stats":{"Line":3}},{"line":1267,"address":[18524231],"length":1,"stats":{"Line":1}},{"line":1268,"address":[5493421],"length":1,"stats":{"Line":1}},{"line":1269,"address":[5865491],"length":1,"stats":{"Line":1}},{"line":1274,"address":[5941386,5941442,5941286],"length":1,"stats":{"Line":3}},{"line":1275,"address":[5457903],"length":1,"stats":{"Line":2}},{"line":1276,"address":[5495381,5495267,5495209,5494957,5494851],"length":1,"stats":{"Line":5}},{"line":1278,"address":[3345070],"length":1,"stats":{"Line":4}},{"line":1279,"address":[5868722,5867365,5868704],"length":1,"stats":{"Line":0}},{"line":1281,"address":[3027308,3027359,3027482,3027522,3027218],"length":1,"stats":{"Line":3}},{"line":1287,"address":[5616506,5616540,5616074],"length":1,"stats":{"Line":4}},{"line":1288,"address":[3027756,3027999],"length":1,"stats":{"Line":2}},{"line":1289,"address":[18524343],"length":1,"stats":{"Line":1}},{"line":1292,"address":[5262496],"length":1,"stats":{"Line":1}},{"line":1299,"address":[20614285,20614343],"length":1,"stats":{"Line":2}},{"line":1300,"address":[18524574,18524623],"length":1,"stats":{"Line":4}},{"line":1302,"address":[3029018],"length":1,"stats":{"Line":1}},{"line":1303,"address":[5617892],"length":1,"stats":{"Line":1}},{"line":1304,"address":[3029154],"length":1,"stats":{"Line":1}},{"line":1305,"address":[20766156,20766210],"length":1,"stats":{"Line":1}},{"line":1310,"address":[18524806],"length":1,"stats":{"Line":3}},{"line":1311,"address":[5619021,5618528,5618965],"length":1,"stats":{"Line":3}},{"line":1313,"address":[5756703],"length":1,"stats":{"Line":5}},{"line":1314,"address":[5799561,5799733,5799197,5799619,5799303,5804523],"length":1,"stats":{"Line":7}},{"line":1316,"address":[20765913,20766420],"length":1,"stats":{"Line":5}},{"line":1317,"address":[5947397,5952242,5952224],"length":1,"stats":{"Line":0}},{"line":1319,"address":[5947805,5947530,5947626,5947680,5947871],"length":1,"stats":{"Line":0}},{"line":1325,"address":[5620640,5621148,5621108],"length":1,"stats":{"Line":4}},{"line":1326,"address":[5872642,5872917],"length":1,"stats":{"Line":3}},{"line":1327,"address":[5500971,5500936,5500920,5501164,5501068],"length":1,"stats":{"Line":4}},{"line":1329,"address":[5872948,5873148,5872956],"length":1,"stats":{"Line":2}},{"line":1332,"address":[5801089,5801166],"length":1,"stats":{"Line":3}},{"line":1333,"address":[5801865,5802003,5801225],"length":1,"stats":{"Line":0}},{"line":1334,"address":[5876188,5874163],"length":1,"stats":{"Line":0}},{"line":1335,"address":[3033875,3034052],"length":1,"stats":{"Line":0}},{"line":1336,"address":[3035441,3033988],"length":1,"stats":{"Line":0}},{"line":1338,"address":[5502482,5502588],"length":1,"stats":{"Line":0}},{"line":1341,"address":[5802823,5802332,5802769],"length":1,"stats":{"Line":0}},{"line":1342,"address":[3035060],"length":1,"stats":{"Line":0}},{"line":1348,"address":[5949078,5949202,5948868,5948954],"length":1,"stats":{"Line":5}},{"line":1354,"address":[5621968],"length":1,"stats":{"Line":2}},{"line":1357,"address":[5806175,5804672,5804884,5804734,5804948],"length":1,"stats":{"Line":4}},{"line":1359,"address":[3036831,3036673],"length":1,"stats":{"Line":2}},{"line":1360,"address":[5805232,5805174,5805313],"length":1,"stats":{"Line":3}},{"line":1362,"address":[3036915],"length":1,"stats":{"Line":1}},{"line":1363,"address":[5952893],"length":1,"stats":{"Line":1}},{"line":1365,"address":[3037082],"length":1,"stats":{"Line":1}},{"line":1369,"address":[5877798,5877954,5877898],"length":1,"stats":{"Line":3}},{"line":1370,"address":[5953903,5954481,5953376,5952610,5953767],"length":1,"stats":{"Line":2}},{"line":1371,"address":[3038901,3040433,3038811,3038379,3038485,3038737],"length":1,"stats":{"Line":4}},{"line":1373,"address":[5627458,5627398,5625639,5627709,5627517],"length":1,"stats":{"Line":3}},{"line":1374,"address":[5956416,5956434,5954809],"length":1,"stats":{"Line":0}},{"line":1376,"address":[5807246,5807336,5807477,5807537,5807370],"length":1,"stats":{"Line":0}},{"line":1382,"address":[5507558,5507971],"length":1,"stats":{"Line":2}},{"line":1383,"address":[5880006,5880093,5880894],"length":1,"stats":{"Line":2}},{"line":1387,"address":[3039891,3039793],"length":1,"stats":{"Line":2}},{"line":1389,"address":[3040106],"length":1,"stats":{"Line":1}},{"line":1390,"address":[5508551],"length":1,"stats":{"Line":1}},{"line":1391,"address":[5808375],"length":1,"stats":{"Line":1}},{"line":1397,"address":[5881150,5881364,5881300,5881088,5882591],"length":1,"stats":{"Line":4}},{"line":1399,"address":[5809195,5809041],"length":1,"stats":{"Line":2}},{"line":1400,"address":[5509574,5509713,5509632],"length":1,"stats":{"Line":6}},{"line":1402,"address":[5881511],"length":1,"stats":{"Line":2}},{"line":1403,"address":[5509597],"length":1,"stats":{"Line":2}},{"line":1405,"address":[3041178],"length":1,"stats":{"Line":2}},{"line":1409,"address":[5510074,5509974,5510130],"length":1,"stats":{"Line":6}},{"line":1410,"address":[5286351],"length":1,"stats":{"Line":4}},{"line":1411,"address":[5511431,5511373,5511545,5511121,5513117,5511015],"length":1,"stats":{"Line":4}},{"line":1413,"address":[5883421,5883110,5883229,5883170,5881351],"length":1,"stats":{"Line":3}},{"line":1414,"address":[5883529,5885136,5885154],"length":1,"stats":{"Line":0}},{"line":1416,"address":[5811704],"length":1,"stats":{"Line":0}},{"line":1422,"address":[5811542,5811955],"length":1,"stats":{"Line":2}},{"line":1423,"address":[3044482,3043725,3043626],"length":1,"stats":{"Line":2}},{"line":1426,"address":[3043987,3043889],"length":1,"stats":{"Line":2}},{"line":1428,"address":[5884802],"length":1,"stats":{"Line":1}},{"line":1429,"address":[5812535],"length":1,"stats":{"Line":1}},{"line":1430,"address":[5960263],"length":1,"stats":{"Line":1}},{"line":1437,"address":[3578912],"length":1,"stats":{"Line":0}},{"line":1438,"address":[5968917],"length":1,"stats":{"Line":0}},{"line":1444,"address":[5717808],"length":1,"stats":{"Line":0}},{"line":1445,"address":[5595009],"length":1,"stats":{"Line":0}},{"line":1448,"address":[3579334],"length":1,"stats":{"Line":4}},{"line":1449,"address":[3353175],"length":1,"stats":{"Line":1}},{"line":1458,"address":[5962031,5962251,5961959],"length":1,"stats":{"Line":3}},{"line":1459,"address":[6018439],"length":1,"stats":{"Line":3}},{"line":1462,"address":[5969607],"length":1,"stats":{"Line":4}},{"line":1463,"address":[5296983],"length":1,"stats":{"Line":1}},{"line":1471,"address":[5636457,5636738,5636864],"length":1,"stats":{"Line":0}},{"line":1474,"address":[3579664],"length":1,"stats":{"Line":0}},{"line":1475,"address":[5718257],"length":1,"stats":{"Line":0}},{"line":1478,"address":[5969808],"length":1,"stats":{"Line":0}},{"line":1479,"address":[5263589],"length":1,"stats":{"Line":0}},{"line":1482,"address":[5420912],"length":1,"stats":{"Line":0}},{"line":1483,"address":[5718309],"length":1,"stats":{"Line":0}},{"line":1486,"address":[5969840],"length":1,"stats":{"Line":0}},{"line":1487,"address":[5595521],"length":1,"stats":{"Line":0}},{"line":1490,"address":[5970847,5971739,5969888],"length":1,"stats":{"Line":1}},{"line":1494,"address":[5595664],"length":1,"stats":{"Line":1}},{"line":1495,"address":[3579938],"length":1,"stats":{"Line":1}},{"line":1497,"address":[5969928,5970127,5970517],"length":1,"stats":{"Line":3}},{"line":1498,"address":[5597234,5597135,5596544],"length":1,"stats":{"Line":3}},{"line":1499,"address":[5422018,5422378],"length":1,"stats":{"Line":2}},{"line":1500,"address":[5422386],"length":1,"stats":{"Line":1}},{"line":1501,"address":[5265117,5265182],"length":1,"stats":{"Line":2}},{"line":1502,"address":[3581246],"length":1,"stats":{"Line":1}},{"line":1505,"address":[5970945,5971097,5971172],"length":1,"stats":{"Line":3}},{"line":1506,"address":[3580822],"length":1,"stats":{"Line":1}},{"line":1507,"address":[5719474],"length":1,"stats":{"Line":1}},{"line":1508,"address":[3580885],"length":1,"stats":{"Line":1}},{"line":1511,"address":[5421378,5421769,5421844],"length":1,"stats":{"Line":3}},{"line":1512,"address":[5264095,5264346],"length":1,"stats":{"Line":2}},{"line":1513,"address":[5264354],"length":1,"stats":{"Line":1}},{"line":1514,"address":[3580485],"length":1,"stats":{"Line":1}},{"line":1517,"address":[5718878,5718822],"length":1,"stats":{"Line":2}},{"line":1521,"address":[5971798],"length":1,"stats":{"Line":4}},{"line":1522,"address":[5638983],"length":1,"stats":{"Line":1}},{"line":1525,"address":[5965378,5965660,5964896,5965035,5965184,5964931,5965231],"length":1,"stats":{"Line":4}},{"line":1526,"address":[5965404,5965062,5965267],"length":1,"stats":{"Line":1}},{"line":1529,"address":[5597670],"length":1,"stats":{"Line":8}},{"line":1530,"address":[5466727],"length":1,"stats":{"Line":2}},{"line":1539,"address":[3050617,3050840,3050553],"length":1,"stats":{"Line":3}},{"line":1540,"address":[6017479],"length":1,"stats":{"Line":5}},{"line":1543,"address":[5597872],"length":1,"stats":{"Line":2}},{"line":1544,"address":[5972239],"length":1,"stats":{"Line":2}},{"line":1547,"address":[5423640,5423608,5423392],"length":1,"stats":{"Line":2}},{"line":1548,"address":[3582268,3582219,3582127],"length":1,"stats":{"Line":6}},{"line":1549,"address":[5598023],"length":1,"stats":{"Line":2}},{"line":1550,"address":[5598054],"length":1,"stats":{"Line":2}},{"line":1554,"address":[5266584,5266336,5266552],"length":1,"stats":{"Line":1}},{"line":1555,"address":[5721087,5721179,5721227],"length":1,"stats":{"Line":3}},{"line":1556,"address":[3582391],"length":1,"stats":{"Line":1}},{"line":1557,"address":[5721126],"length":1,"stats":{"Line":1}},{"line":1561,"address":[5266806,5266592,5266838],"length":1,"stats":{"Line":1}},{"line":1562,"address":[5598617,5598526,5598665],"length":1,"stats":{"Line":3}},{"line":1563,"address":[5598534],"length":1,"stats":{"Line":1}},{"line":1564,"address":[5972900],"length":1,"stats":{"Line":1}},{"line":1568,"address":[5599110,5599116,5598736],"length":1,"stats":{"Line":1}},{"line":1573,"address":[5973145,5973395,5973323],"length":1,"stats":{"Line":3}},{"line":1574,"address":[5973161],"length":1,"stats":{"Line":1}},{"line":1575,"address":[5973192,5973262],"length":1,"stats":{"Line":2}},{"line":1576,"address":[3583030],"length":1,"stats":{"Line":1}},{"line":1580,"address":[3583232],"length":1,"stats":{"Line":2}},{"line":1581,"address":[5599182],"length":1,"stats":{"Line":2}},{"line":1584,"address":[5722064],"length":1,"stats":{"Line":1}},{"line":1588,"address":[5424728],"length":1,"stats":{"Line":1}},{"line":1589,"address":[5722107],"length":1,"stats":{"Line":1}},{"line":1594,"address":[5599606,5599360,5599574],"length":1,"stats":{"Line":1}},{"line":1595,"address":[3583454,3583545,3583594],"length":1,"stats":{"Line":3}},{"line":1596,"address":[5973750],"length":1,"stats":{"Line":1}},{"line":1597,"address":[5267556],"length":1,"stats":{"Line":1}},{"line":1601,"address":[3583854,3583648,3583882],"length":1,"stats":{"Line":1}},{"line":1602,"address":[5974137,5973998,5974089],"length":1,"stats":{"Line":4}},{"line":1603,"address":[5425094],"length":1,"stats":{"Line":1}},{"line":1604,"address":[5722516],"length":1,"stats":{"Line":1}},{"line":1608,"address":[3051680,3050979,3050944,3051083,3051228,3051275,3051410],"length":1,"stats":{"Line":4}},{"line":1609,"address":[6016599],"length":1,"stats":{"Line":1}},{"line":1612,"address":[5968530,5968048,5968336,5968083,5968187,5968812,5968383],"length":1,"stats":{"Line":4}},{"line":1613,"address":[3051862,3052063,3052188],"length":1,"stats":{"Line":1}},{"line":1616,"address":[5425535],"length":1,"stats":{"Line":4}},{"line":1617,"address":[3052584,3052648,3052752,3052830],"length":1,"stats":{"Line":2}},{"line":1626,"address":[3053469,3053534,3053742],"length":1,"stats":{"Line":3}},{"line":1627,"address":[5297175],"length":1,"stats":{"Line":3}}],"covered":572,"coverable":757},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","album_tracks.rs"],"content":"use super::common::filter_by_original_album_artist;\nuse crate::{\n    AsyncDiscoveryIterator, AsyncPaginatedIterator, ExactScrobbleEdit, LastFmEditClientImpl,\n    Result, ScrobbleEdit,\n};\nuse async_trait::async_trait;\n\n/// Case 3: Album tracks discovery (album specified, track not specified)\n///\n/// This discovers all tracks in a specific album by iterating through the album's tracks\n/// and for each track, loading its scrobbles incrementally. This is now truly incremental\n/// like the artist tracks discovery.\npub struct AlbumTracksDiscovery {\n    client: LastFmEditClientImpl,\n    edit: ScrobbleEdit,\n    album_name: String,\n    tracks_iterator: crate::AlbumTracksIterator,\n    current_track_results: Vec\u003cExactScrobbleEdit\u003e,\n    current_track_index: usize,\n}\n\nimpl AlbumTracksDiscovery {\n    pub fn new(client: LastFmEditClientImpl, edit: ScrobbleEdit, album_name: String) -\u003e Self {\n        let tracks_iterator = crate::AlbumTracksIterator::new(\n            client.clone(),\n            album_name.clone(),\n            edit.artist_name_original.clone(),\n        );\n\n        Self {\n            client,\n            edit,\n            album_name,\n            tracks_iterator,\n            current_track_results: Vec::new(),\n            current_track_index: 0,\n        }\n    }\n}\n\n#[async_trait(?Send)]\nimpl AsyncDiscoveryIterator\u003cExactScrobbleEdit\u003e for AlbumTracksDiscovery {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cExactScrobbleEdit\u003e\u003e {\n        // If we have results from the current track, return the next one\n        if self.current_track_index \u003c self.current_track_results.len() {\n            let result = self.current_track_results[self.current_track_index].clone();\n            self.current_track_index += 1;\n            return Ok(Some(result));\n        }\n\n        // Get the next track from the iterator\n        while let Some(track) = self.tracks_iterator.next().await? {\n            log::debug!(\n                \"Getting scrobble data for track '{}' from album '{}' by '{}'\",\n                track.name,\n                self.album_name,\n                self.edit.artist_name_original\n            );\n\n            // Get scrobble data for this track\n            match self\n                .client\n                .load_edit_form_values_internal(\u0026track.name, \u0026self.edit.artist_name_original)\n                .await\n            {\n                Ok(track_scrobbles) =\u003e {\n                    // Apply user's changes and filtering\n                    let mut modified_edits = Vec::new();\n                    for scrobble in track_scrobbles {\n                        let mut modified_edit = scrobble.clone();\n                        if let Some(new_track_name) = \u0026self.edit.track_name {\n                            modified_edit.track_name = new_track_name.clone();\n                        }\n                        if let Some(new_album_name) = \u0026self.edit.album_name {\n                            modified_edit.album_name = new_album_name.clone();\n                        }\n                        modified_edit.artist_name = self.edit.artist_name.clone();\n                        if let Some(new_album_artist_name) = \u0026self.edit.album_artist_name {\n                            modified_edit.album_artist_name = new_album_artist_name.clone();\n                        }\n                        modified_edit.edit_all = self.edit.edit_all;\n                        modified_edits.push(modified_edit);\n                    }\n\n                    let filtered_edits =\n                        filter_by_original_album_artist(modified_edits, \u0026self.edit);\n\n                    if !filtered_edits.is_empty() {\n                        // Store results and return the first one\n                        self.current_track_results = filtered_edits;\n                        self.current_track_index = 1; // We'll return the first result below\n                        return Ok(Some(self.current_track_results[0].clone()));\n                    }\n                }\n                Err(e) =\u003e {\n                    log::debug!(\n                        \"Failed to get scrobble data for track '{}': {}\",\n                        track.name,\n                        e\n                    );\n                    // Continue with next track\n                }\n            }\n        }\n\n        // No more tracks\n        Ok(None)\n    }\n}\n","traces":[{"line":23,"address":[6418192,6419032,6419198],"length":1,"stats":{"Line":1}},{"line":25,"address":[3329928,3329981],"length":1,"stats":{"Line":2}},{"line":26,"address":[5661955,5661893],"length":1,"stats":{"Line":2}},{"line":27,"address":[6065291],"length":1,"stats":{"Line":1}},{"line":35,"address":[5835423],"length":1,"stats":{"Line":1}},{"line":43,"address":[6252061,6251984,6252435,6252244,6252910,6252482],"length":1,"stats":{"Line":4}},{"line":45,"address":[5502465],"length":1,"stats":{"Line":1}},{"line":46,"address":[6001100],"length":1,"stats":{"Line":1}},{"line":47,"address":[5691674,5691822],"length":1,"stats":{"Line":1}},{"line":48,"address":[6001243],"length":1,"stats":{"Line":1}},{"line":52,"address":[6021311],"length":1,"stats":{"Line":4}},{"line":53,"address":[3562985,3562929,3562861],"length":1,"stats":{"Line":4}},{"line":61,"address":[5876242,5876133,5880923,5880419,5880969],"length":1,"stats":{"Line":6}},{"line":63,"address":[5880866,5880442],"length":1,"stats":{"Line":3}},{"line":64,"address":[6000775,6001456,6001490,6001685,6006522,6006462],"length":1,"stats":{"Line":5}},{"line":66,"address":[3558978],"length":1,"stats":{"Line":1}},{"line":68,"address":[6253430],"length":1,"stats":{"Line":1}},{"line":69,"address":[5692725,5692590,5692474],"length":1,"stats":{"Line":3}},{"line":70,"address":[5693657,5692816],"length":1,"stats":{"Line":2}},{"line":71,"address":[6003571,6003201],"length":1,"stats":{"Line":1}},{"line":72,"address":[3560468,3560487,3560334],"length":1,"stats":{"Line":0}},{"line":74,"address":[5878064,5877781,5878287],"length":1,"stats":{"Line":3}},{"line":75,"address":[6003668,6003649,6003592],"length":1,"stats":{"Line":2}},{"line":77,"address":[6255351,6255131,6255332],"length":1,"stats":{"Line":2}},{"line":78,"address":[5505458,5505859],"length":1,"stats":{"Line":1}},{"line":79,"address":[6255571,6255752,6255733],"length":1,"stats":{"Line":0}},{"line":81,"address":[6255593],"length":1,"stats":{"Line":1}},{"line":82,"address":[5505586],"length":1,"stats":{"Line":1}},{"line":85,"address":[6253983,6253869],"length":1,"stats":{"Line":2}},{"line":88,"address":[6253991,6254062],"length":1,"stats":{"Line":2}},{"line":90,"address":[5504036,5504128],"length":1,"stats":{"Line":1}},{"line":91,"address":[5877246],"length":1,"stats":{"Line":1}},{"line":92,"address":[6002789],"length":1,"stats":{"Line":1}},{"line":95,"address":[3558898],"length":1,"stats":{"Line":0}},{"line":96,"address":[5503310,5506301,5506273],"length":1,"stats":{"Line":0}},{"line":107,"address":[5508015],"length":1,"stats":{"Line":1}}],"covered":32,"coverable":36},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","artist_tracks.rs"],"content":"use super::common::filter_by_original_album_artist;\nuse crate::{\n    AsyncDiscoveryIterator, AsyncPaginatedIterator, ExactScrobbleEdit, LastFmEditClientImpl,\n    Result, ScrobbleEdit,\n};\nuse async_trait::async_trait;\n\n/// Case 4: Artist tracks discovery (neither track nor album specified)\n///\n/// This discovers all tracks by an artist by iterating through the artist's catalog\n/// and for each track, loading its scrobbles incrementally. This is the most complex\n/// case as it involves nested iteration.\npub struct ArtistTracksDiscovery {\n    client: LastFmEditClientImpl,\n    edit: ScrobbleEdit,\n    tracks_iterator: crate::ArtistTracksIterator,\n    current_track_results: Vec\u003cExactScrobbleEdit\u003e,\n    current_track_index: usize,\n}\n\nimpl ArtistTracksDiscovery {\n    pub fn new(client: LastFmEditClientImpl, edit: ScrobbleEdit) -\u003e Self {\n        let tracks_iterator =\n            crate::ArtistTracksIterator::new(client.clone(), edit.artist_name_original.clone());\n\n        Self {\n            client,\n            edit,\n            tracks_iterator,\n            current_track_results: Vec::new(),\n            current_track_index: 0,\n        }\n    }\n}\n\n#[async_trait(?Send)]\nimpl AsyncDiscoveryIterator\u003cExactScrobbleEdit\u003e for ArtistTracksDiscovery {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cExactScrobbleEdit\u003e\u003e {\n        // If we have results from the current track, return the next one\n        if self.current_track_index \u003c self.current_track_results.len() {\n            let result = self.current_track_results[self.current_track_index].clone();\n            self.current_track_index += 1;\n            return Ok(Some(result));\n        }\n\n        // Get the next track from the iterator\n        while let Some(track) = self.tracks_iterator.next().await? {\n            // Get scrobble data for this track\n            match self\n                .client\n                .load_edit_form_values_internal(\u0026track.name, \u0026self.edit.artist_name_original)\n                .await\n            {\n                Ok(track_scrobbles) =\u003e {\n                    // Apply user's changes and filtering\n                    let mut modified_edits = Vec::new();\n                    for scrobble in track_scrobbles {\n                        let mut modified_edit = scrobble.clone();\n                        if let Some(new_track_name) = \u0026self.edit.track_name {\n                            modified_edit.track_name = new_track_name.clone();\n                        }\n                        if let Some(new_album_name) = \u0026self.edit.album_name {\n                            modified_edit.album_name = new_album_name.clone();\n                        }\n                        modified_edit.artist_name = self.edit.artist_name.clone();\n                        if let Some(new_album_artist_name) = \u0026self.edit.album_artist_name {\n                            modified_edit.album_artist_name = new_album_artist_name.clone();\n                        }\n                        modified_edit.edit_all = self.edit.edit_all;\n                        modified_edits.push(modified_edit);\n                    }\n\n                    let filtered_edits =\n                        filter_by_original_album_artist(modified_edits, \u0026self.edit);\n\n                    if !filtered_edits.is_empty() {\n                        // Store results and return the first one\n                        self.current_track_results = filtered_edits;\n                        self.current_track_index = 1; // We'll return the first result below\n                        return Ok(Some(self.current_track_results[0].clone()));\n                    }\n                }\n                Err(e) =\u003e {\n                    log::warn!(\n                        \"Failed to get scrobble data for track '{}': {}\",\n                        track.name,\n                        e\n                    );\n                    // Continue with next track\n                }\n            }\n        }\n\n        // No more tracks\n        Ok(None)\n    }\n}\n","traces":[{"line":22,"address":[5635534,5634896,5635631],"length":1,"stats":{"Line":1}},{"line":23,"address":[5811744,5812301,5811691],"length":1,"stats":{"Line":1}},{"line":30,"address":[6157026],"length":1,"stats":{"Line":1}},{"line":38,"address":[5635679],"length":1,"stats":{"Line":4}},{"line":40,"address":[5961457],"length":1,"stats":{"Line":1}},{"line":41,"address":[3549296],"length":1,"stats":{"Line":1}},{"line":42,"address":[5961658,5961806],"length":1,"stats":{"Line":1}},{"line":43,"address":[3549435],"length":1,"stats":{"Line":1}},{"line":47,"address":[5767857,5763134,5766891,5766839,5762466,5762763],"length":1,"stats":{"Line":3}},{"line":49,"address":[6090485,6090594,6094818,6094864,6094669],"length":1,"stats":{"Line":5}},{"line":51,"address":[6094761,6094692],"length":1,"stats":{"Line":2}},{"line":52,"address":[3359934],"length":1,"stats":{"Line":5}},{"line":54,"address":[5572718],"length":1,"stats":{"Line":1}},{"line":56,"address":[5962390],"length":1,"stats":{"Line":1}},{"line":57,"address":[6339594,6339710,6339845],"length":1,"stats":{"Line":3}},{"line":58,"address":[6340777,6339936],"length":1,"stats":{"Line":2}},{"line":59,"address":[3551309,3551676],"length":1,"stats":{"Line":1}},{"line":60,"address":[3551521,3551540,3551390],"length":1,"stats":{"Line":0}},{"line":62,"address":[5765513,5765290,5765013],"length":1,"stats":{"Line":1}},{"line":63,"address":[3551694,3551770,3551751],"length":1,"stats":{"Line":0}},{"line":65,"address":[6092657,6092638,6092437],"length":1,"stats":{"Line":2}},{"line":66,"address":[6092796,6093185],"length":1,"stats":{"Line":2}},{"line":67,"address":[3552147,3552299,3552318],"length":1,"stats":{"Line":2}},{"line":69,"address":[6092893],"length":1,"stats":{"Line":1}},{"line":70,"address":[6341702],"length":1,"stats":{"Line":1}},{"line":73,"address":[5764175,5764061],"length":1,"stats":{"Line":2}},{"line":76,"address":[6091303,6091374],"length":1,"stats":{"Line":2}},{"line":78,"address":[3550768,3550684],"length":1,"stats":{"Line":1}},{"line":79,"address":[3550894],"length":1,"stats":{"Line":1}},{"line":80,"address":[6091621],"length":1,"stats":{"Line":1}},{"line":83,"address":[3549954],"length":1,"stats":{"Line":0}},{"line":84,"address":[5572670,5575643,5575615],"length":1,"stats":{"Line":0}},{"line":95,"address":[5576918],"length":1,"stats":{"Line":1}}],"covered":29,"coverable":33},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","common.rs"],"content":"use crate::{ExactScrobbleEdit, ScrobbleEdit};\n\n/// Filter discovered edits based on original album artist if specified\n///\n/// When album_artist_name_original is specified in the ScrobbleEdit, we only want\n/// to return ExactScrobbleEdits that match that original album artist value.\n/// This prevents implicit fan-out over different album artists.\npub fn filter_by_original_album_artist(\n    discovered_edits: Vec\u003cExactScrobbleEdit\u003e,\n    edit: \u0026ScrobbleEdit,\n) -\u003e Vec\u003cExactScrobbleEdit\u003e {\n    if let Some(target_album_artist) = \u0026edit.album_artist_name_original {\n        log::debug!(\n            \"Filtering {} discovered edits to only include album artist '{}'\",\n            discovered_edits.len(),\n            target_album_artist\n        );\n\n        let filtered: Vec\u003cExactScrobbleEdit\u003e = discovered_edits\n            .into_iter()\n            .filter(|scrobble| scrobble.album_artist_name_original == *target_album_artist)\n            .collect();\n\n        log::debug!(\n            \"After filtering by album artist '{}': {} edits remain\",\n            target_album_artist,\n            filtered.len()\n        );\n\n        filtered\n    } else {\n        discovered_edits\n    }\n}\n","traces":[{"line":8,"address":[3146697,3145520],"length":1,"stats":{"Line":1}},{"line":12,"address":[6108647,6109307,6108494],"length":1,"stats":{"Line":4}},{"line":13,"address":[5982635],"length":1,"stats":{"Line":3}},{"line":19,"address":[3146178,3145764],"length":1,"stats":{"Line":2}},{"line":21,"address":[3563696,3563721],"length":1,"stats":{"Line":3}},{"line":24,"address":[5890650],"length":1,"stats":{"Line":0}},{"line":30,"address":[5890520],"length":1,"stats":{"Line":1}},{"line":32,"address":[5889865],"length":1,"stats":{"Line":2}}],"covered":7,"coverable":8},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","discovery_iterator.rs"],"content":"use crate::Result;\nuse async_trait::async_trait;\n\n/// Async iterator trait for discovering scrobble edits incrementally\n///\n/// This trait is designed for iterators that yield individual results one at a time,\n/// unlike AsyncPaginatedIterator which is designed for page-based iteration.\n/// This is particularly useful for discovery operations that might make many API\n/// requests and need to avoid rate limiting by yielding results incrementally.\n#[async_trait(?Send)]\npub trait AsyncDiscoveryIterator\u003cT\u003e {\n    /// Get the next item from the iterator\n    ///\n    /// Returns `Ok(Some(item))` if there's a next item available,\n    /// `Ok(None)` if the iterator is exhausted, or `Err(e)` if an error occurred.\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cT\u003e\u003e;\n\n    /// Collect all remaining items from the iterator into a Vec\n    ///\n    /// This is a convenience method that calls `next()` repeatedly until\n    /// the iterator is exhausted and collects all results.\n    async fn collect_all(\u0026mut self) -\u003e Result\u003cVec\u003cT\u003e\u003e {\n        let mut items = Vec::new();\n        while let Some(item) = self.next().await? {\n            items.push(item);\n        }\n        Ok(items)\n    }\n\n    /// Take the first `n` items from the iterator\n    ///\n    /// This stops after collecting `n` items or when the iterator is exhausted,\n    /// whichever comes first.\n    async fn take(\u0026mut self, n: usize) -\u003e Result\u003cVec\u003cT\u003e\u003e {\n        let mut items = Vec::with_capacity(n);\n        for _ in 0..n {\n            if let Some(item) = self.next().await? {\n                items.push(item);\n            } else {\n                break;\n            }\n        }\n        Ok(items)\n    }\n}\n","traces":[{"line":22,"address":[5415411,5417152,5413998,5415500,5418078,5413139,5415859,5416736,5414499,5414051,5415792,5415376,5412780,5416718,5414140,5417108,5412656,5417219,5414432,5413072,5415358,5413028,5414016,5415748,5412691,5414388,5416771,5416860],"length":1,"stats":{"Line":8}},{"line":23,"address":[5903948,5906668,5902588,5905308],"length":1,"stats":{"Line":2}},{"line":24,"address":[5905414,5905031,5902694,5905389,5906690,5906391,5907017,5905980,5906774,5907340,5905657,5905330,5902311,5904297,5904620,5904029,5902610,5903260,5903671,5903970,5902669,5906749,5902937,5904054],"length":1,"stats":{"Line":8}},{"line":25,"address":[5904605,5905965,5904559,5907325,5903245,5907279,5903199,5905919],"length":1,"stats":{"Line":4}},{"line":27,"address":[5601853,5603213,5604573,5605933],"length":1,"stats":{"Line":2}},{"line":34,"address":[5421234,5421497,5421541,5422608,5422738,5421084,5423001,5421139,5423232,5419600,5424092,5418131,5422643,5419580,5423045,5418096,5420037,5420224,5421104,5421728,5422588,5419993,5418489,5418226,5419635,5419730,5418533,5418720],"length":1,"stats":{"Line":0}},{"line":35,"address":[3454499,3455939,3453059,3451619],"length":1,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[5303460,5302868,5306100,5307572],"length":1,"stats":{"Line":0}},{"line":38,"address":[3453729,3453691,3455169,3452289,3452251,3456609,3456571,3455131],"length":1,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}}],"covered":5,"coverable":12},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","exact_match.rs"],"content":"use super::common::filter_by_original_album_artist;\nuse crate::{\n    AsyncDiscoveryIterator, ExactScrobbleEdit, LastFmEditClientImpl, LastFmError, Result,\n    ScrobbleEdit,\n};\nuse async_trait::async_trait;\n\n/// Case 1: Exact match discovery (track + album specified)\n///\n/// This discovers the specific scrobble that matches both the track and album,\n/// yielding at most one result.\npub struct ExactMatchDiscovery {\n    client: LastFmEditClientImpl,\n    edit: ScrobbleEdit,\n    track_name: String,\n    album_name: String,\n    result: Option\u003cExactScrobbleEdit\u003e,\n    completed: bool,\n}\n\nimpl ExactMatchDiscovery {\n    pub fn new(\n        client: LastFmEditClientImpl,\n        edit: ScrobbleEdit,\n        track_name: String,\n        album_name: String,\n    ) -\u003e Self {\n        Self {\n            client,\n            edit,\n            track_name,\n            album_name,\n            result: None,\n            completed: false,\n        }\n    }\n}\n\n#[async_trait(?Send)]\nimpl AsyncDiscoveryIterator\u003cExactScrobbleEdit\u003e for ExactMatchDiscovery {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cExactScrobbleEdit\u003e\u003e {\n        if self.completed {\n            return Ok(None);\n        }\n\n        if self.result.is_none() {\n            // Perform the lookup inline (previously discover_track_album_exact_match)\n            log::debug!(\n                \"Looking up missing metadata for track '{}' on album '{}' by '{}'\",\n                self.track_name,\n                self.album_name,\n                self.edit.artist_name_original\n            );\n\n            match self\n                .client\n                .load_edit_form_values_internal(\u0026self.track_name, \u0026self.edit.artist_name_original)\n                .await\n            {\n                Ok(all_variations) =\u003e {\n                    // Filter by album artist first if specified, then find the variation that matches the specific album\n                    let filtered_variations =\n                        filter_by_original_album_artist(all_variations, \u0026self.edit);\n\n                    if let Some(exact_edit) = filtered_variations\n                        .iter()\n                        .find(|variation| variation.album_name_original == self.album_name)\n                    {\n                        // Apply the user's desired changes to this exact variation\n                        let mut modified_edit = exact_edit.clone();\n                        if let Some(new_track_name) = \u0026self.edit.track_name {\n                            modified_edit.track_name = new_track_name.clone();\n                        }\n                        if let Some(new_album_name) = \u0026self.edit.album_name {\n                            modified_edit.album_name = new_album_name.clone();\n                        }\n                        modified_edit.artist_name = self.edit.artist_name.clone();\n                        if let Some(new_album_artist_name) = \u0026self.edit.album_artist_name {\n                            modified_edit.album_artist_name = new_album_artist_name.clone();\n                        }\n                        modified_edit.edit_all = self.edit.edit_all;\n\n                        self.result = Some(modified_edit);\n                    } else {\n                        let album_artist_filter = if self.edit.album_artist_name_original.is_some()\n                        {\n                            format!(\n                                \" with album artist '{}'\",\n                                self.edit.album_artist_name_original.as_ref().unwrap()\n                            )\n                        } else {\n                            String::new()\n                        };\n                        self.completed = true;\n                        return Err(LastFmError::Parse(format!(\n                            \"Track '{}' not found on album '{}' by '{}'{} in recent scrobbles\",\n                            self.track_name,\n                            self.album_name,\n                            self.edit.artist_name_original,\n                            album_artist_filter\n                        )));\n                    }\n                }\n                Err(e) =\u003e {\n                    self.completed = true;\n                    return Err(e);\n                }\n            }\n        }\n\n        self.completed = true;\n        Ok(self.result.take())\n    }\n}\n","traces":[{"line":22,"address":[5690192],"length":1,"stats":{"Line":1}},{"line":41,"address":[3152639],"length":1,"stats":{"Line":4}},{"line":42,"address":[3080610],"length":1,"stats":{"Line":1}},{"line":43,"address":[3080664],"length":1,"stats":{"Line":1}},{"line":46,"address":[6068536,6068443],"length":1,"stats":{"Line":2}},{"line":48,"address":[5838482,5838362],"length":1,"stats":{"Line":2}},{"line":55,"address":[5479796,5479220,5480086,5480141,5479842],"length":1,"stats":{"Line":5}},{"line":57,"address":[3080869,3081337],"length":1,"stats":{"Line":2}},{"line":58,"address":[5666038,5666230,5665927,5665984,5664878],"length":1,"stats":{"Line":3}},{"line":60,"address":[5839543],"length":1,"stats":{"Line":1}},{"line":62,"address":[5839575],"length":1,"stats":{"Line":1}},{"line":65,"address":[5839614,5839763,5839697],"length":1,"stats":{"Line":3}},{"line":67,"address":[5480544,5483184,5483201],"length":1,"stats":{"Line":3}},{"line":70,"address":[5480655,5480763],"length":1,"stats":{"Line":2}},{"line":71,"address":[3082740,3082379],"length":1,"stats":{"Line":1}},{"line":72,"address":[5741953,5741972,5741822],"length":1,"stats":{"Line":0}},{"line":74,"address":[5741841,5742341,5742118],"length":1,"stats":{"Line":1}},{"line":75,"address":[3082834,3082758,3082815],"length":1,"stats":{"Line":0}},{"line":77,"address":[3082777,3082978,3082997],"length":1,"stats":{"Line":2}},{"line":78,"address":[5668095,5667672],"length":1,"stats":{"Line":1}},{"line":79,"address":[3083416,3083211,3083397],"length":1,"stats":{"Line":0}},{"line":81,"address":[5481657],"length":1,"stats":{"Line":1}},{"line":83,"address":[5481988,5481682],"length":1,"stats":{"Line":1}},{"line":85,"address":[3084032,3082238],"length":1,"stats":{"Line":0}},{"line":87,"address":[5482620],"length":1,"stats":{"Line":0}},{"line":89,"address":[5743528,5743429],"length":1,"stats":{"Line":0}},{"line":92,"address":[5841678,5841717],"length":1,"stats":{"Line":0}},{"line":94,"address":[5482519],"length":1,"stats":{"Line":0}},{"line":95,"address":[3084106,3084360],"length":1,"stats":{"Line":0}},{"line":104,"address":[3081769],"length":1,"stats":{"Line":0}},{"line":105,"address":[5480237],"length":1,"stats":{"Line":0}},{"line":106,"address":[3081852],"length":1,"stats":{"Line":0}},{"line":111,"address":[5665214],"length":1,"stats":{"Line":1}},{"line":112,"address":[5668267,5665233],"length":1,"stats":{"Line":2}}],"covered":22,"coverable":34},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","mod.rs"],"content":"pub mod album_tracks;\npub mod artist_tracks;\npub mod common;\npub mod discovery_iterator;\npub mod exact_match;\npub mod track_variations;\n\npub use album_tracks::AlbumTracksDiscovery;\npub use artist_tracks::ArtistTracksDiscovery;\npub use common::filter_by_original_album_artist;\npub use discovery_iterator::AsyncDiscoveryIterator;\npub use exact_match::ExactMatchDiscovery;\npub use track_variations::TrackVariationsDiscovery;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","track_variations.rs"],"content":"use super::common::filter_by_original_album_artist;\nuse crate::{\n    AsyncDiscoveryIterator, ExactScrobbleEdit, LastFmEditClientImpl, Result, ScrobbleEdit,\n};\nuse async_trait::async_trait;\n\n/// Case 2: Track variations discovery (track specified, album not specified)\n///\n/// This discovers all album variations of a specific track by loading the track's\n/// scrobble data incrementally and yielding each variation as it processes them.\n/// This is now truly incremental like the artist and album tracks discovery.\npub struct TrackVariationsDiscovery {\n    client: LastFmEditClientImpl,\n    edit: ScrobbleEdit,\n    track_name: String,\n    scrobbles_loaded: bool,\n    current_results: Vec\u003cExactScrobbleEdit\u003e,\n    current_index: usize,\n}\n\nimpl TrackVariationsDiscovery {\n    pub fn new(client: LastFmEditClientImpl, edit: ScrobbleEdit, track_name: String) -\u003e Self {\n        Self {\n            client,\n            edit,\n            track_name,\n            scrobbles_loaded: false,\n            current_results: Vec::new(),\n            current_index: 0,\n        }\n    }\n}\n\n#[async_trait(?Send)]\nimpl AsyncDiscoveryIterator\u003cExactScrobbleEdit\u003e for TrackVariationsDiscovery {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cExactScrobbleEdit\u003e\u003e {\n        // If we have results from current batch, return the next one\n        if self.current_index \u003c self.current_results.len() {\n            let result = self.current_results[self.current_index].clone();\n            self.current_index += 1;\n            return Ok(Some(result));\n        }\n\n        // If we haven't loaded scrobbles yet, load them\n        if !self.scrobbles_loaded {\n            log::debug!(\n                \"Getting scrobble data for track '{}' by '{}'\",\n                self.track_name,\n                self.edit.artist_name_original\n            );\n\n            match self\n                .client\n                .load_edit_form_values_internal(\u0026self.track_name, \u0026self.edit.artist_name_original)\n                .await\n            {\n                Ok(track_scrobbles) =\u003e {\n                    // Apply user's changes and filtering\n                    let mut modified_edits = Vec::new();\n                    for scrobble in track_scrobbles {\n                        let mut modified_edit = scrobble.clone();\n                        if let Some(new_track_name) = \u0026self.edit.track_name {\n                            modified_edit.track_name = new_track_name.clone();\n                        }\n                        if let Some(new_album_name) = \u0026self.edit.album_name {\n                            modified_edit.album_name = new_album_name.clone();\n                        }\n                        modified_edit.artist_name = self.edit.artist_name.clone();\n                        if let Some(new_album_artist_name) = \u0026self.edit.album_artist_name {\n                            modified_edit.album_artist_name = new_album_artist_name.clone();\n                        }\n                        modified_edit.edit_all = self.edit.edit_all;\n                        modified_edits.push(modified_edit);\n                    }\n\n                    let filtered_edits =\n                        filter_by_original_album_artist(modified_edits, \u0026self.edit);\n\n                    if !filtered_edits.is_empty() {\n                        // Store results and return the first one\n                        self.current_results = filtered_edits;\n                        self.current_index = 1; // We'll return the first result below\n                        self.scrobbles_loaded = true;\n                        return Ok(Some(self.current_results[0].clone()));\n                    }\n                }\n                Err(e) =\u003e {\n                    log::debug!(\n                        \"Failed to get scrobble data for track '{}': {}\",\n                        self.track_name,\n                        e\n                    );\n                    self.scrobbles_loaded = true;\n                    return Err(e);\n                }\n            }\n            self.scrobbles_loaded = true;\n        }\n\n        // No more results\n        Ok(None)\n    }\n}\n","traces":[{"line":22,"address":[6422928,6423337,6423378],"length":1,"stats":{"Line":1}},{"line":28,"address":[2889890],"length":1,"stats":{"Line":1}},{"line":36,"address":[5436605,5436791,5436528,5436964,5437014,5438157],"length":1,"stats":{"Line":4}},{"line":38,"address":[5611637],"length":1,"stats":{"Line":1}},{"line":39,"address":[5437126,5437944],"length":1,"stats":{"Line":2}},{"line":40,"address":[5437951,5438093],"length":1,"stats":{"Line":1}},{"line":41,"address":[5612618],"length":1,"stats":{"Line":1}},{"line":45,"address":[5437103,5439625],"length":1,"stats":{"Line":1}},{"line":46,"address":[3325463,3325268,3325395],"length":1,"stats":{"Line":3}},{"line":52,"address":[5274923,5274373,5274877,5275405,5275460],"length":1,"stats":{"Line":7}},{"line":54,"address":[5988618,5988210],"length":1,"stats":{"Line":2}},{"line":55,"address":[5989053,5989245,5988761,5987685,5988704],"length":1,"stats":{"Line":5}},{"line":57,"address":[5613117],"length":1,"stats":{"Line":1}},{"line":59,"address":[5737893],"length":1,"stats":{"Line":1}},{"line":60,"address":[5613225,5613341,5613476],"length":1,"stats":{"Line":4}},{"line":61,"address":[5614344,5613561],"length":1,"stats":{"Line":4}},{"line":62,"address":[5614384,5614745],"length":1,"stats":{"Line":4}},{"line":63,"address":[5990846,5990865,5990715],"length":1,"stats":{"Line":4}},{"line":65,"address":[5440147,5440370,5439870],"length":1,"stats":{"Line":2}},{"line":66,"address":[5277211,5277268,5277287],"length":1,"stats":{"Line":0}},{"line":68,"address":[5739518,5739719,5739738],"length":1,"stats":{"Line":4}},{"line":69,"address":[3328926,3328541],"length":1,"stats":{"Line":4}},{"line":70,"address":[5615216,5615372,5615391],"length":1,"stats":{"Line":4}},{"line":72,"address":[5739974],"length":1,"stats":{"Line":2}},{"line":73,"address":[5991519],"length":1,"stats":{"Line":2}},{"line":76,"address":[5276038,5276152],"length":1,"stats":{"Line":3}},{"line":79,"address":[5989968,5990033],"length":1,"stats":{"Line":4}},{"line":81,"address":[5990039,5990131],"length":1,"stats":{"Line":2}},{"line":82,"address":[5439393],"length":1,"stats":{"Line":2}},{"line":83,"address":[5990280],"length":1,"stats":{"Line":2}},{"line":84,"address":[5990299],"length":1,"stats":{"Line":2}},{"line":87,"address":[5275488],"length":1,"stats":{"Line":0}},{"line":88,"address":[5615941,5616121,5613072],"length":1,"stats":{"Line":0}},{"line":93,"address":[5740687],"length":1,"stats":{"Line":0}},{"line":94,"address":[3329350],"length":1,"stats":{"Line":0}},{"line":97,"address":[5276662],"length":1,"stats":{"Line":0}},{"line":101,"address":[5274285],"length":1,"stats":{"Line":1}}],"covered":31,"coverable":37},{"path":["/","home","imalison","Projects","lastfm-edit","src","edit_analysis.rs"],"content":"use http_types::StatusCode;\nuse scraper::{Html, Selector};\n\n/// Result of analyzing an edit response from Last.fm\n#[derive(Debug, Clone)]\npub struct EditAnalysisResult {\n    /// Whether the edit was successful based on all indicators\n    pub success: bool,\n    /// Optional detailed message about the result\n    pub message: Option\u003cString\u003e,\n    /// Track name found in the response (if any)\n    pub actual_track_name: Option\u003cString\u003e,\n    /// Album name found in the response (if any)\n    pub actual_album_name: Option\u003cString\u003e,\n}\n\n/// Analyze the HTML response from a Last.fm edit request to determine success/failure\n///\n/// This function parses the response HTML to look for success/error indicators\n/// and extract the actual track/album names that were processed.\n///\n/// # Arguments\n/// * `response_text` - The HTML response body from the edit request\n/// * `status_code` - The HTTP status code of the response\n///\n/// # Returns\n/// An `EditAnalysisResult` containing the analysis results\npub fn analyze_edit_response(response_text: \u0026str, status_code: StatusCode) -\u003e EditAnalysisResult {\n    // Parse the HTML response to check for actual success/failure\n    let document = Html::parse_document(response_text);\n\n    // Check for success indicator\n    let success_selector = Selector::parse(\".alert-success\").unwrap();\n    let error_selector = Selector::parse(\".alert-danger, .alert-error, .error\").unwrap();\n\n    let has_success_alert = document.select(\u0026success_selector).next().is_some();\n    let has_error_alert = document.select(\u0026error_selector).next().is_some();\n\n    // Extract track and album names from the response\n    let (actual_track_name, actual_album_name) =\n        extract_track_album_names(\u0026document, response_text);\n\n    log::debug!(\n        \"Response analysis: success_alert={}, error_alert={}, track='{}', album='{}'\",\n        has_success_alert,\n        has_error_alert,\n        actual_track_name.as_deref().unwrap_or(\"not found\"),\n        actual_album_name.as_deref().unwrap_or(\"not found\")\n    );\n\n    // Determine if edit was truly successful\n    let final_success = status_code.is_success() \u0026\u0026 has_success_alert \u0026\u0026 !has_error_alert;\n\n    // Create detailed message\n    let message = if has_error_alert {\n        // Extract error message\n        if let Some(error_element) = document.select(\u0026error_selector).next() {\n            Some(format!(\n                \"Edit failed: {}\",\n                error_element.text().collect::\u003cString\u003e().trim()\n            ))\n        } else {\n            Some(\"Edit failed with unknown error\".to_string())\n        }\n    } else if final_success {\n        Some(format!(\n            \"Edit successful - Track: '{}', Album: '{}'\",\n            actual_track_name.as_deref().unwrap_or(\"unknown\"),\n            actual_album_name.as_deref().unwrap_or(\"unknown\")\n        ))\n    } else {\n        Some(format!(\"Edit failed with status: {status_code}\"))\n    };\n\n    EditAnalysisResult {\n        success: final_success,\n        message,\n        actual_track_name,\n        actual_album_name,\n    }\n}\n\n/// Extract track and album names from the edit response\n///\n/// This function tries multiple strategies to find the actual track and album names\n/// in the response, including direct CSS selectors and regex patterns.\nfn extract_track_album_names(\n    document: \u0026Html,\n    response_text: \u0026str,\n) -\u003e (Option\u003cString\u003e, Option\u003cString\u003e) {\n    let mut actual_track_name = None;\n    let mut actual_album_name = None;\n\n    // Try direct selectors first\n    let track_name_selector = Selector::parse(\"td.chartlist-name a\").unwrap();\n    let album_name_selector = Selector::parse(\"td.chartlist-album a\").unwrap();\n\n    if let Some(track_element) = document.select(\u0026track_name_selector).next() {\n        actual_track_name = Some(track_element.text().collect::\u003cString\u003e().trim().to_string());\n    }\n\n    if let Some(album_element) = document.select(\u0026album_name_selector).next() {\n        actual_album_name = Some(album_element.text().collect::\u003cString\u003e().trim().to_string());\n    }\n\n    // If not found, try extracting from the raw response text using generic patterns\n    if actual_track_name.is_none() || actual_album_name.is_none() {\n        if actual_track_name.is_none() {\n            actual_track_name = extract_track_name_from_text(response_text);\n        }\n\n        if actual_album_name.is_none() {\n            actual_album_name = extract_album_name_from_text(response_text);\n        }\n    }\n\n    (actual_track_name, actual_album_name)\n}\n\n/// Extract track name from response text using regex patterns\nfn extract_track_name_from_text(response_text: \u0026str) -\u003e Option\u003cString\u003e {\n    // Look for track name in href=\"/music/{artist}/_/{track}\"\n    // Use regex to find track URLs\n    let track_pattern = regex::Regex::new(r#\"href=\"/music/[^\"]+/_/([^\"]+)\"\"#).unwrap();\n    if let Some(captures) = track_pattern.captures(response_text) {\n        if let Some(track_match) = captures.get(1) {\n            let raw_track = track_match.as_str();\n            // URL decode the track name\n            let decoded_track = urlencoding::decode(raw_track)\n                .unwrap_or_else(|_| raw_track.into())\n                .replace('+', \" \");\n            return Some(decoded_track);\n        }\n    }\n    None\n}\n\n/// Extract album name from response text using regex patterns\nfn extract_album_name_from_text(response_text: \u0026str) -\u003e Option\u003cString\u003e {\n    // Look for album name in href=\"/music/{artist}/{album}\"\n    // Find album links that are not track links (don't contain /_/)\n    let album_pattern =\n        regex::Regex::new(r#\"href=\"/music/[^\"]+/([^\"/_]+)\"[^\u003e]*\u003e[^\u003c]*\u003c/a\u003e\"#).unwrap();\n    if let Some(captures) = album_pattern.captures(response_text) {\n        if let Some(album_match) = captures.get(1) {\n            let raw_album = album_match.as_str();\n            // URL decode the album name\n            let decoded_album = urlencoding::decode(raw_album)\n                .unwrap_or_else(|_| raw_album.into())\n                .replace('+', \" \");\n            return Some(decoded_album);\n        }\n    }\n    None\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_analyze_success_response() {\n        let html = r#\"\n            \u003cdiv class=\"alert-success\"\u003eEdit successful\u003c/div\u003e\n            \u003ctable\u003e\n                \u003ctr\u003e\n                    \u003ctd class=\"chartlist-name\"\u003e\u003ca href=\"/music/artist/_/track\"\u003eTest Track\u003c/a\u003e\u003c/td\u003e\n                    \u003ctd class=\"chartlist-album\"\u003e\u003ca href=\"/music/artist/album\"\u003eTest Album\u003c/a\u003e\u003c/td\u003e\n                \u003c/tr\u003e\n            \u003c/table\u003e\n        \"#;\n\n        let result = analyze_edit_response(html, StatusCode::Ok);\n        assert!(result.success);\n        // The CSS selectors should extract the text content of the links\n        assert_eq!(result.actual_track_name, Some(\"Test Track\".to_string()));\n        assert_eq!(result.actual_album_name, Some(\"Test Album\".to_string()));\n    }\n\n    #[test]\n    fn test_analyze_error_response() {\n        let html = r#\"\n            \u003cdiv class=\"alert-danger\"\u003eEdit failed: Invalid data\u003c/div\u003e\n        \"#;\n\n        let result = analyze_edit_response(html, StatusCode::Ok);\n        assert!(!result.success);\n        assert!(result\n            .message\n            .unwrap()\n            .contains(\"Edit failed: Invalid data\"));\n    }\n\n    #[test]\n    fn test_extract_from_regex_patterns() {\n        let html = r#\"\n            Some content with \u003ca href=\"/music/Artist/AlbumName\"\u003ealbum link\u003c/a\u003e\n            and later \u003ca href=\"/music/Artist/_/TrackName\"\u003etrack link\u003c/a\u003e\n        \"#;\n\n        let result = analyze_edit_response(html, StatusCode::Ok);\n        // Should extract from regex patterns when direct selectors fail\n        // The track pattern captures from /_/ URLs, album pattern from non-/_/ URLs\n        assert_eq!(result.actual_track_name, Some(\"TrackName\".to_string()));\n        assert_eq!(result.actual_album_name, Some(\"AlbumName\".to_string()));\n    }\n}\n","traces":[{"line":28,"address":[5991200,5994245,5994372],"length":1,"stats":{"Line":4}},{"line":30,"address":[5865810],"length":1,"stats":{"Line":2}},{"line":33,"address":[6242803,6242878],"length":1,"stats":{"Line":5}},{"line":34,"address":[3434268,3434343],"length":1,"stats":{"Line":5}},{"line":36,"address":[5923324,5923245],"length":1,"stats":{"Line":5}},{"line":37,"address":[3434593],"length":1,"stats":{"Line":3}},{"line":40,"address":[3434795],"length":1,"stats":{"Line":2}},{"line":43,"address":[3435244,3434859,3434990,3434955,3435375],"length":1,"stats":{"Line":6}},{"line":52,"address":[5992782,5992113],"length":1,"stats":{"Line":4}},{"line":55,"address":[5924538],"length":1,"stats":{"Line":2}},{"line":57,"address":[5868305,5868843,5868234,5867392],"length":1,"stats":{"Line":6}},{"line":58,"address":[6245549,6245454],"length":1,"stats":{"Line":2}},{"line":60,"address":[5925700,5925533,5925594],"length":1,"stats":{"Line":6}},{"line":63,"address":[5925560,5925963],"length":1,"stats":{"Line":0}},{"line":65,"address":[5868261,5868229,5867380,5868767],"length":1,"stats":{"Line":6}},{"line":66,"address":[3436338,3436213],"length":1,"stats":{"Line":4}},{"line":68,"address":[5993310,5992913],"length":1,"stats":{"Line":4}},{"line":69,"address":[6244916],"length":1,"stats":{"Line":2}},{"line":72,"address":[5992886,5992945],"length":1,"stats":{"Line":2}},{"line":87,"address":[5926112,5928378,5927062],"length":1,"stats":{"Line":2}},{"line":91,"address":[5985224],"length":1,"stats":{"Line":3}},{"line":92,"address":[5994498],"length":1,"stats":{"Line":2}},{"line":95,"address":[5926226,5926298],"length":1,"stats":{"Line":5}},{"line":96,"address":[5994705,5994630],"length":1,"stats":{"Line":5}},{"line":98,"address":[5869369,5869298,5869437],"length":1,"stats":{"Line":8}},{"line":99,"address":[6246473,6246522,6246725],"length":1,"stats":{"Line":2}},{"line":102,"address":[6246881,6246979],"length":1,"stats":{"Line":4}},{"line":103,"address":[5986287,5986539,5986336],"length":1,"stats":{"Line":2}},{"line":107,"address":[5927714,5927628],"length":1,"stats":{"Line":3}},{"line":108,"address":[5995972,5996381,5996166],"length":1,"stats":{"Line":6}},{"line":109,"address":[5927954,5927928],"length":1,"stats":{"Line":2}},{"line":112,"address":[6247692,6247910,6248102],"length":1,"stats":{"Line":6}},{"line":113,"address":[3439259,3439233],"length":1,"stats":{"Line":2}},{"line":117,"address":[5927725],"length":1,"stats":{"Line":2}},{"line":121,"address":[5872177,5872251,5871248],"length":1,"stats":{"Line":2}},{"line":124,"address":[5996747],"length":1,"stats":{"Line":2}},{"line":125,"address":[5996843,5996891],"length":1,"stats":{"Line":4}},{"line":126,"address":[3439848,3439936],"length":1,"stats":{"Line":4}},{"line":127,"address":[5997244,5997195],"length":1,"stats":{"Line":4}},{"line":129,"address":[5988190,5988044],"length":1,"stats":{"Line":4}},{"line":130,"address":[2783707,2783680],"length":1,"stats":{"Line":0}},{"line":132,"address":[6249047],"length":1,"stats":{"Line":2}},{"line":135,"address":[5872206],"length":1,"stats":{"Line":2}},{"line":139,"address":[5998731,5997728,5998657],"length":1,"stats":{"Line":2}},{"line":142,"address":[3440571],"length":1,"stats":{"Line":2}},{"line":144,"address":[5988635,5988683],"length":1,"stats":{"Line":6}},{"line":145,"address":[5929772,5929860],"length":1,"stats":{"Line":4}},{"line":146,"address":[5988987,5989036],"length":1,"stats":{"Line":4}},{"line":148,"address":[5989068,5989214],"length":1,"stats":{"Line":4}},{"line":149,"address":[2783808,2783835],"length":1,"stats":{"Line":0}},{"line":151,"address":[5930263],"length":1,"stats":{"Line":2}},{"line":154,"address":[5930398],"length":1,"stats":{"Line":2}}],"covered":49,"coverable":52},{"path":["/","home","imalison","Projects","lastfm-edit","src","headers.rs"],"content":"use http_client::Request;\n\n/// Common Chrome user agent string for all requests\nconst USER_AGENT: \u0026str = \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36\";\n\n/// Common Chrome headers for security info\nconst SEC_CH_UA: \u0026str =\n    \"\\\"Not)A;Brand\\\";v=\\\"8\\\", \\\"Chromium\\\";v=\\\"138\\\", \\\"Google Chrome\\\";v=\\\"138\\\"\";\nconst SEC_CH_UA_MOBILE: \u0026str = \"?0\";\nconst SEC_CH_UA_PLATFORM: \u0026str = \"\\\"Linux\\\"\";\n\n/// Add common browser headers to a request\npub fn add_common_headers(request: \u0026mut Request) {\n    let _ = request.insert_header(\"User-Agent\", USER_AGENT);\n    let _ = request.insert_header(\"Accept-Language\", \"en-US,en;q=0.9\");\n    let _ = request.insert_header(\"Accept-Encoding\", \"gzip, deflate, br\");\n    let _ = request.insert_header(\"DNT\", \"1\");\n    let _ = request.insert_header(\"Connection\", \"keep-alive\");\n    let _ = request.insert_header(\"sec-ch-ua\", SEC_CH_UA);\n    let _ = request.insert_header(\"sec-ch-ua-mobile\", SEC_CH_UA_MOBILE);\n    let _ = request.insert_header(\"sec-ch-ua-platform\", SEC_CH_UA_PLATFORM);\n}\n\n/// Add headers for HTML form login requests\npub fn add_login_headers(request: \u0026mut Request, login_url: \u0026str, base_url: \u0026str) {\n    add_common_headers(request);\n    let _ = request.insert_header(\"Referer\", login_url);\n    let _ = request.insert_header(\"Origin\", base_url);\n    let _ = request.insert_header(\"Content-Type\", \"application/x-www-form-urlencoded\");\n    let _ = request.insert_header(\n        \"Accept\",\n        \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\"\n    );\n    let _ = request.insert_header(\"Upgrade-Insecure-Requests\", \"1\");\n    let _ = request.insert_header(\"Sec-Fetch-Dest\", \"document\");\n    let _ = request.insert_header(\"Sec-Fetch-Mode\", \"navigate\");\n    let _ = request.insert_header(\"Sec-Fetch-Site\", \"same-origin\");\n    let _ = request.insert_header(\"Sec-Fetch-User\", \"?1\");\n}\n\n/// Add headers for AJAX form edit requests\npub fn add_edit_headers(request: \u0026mut Request, referer_url: \u0026str) {\n    add_common_headers(request);\n    let _ = request.insert_header(\"Accept\", \"*/*\");\n    let _ = request.insert_header(\n        \"Content-Type\",\n        \"application/x-www-form-urlencoded;charset=UTF-8\",\n    );\n    let _ = request.insert_header(\"Priority\", \"u=1, i\");\n    let _ = request.insert_header(\"X-Requested-With\", \"XMLHttpRequest\");\n    let _ = request.insert_header(\"Sec-Fetch-Dest\", \"empty\");\n    let _ = request.insert_header(\"Sec-Fetch-Mode\", \"cors\");\n    let _ = request.insert_header(\"Sec-Fetch-Site\", \"same-origin\");\n    let _ = request.insert_header(\"Referer\", referer_url);\n}\n\n/// Add headers for GET requests (regular pages or AJAX)\npub fn add_get_headers(request: \u0026mut Request, is_ajax: bool, referer_url: Option\u003c\u0026str\u003e) {\n    add_common_headers(request);\n\n    if is_ajax {\n        let _ = request.insert_header(\"Accept\", \"*/*\");\n        let _ = request.insert_header(\"X-Requested-With\", \"XMLHttpRequest\");\n    } else {\n        let _ = request.insert_header(\n            \"Accept\",\n            \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\"\n        );\n        let _ = request.insert_header(\"Upgrade-Insecure-Requests\", \"1\");\n    }\n\n    if let Some(referer) = referer_url {\n        let _ = request.insert_header(\"Referer\", referer);\n    }\n}\n\n/// Add cookies to a request if they exist\npub fn add_cookies(request: \u0026mut Request, cookies: \u0026[String]) {\n    if !cookies.is_empty() {\n        let cookie_header = cookies.join(\"; \");\n        let _ = request.insert_header(\"Cookie\", \u0026cookie_header);\n    }\n}\n","traces":[{"line":13,"address":[6092352],"length":1,"stats":{"Line":10}},{"line":14,"address":[5979431],"length":1,"stats":{"Line":9}},{"line":15,"address":[5840907],"length":1,"stats":{"Line":10}},{"line":16,"address":[5900703],"length":1,"stats":{"Line":9}},{"line":17,"address":[6092531],"length":1,"stats":{"Line":10}},{"line":18,"address":[21078032],"length":1,"stats":{"Line":9}},{"line":19,"address":[6092639],"length":1,"stats":{"Line":10}},{"line":20,"address":[2801581],"length":1,"stats":{"Line":9}},{"line":21,"address":[20643609,20643600],"length":1,"stats":{"Line":10}},{"line":25,"address":[5841296],"length":1,"stats":{"Line":0}},{"line":26,"address":[21393728],"length":1,"stats":{"Line":0}},{"line":27,"address":[2801788],"length":1,"stats":{"Line":0}},{"line":28,"address":[21393736],"length":1,"stats":{"Line":0}},{"line":29,"address":[5841477],"length":1,"stats":{"Line":0}},{"line":30,"address":[5980105],"length":1,"stats":{"Line":0}},{"line":34,"address":[5980163],"length":1,"stats":{"Line":0}},{"line":35,"address":[5901389],"length":1,"stats":{"Line":0}},{"line":36,"address":[5901447],"length":1,"stats":{"Line":0}},{"line":37,"address":[5841761],"length":1,"stats":{"Line":0}},{"line":38,"address":[21291168],"length":1,"stats":{"Line":0}},{"line":42,"address":[5901632],"length":1,"stats":{"Line":1}},{"line":43,"address":[2802318],"length":1,"stats":{"Line":1}},{"line":44,"address":[5716585],"length":1,"stats":{"Line":1}},{"line":45,"address":[6093517],"length":1,"stats":{"Line":1}},{"line":49,"address":[5842049],"length":1,"stats":{"Line":1}},{"line":50,"address":[5842101],"length":1,"stats":{"Line":1}},{"line":51,"address":[6093679],"length":1,"stats":{"Line":1}},{"line":52,"address":[5901961],"length":1,"stats":{"Line":1}},{"line":53,"address":[2802646],"length":1,"stats":{"Line":1}},{"line":54,"address":[5716983],"length":1,"stats":{"Line":1}},{"line":58,"address":[6093920],"length":1,"stats":{"Line":10}},{"line":59,"address":[5842446],"length":1,"stats":{"Line":9}},{"line":61,"address":[2802823],"length":1,"stats":{"Line":9}},{"line":62,"address":[2802940],"length":1,"stats":{"Line":3}},{"line":63,"address":[6094149],"length":1,"stats":{"Line":4}},{"line":65,"address":[5717105],"length":1,"stats":{"Line":7}},{"line":69,"address":[5902261],"length":1,"stats":{"Line":5}},{"line":72,"address":[5981252],"length":1,"stats":{"Line":10}},{"line":73,"address":[5981311],"length":1,"stats":{"Line":7}},{"line":78,"address":[5981591,5981360,5981597],"length":1,"stats":{"Line":6}},{"line":79,"address":[2803218],"length":1,"stats":{"Line":7}},{"line":80,"address":[5902614],"length":1,"stats":{"Line":7}},{"line":81,"address":[5902730,5902656],"length":1,"stats":{"Line":8}}],"covered":32,"coverable":43},{"path":["/","home","imalison","Projects","lastfm-edit","src","iterator.rs"],"content":"use crate::r#trait::LastFmEditClient;\nuse crate::{Album, AlbumPage, Result, Track, TrackPage};\n\nuse async_trait::async_trait;\n\n/// Async iterator trait for paginated Last.fm data.\n///\n/// This trait provides a common interface for iterating over paginated data from Last.fm,\n/// such as tracks, albums, and recent scrobbles. All iterators implement efficient streaming\n/// with automatic pagination and built-in rate limiting.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n///\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut tracks = client.artist_tracks(\"Radiohead\");\n///\n/// // Iterate one by one\n/// while let Some(track) = tracks.next().await? {\n///     println!(\"{}\", track.name);\n/// }\n///\n/// // Or collect a limited number\n/// let first_10 = tracks.take(10).await?;\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\n#[cfg_attr(feature = \"mock\", mockall::automock)]\n#[async_trait(?Send)]\npub trait AsyncPaginatedIterator\u003cT\u003e {\n    /// Fetch the next item from the iterator.\n    ///\n    /// This method automatically handles pagination, fetching new pages as needed.\n    /// Returns `None` when there are no more items available.\n    ///\n    /// # Returns\n    ///\n    /// - `Ok(Some(item))` - Next item in the sequence\n    /// - `Ok(None)` - No more items available\n    /// - `Err(...)` - Network or parsing error occurred\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cT\u003e\u003e;\n\n    /// Collect all remaining items into a Vec.\n    ///\n    /// **Warning**: This method will fetch ALL remaining pages, which could be\n    /// many thousands of items for large libraries. Use [`take`](Self::take) for\n    /// safer bounded collection.\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n    /// # tokio_test::block_on(async {\n    /// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n    /// let mut tracks = client.artist_tracks(\"Small Artist\");\n    /// let all_tracks = tracks.collect_all().await?;\n    /// println!(\"Found {} tracks total\", all_tracks.len());\n    /// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n    /// # });\n    /// ```\n    async fn collect_all(\u0026mut self) -\u003e Result\u003cVec\u003cT\u003e\u003e {\n        let mut items = Vec::new();\n        while let Some(item) = self.next().await? {\n            items.push(item);\n        }\n        Ok(items)\n    }\n\n    /// Take up to n items from the iterator.\n    ///\n    /// This is the recommended way to collect a bounded number of items\n    /// from potentially large datasets.\n    ///\n    /// # Arguments\n    ///\n    /// * `n` - Maximum number of items to collect\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n    /// # tokio_test::block_on(async {\n    /// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n    /// let mut tracks = client.artist_tracks(\"Radiohead\");\n    /// let top_20 = tracks.take(20).await?;\n    /// println!(\"Top 20 tracks: {:?}\", top_20);\n    /// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n    /// # });\n    /// ```\n    async fn take(\u0026mut self, n: usize) -\u003e Result\u003cVec\u003cT\u003e\u003e {\n        let mut items = Vec::new();\n        for _ in 0..n {\n            match self.next().await? {\n                Some(item) =\u003e items.push(item),\n                None =\u003e break,\n            }\n        }\n        Ok(items)\n    }\n\n    /// Get the current page number (0-indexed).\n    ///\n    /// Returns the page number of the most recently fetched page.\n    fn current_page(\u0026self) -\u003e u32;\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `Some(n)` if the total page count is known, `None` otherwise.\n    /// This information may not be available until at least one page has been fetched.\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        None // Default implementation returns None\n    }\n}\n\n/// Iterator for browsing an artist's tracks from a user's library.\n///\n/// This iterator provides access to all tracks by a specific artist\n/// in the authenticated user's Last.fm library. Unlike the basic track listing,\n/// this iterator fetches tracks by iterating through the artist's albums first,\n/// which provides complete album information for each track.\n///\n/// The iterator loads albums and their tracks as needed and handles rate limiting\n/// automatically to be respectful to Last.fm's servers.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut tracks = client.artist_tracks(\"The Beatles\");\n///\n/// // Get the top 5 tracks with album information\n/// let top_tracks = tracks.take(5).await?;\n/// for track in top_tracks {\n///     let album = track.album.as_deref().unwrap_or(\"Unknown Album\");\n///     println!(\"{} [{}] (played {} times)\", track.name, album, track.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct ArtistTracksIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    artist: String,\n    album_iterator: Option\u003cArtistAlbumsIterator\u003cC\u003e\u003e,\n    current_album_tracks: Option\u003cAlbumTracksIterator\u003cC\u003e\u003e,\n    track_buffer: Vec\u003cTrack\u003e,\n    finished: bool,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient + Clone\u003e AsyncPaginatedIterator\u003cTrack\u003e for ArtistTracksIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        // If we're finished, return None\n        if self.finished {\n            return Ok(None);\n        }\n\n        // If track buffer is empty, try to get more tracks\n        while self.track_buffer.is_empty() {\n            // If we don't have a current album tracks iterator, get the next album\n            if self.current_album_tracks.is_none() {\n                // Initialize album iterator if needed\n                if self.album_iterator.is_none() {\n                    self.album_iterator = Some(ArtistAlbumsIterator::new(\n                        self.client.clone(),\n                        self.artist.clone(),\n                    ));\n                }\n\n                // Get next album\n                if let Some(ref mut album_iter) = self.album_iterator {\n                    if let Some(album) = album_iter.next().await? {\n                        log::debug!(\n                            \"Processing album '{}' for artist '{}'\",\n                            album.name,\n                            self.artist\n                        );\n                        // Create album tracks iterator for this album\n                        self.current_album_tracks = Some(AlbumTracksIterator::new(\n                            self.client.clone(),\n                            album.name.clone(),\n                            self.artist.clone(),\n                        ));\n                    } else {\n                        // No more albums, we're done\n                        log::debug!(\"No more albums for artist '{}'\", self.artist);\n                        self.finished = true;\n                        return Ok(None);\n                    }\n                }\n            }\n\n            // Get tracks from current album\n            if let Some(ref mut album_tracks) = self.current_album_tracks {\n                if let Some(track) = album_tracks.next().await? {\n                    self.track_buffer.push(track);\n                } else {\n                    // This album is exhausted, move to next album\n                    log::debug!(\n                        \"Finished processing current album for artist '{}'\",\n                        self.artist\n                    );\n                    self.current_album_tracks = None;\n                    // Continue the loop to try getting the next album\n                }\n            }\n        }\n\n        // Return the next track from our buffer\n        Ok(self.track_buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        // Since we're iterating through albums, return the album iterator's current page\n        if let Some(ref album_iter) = self.album_iterator {\n            album_iter.current_page()\n        } else {\n            0\n        }\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        // Since we're iterating through albums, return the album iterator's total pages\n        if let Some(ref album_iter) = self.album_iterator {\n            album_iter.total_pages()\n        } else {\n            None\n        }\n    }\n}\n\nimpl\u003cC: LastFmEditClient + Clone\u003e ArtistTracksIterator\u003cC\u003e {\n    /// Create a new artist tracks iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::artist_tracks`](crate::LastFmEditClient::artist_tracks).\n    pub fn new(client: C, artist: String) -\u003e Self {\n        Self {\n            client,\n            artist,\n            album_iterator: None,\n            current_album_tracks: None,\n            track_buffer: Vec::new(),\n            finished: false,\n        }\n    }\n}\n\n/// Iterator for browsing an artist's tracks directly using the paginated artist tracks endpoint.\n///\n/// This iterator provides access to all tracks by a specific artist\n/// in the authenticated user's Last.fm library by directly using the\n/// `/user/{username}/library/music/{artist}/+tracks` endpoint with pagination.\n/// This is more efficient than the album-based approach as it doesn't need to\n/// iterate through albums first.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut tracks = client.artist_tracks_direct(\"The Beatles\");\n///\n/// // Get the first 10 tracks directly from the paginated endpoint\n/// let first_10_tracks = tracks.take(10).await?;\n/// for track in first_10_tracks {\n///     println!(\"{} (played {} times)\", track.name, track.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct ArtistTracksDirectIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    artist: String,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003cTrack\u003e,\n    total_pages: Option\u003cu32\u003e,\n    tracks_yielded: u32,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cTrack\u003e for ArtistTracksDirectIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if let Some(page) = self.next_page().await? {\n                self.buffer = page.tracks;\n                self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            }\n        }\n\n        if let Some(track) = self.buffer.pop() {\n            self.tracks_yielded += 1;\n            Ok(Some(track))\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e ArtistTracksDirectIterator\u003cC\u003e {\n    /// Create a new direct artist tracks iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::artist_tracks_direct`](crate::LastFmEditClient::artist_tracks_direct).\n    pub fn new(client: C, artist: String) -\u003e Self {\n        Self {\n            client,\n            artist,\n            current_page: 1,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n            tracks_yielded: 0,\n        }\n    }\n\n    /// Fetch the next page of tracks.\n    ///\n    /// This method handles pagination automatically and includes rate limiting.\n    pub async fn next_page(\u0026mut self) -\u003e Result\u003cOption\u003cTrackPage\u003e\u003e {\n        if !self.has_more {\n            return Ok(None);\n        }\n\n        log::debug!(\n            \"Fetching page {} of {} tracks (yielded {} tracks so far)\",\n            self.current_page,\n            self.artist,\n            self.tracks_yielded\n        );\n\n        let page = self\n            .client\n            .get_artist_tracks_page(\u0026self.artist, self.current_page)\n            .await?;\n\n        self.has_more = page.has_next_page;\n        self.current_page += 1;\n        self.total_pages = page.total_pages;\n\n        Ok(Some(page))\n    }\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `None` until at least one page has been fetched.\n    pub fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\n/// Iterator for browsing an artist's albums from a user's library.\n///\n/// This iterator provides paginated access to all albums by a specific artist\n/// in the authenticated user's Last.fm library, ordered by play count.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut albums = client.artist_albums(\"Pink Floyd\");\n///\n/// // Get all albums (be careful with large discographies!)\n/// while let Some(album) = albums.next().await? {\n///     println!(\"{} (played {} times)\", album.name, album.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct ArtistAlbumsIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    artist: String,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003cAlbum\u003e,\n    total_pages: Option\u003cu32\u003e,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cAlbum\u003e for ArtistAlbumsIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cAlbum\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if let Some(page) = self.next_page().await? {\n                self.buffer = page.albums;\n                self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            }\n        }\n\n        Ok(self.buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e ArtistAlbumsIterator\u003cC\u003e {\n    /// Create a new artist albums iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::artist_albums`](crate::LastFmEditClient::artist_albums).\n    pub fn new(client: C, artist: String) -\u003e Self {\n        Self {\n            client,\n            artist,\n            current_page: 1,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Fetch the next page of albums.\n    ///\n    /// This method handles pagination automatically and includes rate limiting.\n    pub async fn next_page(\u0026mut self) -\u003e Result\u003cOption\u003cAlbumPage\u003e\u003e {\n        if !self.has_more {\n            return Ok(None);\n        }\n\n        let page = self\n            .client\n            .get_artist_albums_page(\u0026self.artist, self.current_page)\n            .await?;\n\n        self.has_more = page.has_next_page;\n        self.current_page += 1;\n        self.total_pages = page.total_pages;\n\n        Ok(Some(page))\n    }\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `None` until at least one page has been fetched.\n    pub fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\n/// Iterator for browsing a user's recent tracks/scrobbles.\n///\n/// This iterator provides access to the user's recent listening history with timestamps,\n/// which is essential for finding tracks that can be edited. It supports optional\n/// timestamp-based filtering to avoid reprocessing old data.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// // Get recent tracks with timestamps\n/// let mut recent = client.recent_tracks();\n/// while let Some(track) = recent.next().await? {\n///     if let Some(timestamp) = track.timestamp {\n///         println!(\"{} - {} ({})\", track.artist, track.name, timestamp);\n///     }\n/// }\n///\n/// // Or stop at a specific timestamp to avoid reprocessing\n/// let last_processed = 1640995200;\n/// let mut recent = lastfm_edit::RecentTracksIterator::new(client).with_stop_timestamp(last_processed);\n/// let new_tracks = recent.collect_all().await?;\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct RecentTracksIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003cTrack\u003e,\n    stop_at_timestamp: Option\u003cu64\u003e,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cTrack\u003e for RecentTracksIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if !self.has_more {\n                return Ok(None);\n            }\n\n            let tracks = self.client.get_recent_scrobbles(self.current_page).await?;\n\n            if tracks.is_empty() {\n                self.has_more = false;\n                return Ok(None);\n            }\n\n            // Check if we should stop based on timestamp\n            if let Some(stop_timestamp) = self.stop_at_timestamp {\n                let mut filtered_tracks = Vec::new();\n                for track in tracks {\n                    if let Some(track_timestamp) = track.timestamp {\n                        if track_timestamp \u003c= stop_timestamp {\n                            self.has_more = false;\n                            break;\n                        }\n                    }\n                    filtered_tracks.push(track);\n                }\n                self.buffer = filtered_tracks;\n            } else {\n                self.buffer = tracks;\n            }\n\n            self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            self.current_page += 1;\n        }\n\n        Ok(self.buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e RecentTracksIterator\u003cC\u003e {\n    /// Create a new recent tracks iterator starting from page 1.\n    ///\n    /// This is typically called via [`LastFmEditClient::recent_tracks`](crate::LastFmEditClient::recent_tracks).\n    pub fn new(client: C) -\u003e Self {\n        Self::with_starting_page(client, 1)\n    }\n\n    /// Create a new recent tracks iterator starting from a specific page.\n    ///\n    /// This allows resuming pagination from an arbitrary page, useful for\n    /// continuing from where a previous iteration left off.\n    ///\n    /// # Arguments\n    ///\n    /// * `client` - The LastFmEditClient to use for API calls\n    /// * `starting_page` - The page number to start from (1-indexed)\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n    /// # tokio_test::block_on(async {\n    /// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n    ///\n    /// // Start from page 5\n    /// let mut recent = client.recent_tracks_from_page(5);\n    /// let tracks = recent.take(10).await?;\n    /// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n    /// # });\n    /// ```\n    pub fn with_starting_page(client: C, starting_page: u32) -\u003e Self {\n        let page = std::cmp::max(1, starting_page);\n        Self {\n            client,\n            current_page: page,\n            has_more: true,\n            buffer: Vec::new(),\n            stop_at_timestamp: None,\n        }\n    }\n\n    /// Set a timestamp to stop iteration at.\n    ///\n    /// When this is set, the iterator will stop returning tracks once it encounters\n    /// a track with a timestamp less than or equal to the specified value. This is\n    /// useful for incremental processing to avoid reprocessing old data.\n    ///\n    /// # Arguments\n    ///\n    /// * `timestamp` - Unix timestamp to stop at\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n    /// # tokio_test::block_on(async {\n    /// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n    /// let last_processed = 1640995200; // Some previous timestamp\n    ///\n    /// let mut recent = lastfm_edit::RecentTracksIterator::new(client).with_stop_timestamp(last_processed);\n    /// let new_tracks = recent.collect_all().await?; // Only gets new tracks\n    /// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n    /// # });\n    /// ```\n    pub fn with_stop_timestamp(mut self, timestamp: u64) -\u003e Self {\n        self.stop_at_timestamp = Some(timestamp);\n        self\n    }\n}\n\n/// Iterator for browsing tracks in a specific album from a user's library.\n///\n/// This iterator provides access to all tracks in a specific album by an artist\n/// in the authenticated user's Last.fm library. Unlike paginated iterators,\n/// this loads tracks once and iterates through them.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut tracks = client.album_tracks(\"The Dark Side of the Moon\", \"Pink Floyd\");\n///\n/// // Get all tracks in the album\n/// while let Some(track) = tracks.next().await? {\n///     println!(\"{} - {}\", track.name, track.artist);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct AlbumTracksIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    album_name: String,\n    artist_name: String,\n    tracks: Option\u003cVec\u003cTrack\u003e\u003e,\n    index: usize,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cTrack\u003e for AlbumTracksIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        // Load tracks if not already loaded\n        if self.tracks.is_none() {\n            // Use get_album_tracks_page instead of get_album_tracks to avoid infinite recursion\n            let tracks_page = self\n                .client\n                .get_album_tracks_page(\u0026self.album_name, \u0026self.artist_name, 1)\n                .await?;\n            log::debug!(\n                \"Album '{}' by '{}' has {} tracks: {:?}\",\n                self.album_name,\n                self.artist_name,\n                tracks_page.tracks.len(),\n                tracks_page\n                    .tracks\n                    .iter()\n                    .map(|t| \u0026t.name)\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n            );\n\n            if tracks_page.tracks.is_empty() {\n                log::warn!(\n                    \"ğŸš¨ ZERO TRACKS FOUND for album '{}' by '{}' - investigating...\",\n                    self.album_name,\n                    self.artist_name\n                );\n                log::debug!(\"Full TrackPage for empty album: has_next_page={}, page_number={}, total_pages={:?}\", \n                           tracks_page.has_next_page, tracks_page.page_number, tracks_page.total_pages);\n            }\n            self.tracks = Some(tracks_page.tracks);\n        }\n\n        // Return next track\n        if let Some(tracks) = \u0026self.tracks {\n            if self.index \u003c tracks.len() {\n                let track = tracks[self.index].clone();\n                self.index += 1;\n                Ok(Some(track))\n            } else {\n                Ok(None)\n            }\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        // Album tracks don't have pages, so return 0\n        0\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e AlbumTracksIterator\u003cC\u003e {\n    /// Create a new album tracks iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::album_tracks`](crate::LastFmEditClient::album_tracks).\n    pub fn new(client: C, album_name: String, artist_name: String) -\u003e Self {\n        Self {\n            client,\n            album_name,\n            artist_name,\n            tracks: None,\n            index: 0,\n        }\n    }\n}\n\n/// Iterator for searching tracks in the user's library.\n///\n/// This iterator provides paginated access to tracks that match a search query\n/// in the authenticated user's Last.fm library, using Last.fm's built-in search functionality.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut search_results = client.search_tracks(\"remaster\");\n///\n/// // Get first 20 search results\n/// while let Some(track) = search_results.next().await? {\n///     println!(\"{} - {} (played {} times)\", track.artist, track.name, track.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct SearchTracksIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    query: String,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003cTrack\u003e,\n    total_pages: Option\u003cu32\u003e,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cTrack\u003e for SearchTracksIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if let Some(page) = self.next_page().await? {\n                self.buffer = page.tracks;\n                self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            }\n        }\n\n        Ok(self.buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e SearchTracksIterator\u003cC\u003e {\n    /// Create a new search tracks iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::search_tracks`](crate::LastFmEditClient::search_tracks).\n    pub fn new(client: C, query: String) -\u003e Self {\n        Self {\n            client,\n            query,\n            current_page: 1,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Create a new search tracks iterator starting from a specific page.\n    ///\n    /// This is useful for implementing offset functionality efficiently by starting\n    /// at the appropriate page rather than iterating through all previous pages.\n    pub fn with_starting_page(client: C, query: String, starting_page: u32) -\u003e Self {\n        let page = std::cmp::max(1, starting_page);\n        Self {\n            client,\n            query,\n            current_page: page,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Fetch the next page of search results.\n    ///\n    /// This method handles pagination automatically and includes rate limiting\n    /// to be respectful to Last.fm's servers.\n    pub async fn next_page(\u0026mut self) -\u003e Result\u003cOption\u003cTrackPage\u003e\u003e {\n        if !self.has_more {\n            return Ok(None);\n        }\n\n        let page = self\n            .client\n            .search_tracks_page(\u0026self.query, self.current_page)\n            .await?;\n\n        self.has_more = page.has_next_page;\n        self.current_page += 1;\n        self.total_pages = page.total_pages;\n\n        Ok(Some(page))\n    }\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `None` until at least one page has been fetched.\n    pub fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\n/// Iterator for searching albums in the user's library.\n///\n/// This iterator provides paginated access to albums that match a search query\n/// in the authenticated user's Last.fm library, using Last.fm's built-in search functionality.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut search_results = client.search_albums(\"deluxe\");\n///\n/// // Get first 10 search results\n/// let top_10 = search_results.take(10).await?;\n/// for album in top_10 {\n///     println!(\"{} - {} (played {} times)\", album.artist, album.name, album.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct SearchAlbumsIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    query: String,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003cAlbum\u003e,\n    total_pages: Option\u003cu32\u003e,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cAlbum\u003e for SearchAlbumsIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cAlbum\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if let Some(page) = self.next_page().await? {\n                self.buffer = page.albums;\n                self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            }\n        }\n\n        Ok(self.buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e SearchAlbumsIterator\u003cC\u003e {\n    /// Create a new search albums iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::search_albums`](crate::LastFmEditClient::search_albums).\n    pub fn new(client: C, query: String) -\u003e Self {\n        Self {\n            client,\n            query,\n            current_page: 1,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Create a new search albums iterator starting from a specific page.\n    ///\n    /// This is useful for implementing offset functionality efficiently by starting\n    /// at the appropriate page rather than iterating through all previous pages.\n    pub fn with_starting_page(client: C, query: String, starting_page: u32) -\u003e Self {\n        let page = std::cmp::max(1, starting_page);\n        Self {\n            client,\n            query,\n            current_page: page,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Fetch the next page of search results.\n    ///\n    /// This method handles pagination automatically and includes rate limiting\n    /// to be respectful to Last.fm's servers.\n    pub async fn next_page(\u0026mut self) -\u003e Result\u003cOption\u003cAlbumPage\u003e\u003e {\n        if !self.has_more {\n            return Ok(None);\n        }\n\n        let page = self\n            .client\n            .search_albums_page(\u0026self.query, self.current_page)\n            .await?;\n\n        self.has_more = page.has_next_page;\n        self.current_page += 1;\n        self.total_pages = page.total_pages;\n\n        Ok(Some(page))\n    }\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `None` until at least one page has been fetched.\n    pub fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\n// =============================================================================\n// ARTISTS ITERATOR\n// =============================================================================\n\n/// Iterator for browsing all artists in the user's library.\n///\n/// This iterator provides access to all artists in the authenticated user's Last.fm library,\n/// sorted by play count (highest first). The iterator loads artists as needed and handles\n/// rate limiting automatically to be respectful to Last.fm's servers.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut artists = client.artists();\n///\n/// // Get the top 10 artists\n/// let top_artists = artists.take(10).await?;\n/// for artist in top_artists {\n///     println!(\"{} ({} plays)\", artist.name, artist.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct ArtistsIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003ccrate::Artist\u003e,\n    total_pages: Option\u003cu32\u003e,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003ccrate::Artist\u003e for ArtistsIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003ccrate::Artist\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if let Some(page) = self.next_page().await? {\n                self.buffer = page.artists;\n                self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            }\n        }\n\n        Ok(self.buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e ArtistsIterator\u003cC\u003e {\n    /// Create a new artists iterator.\n    ///\n    /// This iterator will start from page 1 and load all artists in the user's library.\n    pub fn new(client: C) -\u003e Self {\n        Self {\n            client,\n            current_page: 1,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Create a new artists iterator starting from a specific page.\n    ///\n    /// This is useful for implementing offset functionality efficiently by starting\n    /// at the appropriate page rather than iterating through all previous pages.\n    pub fn with_starting_page(client: C, starting_page: u32) -\u003e Self {\n        let page = std::cmp::max(1, starting_page);\n        Self {\n            client,\n            current_page: page,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Fetch the next page of artists.\n    ///\n    /// This method handles pagination automatically and includes rate limiting\n    /// to be respectful to Last.fm's servers.\n    pub async fn next_page(\u0026mut self) -\u003e Result\u003cOption\u003ccrate::ArtistPage\u003e\u003e {\n        if !self.has_more {\n            return Ok(None);\n        }\n\n        let page = self.client.get_artists_page(self.current_page).await?;\n\n        self.has_more = page.has_next_page;\n        self.current_page += 1;\n        self.total_pages = page.total_pages;\n\n        Ok(Some(page))\n    }\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `None` until at least one page has been fetched.\n    pub fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n","traces":[{"line":67,"address":[3101281,3109610,3109654,3099257,3099113,3109283,3101222,3102641,3103648,3107776,3103627,3099017,3103772,3105043,3102167,3102538,3105132,3105364,3099750,3105408,3106287,3104010,3106769,3107755,3108138,3110699,3099065,3099161,3099305,3102176,3103683,3107900,3109227,3106304,3109248,3109372,3099209,3106666,3106710,3108182,3104054,3098969,3107811,3100816,3100940,3099468,3101178,3102211,3106428,3099344,3100851,3102300,3099379,3106339,3105008,3105467,3109713,3099809,3102582,3104113,3104999,3108241,3100795,3099706],"length":1,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[5804524,5800320,5801756,5804583,5804940,5805751,5809805,5807271,5800295,5801057,5803510,5804231,5805345,5803233,5807564,5798716,5808385,5809143,5799132,5801815,5806103,5802477,5808791,5809168,5799943,5806460,5798775,5809084,5806044,5807648,5799537,5800236,5809452,5803174,5798423,5801840,5803258,5806865,5807623,5807980,5806128,5800652,5804608,5801463,5802887,5803831,5802124,5798800],"length":1,"stats":{"Line":0}},{"line":70,"address":[5633736,5627762,5632316,5626408,5626462,5630796,5623522,5629276,5632370,5630850,5623468,5633790,5625042,5629330,5624988,5627816],"length":1,"stats":{"Line":0}},{"line":72,"address":[5799586,5808434,5805394,5802526,5806914,5809854,5803878,5801106],"length":1,"stats":{"Line":0}},{"line":97,"address":[5821898,5818566,5818611,5812300,5820051,5810576,5821506,5817100,5812176,5812211,5811178,5812778,5810206,5810270,5810998,5813776,5815376,5816966,5820016,5818998,5813900,5820140,5818576,5820438,5813811,5821644,5810954,5818700,5815411,5820394,5821555,5815978,5817398,5810078,5817578,5820002,5810700,5816976,5810398,5815754,5815366,5810611,5810142,5823010,5822122,5810462,5815500,5821520,5819178,5810334,5810526,5815798,5814154,5821942,5812554,5814198,5817011,5814378,5817354,5812598,5813766,5818954,5820618,5812166],"length":1,"stats":{"Line":20}},{"line":98,"address":[5811032,5820472,5817432,5812632,5814232,5821976,5819032,5815832],"length":1,"stats":{"Line":5}},{"line":99,"address":[5641457,5644497,5636044,5638337,5635057,5641537,5646001,5636737,5635150,5644590,5644577,5636657,5639937,5639857,5637644,5646094,5643137,5643057,5646888,5638350,5638257,5642444,5641550,5643150,5645384,5635137,5646081,5636750,5639244,5639950,5640844,5643880],"length":1,"stats":{"Line":21}},{"line":100,"address":[5471508,5472548,5472868,5472228,5471924,5471140,5474612,5469924],"length":1,"stats":{"Line":12}},{"line":101,"address":[3112190,3122778,3112522,3118346,3119854,3118630,3123030,3115626,3113742,3114074,3121354,3121638,3115294,3120186,3117178,3116846],"length":1,"stats":{"Line":6}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[6190440,6188840,6193640,6195240,6199684,6196676,6192040,6198180],"length":1,"stats":{"Line":3}},{"line":117,"address":[5647056,5647024],"length":1,"stats":{"Line":0}},{"line":118,"address":[3123205,3123173],"length":1,"stats":{"Line":0}},{"line":162,"address":[6200553,6200680,6200315,6200073,6200112,6204565,6200506,6200171],"length":1,"stats":{"Line":4}},{"line":164,"address":[3123740],"length":1,"stats":{"Line":1}},{"line":165,"address":[5647661],"length":1,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":171,"address":[],"length":0,"stats":{"Line":2}},{"line":173,"address":[6202821,6202365],"length":1,"stats":{"Line":2}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":175,"address":[5649552,5649490],"length":1,"stats":{"Line":2}},{"line":176,"address":[5649560],"length":1,"stats":{"Line":1}},{"line":181,"address":[5461385,5461802,5463514],"length":1,"stats":{"Line":3}},{"line":182,"address":[3128155,3123866,3125950,3126012,3123513,3126060],"length":1,"stats":{"Line":3}},{"line":183,"address":[5826553,5826688,5826724],"length":1,"stats":{"Line":3}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[5651373,5651341,5651238],"length":1,"stats":{"Line":2}},{"line":190,"address":[5463028,5462646],"length":1,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":4}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":196,"address":[3126640,3127646,3127833],"length":1,"stats":{"Line":3}},{"line":197,"address":[3127656],"length":1,"stats":{"Line":1}},{"line":198,"address":[5463602],"length":1,"stats":{"Line":1}},{"line":204,"address":[5649156,5649332,5652140],"length":1,"stats":{"Line":3}},{"line":205,"address":[5645765],"length":1,"stats":{"Line":5}},{"line":206,"address":[],"length":0,"stats":{"Line":2}},{"line":209,"address":[6201508,6201713,6201656],"length":1,"stats":{"Line":3}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[5460984,5460648],"length":1,"stats":{"Line":1}},{"line":220,"address":[],"length":0,"stats":{"Line":2}},{"line":223,"address":[5464272],"length":1,"stats":{"Line":0}},{"line":225,"address":[6205310],"length":1,"stats":{"Line":0}},{"line":226,"address":[5652387],"length":1,"stats":{"Line":0}},{"line":228,"address":[5652399],"length":1,"stats":{"Line":0}},{"line":232,"address":[5953872],"length":1,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[5652483],"length":1,"stats":{"Line":0}},{"line":237,"address":[5828499],"length":1,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":2}},{"line":252,"address":[6165444],"length":1,"stats":{"Line":2}},{"line":296,"address":[5652865,5652537,5652576,5652713,5653142,5654376,5652909,5652611],"length":1,"stats":{"Line":4}},{"line":298,"address":[5829976,5828921],"length":1,"stats":{"Line":2}},{"line":299,"address":[6206039,6206144,6205976,6205716],"length":1,"stats":{"Line":2}},{"line":300,"address":[6206751,6206646],"length":1,"stats":{"Line":1}},{"line":301,"address":[6206871],"length":1,"stats":{"Line":1}},{"line":305,"address":[3130118,3128954,3129975,3130220],"length":1,"stats":{"Line":4}},{"line":306,"address":[],"length":0,"stats":{"Line":2}},{"line":307,"address":[5830202],"length":1,"stats":{"Line":1}},{"line":309,"address":[5654140],"length":1,"stats":{"Line":1}},{"line":313,"address":[5466480],"length":1,"stats":{"Line":0}},{"line":314,"address":[5466485],"length":1,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[5830565],"length":1,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":1}},{"line":332,"address":[],"length":0,"stats":{"Line":1}},{"line":341,"address":[3090853,3090520,3090528,3090512,3092152,3090569,3090674,3091460],"length":1,"stats":{"Line":4}},{"line":342,"address":[5613355],"length":1,"stats":{"Line":1}},{"line":343,"address":[],"length":0,"stats":{"Line":1}},{"line":346,"address":[3090760,3090951,3090904],"length":1,"stats":{"Line":3}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[5790070,5790132,5790365,5790436,5790532,5789614,5790898],"length":1,"stats":{"Line":5}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[6167028,6166607],"length":1,"stats":{"Line":2}},{"line":356,"address":[5614202,5614148,5614101,5613405,5614413,5614500],"length":1,"stats":{"Line":3}},{"line":358,"address":[3091885],"length":1,"stats":{"Line":1}},{"line":359,"address":[6167804,6167625],"length":1,"stats":{"Line":1}},{"line":360,"address":[3091971],"length":1,"stats":{"Line":1}},{"line":362,"address":[5916201],"length":1,"stats":{"Line":1}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[5830921,5830965,5831198,5830601,5832126,5830675,5830640,5830769],"length":1,"stats":{"Line":4}},{"line":408,"address":[],"length":0,"stats":{"Line":2}},{"line":409,"address":[5830796,5831056,5831119,5831224],"length":1,"stats":{"Line":3}},{"line":410,"address":[5957287,5957182],"length":1,"stats":{"Line":1}},{"line":411,"address":[3131823],"length":1,"stats":{"Line":1}},{"line":415,"address":[5956474,5957512],"length":1,"stats":{"Line":2}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[3132005],"length":1,"stats":{"Line":0}},{"line":422,"address":[3132032],"length":1,"stats":{"Line":0}},{"line":423,"address":[6209157],"length":1,"stats":{"Line":0}},{"line":431,"address":[3092557,3092176,3092539],"length":1,"stats":{"Line":2}},{"line":437,"address":[5426986],"length":1,"stats":{"Line":2}},{"line":445,"address":[3092874,3092592,3092714,3092584,3093704,3092627,3092576,3093036],"length":1,"stats":{"Line":6}},{"line":446,"address":[6168422],"length":1,"stats":{"Line":2}},{"line":447,"address":[5427458],"length":1,"stats":{"Line":1}},{"line":450,"address":[3092948,3093002,3093208,3092794,3093288,3093364,3093710],"length":1,"stats":{"Line":8}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[3092808,3092933],"length":1,"stats":{"Line":4}},{"line":453,"address":[6013828],"length":1,"stats":{"Line":5}},{"line":455,"address":[5616233],"length":1,"stats":{"Line":1}},{"line":456,"address":[5792428,5792258],"length":1,"stats":{"Line":2}},{"line":457,"address":[],"length":0,"stats":{"Line":2}},{"line":459,"address":[5917801],"length":1,"stats":{"Line":1}},{"line":465,"address":[5616512],"length":1,"stats":{"Line":0}},{"line":466,"address":[5616517],"length":1,"stats":{"Line":0}},{"line":509,"address":[5832601,5832217,5832399,5834580,5832256,5832557,5832291,5832910],"length":1,"stats":{"Line":4}},{"line":511,"address":[5470777,5468565],"length":1,"stats":{"Line":4}},{"line":512,"address":[5656692],"length":1,"stats":{"Line":1}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[3358996],"length":1,"stats":{"Line":2}},{"line":518,"address":[3133143,3133199],"length":1,"stats":{"Line":3}},{"line":519,"address":[3133232],"length":1,"stats":{"Line":0}},{"line":520,"address":[5469392],"length":1,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":4}},{"line":525,"address":[5959084],"length":1,"stats":{"Line":0}},{"line":526,"address":[5658000,5657865,5657752],"length":1,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[5658113],"length":1,"stats":{"Line":0}},{"line":529,"address":[3134063],"length":1,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[5470527,5470074],"length":1,"stats":{"Line":0}},{"line":535,"address":[5834392,5834325],"length":1,"stats":{"Line":0}},{"line":537,"address":[5959103,5960064],"length":1,"stats":{"Line":2}},{"line":540,"address":[3134303,3134518],"length":1,"stats":{"Line":4}},{"line":541,"address":[3134586,3134525],"length":1,"stats":{"Line":3}},{"line":544,"address":[5958110,5960306],"length":1,"stats":{"Line":5}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[5616544],"length":1,"stats":{"Line":2}},{"line":557,"address":[5616552],"length":1,"stats":{"Line":2}},{"line":584,"address":[],"length":0,"stats":{"Line":2}},{"line":585,"address":[3093918,3093832],"length":1,"stats":{"Line":4}},{"line":590,"address":[],"length":0,"stats":{"Line":3}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[5835024,5835183,5835874,5838682,5834985,5835353,5835071,5835400],"length":1,"stats":{"Line":4}},{"line":660,"address":[5835415,5838221],"length":1,"stats":{"Line":2}},{"line":662,"address":[],"length":0,"stats":{"Line":5}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[5961015,5961109],"length":1,"stats":{"Line":2}},{"line":665,"address":[5659213,5659900,5660198,5659784,5659843,5660111],"length":1,"stats":{"Line":5}},{"line":666,"address":[5836720],"length":1,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[5961926,5962624],"length":1,"stats":{"Line":3}},{"line":679,"address":[3137056,3136959],"length":1,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[5962787,5963164],"length":1,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":2}},{"line":691,"address":[],"length":0,"stats":{"Line":3}},{"line":692,"address":[5662613,5662332,5662375,5662242],"length":1,"stats":{"Line":5}},{"line":693,"address":[6215361,6215447],"length":1,"stats":{"Line":3}},{"line":694,"address":[3138150,3138290],"length":1,"stats":{"Line":2}},{"line":695,"address":[3138207],"length":1,"stats":{"Line":1}},{"line":697,"address":[5662337],"length":1,"stats":{"Line":1}},{"line":700,"address":[5474234],"length":1,"stats":{"Line":0}},{"line":704,"address":[5964192],"length":1,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[5918496],"length":1,"stats":{"Line":1}},{"line":758,"address":[5474784,5474913,5475065,5475109,5475342,5476270,5474819,5474745],"length":1,"stats":{"Line":4}},{"line":760,"address":[5840224,5839169],"length":1,"stats":{"Line":2}},{"line":761,"address":[5662988,5663416,5663248,5663311],"length":1,"stats":{"Line":2}},{"line":762,"address":[5663918,5664023],"length":1,"stats":{"Line":1}},{"line":763,"address":[3139759],"length":1,"stats":{"Line":1}},{"line":767,"address":[3139852,3138866],"length":1,"stats":{"Line":2}},{"line":770,"address":[6217312],"length":1,"stats":{"Line":0}},{"line":771,"address":[5840341],"length":1,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[6217349],"length":1,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":1}},{"line":789,"address":[],"length":0,"stats":{"Line":1}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":799,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[5617648,5617656,5618120,5618812,5617946,5617699,5617664,5617786],"length":1,"stats":{"Line":4}},{"line":815,"address":[5429718],"length":1,"stats":{"Line":1}},{"line":816,"address":[5617826],"length":1,"stats":{"Line":1}},{"line":819,"address":[5794368,5794818,5794300,5794082,5794020,5793866,5794464],"length":1,"stats":{"Line":5}},{"line":820,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[6170856,6170981],"length":1,"stats":{"Line":2}},{"line":822,"address":[5618146,5618432,5617813,5618348,5618051,5618095],"length":1,"stats":{"Line":3}},{"line":824,"address":[6171529],"length":1,"stats":{"Line":1}},{"line":825,"address":[3095730,3095900],"length":1,"stats":{"Line":1}},{"line":826,"address":[],"length":0,"stats":{"Line":1}},{"line":828,"address":[5430617],"length":1,"stats":{"Line":1}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[5965865,5966462,5966033,5966229,5966185,5967390,5965904,5965939],"length":1,"stats":{"Line":5}},{"line":875,"address":[5841840,5840785],"length":1,"stats":{"Line":2}},{"line":876,"address":[5966383,5966060,5966320,5966488],"length":1,"stats":{"Line":2}},{"line":877,"address":[5966990,5967095],"length":1,"stats":{"Line":1}},{"line":878,"address":[5967215],"length":1,"stats":{"Line":1}},{"line":882,"address":[5840826,5841864],"length":1,"stats":{"Line":2}},{"line":885,"address":[5665952],"length":1,"stats":{"Line":0}},{"line":886,"address":[5665957],"length":1,"stats":{"Line":0}},{"line":889,"address":[5967440],"length":1,"stats":{"Line":0}},{"line":890,"address":[5477941],"length":1,"stats":{"Line":0}},{"line":898,"address":[5794832,5795221,5795199],"length":1,"stats":{"Line":1}},{"line":904,"address":[5618954],"length":1,"stats":{"Line":1}},{"line":913,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":920,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[5795248,5795299,5795256,5795720,5795264,5796412,5795386,5795546],"length":1,"stats":{"Line":4}},{"line":930,"address":[6172342],"length":1,"stats":{"Line":1}},{"line":931,"address":[6172402],"length":1,"stats":{"Line":1}},{"line":934,"address":[5796418,5795466,5795620,5795968,5795682,5795900,5796064],"length":1,"stats":{"Line":5}},{"line":935,"address":[],"length":0,"stats":{"Line":0}},{"line":936,"address":[5619480,5619605],"length":1,"stats":{"Line":2}},{"line":937,"address":[5637108],"length":1,"stats":{"Line":3}},{"line":939,"address":[5796153],"length":1,"stats":{"Line":1}},{"line":940,"address":[5796348,5796178],"length":1,"stats":{"Line":1}},{"line":941,"address":[6173206],"length":1,"stats":{"Line":1}},{"line":943,"address":[5796265],"length":1,"stats":{"Line":1}},{"line":949,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":0}},{"line":992,"address":[],"length":0,"stats":{"Line":8}},{"line":994,"address":[5666395,5667436],"length":1,"stats":{"Line":3}},{"line":995,"address":[5666636,5666220,5666531,5666468],"length":1,"stats":{"Line":3}},{"line":996,"address":[6220216,6220114],"length":1,"stats":{"Line":1}},{"line":997,"address":[5843360],"length":1,"stats":{"Line":1}},{"line":1001,"address":[5478385,5479412],"length":1,"stats":{"Line":2}},{"line":1004,"address":[6220512],"length":1,"stats":{"Line":0}},{"line":1005,"address":[3143029],"length":1,"stats":{"Line":0}},{"line":1008,"address":[5667568],"length":1,"stats":{"Line":0}},{"line":1009,"address":[5479525],"length":1,"stats":{"Line":0}},{"line":1017,"address":[],"length":0,"stats":{"Line":2}},{"line":1022,"address":[6173507],"length":1,"stats":{"Line":2}},{"line":1031,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":0}},{"line":1046,"address":[5922216,5922259,5923322,5922208,5922346,5922630,5922507,5922224],"length":1,"stats":{"Line":5}},{"line":1047,"address":[3097974],"length":1,"stats":{"Line":1}},{"line":1048,"address":[5620930],"length":1,"stats":{"Line":0}},{"line":1051,"address":[3349908],"length":1,"stats":{"Line":2}},{"line":1053,"address":[5797607],"length":1,"stats":{"Line":1}},{"line":1054,"address":[3098874,3098704],"length":1,"stats":{"Line":1}},{"line":1055,"address":[5433636],"length":1,"stats":{"Line":1}},{"line":1057,"address":[],"length":0,"stats":{"Line":1}},{"line":1063,"address":[],"length":0,"stats":{"Line":0}},{"line":1064,"address":[],"length":0,"stats":{"Line":0}}],"covered":152,"coverable":258},{"path":["/","home","imalison","Projects","lastfm-edit","src","lib.rs"],"content":"//! # lastfm-edit\n//!\n//! A Rust crate for programmatic access to Last.fm's scrobble editing functionality via web scraping.\n//!\n//! This crate provides a high-level interface for authenticating with Last.fm, browsing user libraries,\n//! and performing bulk edits on scrobbled tracks. It uses web scraping to access functionality not\n//! available through Last.fm's public API.\n//!\n//! ## Features\n//!\n//! - **Authentication**: Login to Last.fm with username/password\n//! - **Library browsing**: Paginated access to tracks, albums, and recent scrobbles\n//! - **Bulk editing**: Edit track names, artist names, and album information\n//! - **Async iterators**: Stream large datasets efficiently\n//! - **HTTP client abstraction**: Works with any HTTP client implementation\n//!\n//! ## Quick Start\n//!\n//! ```rust,no_run\n//! use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, AsyncPaginatedIterator, Result};\n//!\n//! #[tokio::main]\n//! async fn main() -\u003e Result\u003c()\u003e {\n//!     // Create HTTP client and login\n//!     let http_client = http_client::native::NativeClient::new();\n//!     let client = LastFmEditClientImpl::login_with_credentials(\n//!         Box::new(http_client),\n//!         \"username\",\n//!         \"password\"\n//!     ).await?;\n//!\n//!     // Browse recent tracks\n//!     let mut recent_tracks = client.recent_tracks();\n//!     while let Some(track) = recent_tracks.next().await? {\n//!         println!(\"{} - {}\", track.artist, track.name);\n//!     }\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ## Core Components\n//!\n//! - [`LastFmEditClient`] - Main client trait for interacting with Last.fm\n//! - [`Track`], [`Album`] - Data structures for music metadata\n//! - [`AsyncPaginatedIterator`] - Trait for streaming paginated data\n//! - [`ScrobbleEdit`] - Represents track edit operations\n//! - [`LastFmError`] - Error types for the crate\n//!\n//! ## Installation\n//!\n//! Add this to your `Cargo.toml`:\n//! ```toml\n//! [dependencies]\n//! lastfm-edit = \"3.1.0\"\n//! http-client = { version = \"^6.6.3\", package = \"http-client-2\", features = [\"curl_client\"] }\n//! tokio = { version = \"1.0\", features = [\"full\"] }\n//! ```\n//!\n//! ## Usage Patterns\n//!\n//! ### Basic Library Browsing\n//!\n//! ```rust,no_run\n//! use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, AsyncPaginatedIterator, Result};\n//!\n//! #[tokio::main]\n//! async fn main() -\u003e Result\u003c()\u003e {\n//!     let http_client = http_client::native::NativeClient::new();\n//!     let client = LastFmEditClientImpl::login_with_credentials(\n//!         Box::new(http_client),\n//!         \"username\",\n//!         \"password\"\n//!     ).await?;\n//!\n//!     // Get all tracks by an artist\n//!     let mut tracks = client.artist_tracks(\"Radiohead\");\n//!     while let Some(track) = tracks.next().await? {\n//!         println!(\"{} - {}\", track.artist, track.name);\n//!     }\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ### Bulk Track Editing\n//!\n//! ```rust,no_run\n//! use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, ScrobbleEdit, AsyncPaginatedIterator, Result};\n//!\n//! #[tokio::main]\n//! async fn main() -\u003e Result\u003c()\u003e {\n//!     let http_client = http_client::native::NativeClient::new();\n//!     let client = LastFmEditClientImpl::login_with_credentials(\n//!         Box::new(http_client),\n//!         \"username\",\n//!         \"password\"\n//!     ).await?;\n//!\n//!     // Find and edit tracks\n//!     let tracks = client.artist_tracks(\"Artist Name\").collect_all().await?;\n//!     for track in tracks {\n//!         if track.name.contains(\"(Remaster)\") {\n//!             let new_name = track.name.replace(\" (Remaster)\", \"\");\n//!\n//!             // Create edit for this track\n//!             let edit = ScrobbleEdit::from_track_info(\n//!                 \u0026track.name,\n//!                 \u0026track.name, // Use track name as album fallback\n//!                 \u0026track.artist,\n//!                 0 // No timestamp needed for bulk edit\n//!             )\n//!             .with_track_name(\u0026new_name)\n//!             .with_edit_all(true);\n//!\n//!             let response = client.edit_scrobble(\u0026edit).await?;\n//!             if response.success() {\n//!                 println!(\"Successfully edited: {} -\u003e {}\", track.name, new_name);\n//!             }\n//!         }\n//!     }\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ### Recent Tracks Monitoring\n//!\n//! ```rust,no_run\n//! use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, AsyncPaginatedIterator, Result};\n//!\n//! #[tokio::main]\n//! async fn main() -\u003e Result\u003c()\u003e {\n//!     let http_client = http_client::native::NativeClient::new();\n//!     let client = LastFmEditClientImpl::login_with_credentials(\n//!         Box::new(http_client),\n//!         \"username\",\n//!         \"password\"\n//!     ).await?;\n//!\n//!     // Get recent tracks (first 100)\n//!     let recent_tracks = client.recent_tracks().take(100).await?;\n//!     println!(\"Found {} recent tracks\", recent_tracks.len());\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ### Mocking for Testing\n//!\n//! Enable the `mock` feature to use `MockLastFmEditClient` for testing:\n//!\n//! ```toml\n//! [dev-dependencies]\n//! lastfm-edit = { version = \"3.1.0\", features = [\"mock\"] }\n//! mockall = \"0.13\"\n//! ```\n//!\n//! ```rust,ignore\n//! #[cfg(feature = \"mock\")]\n//! mod tests {\n//!     use lastfm_edit::{LastFmEditClient, MockLastFmEditClient, Result, EditResponse, ScrobbleEdit};\n//!     use mockall::predicate::*;\n//!\n//!     #[tokio::test]\n//!     async fn test_edit_workflow() -\u003e Result\u003c()\u003e {\n//!         let mut mock_client = MockLastFmEditClient::new();\n//!\n//!         // Set up expectations\n//!         mock_client\n//!             .expect_login()\n//!             .with(eq(\"testuser\"), eq(\"testpass\"))\n//!             .times(1)\n//!             .returning(|_, _| Ok(()));\n//!\n//!         mock_client\n//!             .expect_edit_scrobble()\n//!             .times(1)\n//!             .returning(|_| Ok(EditResponse {\n//!                 success: true,\n//!                 message: Some(\"Edit successful\".to_string()),\n//!             }));\n//!\n//!         // Use as trait object\n//!         let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n//!\n//!         client.login(\"testuser\", \"testpass\").await?;\n//!\n//!         let edit = ScrobbleEdit::new(\n//!             Some(\"Old Track\".to_string()),\n//!             Some(\"Old Album\".to_string()),\n//!             Some(\"Old Artist\".to_string()),\n//!             Some(\"Old Artist\".to_string()),\n//!             \"New Track\".to_string(),\n//!             \"New Album\".to_string(),\n//!             \"New Artist\".to_string(),\n//!             \"New Artist\".to_string(),\n//!             1640995200,\n//!             false,\n//!         );\n//!\n//!         let response = client.edit_scrobble(\u0026edit).await?;\n//!         assert!(response.success);\n//!\n//!         Ok(())\n//!     }\n//! }\n//! ```\n//!\n//! ## License\n//!\n//! MIT\n\npub mod client;\npub mod discovery;\npub mod edit_analysis;\npub mod headers;\npub mod iterator;\npub mod login;\npub mod parsing;\npub mod retry;\npub mod session_persistence;\npub mod r#trait;\npub mod types;\npub mod vcr_form_data;\npub mod vcr_matcher;\npub mod vcr_test_utils;\n\npub use client::LastFmEditClientImpl;\npub use discovery::{\n    AlbumTracksDiscovery, ArtistTracksDiscovery, AsyncDiscoveryIterator, ExactMatchDiscovery,\n    TrackVariationsDiscovery,\n};\npub use login::LoginManager;\npub use r#trait::LastFmEditClient;\n\n// Re-export all types from the consolidated types module\npub use iterator::AsyncPaginatedIterator;\npub use types::{\n    Album, AlbumPage, Artist, ArtistPage, ClientConfig, ClientEvent, ClientEventReceiver,\n    ClientEventWatcher, EditResponse, ExactScrobbleEdit, LastFmEditSession, LastFmError,\n    OperationalDelayConfig, RateLimitConfig, RateLimitType, RequestInfo, RetryConfig, RetryResult,\n    ScrobbleEdit, SharedEventBroadcaster, SingleEditResponse, Track, TrackPage,\n};\n\n// Type aliases for iterators with the concrete client type\npub type ArtistsIterator = iterator::ArtistsIterator\u003cLastFmEditClientImpl\u003e;\npub type ArtistTracksIterator = iterator::ArtistTracksIterator\u003cLastFmEditClientImpl\u003e;\npub type ArtistTracksDirectIterator = iterator::ArtistTracksDirectIterator\u003cLastFmEditClientImpl\u003e;\npub type ArtistAlbumsIterator = iterator::ArtistAlbumsIterator\u003cLastFmEditClientImpl\u003e;\npub type AlbumTracksIterator = iterator::AlbumTracksIterator\u003cLastFmEditClientImpl\u003e;\npub type RecentTracksIterator = iterator::RecentTracksIterator\u003cLastFmEditClientImpl\u003e;\npub type SearchTracksIterator = iterator::SearchTracksIterator\u003cLastFmEditClientImpl\u003e;\npub type SearchAlbumsIterator = iterator::SearchAlbumsIterator\u003cLastFmEditClientImpl\u003e;\n#[cfg(feature = \"mock\")]\npub use r#trait::MockLastFmEditClient;\n\n// Re-export the mock iterator when the mock feature is enabled\n#[cfg(feature = \"mock\")]\npub use iterator::MockAsyncPaginatedIterator;\npub use session_persistence::{SessionManager, SessionPersistence};\n\n// Re-export scraper types for testing\npub use scraper::Html;\n\n/// A convenient type alias for [`Result`] with [`LastFmError`] as the error type.\npub type Result\u003cT\u003e = std::result::Result\u003cT, LastFmError\u003e;\n","traces":[{"line":247,"address":[24074421,24071557,24072336,24074343,24071623,24072270,24073406,24073472],"length":1,"stats":{"Line":4}},{"line":248,"address":[27439404],"length":1,"stats":{"Line":3}},{"line":249,"address":[22069014,22068980],"length":1,"stats":{"Line":1}},{"line":250,"address":[16812232,16812264],"length":1,"stats":{"Line":2}},{"line":251,"address":[22907088,22907109,22907104,22907093,22907120,22907137],"length":1,"stats":{"Line":6}},{"line":252,"address":[25148512,25148518,25148570],"length":1,"stats":{"Line":1}},{"line":253,"address":[24024492],"length":1,"stats":{"Line":1}},{"line":254,"address":[29141763,29144816,29142899,29141050,29140992,29143776,29141712,29142848,29143842,29144898],"length":1,"stats":{"Line":2}},{"line":267,"address":[29279765],"length":1,"stats":{"Line":2}}],"covered":9,"coverable":9},{"path":["/","home","imalison","Projects","lastfm-edit","src","login.rs"],"content":"use crate::types::{LastFmEditSession, LastFmError};\nuse crate::Result;\nuse http_client::{HttpClient, Request};\nuse http_types::{Method, Url};\nuse scraper::{Html, Selector};\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\n/// Login functionality separated from the main client\npub struct LoginManager {\n    client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n    base_url: String,\n}\n\nimpl LoginManager {\n    pub fn new(client: Arc\u003cdyn HttpClient + Send + Sync\u003e, base_url: String) -\u003e Self {\n        Self { client, base_url }\n    }\n\n    /// Authenticate with Last.fm using username and password.\n    ///\n    /// This method:\n    /// 1. Fetches the login page to extract CSRF tokens\n    /// 2. Submits the login form with credentials\n    /// 3. Validates the authentication by checking for session cookies\n    /// 4. Returns a valid session for use with the client\n    ///\n    /// # Arguments\n    ///\n    /// * `username` - Last.fm username or email\n    /// * `password` - Last.fm password\n    ///\n    /// # Returns\n    ///\n    /// Returns a [`LastFmEditSession`] on successful authentication, or [`LastFmError::Auth`] on failure.\n    pub async fn login(\u0026self, username: \u0026str, password: \u0026str) -\u003e Result\u003cLastFmEditSession\u003e {\n        log::info!(\"ğŸ” Starting Last.fm login for username: {username}\");\n\n        // Step 1: Fetch login page and extract CSRF token and cookies\n        let login_url = format!(\"{}/login\", self.base_url);\n        let (csrf_token, next_field, mut cookies) = self.fetch_login_page(\u0026login_url).await?;\n\n        // Step 2: Submit login form\n        let response = self\n            .submit_login_form(\n                \u0026login_url,\n                username,\n                password,\n                \u0026csrf_token,\n                \u0026next_field,\n                \u0026cookies,\n            )\n            .await?;\n\n        // Step 3: Extract cookies from login response\n        extract_cookies_from_response(\u0026response, \u0026mut cookies);\n        log::debug!(\"ğŸª Cookies after login response: {cookies:?}\");\n\n        // Step 4: Validate login response\n        self.validate_login_response(response, username, cookies, csrf_token)\n            .await\n    }\n\n    /// Fetch the login page and extract CSRF token, next field, and cookies\n    async fn fetch_login_page(\n        \u0026self,\n        login_url: \u0026str,\n    ) -\u003e Result\u003c(String, Option\u003cString\u003e, Vec\u003cString\u003e)\u003e {\n        log::debug!(\"ğŸ“¡ Fetching login page: {login_url}\");\n        let mut response = self.get(login_url).await?;\n\n        log::debug!(\"ğŸ“‹ Login page response status: {}\", response.status());\n        log::debug!(\n            \"ğŸ“‹ Login page response headers: {:?}\",\n            response.iter().collect::\u003cVec\u003c_\u003e\u003e()\n        );\n\n        // Extract cookies from the login page response\n        let mut cookies = Vec::new();\n        extract_cookies_from_response(\u0026response, \u0026mut cookies);\n        log::debug!(\"ğŸª Initial cookies from login page: {cookies:?}\");\n\n        // Read and parse the HTML response\n        let html = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\"ğŸ“„ Login page HTML length: {} chars\", html.len());\n        if html.len() \u003c 500 {\n            log::debug!(\"ğŸ“„ Login page HTML content (short): {html}\");\n        }\n\n        // Extract CSRF token and next field from form\n        let (csrf_token, next_field) = self.extract_login_form_data(\u0026html)?;\n        log::debug!(\"ğŸ”‘ Extracted CSRF token: {csrf_token}\",);\n        log::debug!(\"â¡ï¸  Next field: {next_field:?}\");\n\n        Ok((csrf_token, next_field, cookies))\n    }\n\n    /// Submit the login form with credentials\n    async fn submit_login_form(\n        \u0026self,\n        login_url: \u0026str,\n        username: \u0026str,\n        password: \u0026str,\n        csrf_token: \u0026str,\n        next_field: \u0026Option\u003cString\u003e,\n        cookies: \u0026[String],\n    ) -\u003e Result\u003chttp_types::Response\u003e {\n        // Prepare form data\n        let mut form_data = HashMap::new();\n        form_data.insert(\"csrfmiddlewaretoken\", csrf_token);\n        form_data.insert(\"username_or_email\", username);\n        form_data.insert(\"password\", password);\n\n        if let Some(ref next_value) = next_field {\n            form_data.insert(\"next\", next_value);\n            log::debug!(\"â¡ï¸  Including next field in form: {next_value}\");\n        }\n\n        log::debug!(\n            \"ğŸ“ Form data fields: {:?}\",\n            form_data.keys().collect::\u003cVec\u003c_\u003e\u003e()\n        );\n        log::debug!(\"ğŸ“ Form username: {username}\");\n        log::debug!(\"ğŸ“ Form password length: {} chars\", password.len());\n\n        // Create and configure the POST request\n        let mut request = self.create_login_request(login_url, cookies)?;\n\n        // Convert form data to URL-encoded string\n        let form_string: String = form_data\n            .iter()\n            .map(|(k, v)| format!(\"{}={}\", urlencoding::encode(k), urlencoding::encode(v)))\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\u0026\");\n\n        log::debug!(\"ğŸ“¤ Sending POST request to: {login_url}\");\n        log::debug!(\"ğŸ“¤ Form body length: {} chars\", form_string.len());\n        log::debug!(\"ğŸ“¤ Form body (masked): {form_string}\");\n        log::debug!(\"ğŸ“¤ Request headers: Referer={}, Origin={}, Content-Type=application/x-www-form-urlencoded\", \n            login_url, \u0026self.base_url);\n\n        request.set_body(form_string);\n\n        // Send the request\n        let response = self\n            .client\n            .send(request)\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\"ğŸ“¥ Login response status: {}\", response.status());\n        log::debug!(\n            \"ğŸ“¥ Login response headers: {:?}\",\n            response.iter().collect::\u003cVec\u003c_\u003e\u003e()\n        );\n\n        Ok(response)\n    }\n\n    /// Create and configure the login POST request with all necessary headers\n    fn create_login_request(\u0026self, login_url: \u0026str, cookies: \u0026[String]) -\u003e Result\u003cRequest\u003e {\n        let mut request = Request::new(Method::Post, login_url.parse::\u003cUrl\u003e().unwrap());\n\n        // Set all the required headers\n        let _ = request.insert_header(\"Referer\", login_url);\n        let _ = request.insert_header(\"Origin\", \u0026self.base_url);\n        let _ = request.insert_header(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        let _ = request.insert_header(\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36\"\n        );\n        let _ = request.insert_header(\n            \"Accept\",\n            \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\"\n        );\n        let _ = request.insert_header(\"Accept-Language\", \"en-US,en;q=0.9\");\n        let _ = request.insert_header(\"Accept-Encoding\", \"gzip, deflate, br\");\n        let _ = request.insert_header(\"DNT\", \"1\");\n        let _ = request.insert_header(\"Connection\", \"keep-alive\");\n        let _ = request.insert_header(\"Upgrade-Insecure-Requests\", \"1\");\n        let _ = request.insert_header(\n            \"sec-ch-ua\",\n            \"\\\"Not)A;Brand\\\";v=\\\"8\\\", \\\"Chromium\\\";v=\\\"138\\\", \\\"Google Chrome\\\";v=\\\"138\\\"\",\n        );\n        let _ = request.insert_header(\"sec-ch-ua-mobile\", \"?0\");\n        let _ = request.insert_header(\"sec-ch-ua-platform\", \"\\\"Linux\\\"\");\n        let _ = request.insert_header(\"Sec-Fetch-Dest\", \"document\");\n        let _ = request.insert_header(\"Sec-Fetch-Mode\", \"navigate\");\n        let _ = request.insert_header(\"Sec-Fetch-Site\", \"same-origin\");\n        let _ = request.insert_header(\"Sec-Fetch-User\", \"?1\");\n\n        // Add cookies if we have any\n        if !cookies.is_empty() {\n            let cookie_header = cookies.join(\"; \");\n            let _ = request.insert_header(\"Cookie\", \u0026cookie_header);\n        }\n\n        Ok(request)\n    }\n\n    /// Validate the login response and return a session if successful\n    async fn validate_login_response(\n        \u0026self,\n        mut response: http_types::Response,\n        username: \u0026str,\n        cookies: Vec\u003cString\u003e,\n        csrf_token: String,\n    ) -\u003e Result\u003cLastFmEditSession\u003e {\n        // Handle 403 Forbidden responses (likely CSRF failures)\n        if response.status() == 403 {\n            return self.handle_403_response(response).await;\n        }\n\n        // Check for successful session establishment\n        if let Some(session) =\n            self.check_session_success(\u0026response, username, \u0026cookies, \u0026csrf_token)\n        {\n            return Ok(session);\n        }\n\n        // For other cases, analyze the response body\n        let response_html = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"ğŸ“„ Login response HTML length: {} chars\",\n            response_html.len()\n        );\n        if response_html.len() \u003c 500 {\n            log::debug!(\"ğŸ“„ Login response HTML content (short): {response_html}\");\n        }\n\n        // Check if we were redirected away from login page (success indicator)\n        let has_login_form = self.check_for_login_form(\u0026response_html);\n        log::debug!(\"ğŸ” Final login validation:\");\n        log::debug!(\"   - Response contains login form: {has_login_form}\");\n        log::debug!(\"   - Response status: {}\", response.status());\n\n        if !has_login_form \u0026\u0026 response.status() == 200 {\n            log::info!(\"âœ… Login successful - no login form detected in response\");\n            Ok(LastFmEditSession::new(\n                username.to_string(),\n                cookies,\n                Some(csrf_token),\n                self.base_url.clone(),\n            ))\n        } else {\n            // Parse and return error message\n            let error_msg = self.parse_login_error(\u0026response_html);\n            log::warn!(\"âŒ Login failed: {error_msg}\");\n            Err(LastFmError::Auth(error_msg))\n        }\n    }\n\n    /// Handle 403 Forbidden responses\n    async fn handle_403_response(\n        \u0026self,\n        mut response: http_types::Response,\n    ) -\u003e Result\u003cLastFmEditSession\u003e {\n        let response_html = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\"ğŸ“„ 403 response HTML length: {} chars\", response_html.len());\n        if response_html.len() \u003c 2000 {\n            log::debug!(\"ğŸ“„ 403 response HTML content: {response_html}\");\n        } else {\n            // Log first and last 500 chars for large responses\n            log::debug!(\"ğŸ“„ 403 response HTML start: {}\", \u0026response_html[..500]);\n            log::debug!(\n                \"ğŸ“„ 403 response HTML end: {}\",\n                \u0026response_html[response_html.len() - 500..]\n            );\n        }\n\n        let login_error = self.parse_login_error(\u0026response_html);\n        Err(LastFmError::Auth(login_error))\n    }\n\n    /// Check if the response indicates successful session establishment\n    fn check_session_success(\n        \u0026self,\n        response: \u0026http_types::Response,\n        username: \u0026str,\n        cookies: \u0026[String],\n        csrf_token: \u0026str,\n    ) -\u003e Option\u003cLastFmEditSession\u003e {\n        let has_real_session = cookies\n            .iter()\n            .any(|cookie| cookie.starts_with(\"sessionid=.\") \u0026\u0026 cookie.len() \u003e 50);\n\n        log::debug!(\"ğŸ” Session validation:\");\n        log::debug!(\"   - Has real session cookie: {has_real_session}\");\n        log::debug!(\"   - Response status: {}\", response.status());\n        log::debug!(\"   - All cookies: {cookies:?}\");\n\n        if has_real_session \u0026\u0026 (response.status() == 302 || response.status() == 200) {\n            log::info!(\"âœ… Login successful - authenticated session established\");\n            Some(LastFmEditSession::new(\n                username.to_string(),\n                cookies.to_vec(),\n                Some(csrf_token.to_string()),\n                self.base_url.clone(),\n            ))\n        } else {\n            None\n        }\n    }\n\n    /// Make a simple HTTP GET request (without retry logic)\n    async fn get(\u0026self, url: \u0026str) -\u003e Result\u003chttp_types::Response\u003e {\n        let mut request = Request::new(Method::Get, url.parse::\u003cUrl\u003e().unwrap());\n        let _ = request.insert_header(\"User-Agent\", \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36\");\n\n        self.client\n            .send(request)\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))\n    }\n\n    /// Extract login form data (CSRF token and next field)\n    fn extract_login_form_data(\u0026self, html: \u0026str) -\u003e Result\u003c(String, Option\u003cString\u003e)\u003e {\n        let document = Html::parse_document(html);\n\n        let csrf_token = self.extract_csrf_token(\u0026document)?;\n\n        // Check if there's a 'next' field in the form\n        let next_selector = Selector::parse(\"input[name=\\\"next\\\"]\").unwrap();\n        let next_field = document\n            .select(\u0026next_selector)\n            .next()\n            .and_then(|input| input.value().attr(\"value\"))\n            .map(|s| s.to_string());\n\n        Ok((csrf_token, next_field))\n    }\n\n    fn extract_csrf_token(\u0026self, document: \u0026Html) -\u003e Result\u003cString\u003e {\n        let csrf_selector = Selector::parse(\"input[name=\\\"csrfmiddlewaretoken\\\"]\").unwrap();\n\n        let csrf_token = document\n            .select(\u0026csrf_selector)\n            .next()\n            .and_then(|input| input.value().attr(\"value\"))\n            .map(|token| token.to_string())\n            .ok_or(LastFmError::CsrfNotFound)?;\n\n        log::debug!(\"ğŸ”‘ CSRF token extracted from HTML: {csrf_token}\");\n        Ok(csrf_token)\n    }\n\n    /// Parse login error messages from HTML\n    fn parse_login_error(\u0026self, html: \u0026str) -\u003e String {\n        let document = Html::parse_document(html);\n\n        let error_selector = Selector::parse(\".alert-danger, .form-error, .error-message\").unwrap();\n\n        let mut error_messages = Vec::new();\n        for error in document.select(\u0026error_selector) {\n            let error_text = error.text().collect::\u003cString\u003e().trim().to_string();\n            if !error_text.is_empty() {\n                error_messages.push(error_text);\n            }\n        }\n\n        if error_messages.is_empty() {\n            \"Login failed - please check your credentials\".to_string()\n        } else {\n            format!(\"Login failed: {}\", error_messages.join(\"; \"))\n        }\n    }\n\n    /// Check if HTML contains a login form\n    fn check_for_login_form(\u0026self, html: \u0026str) -\u003e bool {\n        let document = Html::parse_document(html);\n        let login_form_selector =\n            Selector::parse(\"form[action*=\\\"login\\\"], input[name=\\\"username_or_email\\\"]\").unwrap();\n        document.select(\u0026login_form_selector).next().is_some()\n    }\n}\n\n/// Extract cookies from HTTP response - utility function\npub fn extract_cookies_from_response(response: \u0026http_types::Response, cookies: \u0026mut Vec\u003cString\u003e) {\n    if let Some(cookie_headers) = response.header(\"set-cookie\") {\n        for cookie_header in cookie_headers {\n            let cookie_str = cookie_header.as_str();\n            // Extract just the cookie name=value part (before any semicolon)\n            if let Some(cookie_value) = cookie_str.split(';').next() {\n                let cookie_name = cookie_value.split('=').next().unwrap_or(\"\");\n\n                // Remove any existing cookie with the same name\n                cookies.retain(|existing| !existing.starts_with(\u0026format!(\"{cookie_name}=\")));\n                cookies.push(cookie_value.to_string());\n            }\n        }\n    }\n}\n","traces":[{"line":16,"address":[6222480],"length":1,"stats":{"Line":1}},{"line":36,"address":[5669552,5669580],"length":1,"stats":{"Line":4}},{"line":37,"address":[5579338,5579298,5579108],"length":1,"stats":{"Line":3}},{"line":40,"address":[5770216,5770538],"length":1,"stats":{"Line":2}},{"line":41,"address":[5485426],"length":1,"stats":{"Line":2}},{"line":44,"address":[5971161,5970831,5970357,5971248,5970755,5971133],"length":1,"stats":{"Line":5}},{"line":46,"address":[5580617],"length":1,"stats":{"Line":1}},{"line":47,"address":[6348135],"length":1,"stats":{"Line":1}},{"line":48,"address":[5580759],"length":1,"stats":{"Line":1}},{"line":49,"address":[5580783],"length":1,"stats":{"Line":1}},{"line":50,"address":[6348250],"length":1,"stats":{"Line":1}},{"line":51,"address":[5771777],"length":1,"stats":{"Line":1}},{"line":53,"address":[6348864,6346615,6348512,6348452,6348580,6348783],"length":1,"stats":{"Line":3}},{"line":56,"address":[6349022],"length":1,"stats":{"Line":1}},{"line":57,"address":[5772613,5772852],"length":1,"stats":{"Line":2}},{"line":60,"address":[5582288,5582792,5581757],"length":1,"stats":{"Line":3}},{"line":61,"address":[5579228,5582261,5582321,5582613,5582984],"length":1,"stats":{"Line":3}},{"line":65,"address":[6222592],"length":1,"stats":{"Line":1}},{"line":69,"address":[5774449,5774239,5774402],"length":1,"stats":{"Line":3}},{"line":70,"address":[5282111],"length":1,"stats":{"Line":2}},{"line":72,"address":[6104358,6104204,6104304],"length":1,"stats":{"Line":3}},{"line":73,"address":[5584891,5584470,5585027,5584856],"length":1,"stats":{"Line":3}},{"line":79,"address":[5584862],"length":1,"stats":{"Line":1}},{"line":80,"address":[5776245],"length":1,"stats":{"Line":1}},{"line":81,"address":[6105260,6105352],"length":1,"stats":{"Line":2}},{"line":84,"address":[5777206,5776742,5777092,5776390,5779512,5777034],"length":1,"stats":{"Line":4}},{"line":86,"address":[5776871,5776715,5777066,5774335,5776775],"length":1,"stats":{"Line":3}},{"line":87,"address":[3522406,3524800,3524823],"length":1,"stats":{"Line":0}},{"line":89,"address":[6106331,6106363,6106235],"length":1,"stats":{"Line":3}},{"line":90,"address":[3522982,3522645],"length":1,"stats":{"Line":2}},{"line":91,"address":[3523035],"length":1,"stats":{"Line":0}},{"line":95,"address":[5587231,5586850],"length":1,"stats":{"Line":2}},{"line":96,"address":[5778407,5778548,5778497],"length":1,"stats":{"Line":3}},{"line":97,"address":[6107746,6108068,6107431],"length":1,"stats":{"Line":3}},{"line":99,"address":[6355324],"length":1,"stats":{"Line":1}},{"line":103,"address":[6222640],"length":1,"stats":{"Line":1}},{"line":113,"address":[5589256],"length":1,"stats":{"Line":1}},{"line":114,"address":[5780300],"length":1,"stats":{"Line":1}},{"line":115,"address":[5589468],"length":1,"stats":{"Line":1}},{"line":116,"address":[6356938],"length":1,"stats":{"Line":1}},{"line":118,"address":[5589573],"length":1,"stats":{"Line":1}},{"line":119,"address":[6109461,6109584],"length":1,"stats":{"Line":2}},{"line":120,"address":[3525871],"length":1,"stats":{"Line":1}},{"line":123,"address":[3526424,3525780,3526280,3526226],"length":1,"stats":{"Line":0}},{"line":127,"address":[6357536,6358048,6357994],"length":1,"stats":{"Line":3}},{"line":128,"address":[5590935,5591002,5590592],"length":1,"stats":{"Line":3}},{"line":131,"address":[3527474,3529859,3527049],"length":1,"stats":{"Line":2}},{"line":134,"address":[5782615,5782521,5782764],"length":1,"stats":{"Line":3}},{"line":136,"address":[6115248,6115294],"length":1,"stats":{"Line":2}},{"line":140,"address":[6359381,6359487],"length":1,"stats":{"Line":2}},{"line":141,"address":[5783336,5782943,5783282],"length":1,"stats":{"Line":3}},{"line":142,"address":[3528875,3528436,3528821],"length":1,"stats":{"Line":3}},{"line":143,"address":[6113157],"length":1,"stats":{"Line":0}},{"line":146,"address":[5593119],"length":1,"stats":{"Line":1}},{"line":149,"address":[6361075,6360963,6361152,6361465,6361493,6361607],"length":1,"stats":{"Line":5}},{"line":151,"address":[3529642],"length":1,"stats":{"Line":1}},{"line":152,"address":[3335303],"length":1,"stats":{"Line":3}},{"line":153,"address":[5595824,5595842,5594167],"length":1,"stats":{"Line":0}},{"line":155,"address":[5984207,5984066,5984156],"length":1,"stats":{"Line":3}},{"line":156,"address":[5785871],"length":1,"stats":{"Line":0}},{"line":161,"address":[5594807],"length":1,"stats":{"Line":1}},{"line":165,"address":[2882857,2881360,2882851],"length":1,"stats":{"Line":1}},{"line":166,"address":[5669986],"length":1,"stats":{"Line":1}},{"line":169,"address":[5481289,5481217],"length":1,"stats":{"Line":2}},{"line":170,"address":[2881653],"length":1,"stats":{"Line":1}},{"line":171,"address":[5846248],"length":1,"stats":{"Line":1}},{"line":172,"address":[2881760],"length":1,"stats":{"Line":1}},{"line":176,"address":[5846384],"length":1,"stats":{"Line":1}},{"line":180,"address":[5481572],"length":1,"stats":{"Line":1}},{"line":181,"address":[6223496],"length":1,"stats":{"Line":1}},{"line":182,"address":[5670588],"length":1,"stats":{"Line":1}},{"line":183,"address":[5481776],"length":1,"stats":{"Line":1}},{"line":184,"address":[5846722],"length":1,"stats":{"Line":1}},{"line":185,"address":[5670790],"length":1,"stats":{"Line":1}},{"line":189,"address":[5481978],"length":1,"stats":{"Line":1}},{"line":190,"address":[2882298],"length":1,"stats":{"Line":1}},{"line":191,"address":[5482114],"length":1,"stats":{"Line":1}},{"line":192,"address":[5671062],"length":1,"stats":{"Line":1}},{"line":193,"address":[6224106],"length":1,"stats":{"Line":1}},{"line":194,"address":[5482318],"length":1,"stats":{"Line":1}},{"line":197,"address":[5972732],"length":1,"stats":{"Line":1}},{"line":198,"address":[6224287],"length":1,"stats":{"Line":1}},{"line":199,"address":[2882822,2882730],"length":1,"stats":{"Line":2}},{"line":202,"address":[2882671],"length":1,"stats":{"Line":1}},{"line":206,"address":[2882880],"length":1,"stats":{"Line":1}},{"line":214,"address":[5787283,5787437],"length":1,"stats":{"Line":2}},{"line":215,"address":[5625340],"length":1,"stats":{"Line":0}},{"line":219,"address":[5787491,5787740],"length":1,"stats":{"Line":1}},{"line":222,"address":[6116866],"length":1,"stats":{"Line":1}},{"line":226,"address":[6364510,6365387,6365501,6365329,6369550,6364571],"length":1,"stats":{"Line":0}},{"line":228,"address":[5451333],"length":1,"stats":{"Line":0}},{"line":229,"address":[6369776,6365469,6369794],"length":1,"stats":{"Line":0}},{"line":231,"address":[5988168],"length":1,"stats":{"Line":0}},{"line":235,"address":[5598653,5598304],"length":1,"stats":{"Line":0}},{"line":236,"address":[6366126],"length":1,"stats":{"Line":0}},{"line":240,"address":[6366495,6366069],"length":1,"stats":{"Line":0}},{"line":241,"address":[6366529,6366635],"length":1,"stats":{"Line":0}},{"line":242,"address":[5599467,5599521,5599179],"length":1,"stats":{"Line":0}},{"line":243,"address":[5989233,5989597,5989572],"length":1,"stats":{"Line":0}},{"line":245,"address":[6121300,6120011,6120095,6119658],"length":1,"stats":{"Line":0}},{"line":246,"address":[6367711,6367807],"length":1,"stats":{"Line":0}},{"line":247,"address":[5791798,5791897],"length":1,"stats":{"Line":0}},{"line":248,"address":[3536613,3536319],"length":1,"stats":{"Line":0}},{"line":249,"address":[5990417],"length":1,"stats":{"Line":0}},{"line":250,"address":[5600718],"length":1,"stats":{"Line":0}},{"line":251,"address":[5600811],"length":1,"stats":{"Line":0}},{"line":255,"address":[5989962,5990911],"length":1,"stats":{"Line":0}},{"line":256,"address":[6368668,6368578,6368873],"length":1,"stats":{"Line":0}},{"line":257,"address":[5792182],"length":1,"stats":{"Line":0}},{"line":262,"address":[2883088],"length":1,"stats":{"Line":0}},{"line":266,"address":[5602830,5603261,5602678,5603089,5603147],"length":1,"stats":{"Line":0}},{"line":268,"address":[5793775,5793835,5793654,5793715,5794033],"length":1,"stats":{"Line":0}},{"line":269,"address":[5605408,5603229,5605426],"length":1,"stats":{"Line":0}},{"line":271,"address":[5603362,5603458,5603490],"length":1,"stats":{"Line":0}},{"line":272,"address":[6371229,6370880],"length":1,"stats":{"Line":0}},{"line":273,"address":[5603874,5604803],"length":1,"stats":{"Line":0}},{"line":276,"address":[5993589,5993689,5993743],"length":1,"stats":{"Line":0}},{"line":277,"address":[6371877],"length":1,"stats":{"Line":0}},{"line":283,"address":[5994107,5994856],"length":1,"stats":{"Line":0}},{"line":284,"address":[5796027],"length":1,"stats":{"Line":0}},{"line":288,"address":[2885204,2883168,2885232],"length":1,"stats":{"Line":1}},{"line":295,"address":[5973451],"length":1,"stats":{"Line":1}},{"line":297,"address":[5605552,5605582],"length":1,"stats":{"Line":2}},{"line":299,"address":[6225115,6225038],"length":1,"stats":{"Line":2}},{"line":300,"address":[5483213,5483459],"length":1,"stats":{"Line":2}},{"line":301,"address":[5483736,5483413],"length":1,"stats":{"Line":2}},{"line":302,"address":[2884211,2883897],"length":1,"stats":{"Line":2}},{"line":304,"address":[5673134,5673859,5672869],"length":1,"stats":{"Line":2}},{"line":305,"address":[5974685,5974803],"length":1,"stats":{"Line":2}},{"line":306,"address":[5484857,5484961],"length":1,"stats":{"Line":2}},{"line":307,"address":[6226266],"length":1,"stats":{"Line":1}},{"line":308,"address":[5484690,5484435],"length":1,"stats":{"Line":2}},{"line":309,"address":[5484698,5484760],"length":1,"stats":{"Line":2}},{"line":310,"address":[5975136],"length":1,"stats":{"Line":1}},{"line":313,"address":[5974577],"length":1,"stats":{"Line":0}},{"line":318,"address":[5673952,5673970],"length":1,"stats":{"Line":4}},{"line":319,"address":[5605810,5605909],"length":1,"stats":{"Line":2}},{"line":320,"address":[3542018,3541916],"length":1,"stats":{"Line":2}},{"line":322,"address":[5606600,5606106,5606231,5606290,5606660],"length":1,"stats":{"Line":5}},{"line":323,"address":[5995932],"length":1,"stats":{"Line":1}},{"line":324,"address":[5996362,5996069,5995621,5996019,5996187],"length":1,"stats":{"Line":3}},{"line":325,"address":[6126592,6126610],"length":1,"stats":{"Line":0}},{"line":329,"address":[6226976,6227940,6227989],"length":1,"stats":{"Line":1}},{"line":330,"address":[5485192],"length":1,"stats":{"Line":1}},{"line":332,"address":[5674117,5674165],"length":1,"stats":{"Line":2}},{"line":335,"address":[5485550,5485478],"length":1,"stats":{"Line":2}},{"line":336,"address":[5976006,5976074,5975930],"length":1,"stats":{"Line":3}},{"line":339,"address":[5797808,5797809],"length":1,"stats":{"Line":2}},{"line":340,"address":[3542864,3542886],"length":1,"stats":{"Line":3}},{"line":342,"address":[2886034],"length":1,"stats":{"Line":1}},{"line":345,"address":[5977564,5976496,5977526],"length":1,"stats":{"Line":1}},{"line":346,"address":[2886358],"length":1,"stats":{"Line":1}},{"line":348,"address":[2886416,2886481,2886557,2886635,2886730],"length":1,"stats":{"Line":4}},{"line":351,"address":[6374400,6374401],"length":1,"stats":{"Line":2}},{"line":352,"address":[3542960,3542982],"length":1,"stats":{"Line":2}},{"line":353,"address":[5851232,5852076,5851438,5851331,5851563],"length":1,"stats":{"Line":2}},{"line":355,"address":[5486910,5486746],"length":1,"stats":{"Line":2}},{"line":356,"address":[5486803],"length":1,"stats":{"Line":1}},{"line":360,"address":[2887392,2888736,2888298],"length":1,"stats":{"Line":0}},{"line":361,"address":[2887459],"length":1,"stats":{"Line":0}},{"line":363,"address":[5676289,5676217],"length":1,"stats":{"Line":0}},{"line":365,"address":[5676333],"length":1,"stats":{"Line":0}},{"line":366,"address":[5487513,5487586,5487710,5488558],"length":1,"stats":{"Line":0}},{"line":367,"address":[6229626,6230069],"length":1,"stats":{"Line":0}},{"line":368,"address":[5853321],"length":1,"stats":{"Line":0}},{"line":369,"address":[5488462,5488548],"length":1,"stats":{"Line":0}},{"line":373,"address":[2887955],"length":1,"stats":{"Line":0}},{"line":374,"address":[5676766,5677048],"length":1,"stats":{"Line":0}},{"line":376,"address":[5676732,5676802],"length":1,"stats":{"Line":0}},{"line":381,"address":[5677504,5677950,5677944],"length":1,"stats":{"Line":0}},{"line":382,"address":[5677535],"length":1,"stats":{"Line":0}},{"line":383,"address":[5979005,5979074],"length":1,"stats":{"Line":0}},{"line":385,"address":[5488776,5488905,5488843],"length":1,"stats":{"Line":0}},{"line":390,"address":[5677968],"length":1,"stats":{"Line":8}},{"line":391,"address":[5677996],"length":1,"stats":{"Line":9}},{"line":392,"address":[2889347,2889307],"length":1,"stats":{"Line":18}},{"line":393,"address":[5678166],"length":1,"stats":{"Line":7}},{"line":395,"address":[5854191],"length":1,"stats":{"Line":9}},{"line":396,"address":[6231293],"length":1,"stats":{"Line":8}},{"line":399,"address":[6231368],"length":1,"stats":{"Line":28}},{"line":400,"address":[5489536],"length":1,"stats":{"Line":7}}],"covered":126,"coverable":181},{"path":["/","home","imalison","Projects","lastfm-edit","src","parsing.rs"],"content":"//! HTML parsing utilities for Last.fm pages.\n//!\n//! This module contains all the HTML parsing logic for extracting track, album,\n//! and other data from Last.fm web pages. These functions are primarily pure\n//! functions that take HTML documents and return structured data.\n\nuse crate::{Album, AlbumPage, Artist, ArtistPage, LastFmError, Result, Track, TrackPage};\nuse scraper::{Html, Selector};\n\n/// Parser struct containing parsing methods for Last.fm HTML pages.\n///\n/// This struct holds the parsing logic that was previously embedded in the client.\n/// It's designed to be stateless and focused purely on HTML parsing.\n#[derive(Debug, Clone)]\npub struct LastFmParser;\n\nimpl LastFmParser {\n    /// Create a new parser instance.\n    pub fn new() -\u003e Self {\n        Self\n    }\n\n    /// Parse recent scrobbles from the user's library page\n    /// This extracts real scrobble data with timestamps for editing\n    pub fn parse_recent_scrobbles(\u0026self, document: \u0026Html) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        let mut tracks = Vec::new();\n\n        // Recent scrobbles are typically in chartlist tables - there can be multiple\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let row_selector = Selector::parse(\"tbody tr\").unwrap();\n\n        let tables: Vec\u003c_\u003e = document.select(\u0026table_selector).collect();\n        log::debug!(\"Found {} chartlist tables\", tables.len());\n\n        for table in tables {\n            for row in table.select(\u0026row_selector) {\n                if let Ok(track) = self.parse_recent_scrobble_row(\u0026row) {\n                    tracks.push(track);\n                }\n            }\n        }\n\n        if tracks.is_empty() {\n            log::debug!(\"No tracks found in recent scrobbles\");\n        }\n\n        log::debug!(\"Parsed {} recent scrobbles\", tracks.len());\n        Ok(tracks)\n    }\n\n    /// Parse a single row from the recent scrobbles table\n    fn parse_recent_scrobble_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cTrack\u003e {\n        // Extract track name\n        let name_selector = Selector::parse(\".chartlist-name a\").unwrap();\n        let name = row\n            .select(\u0026name_selector)\n            .next()\n            .ok_or(LastFmError::Parse(\"Missing track name\".to_string()))?\n            .text()\n            .collect::\u003cString\u003e()\n            .trim()\n            .to_string();\n\n        // Extract artist name\n        let artist_selector = Selector::parse(\".chartlist-artist a\").unwrap();\n        let artist = row\n            .select(\u0026artist_selector)\n            .next()\n            .ok_or(LastFmError::Parse(\"Missing artist name\".to_string()))?\n            .text()\n            .collect::\u003cString\u003e()\n            .trim()\n            .to_string();\n\n        // Extract timestamp from data attributes or hidden inputs\n        let timestamp = self.extract_scrobble_timestamp(row);\n\n        // Extract album from hidden inputs in edit form\n        let album = self.extract_scrobble_album(row);\n\n        // Extract album artist from hidden inputs in edit form\n        let album_artist = self.extract_scrobble_album_artist(row);\n\n        // For recent scrobbles, playcount is typically 1 since they're individual scrobbles\n        let playcount = 1;\n\n        Ok(Track {\n            name,\n            artist,\n            playcount,\n            timestamp,\n            album,\n            album_artist,\n        })\n    }\n\n    /// Extract timestamp from scrobble row elements\n    fn extract_scrobble_timestamp(\u0026self, row: \u0026scraper::ElementRef) -\u003e Option\u003cu64\u003e {\n        // Look for timestamp in various places:\n\n        // 1. Check for data-timestamp attribute\n        if let Some(timestamp_str) = row.value().attr(\"data-timestamp\") {\n            if let Ok(timestamp) = timestamp_str.parse::\u003cu64\u003e() {\n                return Some(timestamp);\n            }\n        }\n\n        // 2. Look for hidden timestamp input\n        let timestamp_input_selector = Selector::parse(\"input[name='timestamp']\").unwrap();\n        if let Some(input) = row.select(\u0026timestamp_input_selector).next() {\n            if let Some(value) = input.value().attr(\"value\") {\n                if let Ok(timestamp) = value.parse::\u003cu64\u003e() {\n                    return Some(timestamp);\n                }\n            }\n        }\n\n        // 3. Look for edit form with timestamp\n        let edit_form_selector =\n            Selector::parse(\"form[data-edit-scrobble] input[name='timestamp']\").unwrap();\n        if let Some(timestamp_input) = row.select(\u0026edit_form_selector).next() {\n            if let Some(value) = timestamp_input.value().attr(\"value\") {\n                if let Ok(timestamp) = value.parse::\u003cu64\u003e() {\n                    return Some(timestamp);\n                }\n            }\n        }\n\n        // Removed time element parsing - testing if needed\n\n        None\n    }\n\n    /// Extract album name from scrobble row elements\n    fn extract_scrobble_album(\u0026self, row: \u0026scraper::ElementRef) -\u003e Option\u003cString\u003e {\n        // Look for album_name in hidden inputs within edit forms\n        let album_input_selector =\n            Selector::parse(\"form[data-edit-scrobble] input[name='album_name']\").unwrap();\n\n        if let Some(album_input) = row.select(\u0026album_input_selector).next() {\n            if let Some(album_name) = album_input.value().attr(\"value\") {\n                if !album_name.is_empty() {\n                    return Some(album_name.to_string());\n                }\n            }\n        }\n\n        None\n    }\n\n    /// Extract album artist name from scrobble row elements\n    fn extract_scrobble_album_artist(\u0026self, row: \u0026scraper::ElementRef) -\u003e Option\u003cString\u003e {\n        // Look for album_artist_name in hidden inputs within edit forms\n        let album_artist_input_selector =\n            Selector::parse(\"form[data-edit-scrobble] input[name='album_artist_name']\").unwrap();\n\n        if let Some(album_artist_input) = row.select(\u0026album_artist_input_selector).next() {\n            if let Some(album_artist_name) = album_artist_input.value().attr(\"value\") {\n                if !album_artist_name.is_empty() {\n                    return Some(album_artist_name.to_string());\n                }\n            }\n        }\n\n        None\n    }\n\n    /// Parse a tracks page into a `TrackPage` structure\n    pub fn parse_tracks_page(\n        \u0026self,\n        document: \u0026Html,\n        page_number: u32,\n        artist: \u0026str,\n        album: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cTrackPage\u003e {\n        let tracks = self.extract_tracks_from_document(document, artist, album)?;\n\n        // Check for pagination\n        let (has_next_page, total_pages) = self.parse_pagination(document, page_number)?;\n\n        Ok(TrackPage {\n            tracks,\n            page_number,\n            has_next_page,\n            total_pages,\n        })\n    }\n\n    /// Extract tracks from HTML document\n    pub fn extract_tracks_from_document(\n        \u0026self,\n        document: \u0026Html,\n        artist: \u0026str,\n        album: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        let mut tracks = Vec::new();\n        let mut seen_tracks = std::collections::HashSet::new();\n\n        log::debug!(\"Starting track extraction for artist: {artist}, album: {album:?}\");\n\n        // JSON parsing removed - was not implemented and always failed\n\n        // Parse track data from data-track-name attributes (AJAX response)\n        let track_selector = Selector::parse(\"[data-track-name]\").unwrap();\n        let track_elements: Vec\u003c_\u003e = document.select(\u0026track_selector).collect();\n        log::debug!(\n            \"Found {} elements with data-track-name\",\n            track_elements.len()\n        );\n\n        for element in track_elements {\n            let track_name = element.value().attr(\"data-track-name\").unwrap_or(\"\");\n            if track_name.is_empty() {\n                continue;\n            }\n            if seen_tracks.contains(track_name) {\n                continue;\n            }\n            seen_tracks.insert(track_name.to_string());\n\n            match self.find_playcount_for_track(document, track_name) {\n                Ok(playcount) =\u003e {\n                    let timestamp = self.find_timestamp_for_track(document, track_name);\n                    let track = Track {\n                        name: track_name.to_string(),\n                        artist: artist.to_string(),\n                        playcount,\n                        timestamp,\n                        album: album.map(|a| a.to_string()),\n                        album_artist: None, // Not available in aggregate track listings\n                    };\n                    tracks.push(track);\n                    log::debug!(\"Added track '{track_name}' with {playcount} plays\");\n                }\n                Err(e) =\u003e {\n                    log::debug!(\"FAILED to find playcount for track '{track_name}': {e}\");\n                }\n            }\n        }\n\n        // Always try fallback parsing from chartlist tables to catch tracks without data-track-name\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let tables: Vec\u003c_\u003e = document.select(\u0026table_selector).collect();\n\n        for table in tables {\n            let row_selector = Selector::parse(\"tbody tr\").unwrap();\n            let rows: Vec\u003c_\u003e = table.select(\u0026row_selector).collect();\n\n            for row in rows.iter() {\n                // Try to parse as track row\n                if let Ok(mut track) = self.parse_track_row(row) {\n                    track.artist = artist.to_string();\n                    if let Some(album_name) = album {\n                        track.album = Some(album_name.to_string());\n                    }\n\n                    // Only add if we don't already have this track\n                    if !seen_tracks.contains(\u0026track.name) {\n                        seen_tracks.insert(track.name.clone());\n                        tracks.push(track);\n                    }\n                }\n            }\n        }\n\n        log::debug!(\"Successfully extracted {} unique tracks\", tracks.len());\n        Ok(tracks)\n    }\n\n    // Removed parse_tracks_from_rows - no longer needed\n\n    /// Parse a single track row from chartlist table\n    pub fn parse_track_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cTrack\u003e {\n        // Extract track name using shared method\n        let name = self.extract_name_from_row(row, \"track\")?;\n\n        // Parse play count using shared method\n        let playcount = self.extract_playcount_from_row(row);\n\n        let artist = \"\".to_string(); // Will be filled in by caller\n\n        Ok(Track {\n            name,\n            artist,\n            playcount,\n            timestamp: None,    // Not available in table parsing mode\n            album: None,        // Not available in table parsing mode\n            album_artist: None, // Not available in table parsing mode\n        })\n    }\n\n    /// Parse albums page into `AlbumPage` structure\n    pub fn parse_albums_page(\n        \u0026self,\n        document: \u0026Html,\n        page_number: u32,\n        artist: \u0026str,\n    ) -\u003e Result\u003cAlbumPage\u003e {\n        let mut albums = Vec::new();\n\n        // Try parsing album data from data attributes (AJAX response)\n        let album_selector = Selector::parse(\"[data-album-name]\").unwrap();\n        let album_elements: Vec\u003c_\u003e = document.select(\u0026album_selector).collect();\n\n        if !album_elements.is_empty() {\n            log::debug!(\n                \"Found {} album elements with data-album-name\",\n                album_elements.len()\n            );\n\n            // Use a set to track unique albums\n            let mut seen_albums = std::collections::HashSet::new();\n\n            for element in album_elements {\n                let album_name = element.value().attr(\"data-album-name\").unwrap_or(\"\");\n                if !album_name.is_empty() \u0026\u0026 !seen_albums.contains(album_name) {\n                    seen_albums.insert(album_name.to_string());\n\n                    if let Ok(playcount) = self.find_playcount_for_album(document, album_name) {\n                        let timestamp = self.find_timestamp_for_album(document, album_name);\n                        let album = Album {\n                            name: album_name.to_string(),\n                            artist: artist.to_string(),\n                            playcount,\n                            timestamp,\n                        };\n                        albums.push(album);\n                    }\n                }\n            }\n        } else {\n            // Fall back to parsing album rows from chartlist tables\n            albums = self.parse_albums_from_rows(document, artist)?;\n        }\n\n        let (has_next_page, total_pages) = self.parse_pagination(document, page_number)?;\n\n        Ok(AlbumPage {\n            albums,\n            page_number,\n            has_next_page,\n            total_pages,\n        })\n    }\n\n    /// Parse albums from chartlist table rows\n    fn parse_albums_from_rows(\u0026self, document: \u0026Html, artist: \u0026str) -\u003e Result\u003cVec\u003cAlbum\u003e\u003e {\n        let mut albums = Vec::new();\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let row_selector = Selector::parse(\"tbody tr\").unwrap();\n\n        for table in document.select(\u0026table_selector) {\n            for row in table.select(\u0026row_selector) {\n                if let Ok(mut album) = self.parse_album_row(\u0026row) {\n                    album.artist = artist.to_string();\n                    albums.push(album);\n                }\n            }\n        }\n        Ok(albums)\n    }\n\n    /// Parse a single album row from chartlist table\n    pub fn parse_album_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cAlbum\u003e {\n        // Extract album name using shared method\n        let name = self.extract_name_from_row(row, \"album\")?;\n\n        // Parse play count using shared method\n        let playcount = self.extract_playcount_from_row(row);\n\n        let artist = \"\".to_string(); // Will be filled in by caller\n\n        Ok(Album {\n            name,\n            artist,\n            playcount,\n            timestamp: None, // Not available in table parsing\n        })\n    }\n\n    // === SEARCH RESULTS PARSING ===\n\n    /// Parse track search results from AJAX response\n    ///\n    /// This parses the HTML returned by `/user/{username}/library/tracks/search?ajax=1\u0026query={query}`\n    /// which contains chartlist tables with track results.\n    pub fn parse_track_search_results(\u0026self, document: \u0026Html) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        let mut tracks = Vec::new();\n\n        // Search results use the same chartlist structure as library pages\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let row_selector = Selector::parse(\"tbody tr\").unwrap();\n\n        let tables: Vec\u003c_\u003e = document.select(\u0026table_selector).collect();\n        log::debug!(\"Found {} chartlist tables in search results\", tables.len());\n\n        for table in tables {\n            for row in table.select(\u0026row_selector) {\n                if let Ok(track) = self.parse_search_track_row(\u0026row) {\n                    tracks.push(track);\n                }\n            }\n        }\n\n        log::debug!(\"Parsed {} tracks from search results\", tracks.len());\n        Ok(tracks)\n    }\n\n    /// Parse album search results from AJAX response\n    ///\n    /// This parses the HTML returned by `/user/{username}/library/albums/search?ajax=1\u0026query={query}`\n    /// which contains chartlist tables with album results.\n    pub fn parse_album_search_results(\u0026self, document: \u0026Html) -\u003e Result\u003cVec\u003cAlbum\u003e\u003e {\n        let mut albums = Vec::new();\n\n        // Search results use the same chartlist structure as library pages\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let row_selector = Selector::parse(\"tbody tr\").unwrap();\n\n        let tables: Vec\u003c_\u003e = document.select(\u0026table_selector).collect();\n        log::debug!(\n            \"Found {} chartlist tables in album search results\",\n            tables.len()\n        );\n\n        for table in tables {\n            for row in table.select(\u0026row_selector) {\n                if let Ok(album) = self.parse_search_album_row(\u0026row) {\n                    albums.push(album);\n                }\n            }\n        }\n\n        log::debug!(\"Parsed {} albums from search results\", albums.len());\n        Ok(albums)\n    }\n\n    /// Parse a single track row from search results\n    fn parse_search_track_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cTrack\u003e {\n        // Extract track name using the standard chartlist structure\n        let name = self.extract_name_from_row(row, \"track\")?;\n\n        // Extract artist name from chartlist-artist column\n        let artist_selector = Selector::parse(\".chartlist-artist a\").unwrap();\n        let artist = row\n            .select(\u0026artist_selector)\n            .next()\n            .map(|el| el.text().collect::\u003cString\u003e().trim().to_string())\n            .ok_or_else(|| {\n                LastFmError::Parse(\"Missing artist name in search results\".to_string())\n            })?;\n\n        // Extract playcount from the bar value\n        let playcount = self.extract_playcount_from_row(row);\n\n        // Search results typically don't have timestamps since they're aggregated\n        let timestamp = None;\n\n        // Try to extract album information if available in the search results\n        let album = self.extract_album_from_search_row(row);\n        let album_artist = self.extract_album_artist_from_search_row(row);\n\n        Ok(Track {\n            name,\n            artist,\n            playcount,\n            timestamp,\n            album,\n            album_artist,\n        })\n    }\n\n    /// Parse a single album row from search results\n    fn parse_search_album_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cAlbum\u003e {\n        // Extract album name using the standard chartlist structure\n        let name = self.extract_name_from_row(row, \"album\")?;\n\n        // Extract artist name from chartlist-artist column\n        let artist_selector = Selector::parse(\".chartlist-artist a\").unwrap();\n        let artist = row\n            .select(\u0026artist_selector)\n            .next()\n            .map(|el| el.text().collect::\u003cString\u003e().trim().to_string())\n            .ok_or_else(|| {\n                LastFmError::Parse(\"Missing artist name in album search results\".to_string())\n            })?;\n\n        // Extract playcount from the bar value\n        let playcount = self.extract_playcount_from_row(row);\n\n        Ok(Album {\n            name,\n            artist,\n            playcount,\n            timestamp: None, // Search results don't have timestamps\n        })\n    }\n\n    /// Extract album information from search track row\n    fn extract_album_from_search_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Option\u003cString\u003e {\n        // Look for album information in hidden form inputs (similar to recent scrobbles)\n        let album_input_selector = Selector::parse(\"input[name='album']\").unwrap();\n        if let Some(input) = row.select(\u0026album_input_selector).next() {\n            if let Some(value) = input.value().attr(\"value\") {\n                let album = value.trim().to_string();\n                if !album.is_empty() {\n                    return Some(album);\n                }\n            }\n        }\n        None\n    }\n\n    /// Extract album artist information from search track row\n    fn extract_album_artist_from_search_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Option\u003cString\u003e {\n        // Look for album artist information in hidden form inputs\n        let album_artist_input_selector = Selector::parse(\"input[name='album_artist']\").unwrap();\n        if let Some(input) = row.select(\u0026album_artist_input_selector).next() {\n            if let Some(value) = input.value().attr(\"value\") {\n                let album_artist = value.trim().to_string();\n                if !album_artist.is_empty() {\n                    return Some(album_artist);\n                }\n            }\n        }\n        None\n    }\n\n    // === SHARED PARSING UTILITIES ===\n\n    /// Extract name from chartlist row (works for both tracks and albums)\n    fn extract_name_from_row(\u0026self, row: \u0026scraper::ElementRef, item_type: \u0026str) -\u003e Result\u003cString\u003e {\n        let name_selector = Selector::parse(\".chartlist-name a\").unwrap();\n        let name = row\n            .select(\u0026name_selector)\n            .next()\n            .map(|el| el.text().collect::\u003cString\u003e().trim().to_string())\n            .ok_or_else(|| LastFmError::Parse(format!(\"Missing {item_type} name\")))?;\n        Ok(name)\n    }\n\n    /// Extract playcount from chartlist row (works for both tracks and albums)\n    fn extract_playcount_from_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e u32 {\n        let playcount_selector = Selector::parse(\".chartlist-count-bar-value\").unwrap();\n        let mut playcount = 1; // default fallback\n\n        if let Some(element) = row.select(\u0026playcount_selector).next() {\n            let text = element.text().collect::\u003cString\u003e().trim().to_string();\n            // Extract just the number part (before \"scrobbles\" if present)\n            if let Some(number_part) = text.split_whitespace().next() {\n                if let Ok(count) = number_part.parse::\u003cu32\u003e() {\n                    playcount = count;\n                }\n            }\n        }\n        playcount\n    }\n\n    /// Parse pagination information from document\n    pub fn parse_pagination(\n        \u0026self,\n        document: \u0026Html,\n        _current_page: u32,\n    ) -\u003e Result\u003c(bool, Option\u003cu32\u003e)\u003e {\n        let pagination_selector = Selector::parse(\".pagination-list\").unwrap();\n\n        if let Some(pagination) = document.select(\u0026pagination_selector).next() {\n            // Try multiple possible selectors for next page link\n            let next_selectors = [\n                \"a[aria-label=\\\"Next\\\"]\",\n                \".pagination-next a\",\n                \"a:contains(\\\"Next\\\")\",\n                \".next a\",\n            ];\n\n            let mut has_next = false;\n            for selector_str in \u0026next_selectors {\n                if let Ok(selector) = Selector::parse(selector_str) {\n                    if pagination.select(\u0026selector).next().is_some() {\n                        has_next = true;\n                        break;\n                    }\n                }\n            }\n\n            // Try to extract total pages from pagination text\n            let total_pages = self.extract_total_pages_from_pagination(\u0026pagination);\n\n            Ok((has_next, total_pages))\n        } else {\n            // No pagination found - single page\n            Ok((false, Some(1)))\n        }\n    }\n\n    /// Helper functions for pagination parsing\n    fn extract_total_pages_from_pagination(\u0026self, pagination: \u0026scraper::ElementRef) -\u003e Option\u003cu32\u003e {\n        // Look for patterns like \"Page 1 of 42\"\n        let text = pagination.text().collect::\u003cString\u003e();\n        if let Some(of_pos) = text.find(\" of \") {\n            let after_of = \u0026text[of_pos + 4..];\n            if let Some(number_end) = after_of.find(|c: char| !c.is_ascii_digit()) {\n                if let Ok(total) = after_of[..number_end].parse::\u003cu32\u003e() {\n                    return Some(total);\n                }\n            } else if let Ok(total) = after_of.trim().parse::\u003cu32\u003e() {\n                return Some(total);\n            }\n        }\n        None\n    }\n\n    // === JSON PARSING METHODS ===\n    // Removed unused JSON parsing method\n\n    // === FIND HELPER METHODS ===\n\n    pub fn find_timestamp_for_track(\u0026self, _document: \u0026Html, _track_name: \u0026str) -\u003e Option\u003cu64\u003e {\n        // Implementation would search for timestamp data\n        None\n    }\n\n    pub fn find_playcount_for_track(\u0026self, document: \u0026Html, track_name: \u0026str) -\u003e Result\u003cu32\u003e {\n        // Look for chartlist-count-bar-value elements near the track\n        let count_selector = Selector::parse(\".chartlist-count-bar-value\").unwrap();\n        let link_selector = Selector::parse(\"a[href*=\\\"/music/\\\"]\").unwrap();\n\n        // Find all track links that match our track name\n        for link in document.select(\u0026link_selector) {\n            let link_text = link.text().collect::\u003cString\u003e().trim().to_string();\n            if link_text == track_name {\n                if let Some(row) = self.find_ancestor_row(link) {\n                    if let Some(count_element) = row.select(\u0026count_selector).next() {\n                        let text = count_element.text().collect::\u003cString\u003e().trim().to_string();\n                        if let Some(number_part) = text.split_whitespace().next() {\n                            if let Ok(count) = number_part.parse::\u003cu32\u003e() {\n                                return Ok(count);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        Err(LastFmError::Parse(format!(\n            \"Could not find playcount for track: {track_name}\"\n        )))\n    }\n\n    pub fn find_timestamp_for_album(\u0026self, _document: \u0026Html, _album_name: \u0026str) -\u003e Option\u003cu64\u003e {\n        // Implementation would search for timestamp data\n        None\n    }\n\n    pub fn find_playcount_for_album(\u0026self, document: \u0026Html, album_name: \u0026str) -\u003e Result\u003cu32\u003e {\n        // Look for chartlist-count-bar-value elements near the album\n        let count_selector = Selector::parse(\".chartlist-count-bar-value\").unwrap();\n        let link_selector = Selector::parse(\"a[href*=\\\"/music/\\\"]\").unwrap();\n\n        // Find all album links that match our album name\n        for link in document.select(\u0026link_selector) {\n            let link_text = link.text().collect::\u003cString\u003e().trim().to_string();\n            if link_text == album_name {\n                if let Some(row) = self.find_ancestor_row(link) {\n                    if let Some(count_element) = row.select(\u0026count_selector).next() {\n                        let text = count_element.text().collect::\u003cString\u003e().trim().to_string();\n                        if let Some(number_part) = text.split_whitespace().next() {\n                            if let Ok(count) = number_part.parse::\u003cu32\u003e() {\n                                return Ok(count);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        Err(LastFmError::Parse(format!(\n            \"Could not find playcount for album: {album_name}\"\n        )))\n    }\n\n    pub fn find_ancestor_row\u003c'a\u003e(\n        \u0026self,\n        element: scraper::ElementRef\u003c'a\u003e,\n    ) -\u003e Option\u003cscraper::ElementRef\u003c'a\u003e\u003e {\n        let mut current = element;\n        while let Some(parent) = current.parent() {\n            if let Some(parent_elem) = scraper::ElementRef::wrap(parent) {\n                if parent_elem.value().name() == \"tr\" {\n                    return Some(parent_elem);\n                }\n                current = parent_elem;\n            } else {\n                break;\n            }\n        }\n        None\n    }\n\n    /// Parse artists page from user's library\n    pub fn parse_artists_page(\u0026self, document: \u0026Html, page_number: u32) -\u003e Result\u003cArtistPage\u003e {\n        let mut artists = Vec::new();\n\n        // Parse artists from chartlist table rows\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let row_selector = Selector::parse(\"tr.js-link-block\").unwrap();\n\n        let tables: Vec\u003c_\u003e = document.select(\u0026table_selector).collect();\n        log::debug!(\"Found {} chartlist tables for artists\", tables.len());\n\n        for table in tables {\n            for row in table.select(\u0026row_selector) {\n                if let Ok(artist) = self.parse_artist_row(\u0026row) {\n                    artists.push(artist);\n                }\n            }\n        }\n\n        log::debug!(\"Parsed {} artists from page {}\", artists.len(), page_number);\n\n        let (has_next_page, total_pages) = self.parse_pagination(document, page_number)?;\n\n        Ok(ArtistPage {\n            artists,\n            page_number,\n            has_next_page,\n            total_pages,\n        })\n    }\n\n    /// Parse a single artist row from the artist library table\n    fn parse_artist_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cArtist\u003e {\n        // Extract artist name from the name column\n        let name_selector = Selector::parse(\"td.chartlist-name a\").unwrap();\n        let name = row\n            .select(\u0026name_selector)\n            .next()\n            .ok_or(LastFmError::Parse(\"Missing artist name\".to_string()))?\n            .text()\n            .collect::\u003cString\u003e()\n            .trim()\n            .to_string();\n\n        // Extract playcount from the count bar\n        let count_selector = Selector::parse(\".chartlist-count-bar\").unwrap();\n        let playcount = if let Some(count_element) = row.select(\u0026count_selector).next() {\n            let count_text = count_element.text().collect::\u003cString\u003e();\n            self.extract_number_from_count_text(\u0026count_text)\n                .unwrap_or(0)\n        } else {\n            0\n        };\n\n        // Artists in library listings typically don't have individual timestamps\n        let timestamp = None;\n\n        Ok(Artist {\n            name,\n            playcount,\n            timestamp,\n        })\n    }\n\n    /// Extract numeric value from count text like \"3,395 scrobbles\"\n    fn extract_number_from_count_text(\u0026self, text: \u0026str) -\u003e Option\u003cu32\u003e {\n        // Remove commas and extract the first numeric part\n        let cleaned = text.replace(',', \"\");\n        cleaned.split_whitespace().next()?.parse::\u003cu32\u003e().ok()\n    }\n}\n\nimpl Default for LastFmParser {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[{"line":19,"address":[20866162,20866444],"length":1,"stats":{"Line":0}},{"line":20,"address":[20866606,20866592],"length":1,"stats":{"Line":0}},{"line":25,"address":[18554501],"length":1,"stats":{"Line":1}},{"line":26,"address":[5797031],"length":1,"stats":{"Line":4}},{"line":29,"address":[5328952,5329024],"length":1,"stats":{"Line":3}},{"line":30,"address":[3280015,3279940],"length":1,"stats":{"Line":3}},{"line":32,"address":[6048843,6048914],"length":1,"stats":{"Line":4}},{"line":33,"address":[5797516,5797592,5797429],"length":1,"stats":{"Line":7}},{"line":35,"address":[5329905,5329770,5329394],"length":1,"stats":{"Line":4}},{"line":36,"address":[6049613,6050610,6051090,6050486],"length":1,"stats":{"Line":8}},{"line":37,"address":[5331075,5331148,5331046],"length":1,"stats":{"Line":6}},{"line":38,"address":[5674052,5674140],"length":1,"stats":{"Line":5}},{"line":43,"address":[5672790],"length":1,"stats":{"Line":5}},{"line":44,"address":[20700300],"length":1,"stats":{"Line":0}},{"line":47,"address":[3280895,3281214,3281329],"length":1,"stats":{"Line":10}},{"line":48,"address":[5798516],"length":1,"stats":{"Line":4}},{"line":52,"address":[20700447],"length":1,"stats":{"Line":3}},{"line":54,"address":[5500460],"length":1,"stats":{"Line":2}},{"line":55,"address":[20646570,20645744,20646564],"length":1,"stats":{"Line":10}},{"line":58,"address":[6051452,6051622],"length":1,"stats":{"Line":3}},{"line":65,"address":[5332406],"length":1,"stats":{"Line":2}},{"line":66,"address":[6052208,6052351,6052478,6052704,6052137],"length":1,"stats":{"Line":10}},{"line":67,"address":[20868305,20868170],"length":1,"stats":{"Line":0}},{"line":69,"address":[6052446,6052276],"length":1,"stats":{"Line":3}},{"line":76,"address":[5676006],"length":1,"stats":{"Line":2}},{"line":79,"address":[5801446],"length":1,"stats":{"Line":1}},{"line":82,"address":[5333346],"length":1,"stats":{"Line":2}},{"line":85,"address":[3282385],"length":1,"stats":{"Line":2}},{"line":87,"address":[6053164],"length":1,"stats":{"Line":3}},{"line":88,"address":[20646275],"length":1,"stats":{"Line":1}},{"line":89,"address":[5333452],"length":1,"stats":{"Line":4}},{"line":92,"address":[20701338],"length":1,"stats":{"Line":2}},{"line":93,"address":[21113183,21113629],"length":1,"stats":{"Line":0}},{"line":98,"address":[5504221,5502848,5504215],"length":1,"stats":{"Line":3}},{"line":102,"address":[5502889],"length":1,"stats":{"Line":2}},{"line":103,"address":[5503103,5502980],"length":1,"stats":{"Line":0}},{"line":104,"address":[6053884],"length":1,"stats":{"Line":0}},{"line":109,"address":[5334128],"length":1,"stats":{"Line":3}},{"line":110,"address":[3285092,3285160,3284976],"length":1,"stats":{"Line":7}},{"line":111,"address":[5677259,5677208],"length":1,"stats":{"Line":5}},{"line":112,"address":[5334613],"length":1,"stats":{"Line":3}},{"line":113,"address":[3285452],"length":1,"stats":{"Line":4}},{"line":119,"address":[5334724],"length":1,"stats":{"Line":0}},{"line":121,"address":[5802932,5803003,5803071],"length":1,"stats":{"Line":0}},{"line":122,"address":[5677771,5677822],"length":1,"stats":{"Line":0}},{"line":123,"address":[5677942],"length":1,"stats":{"Line":0}},{"line":124,"address":[5678001],"length":1,"stats":{"Line":0}},{"line":131,"address":[5504168],"length":1,"stats":{"Line":0}},{"line":135,"address":[5335996,5335990,5335360],"length":1,"stats":{"Line":2}},{"line":137,"address":[5803526],"length":1,"stats":{"Line":2}},{"line":140,"address":[6055108,6055173,6055241],"length":1,"stats":{"Line":8}},{"line":141,"address":[6055352,6055301],"length":1,"stats":{"Line":5}},{"line":142,"address":[5803963],"length":1,"stats":{"Line":2}},{"line":143,"address":[5678637],"length":1,"stats":{"Line":3}},{"line":148,"address":[6055612],"length":1,"stats":{"Line":0}},{"line":152,"address":[5804780,5804144,5804774],"length":1,"stats":{"Line":3}},{"line":154,"address":[5678822],"length":1,"stats":{"Line":1}},{"line":157,"address":[5804309,5804244,5804377],"length":1,"stats":{"Line":9}},{"line":158,"address":[5804437,5804488],"length":1,"stats":{"Line":5}},{"line":159,"address":[5505371],"length":1,"stats":{"Line":1}},{"line":160,"address":[3287305],"length":1,"stats":{"Line":4}},{"line":165,"address":[5804748],"length":1,"stats":{"Line":0}},{"line":169,"address":[5680213,5680219,5679440],"length":1,"stats":{"Line":1}},{"line":176,"address":[5804934],"length":1,"stats":{"Line":1}},{"line":179,"address":[5505897,5505957],"length":1,"stats":{"Line":3}},{"line":181,"address":[6056970],"length":1,"stats":{"Line":1}},{"line":182,"address":[5337283],"length":1,"stats":{"Line":2}},{"line":190,"address":[5506352,5510873,5512837],"length":1,"stats":{"Line":1}},{"line":196,"address":[5506447],"length":1,"stats":{"Line":2}},{"line":197,"address":[5805768],"length":1,"stats":{"Line":1}},{"line":199,"address":[5506713,5506580,5506673],"length":1,"stats":{"Line":5}},{"line":204,"address":[5507040,5506679],"length":1,"stats":{"Line":3}},{"line":205,"address":[5680986,5681057],"length":1,"stats":{"Line":3}},{"line":206,"address":[3289161,3289068,3289233,3289353],"length":1,"stats":{"Line":0}},{"line":211,"address":[5338823,5338423,5338958],"length":1,"stats":{"Line":4}},{"line":212,"address":[5681786,5685017],"length":1,"stats":{"Line":3}},{"line":213,"address":[5342352],"length":1,"stats":{"Line":2}},{"line":216,"address":[6062041],"length":1,"stats":{"Line":3}},{"line":219,"address":[5342446],"length":1,"stats":{"Line":3}},{"line":221,"address":[5511404],"length":1,"stats":{"Line":3}},{"line":222,"address":[5511560],"length":1,"stats":{"Line":3}},{"line":223,"address":[3293326],"length":1,"stats":{"Line":3}},{"line":225,"address":[6062421],"length":1,"stats":{"Line":3}},{"line":226,"address":[5342808],"length":1,"stats":{"Line":2}},{"line":229,"address":[6155488,6155510],"length":1,"stats":{"Line":3}},{"line":232,"address":[5685917],"length":1,"stats":{"Line":2}},{"line":233,"address":[5685951],"length":1,"stats":{"Line":1}},{"line":235,"address":[5810715],"length":1,"stats":{"Line":0}},{"line":236,"address":[5512478,5512506,5511499],"length":1,"stats":{"Line":0}},{"line":242,"address":[5807195],"length":1,"stats":{"Line":1}},{"line":243,"address":[5807284,5807355],"length":1,"stats":{"Line":2}},{"line":245,"address":[5682022,5682184],"length":1,"stats":{"Line":2}},{"line":246,"address":[6059124,6059736],"length":1,"stats":{"Line":2}},{"line":247,"address":[6059865,6059786],"length":1,"stats":{"Line":2}},{"line":249,"address":[6059984,6059892,6061865],"length":1,"stats":{"Line":9}},{"line":251,"address":[6061538,6060184,6060244,6060317],"length":1,"stats":{"Line":6}},{"line":252,"address":[5808957,5809033,5809052],"length":1,"stats":{"Line":3}},{"line":253,"address":[5809497,5809188],"length":1,"stats":{"Line":3}},{"line":254,"address":[5683998,5683891,5683947],"length":1,"stats":{"Line":3}},{"line":258,"address":[5809270,5809509],"length":1,"stats":{"Line":3}},{"line":259,"address":[5510313,5510267],"length":1,"stats":{"Line":2}},{"line":260,"address":[6061108],"length":1,"stats":{"Line":1}},{"line":266,"address":[3290229,3290388],"length":1,"stats":{"Line":3}},{"line":267,"address":[5339595],"length":1,"stats":{"Line":2}},{"line":273,"address":[5812128,5812829,5812835],"length":1,"stats":{"Line":2}},{"line":275,"address":[6063691],"length":1,"stats":{"Line":1}},{"line":278,"address":[3294914,3294858],"length":1,"stats":{"Line":3}},{"line":280,"address":[5344315],"length":1,"stats":{"Line":1}},{"line":282,"address":[3295045],"length":1,"stats":{"Line":2}},{"line":283,"address":[5687120],"length":1,"stats":{"Line":1}},{"line":286,"address":[6064039],"length":1,"stats":{"Line":2}},{"line":287,"address":[6064051],"length":1,"stats":{"Line":1}},{"line":288,"address":[5344421],"length":1,"stats":{"Line":1}},{"line":293,"address":[6067308,6064368,6066427],"length":1,"stats":{"Line":1}},{"line":299,"address":[5344821],"length":1,"stats":{"Line":1}},{"line":302,"address":[5513814,5513742],"length":1,"stats":{"Line":2}},{"line":303,"address":[5813191,5813120],"length":1,"stats":{"Line":2}},{"line":305,"address":[5347099,5345098,5345169],"length":1,"stats":{"Line":3}},{"line":306,"address":[3295979],"length":1,"stats":{"Line":0}},{"line":312,"address":[3295883],"length":1,"stats":{"Line":0}},{"line":314,"address":[5688505,5688640,5688394],"length":1,"stats":{"Line":0}},{"line":315,"address":[6065692,6065580],"length":1,"stats":{"Line":0}},{"line":316,"address":[5814285],"length":1,"stats":{"Line":0}},{"line":317,"address":[5814367],"length":1,"stats":{"Line":0}},{"line":319,"address":[5515191,5515286],"length":1,"stats":{"Line":0}},{"line":320,"address":[6066157,6066072],"length":1,"stats":{"Line":0}},{"line":322,"address":[5515421],"length":1,"stats":{"Line":0}},{"line":323,"address":[5814704],"length":1,"stats":{"Line":0}},{"line":327,"address":[5346740],"length":1,"stats":{"Line":0}},{"line":333,"address":[5514140,5515665,5515840,5516446],"length":1,"stats":{"Line":2}},{"line":336,"address":[3296585,3297636,3298060],"length":1,"stats":{"Line":2}},{"line":338,"address":[5516255],"length":1,"stats":{"Line":1}},{"line":339,"address":[5690087],"length":1,"stats":{"Line":1}},{"line":347,"address":[5817405,5815824,5817545],"length":1,"stats":{"Line":1}},{"line":348,"address":[3298277],"length":1,"stats":{"Line":1}},{"line":349,"address":[6067536,6067467],"length":1,"stats":{"Line":2}},{"line":350,"address":[6067643,6067574],"length":1,"stats":{"Line":2}},{"line":352,"address":[5690999,5690875,5690810],"length":1,"stats":{"Line":3}},{"line":353,"address":[5348291,5348598,5349393,5348474],"length":1,"stats":{"Line":4}},{"line":354,"address":[3299283,3299725,3299171,3299200],"length":1,"stats":{"Line":4}},{"line":355,"address":[5817106,5817087,5817027],"length":1,"stats":{"Line":2}},{"line":356,"address":[5817226],"length":1,"stats":{"Line":1}},{"line":360,"address":[5348353],"length":1,"stats":{"Line":1}},{"line":364,"address":[3300487,3299920,3300493],"length":1,"stats":{"Line":1}},{"line":366,"address":[5518379],"length":1,"stats":{"Line":1}},{"line":369,"address":[5349708,5349764],"length":1,"stats":{"Line":2}},{"line":371,"address":[5518651],"length":1,"stats":{"Line":1}},{"line":373,"address":[5817987],"length":1,"stats":{"Line":1}},{"line":374,"address":[5692576],"length":1,"stats":{"Line":1}},{"line":377,"address":[5518727],"length":1,"stats":{"Line":1}},{"line":387,"address":[3300512,3302679,3302760],"length":1,"stats":{"Line":1}},{"line":388,"address":[5518971],"length":1,"stats":{"Line":1}},{"line":391,"address":[5818268,5818340],"length":1,"stats":{"Line":2}},{"line":392,"address":[5350331,5350256],"length":1,"stats":{"Line":2}},{"line":394,"address":[5350380,5350451],"length":1,"stats":{"Line":2}},{"line":395,"address":[3301093,3301021,3300934],"length":1,"stats":{"Line":3}},{"line":397,"address":[3301395,3301027,3301522],"length":1,"stats":{"Line":3}},{"line":398,"address":[5694601,5695078,5694477,5693918],"length":1,"stats":{"Line":4}},{"line":399,"address":[5351943,5352016,5351914],"length":1,"stats":{"Line":3}},{"line":400,"address":[5521032,5521120],"length":1,"stats":{"Line":2}},{"line":405,"address":[5819335,5819493],"length":1,"stats":{"Line":2}},{"line":406,"address":[3301692],"length":1,"stats":{"Line":1}},{"line":413,"address":[5521280,5523451,5523540],"length":1,"stats":{"Line":1}},{"line":414,"address":[3302843],"length":1,"stats":{"Line":1}},{"line":417,"address":[6072140,6072212],"length":1,"stats":{"Line":2}},{"line":418,"address":[6072331,6072256],"length":1,"stats":{"Line":2}},{"line":420,"address":[3303120,3303207],"length":1,"stats":{"Line":2}},{"line":421,"address":[5695875,5695606,5695693,5695769],"length":1,"stats":{"Line":0}},{"line":426,"address":[3303683,3303810,3303315],"length":1,"stats":{"Line":3}},{"line":427,"address":[5353502,5354061,5354185,5354614],"length":1,"stats":{"Line":4}},{"line":428,"address":[5697063,5697136,5697034],"length":1,"stats":{"Line":3}},{"line":429,"address":[5697224,5697312],"length":1,"stats":{"Line":2}},{"line":434,"address":[5821687,5821845],"length":1,"stats":{"Line":2}},{"line":435,"address":[6073264],"length":1,"stats":{"Line":1}},{"line":439,"address":[5824264,5822832,5824199],"length":1,"stats":{"Line":1}},{"line":441,"address":[5523627],"length":1,"stats":{"Line":1}},{"line":444,"address":[6074682,6074610],"length":1,"stats":{"Line":2}},{"line":445,"address":[5523963,5524034,5524248,5524102],"length":1,"stats":{"Line":3}},{"line":448,"address":[5633824,5633841],"length":1,"stats":{"Line":2}},{"line":449,"address":[6037232],"length":1,"stats":{"Line":0}},{"line":450,"address":[5634062],"length":1,"stats":{"Line":0}},{"line":454,"address":[5698302],"length":1,"stats":{"Line":1}},{"line":457,"address":[6075214],"length":1,"stats":{"Line":1}},{"line":460,"address":[3305900],"length":1,"stats":{"Line":1}},{"line":461,"address":[5823739],"length":1,"stats":{"Line":1}},{"line":463,"address":[6075417],"length":1,"stats":{"Line":1}},{"line":464,"address":[5524551],"length":1,"stats":{"Line":1}},{"line":465,"address":[3306019],"length":1,"stats":{"Line":1}},{"line":468,"address":[6075385],"length":1,"stats":{"Line":1}},{"line":474,"address":[5526193,5526258,5525056],"length":1,"stats":{"Line":1}},{"line":476,"address":[5698987],"length":1,"stats":{"Line":1}},{"line":479,"address":[5699274,5699202],"length":1,"stats":{"Line":2}},{"line":480,"address":[5824683,5824754,5824822,5824968],"length":1,"stats":{"Line":3}},{"line":483,"address":[5810864,5810881],"length":1,"stats":{"Line":2}},{"line":484,"address":[5634368],"length":1,"stats":{"Line":0}},{"line":485,"address":[5634382],"length":1,"stats":{"Line":0}},{"line":489,"address":[5699774],"length":1,"stats":{"Line":1}},{"line":491,"address":[5357111],"length":1,"stats":{"Line":1}},{"line":492,"address":[5825161],"length":1,"stats":{"Line":1}},{"line":493,"address":[5357067],"length":1,"stats":{"Line":1}},{"line":495,"address":[3307381],"length":1,"stats":{"Line":1}},{"line":500,"address":[5358118,5357408,5358155],"length":1,"stats":{"Line":1}},{"line":502,"address":[3307734],"length":1,"stats":{"Line":1}},{"line":503,"address":[5526453,5526521,5526388],"length":1,"stats":{"Line":3}},{"line":504,"address":[3308036,3307985],"length":1,"stats":{"Line":0}},{"line":505,"address":[5357874],"length":1,"stats":{"Line":0}},{"line":506,"address":[5357928,5357987],"length":1,"stats":{"Line":0}},{"line":507,"address":[3308282],"length":1,"stats":{"Line":0}},{"line":511,"address":[5826257],"length":1,"stats":{"Line":1}},{"line":515,"address":[6078534,6077824,6078571],"length":1,"stats":{"Line":1}},{"line":517,"address":[5358214],"length":1,"stats":{"Line":1}},{"line":518,"address":[6077989,6078057,6077924],"length":1,"stats":{"Line":3}},{"line":519,"address":[5527400,5527349],"length":1,"stats":{"Line":0}},{"line":520,"address":[5527522],"length":1,"stats":{"Line":0}},{"line":521,"address":[5826883,5826824],"length":1,"stats":{"Line":0}},{"line":522,"address":[5701534],"length":1,"stats":{"Line":0}},{"line":526,"address":[3309181],"length":1,"stats":{"Line":1}},{"line":532,"address":[5827750,5827072,5827712],"length":1,"stats":{"Line":1}},{"line":533,"address":[5358991],"length":1,"stats":{"Line":1}},{"line":534,"address":[3309486,3309337,3309599,3309402],"length":1,"stats":{"Line":6}},{"line":537,"address":[5811184,5811201],"length":1,"stats":{"Line":2}},{"line":538,"address":[5701913,5702182,5702358,5702066],"length":1,"stats":{"Line":10}},{"line":539,"address":[5827606],"length":1,"stats":{"Line":1}},{"line":543,"address":[6080128,6079296,6080168],"length":1,"stats":{"Line":1}},{"line":544,"address":[3309932],"length":1,"stats":{"Line":1}},{"line":545,"address":[5359738],"length":1,"stats":{"Line":1}},{"line":547,"address":[6079397,6079530,6079462],"length":1,"stats":{"Line":3}},{"line":548,"address":[5828070,5828119],"length":1,"stats":{"Line":2}},{"line":550,"address":[6079862],"length":1,"stats":{"Line":1}},{"line":551,"address":[5703138,5703181,5703246],"length":1,"stats":{"Line":6}},{"line":552,"address":[5828599],"length":1,"stats":{"Line":2}},{"line":556,"address":[5360486],"length":1,"stats":{"Line":2}},{"line":560,"address":[5830145,5828672,5829988],"length":1,"stats":{"Line":1}},{"line":565,"address":[5360594],"length":1,"stats":{"Line":1}},{"line":567,"address":[5828792,5828857,5829226,5828925],"length":1,"stats":{"Line":5}},{"line":569,"address":[3311097],"length":1,"stats":{"Line":1}},{"line":576,"address":[5360969],"length":1,"stats":{"Line":1}},{"line":577,"address":[6080761,6081573,6080625],"length":1,"stats":{"Line":6}},{"line":578,"address":[5530150,5530223,5530093],"length":1,"stats":{"Line":6}},{"line":579,"address":[3311603,3311682],"length":1,"stats":{"Line":4}},{"line":580,"address":[3311896],"length":1,"stats":{"Line":2}},{"line":587,"address":[5704532,5704020],"length":1,"stats":{"Line":3}},{"line":589,"address":[5704546],"length":1,"stats":{"Line":1}},{"line":592,"address":[6080659],"length":1,"stats":{"Line":1}},{"line":597,"address":[3313060,3313054,3312256],"length":1,"stats":{"Line":1}},{"line":599,"address":[6081703],"length":1,"stats":{"Line":1}},{"line":600,"address":[5704889,5704972],"length":1,"stats":{"Line":2}},{"line":601,"address":[5531173,5531224],"length":1,"stats":{"Line":0}},{"line":602,"address":[5811597,5811584],"length":1,"stats":{"Line":0}},{"line":603,"address":[5362594,5362529],"length":1,"stats":{"Line":0}},{"line":604,"address":[6082325],"length":1,"stats":{"Line":0}},{"line":606,"address":[6082215,6082369],"length":1,"stats":{"Line":0}},{"line":607,"address":[6082452],"length":1,"stats":{"Line":0}},{"line":610,"address":[5531189],"length":1,"stats":{"Line":1}},{"line":618,"address":[5705648],"length":1,"stats":{"Line":3}},{"line":620,"address":[5705668],"length":1,"stats":{"Line":3}},{"line":623,"address":[5364988,5364982,5362928],"length":1,"stats":{"Line":3}},{"line":625,"address":[6082644],"length":1,"stats":{"Line":3}},{"line":626,"address":[5831212,5831280],"length":1,"stats":{"Line":3}},{"line":629,"address":[3313488,3313592,3313401],"length":1,"stats":{"Line":8}},{"line":630,"address":[5532336,5532636],"length":1,"stats":{"Line":6}},{"line":631,"address":[5532867],"length":1,"stats":{"Line":3}},{"line":632,"address":[6083686],"length":1,"stats":{"Line":3}},{"line":633,"address":[5706925,5707031],"length":1,"stats":{"Line":3}},{"line":634,"address":[5364323,5364372],"length":1,"stats":{"Line":3}},{"line":635,"address":[3314779],"length":1,"stats":{"Line":2}},{"line":636,"address":[3314972,3314935],"length":1,"stats":{"Line":3}},{"line":637,"address":[5707626],"length":1,"stats":{"Line":3}},{"line":644,"address":[5706273],"length":1,"stats":{"Line":0}},{"line":649,"address":[6084656],"length":1,"stats":{"Line":0}},{"line":651,"address":[5533908],"length":1,"stats":{"Line":0}},{"line":654,"address":[5709878,5709884,5707824],"length":1,"stats":{"Line":0}},{"line":656,"address":[5365124],"length":1,"stats":{"Line":0}},{"line":657,"address":[3315452,3315384],"length":1,"stats":{"Line":0}},{"line":660,"address":[5833528,5833457,5833652],"length":1,"stats":{"Line":0}},{"line":661,"address":[5708652,5708352],"length":1,"stats":{"Line":0}},{"line":662,"address":[5534995],"length":1,"stats":{"Line":0}},{"line":663,"address":[5366166],"length":1,"stats":{"Line":0}},{"line":664,"address":[5366285,5366391],"length":1,"stats":{"Line":0}},{"line":665,"address":[5535380,5535331],"length":1,"stats":{"Line":0}},{"line":666,"address":[5709491],"length":1,"stats":{"Line":0}},{"line":667,"address":[3317031,3317068],"length":1,"stats":{"Line":0}},{"line":668,"address":[5709754],"length":1,"stats":{"Line":0}},{"line":675,"address":[5534513],"length":1,"stats":{"Line":0}},{"line":680,"address":[3317280],"length":1,"stats":{"Line":3}},{"line":684,"address":[5536040],"length":1,"stats":{"Line":3}},{"line":685,"address":[5536066,5536372],"length":1,"stats":{"Line":3}},{"line":686,"address":[6086914,6087013],"length":1,"stats":{"Line":3}},{"line":687,"address":[5367398],"length":1,"stats":{"Line":1}},{"line":688,"address":[3317645],"length":1,"stats":{"Line":1}},{"line":690,"address":[5835587],"length":1,"stats":{"Line":2}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[3320198,3317696,3320279],"length":1,"stats":{"Line":1}},{"line":700,"address":[3317749],"length":1,"stats":{"Line":1}},{"line":703,"address":[5710422,5710494],"length":1,"stats":{"Line":2}},{"line":704,"address":[3317906,3317981],"length":1,"stats":{"Line":2}},{"line":706,"address":[6087542,6087613],"length":1,"stats":{"Line":3}},{"line":707,"address":[5836128,5836215,5836291],"length":1,"stats":{"Line":3}},{"line":709,"address":[5711237,5711372,5710861],"length":1,"stats":{"Line":3}},{"line":710,"address":[5712409,5711432,5712930,5712533],"length":1,"stats":{"Line":4}},{"line":711,"address":[6089596,6089494,6089523],"length":1,"stats":{"Line":3}},{"line":712,"address":[5538884,5538972],"length":1,"stats":{"Line":2}},{"line":717,"address":[5368721,5368812],"length":1,"stats":{"Line":4}},{"line":719,"address":[5711551,5711926],"length":1,"stats":{"Line":3}},{"line":721,"address":[5837526],"length":1,"stats":{"Line":1}},{"line":722,"address":[6089006],"length":1,"stats":{"Line":1}},{"line":730,"address":[5840030,5838368,5839741],"length":1,"stats":{"Line":2}},{"line":732,"address":[3320363],"length":1,"stats":{"Line":2}},{"line":733,"address":[3320432,3320664,3320759,3320497,3320977],"length":1,"stats":{"Line":8}},{"line":736,"address":[5370489,5370659],"length":1,"stats":{"Line":2}},{"line":743,"address":[5371091],"length":1,"stats":{"Line":2}},{"line":744,"address":[3321464,3321366,3321298,3321227],"length":1,"stats":{"Line":3}},{"line":745,"address":[3321426,3321485],"length":1,"stats":{"Line":2}},{"line":746,"address":[5540328,5540404],"length":1,"stats":{"Line":2}},{"line":749,"address":[5540277],"length":1,"stats":{"Line":0}},{"line":753,"address":[5714392],"length":1,"stats":{"Line":1}},{"line":755,"address":[5714451],"length":1,"stats":{"Line":1}},{"line":756,"address":[5540516],"length":1,"stats":{"Line":1}},{"line":757,"address":[5540556],"length":1,"stats":{"Line":1}},{"line":763,"address":[5540800,5541264,5541270],"length":1,"stats":{"Line":1}},{"line":765,"address":[5840079],"length":1,"stats":{"Line":1}},{"line":766,"address":[5541243,5540947,5540871],"length":1,"stats":{"Line":2}},{"line":771,"address":[5372416],"length":1,"stats":{"Line":0}},{"line":772,"address":[5372417],"length":1,"stats":{"Line":0}}],"covered":256,"coverable":325},{"path":["/","home","imalison","Projects","lastfm-edit","src","retry.rs"],"content":"use crate::types::{LastFmError, RetryConfig, RetryResult};\nuse crate::Result;\nuse std::future::Future;\nuse std::time::{Instant, SystemTime, UNIX_EPOCH};\n\n/// Execute an async operation with retry logic for rate limiting\n///\n/// This function handles the common pattern of retrying operations that may fail\n/// due to rate limiting, with exponential backoff and configurable limits.\n///\n/// # Arguments\n/// * `config` - Retry configuration\n/// * `operation_name` - Name of the operation for logging\n/// * `operation` - Async function that returns a Result\n/// * `on_rate_limit` - Callback for rate limit events (delay in seconds, timestamp)\n/// * `on_rate_limit_end` - Optional callback for when rate limiting ends (total duration in seconds)\n///\n/// # Returns\n/// A `RetryResult` containing the successful result and retry statistics\npub async fn retry_with_backoff\u003cT, F, Fut, OnRateLimit, OnRateLimitEnd\u003e(\n    config: RetryConfig,\n    operation_name: \u0026str,\n    mut operation: F,\n    mut on_rate_limit: OnRateLimit,\n    mut on_rate_limit_end: OnRateLimitEnd,\n) -\u003e Result\u003cRetryResult\u003cT\u003e\u003e\nwhere\n    F: FnMut() -\u003e Fut,\n    Fut: Future\u003cOutput = Result\u003cT\u003e\u003e,\n    OnRateLimit: FnMut(u64, u64, \u0026str),\n    OnRateLimitEnd: FnMut(u64, \u0026str),\n{\n    let mut retries = 0;\n    let mut total_retry_time = 0;\n    let mut rate_limit_start_time: Option\u003cInstant\u003e = None;\n\n    loop {\n        match operation().await {\n            Ok(result) =\u003e {\n                // If we had rate limiting and now succeeded, emit rate limit end event\n                if let Some(start_time) = rate_limit_start_time {\n                    let total_duration = start_time.elapsed().as_secs();\n                    on_rate_limit_end(total_duration, operation_name);\n                }\n\n                return Ok(RetryResult {\n                    result,\n                    attempts_made: retries,\n                    total_retry_time,\n                });\n            }\n            Err(LastFmError::RateLimit { retry_after }) =\u003e {\n                // Track when rate limiting first occurs\n                if rate_limit_start_time.is_none() {\n                    rate_limit_start_time = Some(Instant::now());\n                }\n\n                if !config.enabled || retries \u003e= config.max_retries {\n                    if !config.enabled {\n                        log::debug!(\"Retries disabled for {operation_name} operation\");\n                    } else {\n                        log::warn!(\n                            \"Max retries ({}) exceeded for {operation_name} operation\",\n                            config.max_retries\n                        );\n                    }\n                    return Err(LastFmError::RateLimit { retry_after });\n                }\n\n                // Calculate delay with exponential backoff\n                let base_backoff = config.base_delay * 2_u64.pow(retries);\n                let delay = std::cmp::min(\n                    std::cmp::min(retry_after + base_backoff, config.max_delay),\n                    retry_after + (retries as u64 * 30), // Legacy backoff for compatibility\n                );\n\n                log::info!(\n                    \"{} rate limited. Waiting {} seconds before retry {} of {}\",\n                    operation_name,\n                    delay,\n                    retries + 1,\n                    config.max_retries\n                );\n\n                // Notify caller about rate limit\n                let timestamp = SystemTime::now()\n                    .duration_since(UNIX_EPOCH)\n                    .unwrap_or_default()\n                    .as_secs();\n                on_rate_limit(delay, timestamp, operation_name);\n\n                tokio::time::sleep(std::time::Duration::from_secs(delay)).await;\n                retries += 1;\n                total_retry_time += delay;\n            }\n            Err(other_error) =\u003e {\n                return Err(other_error);\n            }\n        }\n    }\n}\n\n/// Simplified retry function for operations that don't need custom rate limit handling\npub async fn retry_operation\u003cT, F, Fut\u003e(\n    config: RetryConfig,\n    operation_name: \u0026str,\n    operation: F,\n) -\u003e Result\u003cRetryResult\u003cT\u003e\u003e\nwhere\n    F: FnMut() -\u003e Fut,\n    Fut: Future\u003cOutput = Result\u003cT\u003e\u003e,\n{\n    retry_with_backoff(\n        config,\n        operation_name,\n        operation,\n        |delay, timestamp, op_name| {\n            log::debug!(\n                \"Rate limited during {op_name}: waiting {delay} seconds (at timestamp {timestamp})\"\n            );\n        },\n        |duration, op_name| {\n            log::debug!(\"Rate limiting ended for {op_name} after {duration} seconds\");\n        },\n    )\n    .await\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::sync::atomic::{AtomicU32, Ordering};\n    use std::sync::Arc;\n\n    #[tokio::test]\n    async fn test_successful_operation() {\n        let config = RetryConfig {\n            max_retries: 3,\n            base_delay: 1,\n            max_delay: 60,\n            enabled: true,\n        };\n\n        let result = retry_operation(config, \"test\", || async { Ok::\u003ci32, LastFmError\u003e(42) }).await;\n\n        assert!(result.is_ok());\n        let retry_result = result.unwrap();\n        assert_eq!(retry_result.result, 42);\n        assert_eq!(retry_result.attempts_made, 0);\n        assert_eq!(retry_result.total_retry_time, 0);\n    }\n\n    #[tokio::test]\n    async fn test_retry_on_rate_limit() {\n        let config = RetryConfig {\n            max_retries: 2,\n            base_delay: 1,\n            max_delay: 60,\n            enabled: true,\n        };\n\n        let call_count = Arc::new(AtomicU32::new(0));\n        let call_count_clone = call_count.clone();\n\n        let result = retry_operation(config, \"test\", move || {\n            let count = call_count_clone.fetch_add(1, Ordering::SeqCst);\n            async move {\n                if count \u003c 2 {\n                    Err(LastFmError::RateLimit { retry_after: 1 })\n                } else {\n                    Ok::\u003ci32, LastFmError\u003e(42)\n                }\n            }\n        })\n        .await;\n\n        assert!(result.is_ok());\n        let retry_result = result.unwrap();\n        assert_eq!(retry_result.result, 42);\n        assert_eq!(retry_result.attempts_made, 2);\n        assert!(retry_result.total_retry_time \u003e= 2); // At least 2 seconds of delay\n    }\n\n    #[tokio::test]\n    async fn test_max_retries_exceeded() {\n        let config = RetryConfig {\n            max_retries: 1,\n            base_delay: 1,\n            max_delay: 60,\n            enabled: true,\n        };\n\n        let result = retry_operation(config, \"test\", || async {\n            Err::\u003ci32, LastFmError\u003e(LastFmError::RateLimit { retry_after: 1 })\n        })\n        .await;\n\n        assert!(result.is_err());\n        match result.unwrap_err() {\n            LastFmError::RateLimit { .. } =\u003e {} // Expected\n            other =\u003e panic!(\"Expected rate limit error, got: {other:?}\"),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_retries_disabled() {\n        let config = RetryConfig::disabled();\n\n        let result = retry_operation(config, \"test\", || async {\n            Err::\u003ci32, LastFmError\u003e(LastFmError::RateLimit { retry_after: 1 })\n        })\n        .await;\n\n        assert!(result.is_err());\n        match result.unwrap_err() {\n            LastFmError::RateLimit { .. } =\u003e {} // Expected - should fail immediately\n            other =\u003e panic!(\"Expected rate limit error, got: {other:?}\"),\n        }\n    }\n}\n","traces":[{"line":20,"address":[3394128,3393728,3393872,3393936,3394272,3393808,3393664],"length":1,"stats":{"Line":9}},{"line":33,"address":[],"length":0,"stats":{"Line":11}},{"line":34,"address":[5896671,5891841,5887212],"length":1,"stats":{"Line":9}},{"line":35,"address":[5891860,5896690,5887231],"length":1,"stats":{"Line":10}},{"line":37,"address":[5991831,5995811,5991182,5996475,6000644,6001295],"length":1,"stats":{"Line":13}},{"line":38,"address":[5479393,5481345,5478913],"length":1,"stats":{"Line":31}},{"line":39,"address":[6021265,6016581,6026048],"length":1,"stats":{"Line":8}},{"line":41,"address":[6001755,5996978,5992288],"length":1,"stats":{"Line":6}},{"line":42,"address":[3396154,3418992,3419175,3423671,3395965,3405241,3400607,3409975,3414433,3414622,3400860,3409792,3405424,3423488],"length":1,"stats":{"Line":4}},{"line":43,"address":[5992595,5997349,6002071],"length":1,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":5}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":48,"address":[5893169,5897936,5888460],"length":1,"stats":{"Line":5}},{"line":49,"address":[3419050,3414491,3400691,3405299,3396023,3409850,3423546],"length":1,"stats":{"Line":9}},{"line":52,"address":[6265829,6270589,6275309],"length":1,"stats":{"Line":4}},{"line":54,"address":[6275337,6270824,6266147,6275637,6270620,6265857,6270935,6266036,6275520],"length":1,"stats":{"Line":12}},{"line":55,"address":[5898505,5893809,5889021],"length":1,"stats":{"Line":4}},{"line":58,"address":[5993071,6002561,5997859,6002422,5992938,5997726],"length":1,"stats":{"Line":7}},{"line":59,"address":[5993045,5997833,6002535],"length":1,"stats":{"Line":2}},{"line":60,"address":[5936626,5936729,5946043,5941318,5941524,5946134,5946237,5936535,5941409],"length":1,"stats":{"Line":3}},{"line":62,"address":[3421503,3398491,3407323,3412303,3421074,3425999,3407752,3425570,3416994,3403234,3402797,3411874,3398062,3416562],"length":1,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[5941423,5946148,5936640],"length":1,"stats":{"Line":2}},{"line":71,"address":[3415315,3406091,3401450,3419842,3410642,3396710,3410522,3419722,3401570,3415192,3405971,3396830,3424218,3424338],"length":1,"stats":{"Line":3}},{"line":73,"address":[6017523,6022311,6022358,6027063,6027016,6017570],"length":1,"stats":{"Line":6}},{"line":74,"address":[5894154,5889366,5898862,5894301,5899009,5889513],"length":1,"stats":{"Line":3}},{"line":77,"address":[],"length":0,"stats":{"Line":5}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[6018373,6022655,6017867,6027363,6027875,6023157],"length":1,"stats":{"Line":6}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[5895032,5890248,5899750],"length":1,"stats":{"Line":3}},{"line":92,"address":[3402628,3399584,3404214,3395003,3394874,3408647,3416393,3417847,3407154,3404184,3399455,3408778,3413453,3420905,3422474,3397893,3411705,3417978,3404085,3413423,3413328,3417948,3394973,3422343,3422444,3408748,3399554,3425401],"length":1,"stats":{"Line":9}},{"line":93,"address":[6025383,6020557,6016023,6025482,6015924,6020656],"length":1,"stats":{"Line":3}},{"line":94,"address":[5933843,5938528,5943351,5938401,5943227,5933891,5943302,5933768,5938476],"length":1,"stats":{"Line":6}},{"line":96,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[6002340,5992856,5997632],"length":1,"stats":{"Line":2}},{"line":104,"address":[3426544,3426608,3426672,3426736],"length":1,"stats":{"Line":4}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[3429648,3430032,3429264,3430416],"length":1,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":4}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":14}}],"covered":39,"coverable":51},{"path":["/","home","imalison","Projects","lastfm-edit","src","session_persistence.rs"],"content":"use crate::types::{LastFmEditSession, LastFmError};\nuse crate::Result;\nuse std::fs;\nuse std::path::PathBuf;\n\n/// Configurable session manager for storing session data in XDG directories.\n///\n/// This struct allows customization of the application prefix for session storage.\n/// Sessions are stored per-user in the format:\n/// `~/.local/share/{app_name}/users/{username}/session.json`\n#[derive(Clone, Debug)]\npub struct SessionManager {\n    app_name: String,\n}\n\nimpl SessionManager {\n    /// Create a new session manager with a custom application name.\n    ///\n    /// # Arguments\n    /// * `app_name` - The application name to use as the directory prefix\n    pub fn new(app_name: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            app_name: app_name.into(),\n        }\n    }\n\n    /// Get the session file path for a given username using the configured app name.\n    ///\n    /// Returns a path like: `~/.local/share/{app_name}/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns the path where the session should be stored, or an error if\n    /// the XDG data directory cannot be determined.\n    pub fn get_session_path(\u0026self, username: \u0026str) -\u003e Result\u003cPathBuf\u003e {\n        let data_dir = dirs::data_dir()\n            .ok_or_else(|| LastFmError::Http(\"Cannot determine XDG data directory\".to_string()))?;\n\n        let session_dir = data_dir.join(\u0026self.app_name).join(\"users\").join(username);\n\n        Ok(session_dir.join(\"session.json\"))\n    }\n\n    /// Save a session to the XDG data directory.\n    ///\n    /// This creates the necessary directory structure and saves the session\n    /// as JSON to `~/.local/share/{app_name}/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `session` - The session to save\n    ///\n    /// # Returns\n    /// Returns Ok(()) on success, or an error if the save fails.\n    pub fn save_session(\u0026self, session: \u0026LastFmEditSession) -\u003e Result\u003c()\u003e {\n        let session_path = self.get_session_path(\u0026session.username)?;\n\n        // Create parent directories if they don't exist\n        if let Some(parent) = session_path.parent() {\n            fs::create_dir_all(parent).map_err(|e| {\n                LastFmError::Http(format!(\"Failed to create session directory: {e}\"))\n            })?;\n        }\n\n        // Serialize session to JSON\n        let session_json = session\n            .to_json()\n            .map_err(|e| LastFmError::Http(format!(\"Failed to serialize session: {e}\")))?;\n\n        // Write to file\n        fs::write(\u0026session_path, session_json)\n            .map_err(|e| LastFmError::Http(format!(\"Failed to write session file: {e}\")))?;\n\n        log::debug!(\"Session saved to: {}\", session_path.display());\n        Ok(())\n    }\n\n    /// Load a session from the XDG data directory.\n    ///\n    /// Attempts to load a session from `~/.local/share/{app_name}/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns the loaded session on success, or an error if the file doesn't exist\n    /// or cannot be parsed.\n    pub fn load_session(\u0026self, username: \u0026str) -\u003e Result\u003cLastFmEditSession\u003e {\n        let session_path = self.get_session_path(username)?;\n\n        if !session_path.exists() {\n            return Err(LastFmError::Http(format!(\n                \"No saved session found for user: {username}\"\n            )));\n        }\n\n        // Read and parse session file\n        let session_json = fs::read_to_string(\u0026session_path)\n            .map_err(|e| LastFmError::Http(format!(\"Failed to read session file: {e}\")))?;\n\n        let session = LastFmEditSession::from_json(\u0026session_json)\n            .map_err(|e| LastFmError::Http(format!(\"Failed to parse session JSON: {e}\")))?;\n\n        log::debug!(\"Session loaded from: {}\", session_path.display());\n        Ok(session)\n    }\n\n    /// Check if a saved session exists for the given username.\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns true if a session file exists, false otherwise.\n    pub fn session_exists(\u0026self, username: \u0026str) -\u003e bool {\n        match self.get_session_path(username) {\n            Ok(path) =\u003e path.exists(),\n            Err(_) =\u003e false,\n        }\n    }\n\n    /// Remove a saved session for the given username.\n    ///\n    /// This deletes the session file from the XDG data directory.\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns Ok(()) on success, or an error if the deletion fails.\n    pub fn remove_session(\u0026self, username: \u0026str) -\u003e Result\u003c()\u003e {\n        let session_path = self.get_session_path(username)?;\n\n        if session_path.exists() {\n            fs::remove_file(\u0026session_path)\n                .map_err(|e| LastFmError::Http(format!(\"Failed to remove session file: {e}\")))?;\n            log::debug!(\"Session removed from: {}\", session_path.display());\n        }\n\n        Ok(())\n    }\n\n    /// List all usernames that have saved sessions.\n    ///\n    /// Scans the XDG data directory for session files and returns the usernames.\n    ///\n    /// # Returns\n    /// Returns a vector of usernames that have saved sessions.\n    pub fn list_saved_users(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        let data_dir = dirs::data_dir()\n            .ok_or_else(|| LastFmError::Http(\"Cannot determine XDG data directory\".to_string()))?;\n\n        let users_dir = data_dir.join(\u0026self.app_name).join(\"users\");\n\n        if !users_dir.exists() {\n            return Ok(Vec::new());\n        }\n\n        let mut users = Vec::new();\n        let entries = fs::read_dir(\u0026users_dir)\n            .map_err(|e| LastFmError::Http(format!(\"Failed to read users directory: {e}\")))?;\n\n        for entry in entries {\n            let entry = entry\n                .map_err(|e| LastFmError::Http(format!(\"Failed to read directory entry: {e}\")))?;\n\n            if entry.file_type().map(|t| t.is_dir()).unwrap_or(false) {\n                let session_file = entry.path().join(\"session.json\");\n                if session_file.exists() {\n                    if let Some(username) = entry.file_name().to_str() {\n                        users.push(username.to_string());\n                    }\n                }\n            }\n        }\n\n        Ok(users)\n    }\n\n    /// Get the application name used by this session manager.\n    pub fn app_name(\u0026self) -\u003e \u0026str {\n        \u0026self.app_name\n    }\n}\n\n/// Session persistence utilities for managing session data in XDG directories.\n///\n/// This module provides functionality to save and load Last.fm session data\n/// using the XDG Base Directory Specification. Sessions are stored per-user\n/// in the format: `~/.local/share/lastfm-edit/users/{username}/session.json`\n///\n/// # Deprecated\n/// Use [`SessionManager`] instead for more flexibility and customization.\npub struct SessionPersistence;\n\nimpl SessionPersistence {\n    /// Get the default session manager for lastfm-edit.\n    fn default_manager() -\u003e SessionManager {\n        SessionManager::new(\"lastfm-edit\")\n    }\n\n    /// Get the session file path for a given username using XDG directories.\n    ///\n    /// Returns a path like: `~/.local/share/lastfm-edit/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns the path where the session should be stored, or an error if\n    /// the XDG data directory cannot be determined.\n    pub fn get_session_path(username: \u0026str) -\u003e Result\u003cPathBuf\u003e {\n        Self::default_manager().get_session_path(username)\n    }\n\n    /// Save a session to the XDG data directory.\n    ///\n    /// This creates the necessary directory structure and saves the session\n    /// as JSON to `~/.local/share/lastfm-edit/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `session` - The session to save\n    ///\n    /// # Returns\n    /// Returns Ok(()) on success, or an error if the save fails.\n    pub fn save_session(session: \u0026LastFmEditSession) -\u003e Result\u003c()\u003e {\n        Self::default_manager().save_session(session)\n    }\n\n    /// Load a session from the XDG data directory.\n    ///\n    /// Attempts to load a session from `~/.local/share/lastfm-edit/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns the loaded session on success, or an error if the file doesn't exist\n    /// or cannot be parsed.\n    pub fn load_session(username: \u0026str) -\u003e Result\u003cLastFmEditSession\u003e {\n        Self::default_manager().load_session(username)\n    }\n\n    /// Check if a saved session exists for the given username.\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns true if a session file exists, false otherwise.\n    pub fn session_exists(username: \u0026str) -\u003e bool {\n        Self::default_manager().session_exists(username)\n    }\n\n    /// Remove a saved session for the given username.\n    ///\n    /// This deletes the session file from the XDG data directory.\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns Ok(()) on success, or an error if the deletion fails.\n    pub fn remove_session(username: \u0026str) -\u003e Result\u003c()\u003e {\n        Self::default_manager().remove_session(username)\n    }\n\n    /// List all usernames that have saved sessions.\n    ///\n    /// Scans the XDG data directory for session files and returns the usernames.\n    ///\n    /// # Returns\n    /// Returns a vector of usernames that have saved sessions.\n    pub fn list_saved_users() -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        Self::default_manager().list_saved_users()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_session_path_generation() {\n        let path = SessionPersistence::get_session_path(\"testuser\").unwrap();\n        assert!(path\n            .to_string_lossy()\n            .contains(\"lastfm-edit/users/testuser/session.json\"));\n    }\n\n    #[test]\n    fn test_session_exists_nonexistent() {\n        let fake_username = format!(\"nonexistent_user_{}\", std::process::id());\n        assert!(!SessionPersistence::session_exists(\u0026fake_username));\n    }\n}\n","traces":[{"line":21,"address":[6278640],"length":1,"stats":{"Line":4}},{"line":23,"address":[6029879],"length":1,"stats":{"Line":4}},{"line":37,"address":[5726656,5727533,5727539],"length":1,"stats":{"Line":2}},{"line":38,"address":[5468424,5468579],"length":1,"stats":{"Line":2}},{"line":39,"address":[5637315],"length":1,"stats":{"Line":0}},{"line":41,"address":[6040719,6040792],"length":1,"stats":{"Line":7}},{"line":43,"address":[5637907],"length":1,"stats":{"Line":4}},{"line":56,"address":[3181920,3181912,3180256],"length":1,"stats":{"Line":1}},{"line":57,"address":[5813868],"length":1,"stats":{"Line":1}},{"line":60,"address":[5814213,5814142],"length":1,"stats":{"Line":2}},{"line":61,"address":[6030283,6030289,6030048],"length":1,"stats":{"Line":2}},{"line":62,"address":[3148278,3148343],"length":1,"stats":{"Line":0}},{"line":67,"address":[3180797,3180977,3181075,3181918],"length":1,"stats":{"Line":2}},{"line":69,"address":[5638878],"length":1,"stats":{"Line":0}},{"line":72,"address":[6042491,6042259,6042377,6042974],"length":1,"stats":{"Line":2}},{"line":73,"address":[5513590,5513568],"length":1,"stats":{"Line":0}},{"line":75,"address":[5470472,5470566],"length":1,"stats":{"Line":2}},{"line":76,"address":[3181481],"length":1,"stats":{"Line":1}},{"line":89,"address":[3183910,3181936,3183943],"length":1,"stats":{"Line":1}},{"line":90,"address":[5729321],"length":1,"stats":{"Line":1}},{"line":92,"address":[5729639,5729568],"length":1,"stats":{"Line":2}},{"line":93,"address":[3182370,3182313],"length":1,"stats":{"Line":0}},{"line":99,"address":[5817573,5816218,5816337,5815943],"length":1,"stats":{"Line":2}},{"line":100,"address":[5471761],"length":1,"stats":{"Line":0}},{"line":102,"address":[6044013,6043942,6044160],"length":1,"stats":{"Line":2}},{"line":103,"address":[6279856,6279878],"length":1,"stats":{"Line":0}},{"line":105,"address":[5816967,5816877,5817171],"length":1,"stats":{"Line":3}},{"line":106,"address":[3183347],"length":1,"stats":{"Line":1}},{"line":116,"address":[5731622,5731344,5731616],"length":1,"stats":{"Line":2}},{"line":117,"address":[5641887],"length":1,"stats":{"Line":2}},{"line":118,"address":[3184044],"length":1,"stats":{"Line":2}},{"line":119,"address":[5817667],"length":1,"stats":{"Line":0}},{"line":132,"address":[6046418,6045440,6046412],"length":1,"stats":{"Line":1}},{"line":133,"address":[5731721],"length":1,"stats":{"Line":1}},{"line":135,"address":[5818270,5818202],"length":1,"stats":{"Line":2}},{"line":136,"address":[3184689,3184809],"length":1,"stats":{"Line":1}},{"line":137,"address":[5818424],"length":1,"stats":{"Line":0}},{"line":138,"address":[5642741],"length":1,"stats":{"Line":1}},{"line":141,"address":[6045800],"length":1,"stats":{"Line":1}},{"line":150,"address":[5732672,5735071,5735169],"length":1,"stats":{"Line":1}},{"line":151,"address":[3185319,3185483],"length":1,"stats":{"Line":1}},{"line":152,"address":[5819069],"length":1,"stats":{"Line":0}},{"line":154,"address":[6046826,6046735],"length":1,"stats":{"Line":2}},{"line":156,"address":[5643785],"length":1,"stats":{"Line":1}},{"line":157,"address":[5475079,5475033],"length":1,"stats":{"Line":0}},{"line":160,"address":[5819596],"length":1,"stats":{"Line":1}},{"line":161,"address":[5475215,5475337,5475144,5476860],"length":1,"stats":{"Line":2}},{"line":162,"address":[3186186],"length":1,"stats":{"Line":0}},{"line":164,"address":[5475419,5475513,5475598],"length":1,"stats":{"Line":3}},{"line":165,"address":[5475935,5475660,5475837],"length":1,"stats":{"Line":2}},{"line":166,"address":[3186768],"length":1,"stats":{"Line":0}},{"line":168,"address":[6032192,6032196],"length":1,"stats":{"Line":4}},{"line":169,"address":[3187072],"length":1,"stats":{"Line":1}},{"line":170,"address":[5645224],"length":1,"stats":{"Line":1}},{"line":171,"address":[5734782,5734888],"length":1,"stats":{"Line":2}},{"line":172,"address":[5821291,5821250],"length":1,"stats":{"Line":2}},{"line":178,"address":[6047765],"length":1,"stats":{"Line":1}},{"line":182,"address":[6048944],"length":1,"stats":{"Line":1}},{"line":183,"address":[6048949],"length":1,"stats":{"Line":1}},{"line":199,"address":[3187776],"length":1,"stats":{"Line":2}},{"line":200,"address":[5735208],"length":1,"stats":{"Line":2}},{"line":213,"address":[6048992,6049125,6049131],"length":1,"stats":{"Line":1}},{"line":214,"address":[5735276],"length":1,"stats":{"Line":1}},{"line":227,"address":[5735516,5735392,5735510],"length":1,"stats":{"Line":0}},{"line":228,"address":[6049186],"length":1,"stats":{"Line":0}},{"line":241,"address":[5735675,5735536,5735669],"length":1,"stats":{"Line":0}},{"line":242,"address":[5735580],"length":1,"stats":{"Line":0}},{"line":252,"address":[5646335,5646208,5646329],"length":1,"stats":{"Line":1}},{"line":253,"address":[5646241],"length":1,"stats":{"Line":1}},{"line":265,"address":[5646491,5646485,5646352],"length":1,"stats":{"Line":0}},{"line":266,"address":[3188396],"length":1,"stats":{"Line":0}},{"line":275,"address":[5646512,5646615,5646621],"length":1,"stats":{"Line":0}},{"line":276,"address":[5646536],"length":1,"stats":{"Line":0}}],"covered":52,"coverable":73},{"path":["/","home","imalison","Projects","lastfm-edit","src","trait.rs"],"content":"use crate::iterator::AsyncPaginatedIterator;\nuse crate::types::{\n    Album, Artist, ArtistPage, ClientEvent, ClientEventReceiver, EditResponse, ExactScrobbleEdit,\n    LastFmEditSession, LastFmError, ScrobbleEdit, Track,\n};\nuse crate::Result;\nuse async_trait::async_trait;\n\n/// Trait for Last.fm client operations that can be mocked for testing.\n///\n/// This trait abstracts the core functionality needed for Last.fm scrobble editing\n/// to enable easy mocking and testing. All methods that perform network operations or\n/// state changes are included to support comprehensive test coverage.\n///\n/// # Mocking Support\n///\n/// When the `mock` feature is enabled, this crate provides `MockLastFmEditClient`\n/// that implements this trait using the `mockall` library.\n///\n#[cfg_attr(feature = \"mock\", mockall::automock)]\n#[async_trait(?Send)]\npub trait LastFmEditClient {\n    // =============================================================================\n    // CORE EDITING METHODS - Most important functionality\n    // =============================================================================\n\n    /// Edit scrobbles by discovering and updating all matching instances.\n    ///\n    /// This is the main editing method that automatically discovers all scrobble instances\n    /// that match the provided criteria and applies the specified changes to each one.\n    ///\n    /// # How it works\n    ///\n    /// 1. **Discovery**: Analyzes the `ScrobbleEdit` to determine what to search for:\n    ///    - If `track_name_original` is specified: finds all album variations of that track\n    ///    - If only `album_name_original` is specified: finds all tracks in that album\n    ///    - If neither is specified: finds all tracks by that artist\n    ///\n    /// 2. **Enrichment**: For each discovered scrobble, extracts complete metadata\n    ///    including album artist information from the user's library\n    ///\n    /// 3. **Editing**: Applies the requested changes to each discovered instance\n    ///\n    /// # Arguments\n    ///\n    /// * `edit` - A `ScrobbleEdit` specifying what to find and how to change it\n    ///\n    /// # Returns\n    ///\n    /// Returns an `EditResponse` containing results for all edited scrobbles, including:\n    /// - Overall success status\n    /// - Individual results for each scrobble instance\n    /// - Detailed error messages if any edits fail\n    ///\n    /// # Errors\n    ///\n    /// Returns `LastFmError::Parse` if no matching scrobbles are found, or other errors\n    /// for network/authentication issues.\n    ///\n    /// # Example\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, ScrobbleEdit, Result};\n    /// # async fn example(client: \u0026dyn LastFmEditClient) -\u003e Result\u003c()\u003e {\n    /// // Change track name for all instances of a track\n    /// let edit = ScrobbleEdit::from_track_and_artist(\"Old Track Name\", \"Artist\")\n    ///     .with_track_name(\"New Track Name\");\n    ///\n    /// let response = client.edit_scrobble(\u0026edit).await?;\n    /// if response.success() {\n    ///     println!(\"Successfully edited {} scrobbles\", response.total_edits());\n    /// }\n    /// # Ok(())\n    /// # }\n    /// ```\n    async fn edit_scrobble(\u0026self, edit: \u0026ScrobbleEdit) -\u003e Result\u003cEditResponse\u003e;\n\n    /// Edit a single scrobble with complete information and retry logic.\n    ///\n    /// This method performs a single edit operation on a fully-specified scrobble.\n    /// Unlike [`edit_scrobble`], this method does not perform discovery, enrichment,\n    /// or multiple edits - it edits exactly one scrobble instance.\n    ///\n    /// # Key Differences from `edit_scrobble`\n    ///\n    /// - **No discovery**: Requires a fully-specified `ExactScrobbleEdit`\n    /// - **Single edit**: Only edits one scrobble instance\n    /// - **No enrichment**: All fields must be provided upfront\n    /// - **Retry logic**: Automatically retries on rate limiting\n    ///\n    /// # Arguments\n    ///\n    /// * `exact_edit` - A fully-specified edit with all required fields populated,\n    ///   including original metadata and timestamps\n    /// * `max_retries` - Maximum number of retry attempts for rate limiting.\n    ///   The method will wait with exponential backoff between retries.\n    ///\n    /// # Returns\n    ///\n    /// Returns an `EditResponse` with a single result indicating success or failure.\n    /// If max retries are exceeded due to rate limiting, returns a failed response\n    /// rather than an error.\n    ///\n    /// # Example\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, ExactScrobbleEdit, Result};\n    /// # async fn example(client: \u0026dyn LastFmEditClient) -\u003e Result\u003c()\u003e {\n    /// let exact_edit = ExactScrobbleEdit::new(\n    ///     \"Original Track\".to_string(),\n    ///     \"Original Album\".to_string(),\n    ///     \"Artist\".to_string(),\n    ///     \"Artist\".to_string(),\n    ///     \"New Track Name\".to_string(),\n    ///     \"Original Album\".to_string(),\n    ///     \"Artist\".to_string(),\n    ///     \"Artist\".to_string(),\n    ///     1640995200, // timestamp\n    ///     false\n    /// );\n    ///\n    /// let response = client.edit_scrobble_single(\u0026exact_edit, 3).await?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    async fn edit_scrobble_single(\n        \u0026self,\n        exact_edit: \u0026ExactScrobbleEdit,\n        max_retries: u32,\n    ) -\u003e Result\u003cEditResponse\u003e;\n\n    /// Delete a scrobble by its identifying information.\n    ///\n    /// This method deletes a specific scrobble from the user's library using the\n    /// artist name, track name, and timestamp to uniquely identify it.\n    ///\n    /// # Arguments\n    ///\n    /// * `artist_name` - The artist name of the scrobble to delete\n    /// * `track_name` - The track name of the scrobble to delete\n    /// * `timestamp` - The unix timestamp of the scrobble to delete\n    ///\n    /// # Returns\n    ///\n    /// Returns `true` if the deletion was successful, `false` otherwise.\n    async fn delete_scrobble(\n        \u0026self,\n        artist_name: \u0026str,\n        track_name: \u0026str,\n        timestamp: u64,\n    ) -\u003e Result\u003cbool\u003e;\n\n    /// Create an incremental discovery iterator for scrobble editing.\n    ///\n    /// This returns the appropriate discovery iterator based on what fields are specified\n    /// in the ScrobbleEdit. The iterator yields `ExactScrobbleEdit` results incrementally,\n    /// which helps avoid rate limiting issues when discovering many scrobbles.\n    ///\n    /// Returns a `Box\u003cdyn AsyncDiscoveryIterator\u003cExactScrobbleEdit\u003e\u003e` to handle the different\n    /// discovery strategies uniformly.\n    fn discover_scrobbles(\n        \u0026self,\n        edit: ScrobbleEdit,\n    ) -\u003e Box\u003cdyn crate::AsyncDiscoveryIterator\u003ccrate::ExactScrobbleEdit\u003e\u003e;\n\n    // =============================================================================\n    // ITERATOR METHODS - Core library browsing functionality\n    // =============================================================================\n\n    /// Create an iterator for browsing all artists in the user's library.\n    fn artists(\u0026self) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cArtist\u003e\u003e;\n\n    /// Create an iterator for browsing an artist's tracks from the user's library.\n    fn artist_tracks(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for browsing an artist's tracks directly using the paginated endpoint.\n    ///\n    /// This alternative approach uses\n    /// `/user/{username}/library/music/{artist}/+tracks` directly with\n    /// pagination, which is more efficient than the album-based approach since\n    /// it doesn't need to iterate through albums first. The downside of this\n    /// approach is that the tracks will not come with album information, which\n    /// will need to get looked up eventually in the process of making edits.\n    fn artist_tracks_direct(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for browsing an artist's albums from the user's library.\n    fn artist_albums(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cAlbum\u003e\u003e;\n\n    /// Create an iterator for browsing tracks from a specific album.\n    fn album_tracks(\n        \u0026self,\n        album_name: \u0026str,\n        artist_name: \u0026str,\n    ) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for browsing the user's recent tracks/scrobbles.\n    fn recent_tracks(\u0026self) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for browsing the user's recent tracks starting from a specific page.\n    fn recent_tracks_from_page(\u0026self, starting_page: u32)\n        -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for searching tracks in the user's library.\n    ///\n    /// This returns an iterator that uses Last.fm's library search functionality\n    /// to find tracks matching the provided query string. The iterator handles\n    /// pagination automatically.\n    ///\n    /// # Arguments\n    ///\n    /// * `query` - The search query (e.g., \"remaster\", \"live\", artist name, etc.)\n    ///\n    /// # Returns\n    ///\n    /// Returns a `SearchTracksIterator` for streaming search results.\n    fn search_tracks(\u0026self, query: \u0026str) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for searching albums in the user's library.\n    ///\n    /// This returns an iterator that uses Last.fm's library search functionality\n    /// to find albums matching the provided query string. The iterator handles\n    /// pagination automatically.\n    ///\n    /// # Arguments\n    ///\n    /// * `query` - The search query (e.g., \"remaster\", \"deluxe\", artist name, etc.)\n    ///\n    /// # Returns\n    ///\n    /// Returns a `SearchAlbumsIterator` for streaming search results.\n    fn search_albums(\u0026self, query: \u0026str) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cAlbum\u003e\u003e;\n\n    // =============================================================================\n    // SEARCH METHODS - Library search functionality\n    // =============================================================================\n\n    /// Get a single page of track search results from the user's library.\n    ///\n    /// This performs a search using Last.fm's library search functionality,\n    /// returning one page of tracks that match the provided query string.\n    /// For iterator-based access, use [`search_tracks`](Self::search_tracks) instead.\n    ///\n    /// # Arguments\n    ///\n    /// * `query` - The search query (e.g., \"remaster\", \"live\", artist name, etc.)\n    /// * `page` - The page number to retrieve (1-based)\n    ///\n    /// # Returns\n    ///\n    /// Returns a `TrackPage` containing the search results with pagination information.\n    async fn search_tracks_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003ccrate::TrackPage\u003e;\n\n    /// Get a single page of album search results from the user's library.\n    ///\n    /// This performs a search using Last.fm's library search functionality,\n    /// returning one page of albums that match the provided query string.\n    /// For iterator-based access, use [`search_albums`](Self::search_albums) instead.\n    ///\n    /// # Arguments\n    ///\n    /// * `query` - The search query (e.g., \"remaster\", \"deluxe\", artist name, etc.)\n    /// * `page` - The page number to retrieve (1-based)\n    ///\n    /// # Returns\n    ///\n    /// Returns an `AlbumPage` containing the search results with pagination information.\n    async fn search_albums_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003ccrate::AlbumPage\u003e;\n\n    // =============================================================================\n    // CORE DATA METHODS - Essential data access\n    // =============================================================================\n\n    /// Get the currently authenticated username.\n    fn username(\u0026self) -\u003e String;\n\n    /// Fetch recent scrobbles from the user's listening history.\n    async fn get_recent_scrobbles(\u0026self, page: u32) -\u003e Result\u003cVec\u003cTrack\u003e\u003e;\n\n    /// Find the most recent scrobble for a specific track.\n    async fn find_recent_scrobble_for_track(\n        \u0026self,\n        track_name: \u0026str,\n        artist_name: \u0026str,\n        max_pages: u32,\n    ) -\u003e Result\u003cOption\u003cTrack\u003e\u003e;\n\n    /// Get a page of artists from the user's library.\n    async fn get_artists_page(\u0026self, page: u32) -\u003e Result\u003cArtistPage\u003e;\n\n    /// Get a page of tracks from the user's library for the specified artist.\n    async fn get_artist_tracks_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003ccrate::TrackPage\u003e;\n\n    /// Get a page of albums from the user's library for the specified artist.\n    async fn get_artist_albums_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003ccrate::AlbumPage\u003e;\n\n    /// Get a page of tracks from a specific album in the user's library.\n    async fn get_album_tracks_page(\n        \u0026self,\n        album_name: \u0026str,\n        artist_name: \u0026str,\n        page: u32,\n    ) -\u003e Result\u003ccrate::TrackPage\u003e;\n\n    /// Get a page of tracks from the user's recent listening history.\n    async fn get_recent_tracks_page(\u0026self, page: u32) -\u003e Result\u003ccrate::TrackPage\u003e {\n        let tracks = self.get_recent_scrobbles(page).await?;\n        let has_next_page = !tracks.is_empty();\n        Ok(crate::TrackPage {\n            tracks,\n            page_number: page,\n            has_next_page,\n            total_pages: None,\n        })\n    }\n\n    // =============================================================================\n    // CONVENIENCE METHODS - Higher-level helpers and shortcuts\n    // =============================================================================\n\n    /// Discover all scrobble edit variations based on the provided ScrobbleEdit template.\n    ///\n    /// This method analyzes what fields are specified in the input ScrobbleEdit and discovers\n    /// all relevant scrobble instances that match the criteria:\n    /// - If track_name_original is specified: discovers all album variations of that track\n    /// - If only album_name_original is specified: discovers all tracks in that album\n    /// - If neither is specified: discovers all tracks by that artist\n    ///\n    /// Returns fully-specified ExactScrobbleEdit instances with all metadata populated\n    /// from the user's library, ready for editing operations.\n    async fn discover_scrobble_edit_variations(\n        \u0026self,\n        edit: \u0026ScrobbleEdit,\n    ) -\u003e Result\u003cVec\u003cExactScrobbleEdit\u003e\u003e {\n        // Use the incremental iterator and collect all results\n        let mut discovery_iterator = self.discover_scrobbles(edit.clone());\n        discovery_iterator.collect_all().await\n    }\n\n    /// Get tracks from a specific album page.\n    async fn get_album_tracks(\u0026self, album_name: \u0026str, artist_name: \u0026str) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        let mut tracks_iterator = self.album_tracks(album_name, artist_name);\n        tracks_iterator.collect_all().await\n    }\n\n    /// Find a scrobble by its timestamp in recent scrobbles.\n    async fn find_scrobble_by_timestamp(\u0026self, timestamp: u64) -\u003e Result\u003cTrack\u003e {\n        log::debug!(\"Searching for scrobble with timestamp {timestamp}\");\n\n        // Search through recent scrobbles to find the one with matching timestamp\n        for page in 1..=10 {\n            // Search up to 10 pages of recent scrobbles\n            let scrobbles = self.get_recent_scrobbles(page).await?;\n\n            for scrobble in scrobbles {\n                if let Some(scrobble_timestamp) = scrobble.timestamp {\n                    if scrobble_timestamp == timestamp {\n                        log::debug!(\n                            \"Found scrobble: '{}' by '{}' with album: '{:?}', album_artist: '{:?}'\",\n                            scrobble.name,\n                            scrobble.artist,\n                            scrobble.album,\n                            scrobble.album_artist\n                        );\n                        return Ok(scrobble);\n                    }\n                }\n            }\n        }\n\n        Err(LastFmError::Parse(format!(\n            \"Could not find scrobble with timestamp {timestamp}\"\n        )))\n    }\n\n    /// Edit album metadata by updating scrobbles with new album name.\n    async fn edit_album(\n        \u0026self,\n        old_album_name: \u0026str,\n        new_album_name: \u0026str,\n        artist_name: \u0026str,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        log::debug!(\"Editing album '{old_album_name}' -\u003e '{new_album_name}' by '{artist_name}'\");\n\n        let edit = ScrobbleEdit::for_album(old_album_name, artist_name, artist_name)\n            .with_album_name(new_album_name);\n\n        self.edit_scrobble(\u0026edit).await\n    }\n\n    /// Edit artist metadata by updating scrobbles with new artist name.\n    ///\n    /// This edits ALL tracks from the artist that are found in recent scrobbles.\n    async fn edit_artist(\n        \u0026self,\n        old_artist_name: \u0026str,\n        new_artist_name: \u0026str,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        log::debug!(\"Editing artist '{old_artist_name}' -\u003e '{new_artist_name}'\");\n\n        let edit = ScrobbleEdit::for_artist(old_artist_name, new_artist_name);\n\n        self.edit_scrobble(\u0026edit).await\n    }\n\n    /// Edit artist metadata for a specific track only.\n    ///\n    /// This edits only the specified track if found in recent scrobbles.\n    async fn edit_artist_for_track(\n        \u0026self,\n        track_name: \u0026str,\n        old_artist_name: \u0026str,\n        new_artist_name: \u0026str,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        log::debug!(\"Editing artist for track '{track_name}' from '{old_artist_name}' -\u003e '{new_artist_name}'\");\n\n        let edit = ScrobbleEdit::from_track_and_artist(track_name, old_artist_name)\n            .with_artist_name(new_artist_name);\n\n        self.edit_scrobble(\u0026edit).await\n    }\n\n    /// Edit artist metadata for all tracks in a specific album.\n    ///\n    /// This edits ALL tracks from the specified album that are found in recent scrobbles.\n    async fn edit_artist_for_album(\n        \u0026self,\n        album_name: \u0026str,\n        old_artist_name: \u0026str,\n        new_artist_name: \u0026str,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        log::debug!(\"Editing artist for album '{album_name}' from '{old_artist_name}' -\u003e '{new_artist_name}'\");\n\n        let edit = ScrobbleEdit::for_album(album_name, old_artist_name, old_artist_name)\n            .with_artist_name(new_artist_name);\n\n        self.edit_scrobble(\u0026edit).await\n    }\n\n    // =============================================================================\n    // SESSION \u0026 EVENT MANAGEMENT - Authentication and monitoring\n    // =============================================================================\n\n    /// Extract the current session state for persistence.\n    ///\n    /// This allows you to save the authentication state and restore it later\n    /// without requiring the user to log in again.\n    ///\n    /// # Returns\n    ///\n    /// Returns a [`LastFmEditSession`] that can be serialized and saved.\n    fn get_session(\u0026self) -\u003e LastFmEditSession;\n\n    /// Restore session state from a previously saved session.\n    ///\n    /// This allows you to restore authentication state without logging in again.\n    ///\n    /// # Arguments\n    ///\n    /// * `session` - Previously saved session state\n    fn restore_session(\u0026self, session: LastFmEditSession);\n\n    /// Subscribe to internal client events.\n    ///\n    /// Returns a broadcast receiver that can be used to listen to events like rate limiting.\n    /// Multiple subscribers can listen simultaneously.\n    ///\n    /// # Example\n    /// ```rust,no_run\n    /// use lastfm_edit::{LastFmEditClientImpl, LastFmEditSession, ClientEvent};\n    ///\n    /// let http_client = http_client::native::NativeClient::new();\n    /// let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let client = LastFmEditClientImpl::from_session(Box::new(http_client), test_session);\n    /// let mut events = client.subscribe();\n    ///\n    /// // Listen for events in a background task\n    /// tokio::spawn(async move {\n    ///     while let Ok(event) = events.recv().await {\n    ///         match event {\n    ///             ClientEvent::RequestStarted { request } =\u003e {\n    ///                 println!(\"Request started: {}\", request.short_description());\n    ///             }\n    ///             ClientEvent::RequestCompleted { request, status_code, duration_ms } =\u003e {\n    ///                 println!(\"Request completed: {} - {} ({} ms)\", request.short_description(), status_code, duration_ms);\n    ///             }\n    ///             ClientEvent::RateLimited { delay_seconds, .. } =\u003e {\n    ///                 println!(\"Rate limited! Waiting {} seconds\", delay_seconds);\n    ///             }\n    ///             ClientEvent::RateLimitEnded { total_rate_limit_duration_seconds, .. } =\u003e {\n    ///                 println!(\"Rate limiting ended after {} seconds\", total_rate_limit_duration_seconds);\n    ///             }\n    ///             ClientEvent::EditAttempted { edit, success, .. } =\u003e {\n    ///                 println!(\"Edit attempt: '{}' -\u003e '{}' - {}\",\n    ///                          edit.track_name_original, edit.track_name,\n    ///                          if success { \"Success\" } else { \"Failed\" });\n    ///             }\n    ///         }\n    ///     }\n    /// });\n    /// ```\n    fn subscribe(\u0026self) -\u003e ClientEventReceiver;\n\n    /// Get the latest client event without subscribing to future events.\n    ///\n    /// This returns the most recent event that occurred, or `None` if no events have occurred yet.\n    /// Unlike `subscribe()`, this provides instant access to the current state without waiting.\n    ///\n    /// # Example\n    /// ```rust,no_run\n    /// use lastfm_edit::{LastFmEditClientImpl, LastFmEditSession, ClientEvent};\n    ///\n    /// let http_client = http_client::native::NativeClient::new();\n    /// let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let client = LastFmEditClientImpl::from_session(Box::new(http_client), test_session);\n    ///\n    /// if let Some(ClientEvent::RateLimited { delay_seconds, .. }) = client.latest_event() {\n    ///     println!(\"Currently rate limited for {} seconds\", delay_seconds);\n    /// }\n    /// ```\n    fn latest_event(\u0026self) -\u003e Option\u003cClientEvent\u003e;\n\n    /// Validate if the current session is still working.\n    ///\n    /// This method makes a test request to a protected Last.fm settings page to verify\n    /// that the current session is still valid. If the session has expired or become\n    /// invalid, Last.fm will redirect to the login page.\n    ///\n    /// This is useful for checking session validity before attempting operations that\n    /// require authentication, especially after loading a previously saved session.\n    ///\n    /// # Returns\n    ///\n    /// Returns `true` if the session is valid and can be used for authenticated operations,\n    /// `false` if the session is invalid or expired.\n    async fn validate_session(\u0026self) -\u003e bool;\n}\n","traces":[{"line":305,"address":[6017304,6017456,6017168,6017500,6017635,6018347,6017203],"length":1,"stats":{"Line":0}},{"line":306,"address":[3353956],"length":1,"stats":{"Line":0}},{"line":307,"address":[5952894,5952965],"length":1,"stats":{"Line":0}},{"line":308,"address":[6010038],"length":1,"stats":{"Line":0}},{"line":309,"address":[6009971],"length":1,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[6010027],"length":1,"stats":{"Line":0}},{"line":335,"address":[6388654],"length":1,"stats":{"Line":1}},{"line":336,"address":[3354724],"length":1,"stats":{"Line":2}},{"line":340,"address":[6389388,6389264,6389642,6389686,6389930,6389299],"length":1,"stats":{"Line":0}},{"line":341,"address":[6011702],"length":1,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[5523070],"length":1,"stats":{"Line":0}},{"line":347,"address":[5955688,5955772],"length":1,"stats":{"Line":0}},{"line":350,"address":[6143164,6143466,6144392],"length":1,"stats":{"Line":0}},{"line":352,"address":[5641284],"length":1,"stats":{"Line":0}},{"line":354,"address":[5956729,5956621,5956864],"length":1,"stats":{"Line":0}},{"line":355,"address":[6144844,6144342],"length":1,"stats":{"Line":0}},{"line":356,"address":[6014428],"length":1,"stats":{"Line":0}},{"line":357,"address":[6144896,6144986,6145274],"length":1,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[6392564],"length":1,"stats":{"Line":0}},{"line":370,"address":[6014052],"length":1,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[5958771,5958875],"length":1,"stats":{"Line":0}},{"line":384,"address":[6016235,6015815],"length":1,"stats":{"Line":0}},{"line":385,"address":[6146654],"length":1,"stats":{"Line":0}},{"line":387,"address":[3350663],"length":1,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[5960327],"length":1,"stats":{"Line":0}},{"line":402,"address":[6395869,6395759,6394960,6395674],"length":1,"stats":{"Line":0}},{"line":414,"address":[6396675,6396770],"length":1,"stats":{"Line":0}},{"line":416,"address":[6396727,6397138],"length":1,"stats":{"Line":0}},{"line":417,"address":[6397125],"length":1,"stats":{"Line":0}},{"line":419,"address":[3353463],"length":1,"stats":{"Line":0}},{"line":431,"address":[6020163,6020267],"length":1,"stats":{"Line":0}},{"line":433,"address":[6398215,6398635],"length":1,"stats":{"Line":0}},{"line":434,"address":[2844726],"length":1,"stats":{"Line":0}},{"line":436,"address":[2844942,2844840,2843968,2844763],"length":1,"stats":{"Line":0}}],"covered":2,"coverable":44},{"path":["/","home","imalison","Projects","lastfm-edit","src","types.rs"],"content":"//! Data types for Last.fm music metadata and operations.\n//!\n//! This module contains all the core data structures used throughout the crate,\n//! including track and album metadata, edit operations, error types, session state,\n//! configuration, and event handling.\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fmt;\nuse thiserror::Error;\nuse tokio::sync::{broadcast, watch};\n\n// ================================================================================================\n// TRACK AND ALBUM METADATA\n// ================================================================================================\n\n/// Represents a music track with associated metadata.\n///\n/// This structure contains track information as parsed from Last.fm pages,\n/// including play count and optional timestamp data for scrobbles.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]\npub struct Track {\n    /// The track name/title\n    pub name: String,\n    /// The artist name\n    pub artist: String,\n    /// Number of times this track has been played/scrobbled\n    pub playcount: u32,\n    /// Unix timestamp of when this track was scrobbled (if available)\n    ///\n    /// This field is populated when tracks are retrieved from recent scrobbles\n    /// or individual scrobble data, but may be `None` for aggregate track listings.\n    pub timestamp: Option\u003cu64\u003e,\n    /// The album name (if available)\n    ///\n    /// This field is populated when tracks are retrieved from recent scrobbles\n    /// where album information is available in the edit forms. May be `None`\n    /// for aggregate track listings or when album information is not available.\n    pub album: Option\u003cString\u003e,\n    /// The album artist name (if available and different from track artist)\n    ///\n    /// This field is populated when tracks are retrieved from recent scrobbles\n    /// where album artist information is available. May be `None` for tracks\n    /// where the album artist is the same as the track artist, or when this\n    /// information is not available.\n    pub album_artist: Option\u003cString\u003e,\n}\n\nimpl fmt::Display for Track {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let album_part = if let Some(ref album) = self.album {\n            format!(\" [{album}]\")\n        } else {\n            String::new()\n        };\n        write!(f, \"{} - {}{}\", self.artist, self.name, album_part)\n    }\n}\n\n/// Represents a paginated collection of tracks.\n///\n/// This structure is returned by track listing methods and provides\n/// information about the current page and pagination state.\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]\npub struct TrackPage {\n    /// The tracks on this page\n    pub tracks: Vec\u003cTrack\u003e,\n    /// Current page number (1-indexed)\n    pub page_number: u32,\n    /// Whether there are more pages available\n    pub has_next_page: bool,\n    /// Total number of pages, if known\n    ///\n    /// This may be `None` if the total page count cannot be determined\n    /// from the Last.fm response.\n    pub total_pages: Option\u003cu32\u003e,\n}\n\n/// Represents a music album with associated metadata.\n///\n/// This structure contains album information as parsed from Last.fm pages,\n/// including play count and optional timestamp data for scrobbles.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]\npub struct Album {\n    /// The album name/title\n    pub name: String,\n    /// The artist name\n    pub artist: String,\n    /// Number of times this album has been played/scrobbled\n    pub playcount: u32,\n    /// Unix timestamp of when this album was last scrobbled (if available)\n    ///\n    /// This field is populated when albums are retrieved from recent scrobbles\n    /// or individual scrobble data, but may be `None` for aggregate album listings.\n    pub timestamp: Option\u003cu64\u003e,\n}\n\nimpl fmt::Display for Album {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{} - {}\", self.artist, self.name)\n    }\n}\n\n/// Represents a paginated collection of albums.\n///\n/// This structure is returned by album listing methods and provides\n/// information about the current page and pagination state.\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]\npub struct AlbumPage {\n    /// The albums on this page\n    pub albums: Vec\u003cAlbum\u003e,\n    /// Current page number (1-indexed)\n    pub page_number: u32,\n    /// Whether there are more pages available\n    pub has_next_page: bool,\n    /// Total number of pages, if known\n    ///\n    /// This may be `None` if the total page count cannot be determined\n    /// from the Last.fm response.\n    pub total_pages: Option\u003cu32\u003e,\n}\n\nimpl Album {\n    /// Convert the Unix timestamp to a human-readable datetime.\n    ///\n    /// Returns `None` if no timestamp is available or if the timestamp is invalid.\n    #[must_use]\n    pub fn scrobbled_at(\u0026self) -\u003e Option\u003cDateTime\u003cUtc\u003e\u003e {\n        self.timestamp\n            .and_then(|ts| DateTime::from_timestamp(i64::try_from(ts).ok()?, 0))\n    }\n}\n\n/// Represents a music artist with associated metadata.\n///\n/// This structure contains artist information as parsed from Last.fm pages,\n/// including the total number of scrobbles for this artist.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]\npub struct Artist {\n    /// The artist name\n    pub name: String,\n    /// Number of times this artist has been played/scrobbled\n    pub playcount: u32,\n    /// Unix timestamp of when this artist was last scrobbled (if available)\n    ///\n    /// This field is populated when artists are retrieved from recent scrobbles\n    /// or individual scrobble data, but may be `None` for aggregate artist listings.\n    pub timestamp: Option\u003cu64\u003e,\n}\n\nimpl fmt::Display for Artist {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.name)\n    }\n}\n\n/// Represents a paginated collection of artists.\n///\n/// This structure is returned by artist listing methods and provides\n/// information about the current page and pagination state.\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]\npub struct ArtistPage {\n    /// The artists on this page\n    pub artists: Vec\u003cArtist\u003e,\n    /// Current page number (1-indexed)\n    pub page_number: u32,\n    /// Whether there are more pages available\n    pub has_next_page: bool,\n    /// Total number of pages, if known\n    ///\n    /// This may be `None` if the total page count cannot be determined\n    /// from the Last.fm response.\n    pub total_pages: Option\u003cu32\u003e,\n}\n\nimpl Artist {\n    /// Convert the Unix timestamp to a human-readable datetime.\n    ///\n    /// Returns `None` if no timestamp is available or if the timestamp is invalid.\n    #[must_use]\n    pub fn scrobbled_at(\u0026self) -\u003e Option\u003cDateTime\u003cUtc\u003e\u003e {\n        self.timestamp\n            .and_then(|ts| DateTime::from_timestamp(i64::try_from(ts).ok()?, 0))\n    }\n}\n\n// ================================================================================================\n// EDIT OPERATIONS\n// ================================================================================================\n\n/// Represents a scrobble edit operation.\n///\n/// This structure contains all the information needed to edit a specific scrobble\n/// on Last.fm, including both the original and new metadata values.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]\npub struct ScrobbleEdit {\n    /// Original track name as it appears in the scrobble (optional - if None, edits all tracks)\n    pub track_name_original: Option\u003cString\u003e,\n    /// Original album name as it appears in the scrobble (optional)\n    pub album_name_original: Option\u003cString\u003e,\n    /// Original artist name as it appears in the scrobble (required)\n    pub artist_name_original: String,\n    /// Original album artist name as it appears in the scrobble (optional)\n    pub album_artist_name_original: Option\u003cString\u003e,\n\n    /// New track name to set (optional - if None, keeps original track names)\n    pub track_name: Option\u003cString\u003e,\n    /// New album name to set (optional - if None, keeps original album names)\n    pub album_name: Option\u003cString\u003e,\n    /// New artist name to set\n    pub artist_name: String,\n    /// New album artist name to set (optional - if None, keeps original album artist names)\n    pub album_artist_name: Option\u003cString\u003e,\n\n    /// Unix timestamp of the scrobble to edit (optional)\n    ///\n    /// This identifies the specific scrobble instance to modify.\n    /// If None, the client will attempt to find a representative timestamp.\n    pub timestamp: Option\u003cu64\u003e,\n    /// Whether to edit all instances or just this specific scrobble\n    ///\n    /// When `true`, Last.fm will update all scrobbles with matching metadata.\n    /// When `false`, only this specific scrobble (identified by timestamp) is updated.\n    pub edit_all: bool,\n}\n\nimpl fmt::Display for ScrobbleEdit {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let mut changes = Vec::new();\n\n        // Check if artist is being changed\n        if self.artist_name != self.artist_name_original {\n            changes.push(format!(\n                \"Artist: {} â†’ {}\",\n                self.artist_name_original, self.artist_name\n            ));\n        }\n\n        // Check if track name is being changed\n        if let Some(ref new_track) = self.track_name {\n            if let Some(ref original_track) = self.track_name_original {\n                if new_track != original_track {\n                    changes.push(format!(\"Track: {original_track} â†’ {new_track}\"));\n                }\n            } else {\n                changes.push(format!(\"Track: â†’ {new_track}\"));\n            }\n        }\n\n        // Check if album name is being changed\n        if let Some(ref new_album) = self.album_name {\n            match \u0026self.album_name_original {\n                Some(ref original_album) if new_album != original_album =\u003e {\n                    changes.push(format!(\"Album: {original_album} â†’ {new_album}\"));\n                }\n                None =\u003e {\n                    changes.push(format!(\"Album: â†’ {new_album}\"));\n                }\n                _ =\u003e {} // No change\n            }\n        }\n\n        // Check if album artist is being changed\n        if let Some(ref new_album_artist) = self.album_artist_name {\n            match \u0026self.album_artist_name_original {\n                Some(ref original_album_artist) if new_album_artist != original_album_artist =\u003e {\n                    changes.push(format!(\n                        \"Album Artist: {original_album_artist} â†’ {new_album_artist}\"\n                    ));\n                }\n                None =\u003e {\n                    changes.push(format!(\"Album Artist: â†’ {new_album_artist}\"));\n                }\n                _ =\u003e {} // No change\n            }\n        }\n\n        if changes.is_empty() {\n            write!(f, \"No changes\")\n        } else {\n            let scope = if self.edit_all {\n                \" (all instances)\"\n            } else {\n                \"\"\n            };\n            write!(f, \"{}{}\", changes.join(\", \"), scope)\n        }\n    }\n}\n\n/// Response from a single scrobble edit operation.\n///\n/// This structure contains the result of attempting to edit a specific scrobble instance,\n/// including success status and any error messages.\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]\npub struct SingleEditResponse {\n    /// Whether this individual edit operation was successful\n    pub success: bool,\n    /// Optional message describing the result or any errors\n    pub message: Option\u003cString\u003e,\n    /// Information about which album variation was edited\n    pub album_info: Option\u003cString\u003e,\n    /// The exact scrobble edit that was performed\n    pub exact_scrobble_edit: ExactScrobbleEdit,\n}\n\n/// Response from a scrobble edit operation that may affect multiple album variations.\n///\n/// When editing a track that appears on multiple albums, this response contains\n/// the results of all individual edit operations performed.\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]\npub struct EditResponse {\n    /// Results of individual edit operations\n    pub individual_results: Vec\u003cSingleEditResponse\u003e,\n}\n\n/// Internal representation of a scrobble edit with all fields fully specified.\n///\n/// This type is used internally by the client after enriching metadata from\n/// Last.fm. Unlike `ScrobbleEdit`, all fields are required and non-optional,\n/// ensuring we have complete information before performing edit operations.\n///\n/// This type represents a fully-specified scrobble edit where all fields are known.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]\npub struct ExactScrobbleEdit {\n    /// Original track name as it appears in the scrobble\n    pub track_name_original: String,\n    /// Original album name as it appears in the scrobble\n    pub album_name_original: String,\n    /// Original artist name as it appears in the scrobble\n    pub artist_name_original: String,\n    /// Original album artist name as it appears in the scrobble\n    pub album_artist_name_original: String,\n\n    /// New track name to set\n    pub track_name: String,\n    /// New album name to set\n    pub album_name: String,\n    /// New artist name to set\n    pub artist_name: String,\n    /// New album artist name to set\n    pub album_artist_name: String,\n\n    /// Unix timestamp of the scrobble to edit\n    pub timestamp: u64,\n    /// Whether to edit all instances or just this specific scrobble\n    pub edit_all: bool,\n}\n\nimpl fmt::Display for ExactScrobbleEdit {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let mut changes = Vec::new();\n\n        // Check if artist is being changed\n        if self.artist_name != self.artist_name_original {\n            changes.push(format!(\n                \"Artist: {} â†’ {}\",\n                self.artist_name_original, self.artist_name\n            ));\n        }\n\n        // Check if track name is being changed\n        if self.track_name != self.track_name_original {\n            changes.push(format!(\n                \"Track: {} â†’ {}\",\n                self.track_name_original, self.track_name\n            ));\n        }\n\n        // Check if album name is being changed\n        if self.album_name != self.album_name_original {\n            changes.push(format!(\n                \"Album: {} â†’ {}\",\n                self.album_name_original, self.album_name\n            ));\n        }\n\n        // Check if album artist is being changed\n        if self.album_artist_name != self.album_artist_name_original {\n            changes.push(format!(\n                \"Album Artist: {} â†’ {}\",\n                self.album_artist_name_original, self.album_artist_name\n            ));\n        }\n\n        if changes.is_empty() {\n            write!(f, \"No changes\")\n        } else {\n            let scope = if self.edit_all {\n                \" (all instances)\"\n            } else {\n                \"\"\n            };\n            write!(f, \"{}{}\", changes.join(\", \"), scope)\n        }\n    }\n}\n\nimpl ScrobbleEdit {\n    /// Create a new [`ScrobbleEdit`] with all required fields.\n    ///\n    /// This is the most general constructor that allows setting all fields.\n    /// For convenience, consider using [`from_track_info`](Self::from_track_info) instead.\n    ///\n    /// # Arguments\n    ///\n    /// * `track_name_original` - The current track name in the scrobble\n    /// * `album_name_original` - The current album name in the scrobble\n    /// * `artist_name_original` - The current artist name in the scrobble\n    /// * `album_artist_name_original` - The current album artist name in the scrobble\n    /// * `track_name` - The new track name to set\n    /// * `album_name` - The new album name to set\n    /// * `artist_name` - The new artist name to set\n    /// * `album_artist_name` - The new album artist name to set\n    /// * `timestamp` - Unix timestamp identifying the scrobble\n    /// * `edit_all` - Whether to edit all matching scrobbles or just this one\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        track_name_original: Option\u003cString\u003e,\n        album_name_original: Option\u003cString\u003e,\n        artist_name_original: String,\n        album_artist_name_original: Option\u003cString\u003e,\n        track_name: Option\u003cString\u003e,\n        album_name: Option\u003cString\u003e,\n        artist_name: String,\n        album_artist_name: Option\u003cString\u003e,\n        timestamp: Option\u003cu64\u003e,\n        edit_all: bool,\n    ) -\u003e Self {\n        Self {\n            track_name_original,\n            album_name_original,\n            artist_name_original,\n            album_artist_name_original,\n            track_name,\n            album_name,\n            artist_name,\n            album_artist_name,\n            timestamp,\n            edit_all,\n        }\n    }\n\n    /// Create an edit request from track information (convenience constructor).\n    ///\n    /// This constructor creates a [`ScrobbleEdit`] with the new values initially\n    /// set to the same as the original values. Use the builder methods like\n    /// [`with_track_name`](Self::with_track_name) to specify what should be changed.\n    ///\n    /// # Arguments\n    ///\n    /// * `original_track` - The current track name\n    /// * `original_album` - The current album name\n    /// * `original_artist` - The current artist name\n    /// * `timestamp` - Unix timestamp identifying the scrobble\n    pub fn from_track_info(\n        original_track: \u0026str,\n        original_album: \u0026str,\n        original_artist: \u0026str,\n        timestamp: u64,\n    ) -\u003e Self {\n        Self::new(\n            Some(original_track.to_string()),\n            Some(original_album.to_string()),\n            original_artist.to_string(),\n            Some(original_artist.to_string()), // album_artist defaults to artist\n            Some(original_track.to_string()),\n            Some(original_album.to_string()),\n            original_artist.to_string(),\n            Some(original_artist.to_string()), // album_artist defaults to artist\n            Some(timestamp),\n            true, // edit_all defaults to true\n        )\n    }\n\n    /// Set the new track name.\n    pub fn with_track_name(mut self, track_name: \u0026str) -\u003e Self {\n        self.track_name = Some(track_name.to_string());\n        self\n    }\n\n    /// Set the new album name.\n    pub fn with_album_name(mut self, album_name: \u0026str) -\u003e Self {\n        self.album_name = Some(album_name.to_string());\n        self\n    }\n\n    /// Set the new artist name.\n    ///\n    /// This also sets the album artist name to the same value.\n    pub fn with_artist_name(mut self, artist_name: \u0026str) -\u003e Self {\n        self.artist_name = artist_name.to_string();\n        self.album_artist_name = Some(artist_name.to_string());\n        self\n    }\n\n    /// Set whether to edit all instances of this track.\n    ///\n    /// When `true`, Last.fm will update all scrobbles with the same metadata.\n    /// When `false` (default), only the specific scrobble is updated.\n    pub fn with_edit_all(mut self, edit_all: bool) -\u003e Self {\n        self.edit_all = edit_all;\n        self\n    }\n\n    /// Create an edit request with minimal information, letting the client look up missing metadata.\n    ///\n    /// This constructor is useful when you only know some of the original metadata and want\n    /// the client to automatically fill in missing information by looking up the scrobble.\n    ///\n    /// # Arguments\n    ///\n    /// * `track_name` - The new track name to set\n    /// * `artist_name` - The new artist name to set\n    /// * `album_name` - The new album name to set\n    /// * `timestamp` - Unix timestamp identifying the scrobble\n    pub fn with_minimal_info(\n        track_name: \u0026str,\n        artist_name: \u0026str,\n        album_name: \u0026str,\n        timestamp: u64,\n    ) -\u003e Self {\n        Self::new(\n            Some(track_name.to_string()),\n            Some(album_name.to_string()),\n            artist_name.to_string(),\n            Some(artist_name.to_string()),\n            Some(track_name.to_string()),\n            Some(album_name.to_string()),\n            artist_name.to_string(),\n            Some(artist_name.to_string()),\n            Some(timestamp),\n            true,\n        )\n    }\n    /// Create an edit request with just track and artist information.\n    ///\n    /// This constructor is useful when you only know the track and artist names.\n    /// The client will use these as both original and new values, and will\n    /// attempt to find a representative timestamp and album information.\n    ///\n    /// # Arguments\n    ///\n    /// * `track_name` - The track name (used as both original and new)\n    /// * `artist_name` - The artist name (used as both original and new)\n    pub fn from_track_and_artist(track_name: \u0026str, artist_name: \u0026str) -\u003e Self {\n        Self::new(\n            Some(track_name.to_string()),\n            None, // Client will look up original album name\n            artist_name.to_string(),\n            None, // Client will look up original album artist name\n            Some(track_name.to_string()),\n            None, // Will be filled by client or kept as original\n            artist_name.to_string(),\n            Some(artist_name.to_string()), // album_artist defaults to artist\n            None,                          // Client will find representative timestamp\n            true,\n        )\n    }\n\n    /// Create an edit request for all tracks by an artist.\n    ///\n    /// This constructor creates a [`ScrobbleEdit`] that will edit all tracks\n    /// by the specified artist, changing the artist name to the new value.\n    ///\n    /// # Arguments\n    ///\n    /// * `old_artist_name` - The current artist name to change from\n    /// * `new_artist_name` - The new artist name to change to\n    pub fn for_artist(old_artist_name: \u0026str, new_artist_name: \u0026str) -\u003e Self {\n        Self::new(\n            None, // No specific track - edit all tracks\n            None, // No specific album - edit all albums\n            old_artist_name.to_string(),\n            None, // Client will look up original album artist name\n            None, // No track name change - keep original track names\n            None, // Keep original album names (they can vary)\n            new_artist_name.to_string(),\n            Some(new_artist_name.to_string()), // album_artist also changes for global renames\n            None,                              // Client will find representative timestamp\n            true,                              // Edit all instances by default for artist changes\n        )\n    }\n\n    /// Create an edit request for all tracks in a specific album.\n    ///\n    /// This constructor creates a [`ScrobbleEdit`] that will edit all tracks\n    /// in the specified album by the specified artist.\n    ///\n    /// # Arguments\n    ///\n    /// * `album_name` - The album name containing tracks to edit\n    /// * `artist_name` - The artist name for the album\n    /// * `new_artist_name` - The new artist name to change to\n    pub fn for_album(album_name: \u0026str, old_artist_name: \u0026str, new_artist_name: \u0026str) -\u003e Self {\n        Self::new(\n            None, // No specific track - edit all tracks in album\n            Some(album_name.to_string()),\n            old_artist_name.to_string(),\n            Some(old_artist_name.to_string()),\n            None,                         // No track name change - keep original track names\n            Some(album_name.to_string()), // Keep same album name\n            new_artist_name.to_string(),\n            None, // Keep original album_artist names (they can vary)\n            None, // Client will find representative timestamp\n            true, // Edit all instances by default for album changes\n        )\n    }\n}\n\nimpl ExactScrobbleEdit {\n    /// Create a new [`ExactScrobbleEdit`] with all fields specified.\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        track_name_original: String,\n        album_name_original: String,\n        artist_name_original: String,\n        album_artist_name_original: String,\n        track_name: String,\n        album_name: String,\n        artist_name: String,\n        album_artist_name: String,\n        timestamp: u64,\n        edit_all: bool,\n    ) -\u003e Self {\n        Self {\n            track_name_original,\n            album_name_original,\n            artist_name_original,\n            album_artist_name_original,\n            track_name,\n            album_name,\n            artist_name,\n            album_artist_name,\n            timestamp,\n            edit_all,\n        }\n    }\n\n    /// Build the form data for submitting this scrobble edit.\n    ///\n    /// This creates a HashMap containing all the form fields needed to submit\n    /// the edit request to Last.fm, including the CSRF token and all metadata fields.\n    pub fn build_form_data(\u0026self, csrf_token: \u0026str) -\u003e HashMap\u003c\u0026str, String\u003e {\n        let mut form_data = HashMap::new();\n\n        // Add fresh CSRF token (required)\n        form_data.insert(\"csrfmiddlewaretoken\", csrf_token.to_string());\n\n        // Include ALL form fields (using ExactScrobbleEdit which has all required fields)\n        form_data.insert(\"track_name_original\", self.track_name_original.clone());\n        form_data.insert(\"track_name\", self.track_name.clone());\n        form_data.insert(\"artist_name_original\", self.artist_name_original.clone());\n        form_data.insert(\"artist_name\", self.artist_name.clone());\n        form_data.insert(\"album_name_original\", self.album_name_original.clone());\n        form_data.insert(\"album_name\", self.album_name.clone());\n        form_data.insert(\n            \"album_artist_name_original\",\n            self.album_artist_name_original.clone(),\n        );\n        form_data.insert(\"album_artist_name\", self.album_artist_name.clone());\n\n        // Include timestamp (ExactScrobbleEdit always has a timestamp)\n        form_data.insert(\"timestamp\", self.timestamp.to_string());\n\n        // Edit flags\n        if self.edit_all {\n            form_data.insert(\"edit_all\", \"1\".to_string());\n        }\n        form_data.insert(\"submit\", \"edit-scrobble\".to_string());\n        form_data.insert(\"ajax\", \"1\".to_string());\n\n        form_data\n    }\n\n    /// Convert this exact edit back to a public ScrobbleEdit.\n    ///\n    /// This is useful when you need to expose the edit data through the public API.\n    pub fn to_scrobble_edit(\u0026self) -\u003e ScrobbleEdit {\n        ScrobbleEdit::new(\n            Some(self.track_name_original.clone()),\n            Some(self.album_name_original.clone()),\n            self.artist_name_original.clone(),\n            Some(self.album_artist_name_original.clone()),\n            Some(self.track_name.clone()),\n            Some(self.album_name.clone()),\n            self.artist_name.clone(),\n            Some(self.album_artist_name.clone()),\n            Some(self.timestamp),\n            self.edit_all,\n        )\n    }\n}\n\nimpl EditResponse {\n    /// Create a new EditResponse from a single result.\n    pub fn single(\n        success: bool,\n        message: Option\u003cString\u003e,\n        album_info: Option\u003cString\u003e,\n        exact_scrobble_edit: ExactScrobbleEdit,\n    ) -\u003e Self {\n        Self {\n            individual_results: vec![SingleEditResponse {\n                success,\n                message,\n                album_info,\n                exact_scrobble_edit,\n            }],\n        }\n    }\n\n    /// Create a new EditResponse from multiple results.\n    pub fn from_results(results: Vec\u003cSingleEditResponse\u003e) -\u003e Self {\n        Self {\n            individual_results: results,\n        }\n    }\n\n    /// Check if all individual edit operations were successful.\n    pub fn all_successful(\u0026self) -\u003e bool {\n        !self.individual_results.is_empty() \u0026\u0026 self.individual_results.iter().all(|r| r.success)\n    }\n\n    /// Check if any individual edit operations were successful.\n    pub fn any_successful(\u0026self) -\u003e bool {\n        self.individual_results.iter().any(|r| r.success)\n    }\n\n    /// Get the total number of edit operations performed.\n    pub fn total_edits(\u0026self) -\u003e usize {\n        self.individual_results.len()\n    }\n\n    /// Get the number of successful edit operations.\n    pub fn successful_edits(\u0026self) -\u003e usize {\n        self.individual_results.iter().filter(|r| r.success).count()\n    }\n\n    /// Get the number of failed edit operations.\n    pub fn failed_edits(\u0026self) -\u003e usize {\n        self.individual_results\n            .iter()\n            .filter(|r| !r.success)\n            .count()\n    }\n\n    /// Generate a summary message describing the overall result.\n    pub fn summary_message(\u0026self) -\u003e String {\n        let total = self.total_edits();\n        let successful = self.successful_edits();\n        let failed = self.failed_edits();\n\n        if total == 0 {\n            return \"No edit operations performed\".to_string();\n        }\n\n        if successful == total {\n            if total == 1 {\n                \"Edit completed successfully\".to_string()\n            } else {\n                format!(\"All {total} edits completed successfully\")\n            }\n        } else if successful == 0 {\n            if total == 1 {\n                \"Edit failed\".to_string()\n            } else {\n                format!(\"All {total} edits failed\")\n            }\n        } else {\n            format!(\"{successful} of {total} edits succeeded, {failed} failed\")\n        }\n    }\n\n    /// Get detailed messages from all edit operations.\n    pub fn detailed_messages(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.individual_results\n            .iter()\n            .enumerate()\n            .map(|(i, result)| {\n                let album_info = result\n                    .album_info\n                    .as_deref()\n                    .map(|info| format!(\" ({info})\"))\n                    .unwrap_or_default();\n\n                match \u0026result.message {\n                    Some(msg) =\u003e format!(\"{}: {}{}\", i + 1, msg, album_info),\n                    None =\u003e {\n                        if result.success {\n                            format!(\"{}: Success{}\", i + 1, album_info)\n                        } else {\n                            format!(\"{}: Failed{}\", i + 1, album_info)\n                        }\n                    }\n                }\n            })\n            .collect()\n    }\n\n    /// Check if this response represents a single edit (for backward compatibility).\n    pub fn is_single_edit(\u0026self) -\u003e bool {\n        self.individual_results.len() == 1\n    }\n\n    /// Check if all edits succeeded (for backward compatibility).\n    pub fn success(\u0026self) -\u003e bool {\n        self.all_successful()\n    }\n\n    /// Get a single message for backward compatibility.\n    /// Returns the summary message.\n    pub fn message(\u0026self) -\u003e Option\u003cString\u003e {\n        Some(self.summary_message())\n    }\n}\n\n// ================================================================================================\n// ERROR TYPES\n// ================================================================================================\n\n/// Error types for Last.fm operations.\n///\n/// This enum covers all possible errors that can occur when interacting with Last.fm,\n/// including network issues, authentication failures, parsing errors, and rate limiting.\n#[derive(Error, Debug)]\npub enum LastFmError {\n    /// HTTP/network related errors.\n    ///\n    /// This includes connection failures, timeouts, DNS errors, and other\n    /// low-level networking issues.\n    #[error(\"HTTP error: {0}\")]\n    Http(String),\n\n    /// Authentication failures.\n    ///\n    /// This occurs when login credentials are invalid, sessions expire,\n    /// or authentication is required but not provided.\n    ///\n    /// # Common Causes\n    /// - Invalid username/password\n    /// - Expired session cookies\n    /// - Account locked or suspended\n    /// - Two-factor authentication required\n    #[error(\"Authentication failed: {0}\")]\n    Auth(String),\n\n    /// CSRF token not found in response.\n    ///\n    /// This typically indicates that Last.fm's page structure has changed\n    /// or that the request was blocked.\n    #[error(\"CSRF token not found\")]\n    CsrfNotFound,\n\n    /// Failed to parse Last.fm's response.\n    ///\n    /// This can happen when Last.fm changes their HTML structure or\n    /// returns unexpected data formats.\n    #[error(\"Failed to parse response: {0}\")]\n    Parse(String),\n\n    /// Rate limiting from Last.fm.\n    ///\n    /// Last.fm has rate limits to prevent abuse. When hit, the client\n    /// should wait before making more requests.\n    ///\n    /// The `retry_after` field indicates how many seconds to wait before\n    /// the next request attempt.\n    #[error(\"Rate limited, retry after {retry_after} seconds\")]\n    RateLimit {\n        /// Number of seconds to wait before retrying\n        retry_after: u64,\n    },\n\n    /// Scrobble edit operation failed.\n    ///\n    /// This is returned when an edit request is properly formatted and sent,\n    /// but Last.fm rejects it for business logic reasons.\n    #[error(\"Edit failed: {0}\")]\n    EditFailed(String),\n\n    /// File system I/O errors.\n    ///\n    /// This can occur when saving debug responses or other file operations.\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n}\n\n// ================================================================================================\n// SESSION MANAGEMENT\n// ================================================================================================\n\n/// Serializable client session state that can be persisted and restored.\n///\n/// This contains all the authentication state needed to resume a Last.fm session\n/// without requiring the user to log in again.\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct LastFmEditSession {\n    /// The authenticated username\n    pub username: String,\n    /// Session cookies required for authenticated requests\n    pub cookies: Vec\u003cString\u003e,\n    /// CSRF token for form submissions\n    pub csrf_token: Option\u003cString\u003e,\n    /// Base URL for the Last.fm instance\n    pub base_url: String,\n}\n\nimpl LastFmEditSession {\n    /// Create a new client session with the provided state\n    pub fn new(\n        username: String,\n        session_cookies: Vec\u003cString\u003e,\n        csrf_token: Option\u003cString\u003e,\n        base_url: String,\n    ) -\u003e Self {\n        Self {\n            username,\n            cookies: session_cookies,\n            csrf_token,\n            base_url,\n        }\n    }\n\n    /// Check if this session appears to be valid\n    ///\n    /// This performs basic validation but doesn't guarantee the session\n    /// is still active on the server.\n    pub fn is_valid(\u0026self) -\u003e bool {\n        !self.username.is_empty()\n            \u0026\u0026 !self.cookies.is_empty()\n            \u0026\u0026 self.csrf_token.is_some()\n            \u0026\u0026 self\n                .cookies\n                .iter()\n                .any(|cookie| cookie.starts_with(\"sessionid=\") \u0026\u0026 cookie.len() \u003e 50)\n    }\n\n    /// Serialize session to JSON string\n    pub fn to_json(\u0026self) -\u003e Result\u003cString, serde_json::Error\u003e {\n        serde_json::to_string(self)\n    }\n\n    /// Deserialize session from JSON string\n    pub fn from_json(json: \u0026str) -\u003e Result\u003cSelf, serde_json::Error\u003e {\n        serde_json::from_str(json)\n    }\n}\n\n// ================================================================================================\n// CLIENT CONFIGURATION\n// ================================================================================================\n\n/// Configuration for rate limit detection behavior\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct RateLimitConfig {\n    /// Whether to detect rate limits by HTTP status codes (429, 403)\n    pub detect_by_status: bool,\n    /// Whether to detect rate limits by response body patterns\n    pub detect_by_patterns: bool,\n    /// Patterns to look for in response bodies (used when detect_by_patterns is true)\n    pub patterns: Vec\u003cString\u003e,\n    /// Additional custom patterns to look for in response bodies\n    pub custom_patterns: Vec\u003cString\u003e,\n}\n\nimpl Default for RateLimitConfig {\n    fn default() -\u003e Self {\n        Self {\n            detect_by_status: true,\n            detect_by_patterns: true,\n            patterns: vec![\n                \"you've tried to log in too many times\".to_string(),\n                \"you're requesting too many pages\".to_string(),\n                \"slow down\".to_string(),\n                \"too fast\".to_string(),\n                \"rate limit\".to_string(),\n                \"throttled\".to_string(),\n                \"temporarily blocked\".to_string(),\n                \"temporarily restricted\".to_string(),\n                \"captcha\".to_string(),\n                \"verify you're human\".to_string(),\n                \"prove you're not a robot\".to_string(),\n                \"security check\".to_string(),\n                \"service temporarily unavailable\".to_string(),\n                \"quota exceeded\".to_string(),\n                \"limit exceeded\".to_string(),\n                \"daily limit\".to_string(),\n            ],\n            custom_patterns: vec![],\n        }\n    }\n}\n\nimpl RateLimitConfig {\n    /// Create config with all detection disabled\n    pub fn disabled() -\u003e Self {\n        Self {\n            detect_by_status: false,\n            detect_by_patterns: false,\n            patterns: vec![],\n            custom_patterns: vec![],\n        }\n    }\n\n    /// Create config with only status code detection\n    pub fn status_only() -\u003e Self {\n        Self {\n            detect_by_status: true,\n            detect_by_patterns: false,\n            patterns: vec![],\n            custom_patterns: vec![],\n        }\n    }\n\n    /// Create config with only default pattern detection\n    pub fn patterns_only() -\u003e Self {\n        Self {\n            detect_by_status: false,\n            detect_by_patterns: true,\n            ..Default::default()\n        }\n    }\n\n    /// Create config with custom patterns only (no default patterns)\n    pub fn custom_patterns_only(patterns: Vec\u003cString\u003e) -\u003e Self {\n        Self {\n            detect_by_status: false,\n            detect_by_patterns: false,\n            patterns: vec![],\n            custom_patterns: patterns,\n        }\n    }\n\n    /// Create config with both default and custom patterns\n    pub fn with_custom_patterns(mut self, patterns: Vec\u003cString\u003e) -\u003e Self {\n        self.custom_patterns = patterns;\n        self\n    }\n\n    /// Create config with custom patterns (replaces built-in patterns)\n    pub fn with_patterns(mut self, patterns: Vec\u003cString\u003e) -\u003e Self {\n        self.patterns = patterns;\n        self\n    }\n}\n\n/// Configuration for operational delays between requests\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct OperationalDelayConfig {\n    /// Delay between multiple edit operations (in milliseconds)\n    pub edit_delay_ms: u64,\n    /// Delay between delete operations (in milliseconds)\n    pub delete_delay_ms: u64,\n}\n\nimpl Default for OperationalDelayConfig {\n    fn default() -\u003e Self {\n        Self {\n            edit_delay_ms: 1000,   // 1 second\n            delete_delay_ms: 1000, // 1 second\n        }\n    }\n}\n\nimpl OperationalDelayConfig {\n    /// Create config with no delays (useful for testing)\n    pub fn no_delays() -\u003e Self {\n        Self {\n            edit_delay_ms: 0,\n            delete_delay_ms: 0,\n        }\n    }\n\n    /// Create config with custom delays\n    pub fn with_delays(edit_delay_ms: u64, delete_delay_ms: u64) -\u003e Self {\n        Self {\n            edit_delay_ms,\n            delete_delay_ms,\n        }\n    }\n}\n\n/// Unified configuration for retry behavior and rate limiting\n#[derive(Debug, Clone, PartialEq, Eq, Default)]\npub struct ClientConfig {\n    /// Retry configuration\n    pub retry: RetryConfig,\n    /// Rate limit detection configuration\n    pub rate_limit: RateLimitConfig,\n    /// Operational delay configuration\n    pub operational_delays: OperationalDelayConfig,\n}\n\nimpl ClientConfig {\n    /// Create a new config with default settings\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Create config with retries disabled\n    pub fn with_retries_disabled() -\u003e Self {\n        Self {\n            retry: RetryConfig::disabled(),\n            rate_limit: RateLimitConfig::default(),\n            operational_delays: OperationalDelayConfig::default(),\n        }\n    }\n\n    /// Create config with rate limit detection disabled\n    pub fn with_rate_limiting_disabled() -\u003e Self {\n        Self {\n            retry: RetryConfig::default(),\n            rate_limit: RateLimitConfig::disabled(),\n            operational_delays: OperationalDelayConfig::default(),\n        }\n    }\n\n    /// Create config with both retries and rate limiting disabled\n    pub fn minimal() -\u003e Self {\n        Self {\n            retry: RetryConfig::disabled(),\n            rate_limit: RateLimitConfig::disabled(),\n            operational_delays: OperationalDelayConfig::default(),\n        }\n    }\n\n    /// Create config optimized for testing (rate limit detection enabled, retries enabled but no delays)\n    pub fn for_testing() -\u003e Self {\n        Self {\n            retry: RetryConfig {\n                max_retries: 3,\n                base_delay: 0, // No delay for fast tests\n                max_delay: 0,  // No delay for fast tests\n                enabled: true,\n            },\n            rate_limit: RateLimitConfig::default(), // Keep detection enabled\n            operational_delays: OperationalDelayConfig::no_delays(),\n        }\n    }\n\n    /// Set custom retry configuration\n    pub fn with_retry_config(mut self, retry_config: RetryConfig) -\u003e Self {\n        self.retry = retry_config;\n        self\n    }\n\n    /// Set custom rate limit configuration\n    pub fn with_rate_limit_config(mut self, rate_limit_config: RateLimitConfig) -\u003e Self {\n        self.rate_limit = rate_limit_config;\n        self\n    }\n\n    /// Set custom operational delay configuration\n    pub fn with_operational_delays(mut self, operational_delays: OperationalDelayConfig) -\u003e Self {\n        self.operational_delays = operational_delays;\n        self\n    }\n\n    /// Set custom retry count\n    pub fn with_max_retries(mut self, max_retries: u32) -\u003e Self {\n        self.retry.max_retries = max_retries;\n        self.retry.enabled = max_retries \u003e 0;\n        self\n    }\n\n    /// Set custom retry delays\n    pub fn with_retry_delays(mut self, base_delay: u64, max_delay: u64) -\u003e Self {\n        self.retry.base_delay = base_delay;\n        self.retry.max_delay = max_delay;\n        self\n    }\n\n    /// Add custom rate limit patterns\n    pub fn with_custom_rate_limit_patterns(mut self, patterns: Vec\u003cString\u003e) -\u003e Self {\n        self.rate_limit.custom_patterns = patterns;\n        self\n    }\n\n    /// Enable/disable HTTP status code rate limit detection\n    pub fn with_status_detection(mut self, enabled: bool) -\u003e Self {\n        self.rate_limit.detect_by_status = enabled;\n        self\n    }\n\n    /// Enable/disable response pattern rate limit detection\n    pub fn with_pattern_detection(mut self, enabled: bool) -\u003e Self {\n        self.rate_limit.detect_by_patterns = enabled;\n        self\n    }\n}\n\n/// Configuration for retry behavior\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct RetryConfig {\n    /// Maximum number of retry attempts (set to 0 to disable retries)\n    pub max_retries: u32,\n    /// Base delay for exponential backoff (in seconds)\n    pub base_delay: u64,\n    /// Maximum delay cap (in seconds)\n    pub max_delay: u64,\n    /// Whether retries are enabled at all\n    pub enabled: bool,\n}\n\nimpl Default for RetryConfig {\n    fn default() -\u003e Self {\n        Self {\n            max_retries: 3,\n            base_delay: 5,\n            max_delay: 300, // 5 minutes\n            enabled: true,\n        }\n    }\n}\n\nimpl RetryConfig {\n    /// Create a config with retries disabled\n    pub fn disabled() -\u003e Self {\n        Self {\n            max_retries: 0,\n            base_delay: 5,\n            max_delay: 300,\n            enabled: false,\n        }\n    }\n\n    /// Create a config with custom retry count\n    pub fn with_retries(max_retries: u32) -\u003e Self {\n        Self {\n            max_retries,\n            enabled: max_retries \u003e 0,\n            ..Default::default()\n        }\n    }\n\n    /// Create a config with custom delays\n    pub fn with_delays(base_delay: u64, max_delay: u64) -\u003e Self {\n        Self {\n            base_delay,\n            max_delay,\n            ..Default::default()\n        }\n    }\n}\n\n/// Result of a retry operation with context\n#[derive(Debug)]\npub struct RetryResult\u003cT\u003e {\n    /// The successful result\n    pub result: T,\n    /// Number of retry attempts made\n    pub attempts_made: u32,\n    /// Total time spent retrying (in seconds)\n    pub total_retry_time: u64,\n}\n\n// ================================================================================================\n// EVENT SYSTEM\n// ================================================================================================\n\n/// Request information for client events\n#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct RequestInfo {\n    /// The HTTP method (GET, POST, etc.)\n    pub method: String,\n    /// The full URI being requested\n    pub uri: String,\n    /// Query parameters as key-value pairs\n    pub query_params: Vec\u003c(String, String)\u003e,\n    /// Path without query parameters\n    pub path: String,\n}\n\nimpl RequestInfo {\n    /// Create RequestInfo from a URL string and method\n    pub fn from_url_and_method(url: \u0026str, method: \u0026str) -\u003e Self {\n        // Parse URL manually to avoid adding dependencies\n        let (path, query_params) = if let Some(query_start) = url.find('?') {\n            let path = url[..query_start].to_string();\n            let query_string = \u0026url[query_start + 1..];\n\n            let query_params: Vec\u003c(String, String)\u003e = query_string\n                .split('\u0026')\n                .filter_map(|pair| {\n                    if let Some(eq_pos) = pair.find('=') {\n                        let key = \u0026pair[..eq_pos];\n                        let value = \u0026pair[eq_pos + 1..];\n                        Some((key.to_string(), value.to_string()))\n                    } else if !pair.is_empty() {\n                        Some((pair.to_string(), String::new()))\n                    } else {\n                        None\n                    }\n                })\n                .collect();\n\n            (path, query_params)\n        } else {\n            (url.to_string(), Vec::new())\n        };\n\n        // Extract just the path part if it's a full URL\n        let path = if path.starts_with(\"http://\") || path.starts_with(\"https://\") {\n            if let Some(third_slash) = path[8..].find('/') {\n                path[8 + third_slash..].to_string()\n            } else {\n                \"/\".to_string()\n            }\n        } else {\n            path\n        };\n\n        Self {\n            method: method.to_string(),\n            uri: url.to_string(),\n            query_params,\n            path,\n        }\n    }\n\n    /// Get a short description of the request for logging\n    pub fn short_description(\u0026self) -\u003e String {\n        let mut desc = format!(\"{} {}\", self.method, self.path);\n        if !self.query_params.is_empty() {\n            let params: Vec\u003cString\u003e = self\n                .query_params\n                .iter()\n                .map(|(k, v)| format!(\"{k}={v}\"))\n                .collect();\n            if params.len() \u003c= 2 {\n                desc.push_str(\u0026format!(\"?{}\", params.join(\"\u0026\")));\n            } else {\n                desc.push_str(\u0026format!(\"?{}...\", params[0]));\n            }\n        }\n        desc\n    }\n}\n\n/// Type of rate limiting detected\n#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum RateLimitType {\n    /// HTTP 429 Too Many Requests\n    Http429,\n    /// HTTP 403 Forbidden (likely rate limiting)\n    Http403,\n    /// Rate limit patterns detected in response body\n    ResponsePattern,\n}\n\n/// Event type to describe internal HTTP client activity\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub enum ClientEvent {\n    /// Request started\n    RequestStarted {\n        /// Request details\n        request: RequestInfo,\n    },\n    /// Request completed successfully\n    RequestCompleted {\n        /// Request details\n        request: RequestInfo,\n        /// HTTP status code\n        status_code: u16,\n        /// Duration of the request in milliseconds\n        duration_ms: u64,\n    },\n    /// Rate limiting detected with backoff duration in seconds\n    RateLimited {\n        /// Duration to wait in seconds\n        delay_seconds: u64,\n        /// Request that triggered the rate limit (if available)\n        request: Option\u003cRequestInfo\u003e,\n        /// Type of rate limiting detected\n        rate_limit_type: RateLimitType,\n        /// Timestamp when the rate limit was detected (seconds since Unix epoch)\n        rate_limit_timestamp: u64,\n    },\n    /// Rate limiting period has ended and normal operation resumed\n    RateLimitEnded {\n        /// Request that successfully completed after rate limiting\n        request: RequestInfo,\n        /// Type of rate limiting that ended\n        rate_limit_type: RateLimitType,\n        /// Total duration the rate limiting was active in seconds\n        total_rate_limit_duration_seconds: u64,\n    },\n    /// Scrobble edit attempt completed\n    EditAttempted {\n        /// The exact scrobble edit that was attempted\n        edit: ExactScrobbleEdit,\n        /// Whether the edit was successful\n        success: bool,\n        /// Optional error message if the edit failed\n        error_message: Option\u003cString\u003e,\n        /// Duration of the edit operation in milliseconds\n        duration_ms: u64,\n    },\n}\n\n/// Type alias for the broadcast receiver\npub type ClientEventReceiver = broadcast::Receiver\u003cClientEvent\u003e;\n\n/// Type alias for the watch receiver\npub type ClientEventWatcher = watch::Receiver\u003cOption\u003cClientEvent\u003e\u003e;\n\n/// Shared event broadcasting state that persists across client clones\n#[derive(Clone)]\npub struct SharedEventBroadcaster {\n    event_tx: broadcast::Sender\u003cClientEvent\u003e,\n    last_event_tx: watch::Sender\u003cOption\u003cClientEvent\u003e\u003e,\n}\n\nimpl SharedEventBroadcaster {\n    /// Create a new shared event broadcaster\n    pub fn new() -\u003e Self {\n        let (event_tx, _) = broadcast::channel(100);\n        let (last_event_tx, _) = watch::channel(None);\n\n        Self {\n            event_tx,\n            last_event_tx,\n        }\n    }\n\n    /// Broadcast an event to all subscribers\n    pub fn broadcast_event(\u0026self, event: ClientEvent) {\n        let _ = self.event_tx.send(event.clone());\n        let _ = self.last_event_tx.send(Some(event));\n    }\n\n    /// Subscribe to events\n    pub fn subscribe(\u0026self) -\u003e ClientEventReceiver {\n        self.event_tx.subscribe()\n    }\n\n    /// Get the latest event\n    pub fn latest_event(\u0026self) -\u003e Option\u003cClientEvent\u003e {\n        self.last_event_tx.borrow().clone()\n    }\n}\n\nimpl Default for SharedEventBroadcaster {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl std::fmt::Debug for SharedEventBroadcaster {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"SharedEventBroadcaster\")\n            .field(\"subscribers\", \u0026self.event_tx.receiver_count())\n            .finish()\n    }\n}\n\n// ================================================================================================\n// TESTS\n// ================================================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_session_validity() {\n        let valid_session = LastFmEditSession::new(\n            \"testuser\".to_string(),\n            vec![\"sessionid=.eJy1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\".to_string()],\n            Some(\"csrf_token_123\".to_string()),\n            \"https://www.last.fm\".to_string(),\n        );\n        assert!(valid_session.is_valid());\n\n        let invalid_session = LastFmEditSession::new(\n            \"\".to_string(),\n            vec![],\n            None,\n            \"https://www.last.fm\".to_string(),\n        );\n        assert!(!invalid_session.is_valid());\n    }\n\n    #[test]\n    fn test_session_serialization() {\n        let session = LastFmEditSession::new(\n            \"testuser\".to_string(),\n            vec![\n                \"sessionid=.test123\".to_string(),\n                \"csrftoken=abc\".to_string(),\n            ],\n            Some(\"csrf_token_123\".to_string()),\n            \"https://www.last.fm\".to_string(),\n        );\n\n        let json = session.to_json().unwrap();\n        let restored_session = LastFmEditSession::from_json(\u0026json).unwrap();\n\n        assert_eq!(session.username, restored_session.username);\n        assert_eq!(session.cookies, restored_session.cookies);\n        assert_eq!(session.csrf_token, restored_session.csrf_token);\n        assert_eq!(session.base_url, restored_session.base_url);\n    }\n}\n","traces":[{"line":51,"address":[6042900,6042906,6042448],"length":1,"stats":{"Line":0}},{"line":52,"address":[5715361],"length":1,"stats":{"Line":0}},{"line":53,"address":[3191680],"length":1,"stats":{"Line":0}},{"line":55,"address":[6042638],"length":1,"stats":{"Line":0}},{"line":57,"address":[5914301,5914370],"length":1,"stats":{"Line":0}},{"line":99,"address":[3495221],"length":1,"stats":{"Line":0}},{"line":100,"address":[5914576],"length":1,"stats":{"Line":0}},{"line":101,"address":[5715847],"length":1,"stats":{"Line":0}},{"line":129,"address":[5525120],"length":1,"stats":{"Line":0}},{"line":130,"address":[5914772],"length":1,"stats":{"Line":0}},{"line":131,"address":[5495840,5495870],"length":1,"stats":{"Line":0}},{"line":153,"address":[5914800],"length":1,"stats":{"Line":0}},{"line":154,"address":[5914824],"length":1,"stats":{"Line":0}},{"line":182,"address":[3192416],"length":1,"stats":{"Line":0}},{"line":183,"address":[3192436],"length":1,"stats":{"Line":0}},{"line":184,"address":[5756912,5756942],"length":1,"stats":{"Line":0}},{"line":229,"address":[5527795,5525328,5527753],"length":1,"stats":{"Line":0}},{"line":230,"address":[5914993],"length":1,"stats":{"Line":0}},{"line":233,"address":[3192587,3192516],"length":1,"stats":{"Line":0}},{"line":234,"address":[3192648],"length":1,"stats":{"Line":0}},{"line":241,"address":[5716326,5716578],"length":1,"stats":{"Line":0}},{"line":242,"address":[5525731,5525821],"length":1,"stats":{"Line":0}},{"line":243,"address":[5716697,5716762],"length":1,"stats":{"Line":0}},{"line":244,"address":[5915539],"length":1,"stats":{"Line":0}},{"line":247,"address":[6043848,6044097],"length":1,"stats":{"Line":0}},{"line":252,"address":[5915403,5915886],"length":1,"stats":{"Line":0}},{"line":253,"address":[3193407],"length":1,"stats":{"Line":0}},{"line":254,"address":[6293141,6293358],"length":1,"stats":{"Line":0}},{"line":255,"address":[6044583],"length":1,"stats":{"Line":0}},{"line":258,"address":[5717287],"length":1,"stats":{"Line":0}},{"line":265,"address":[5526323,5526810],"length":1,"stats":{"Line":0}},{"line":266,"address":[5916459],"length":1,"stats":{"Line":0}},{"line":267,"address":[3194255,3194038],"length":1,"stats":{"Line":0}},{"line":268,"address":[6293896],"length":1,"stats":{"Line":0}},{"line":273,"address":[6044936],"length":1,"stats":{"Line":0}},{"line":279,"address":[5527338,5526874],"length":1,"stats":{"Line":0}},{"line":280,"address":[5527360,5527772],"length":1,"stats":{"Line":0}},{"line":282,"address":[3194550,3194485],"length":1,"stats":{"Line":0}},{"line":283,"address":[5527416],"length":1,"stats":{"Line":0}},{"line":285,"address":[6294157],"length":1,"stats":{"Line":0}},{"line":287,"address":[6045427,6045566],"length":1,"stats":{"Line":0}},{"line":352,"address":[6296145,6296103,6294576],"length":1,"stats":{"Line":0}},{"line":353,"address":[5527841],"length":1,"stats":{"Line":0}},{"line":356,"address":[5917492,5917566],"length":1,"stats":{"Line":0}},{"line":357,"address":[6045959],"length":1,"stats":{"Line":0}},{"line":364,"address":[5718809,5719037],"length":1,"stats":{"Line":0}},{"line":365,"address":[6294986],"length":1,"stats":{"Line":0}},{"line":372,"address":[5528184,5528421],"length":1,"stats":{"Line":0}},{"line":373,"address":[6046453],"length":1,"stats":{"Line":0}},{"line":380,"address":[6295200,6295444],"length":1,"stats":{"Line":0}},{"line":381,"address":[5918342],"length":1,"stats":{"Line":0}},{"line":387,"address":[6046666,6046904],"length":1,"stats":{"Line":0}},{"line":388,"address":[3196490,3196078],"length":1,"stats":{"Line":0}},{"line":390,"address":[6046980,6046915],"length":1,"stats":{"Line":0}},{"line":391,"address":[5528998],"length":1,"stats":{"Line":0}},{"line":393,"address":[5528971],"length":1,"stats":{"Line":0}},{"line":395,"address":[5529025,5529164],"length":1,"stats":{"Line":0}},{"line":419,"address":[5529392],"length":1,"stats":{"Line":1}},{"line":457,"address":[6049037,6048921,6047712],"length":1,"stats":{"Line":0}},{"line":464,"address":[5720708],"length":1,"stats":{"Line":0}},{"line":465,"address":[6296753,6296808],"length":1,"stats":{"Line":0}},{"line":466,"address":[5721011,5720944],"length":1,"stats":{"Line":0}},{"line":467,"address":[5530155,5530222],"length":1,"stats":{"Line":0}},{"line":468,"address":[5721193,5721126],"length":1,"stats":{"Line":0}},{"line":469,"address":[5530369,5530436],"length":1,"stats":{"Line":0}},{"line":470,"address":[6297244,6297311],"length":1,"stats":{"Line":0}},{"line":471,"address":[5920183,5920250],"length":1,"stats":{"Line":0}},{"line":472,"address":[5721514],"length":1,"stats":{"Line":0}},{"line":478,"address":[3198224,3198506],"length":1,"stats":{"Line":1}},{"line":479,"address":[5531146,5531205],"length":1,"stats":{"Line":2}},{"line":480,"address":[5531351],"length":1,"stats":{"Line":1}},{"line":484,"address":[5921310,5921024],"length":1,"stats":{"Line":1}},{"line":485,"address":[3198586,3198641],"length":1,"stats":{"Line":2}},{"line":486,"address":[5722519],"length":1,"stats":{"Line":1}},{"line":492,"address":[5722560,5722980],"length":1,"stats":{"Line":0}},{"line":493,"address":[5722619,5722681],"length":1,"stats":{"Line":0}},{"line":494,"address":[5531920],"length":1,"stats":{"Line":0}},{"line":495,"address":[3199225],"length":1,"stats":{"Line":0}},{"line":502,"address":[3199280],"length":1,"stats":{"Line":1}},{"line":503,"address":[6298935],"length":1,"stats":{"Line":1}},{"line":504,"address":[5921807],"length":1,"stats":{"Line":1}},{"line":518,"address":[5724281,5723072,5724397],"length":1,"stats":{"Line":0}},{"line":525,"address":[5532324],"length":1,"stats":{"Line":0}},{"line":526,"address":[5922097,5922152],"length":1,"stats":{"Line":0}},{"line":527,"address":[5723424,5723491],"length":1,"stats":{"Line":0}},{"line":528,"address":[6050686,6050619],"length":1,"stats":{"Line":0}},{"line":529,"address":[5532742,5532809],"length":1,"stats":{"Line":0}},{"line":530,"address":[3200052,3199985],"length":1,"stats":{"Line":0}},{"line":531,"address":[6299791,6299724],"length":1,"stats":{"Line":0}},{"line":532,"address":[6299799,6299866],"length":1,"stats":{"Line":0}},{"line":533,"address":[6299898],"length":1,"stats":{"Line":0}},{"line":547,"address":[5534623,5533568,5534474],"length":1,"stats":{"Line":1}},{"line":549,"address":[3200773],"length":1,"stats":{"Line":1}},{"line":550,"address":[6300535],"length":1,"stats":{"Line":1}},{"line":551,"address":[6300569,6300624],"length":1,"stats":{"Line":2}},{"line":552,"address":[6300632],"length":1,"stats":{"Line":1}},{"line":553,"address":[5923522,5923592],"length":1,"stats":{"Line":2}},{"line":554,"address":[5724864],"length":1,"stats":{"Line":1}},{"line":555,"address":[5923728,5923658],"length":1,"stats":{"Line":2}},{"line":556,"address":[3201302,3201240],"length":1,"stats":{"Line":2}},{"line":557,"address":[3201334],"length":1,"stats":{"Line":1}},{"line":571,"address":[5726252,5726404,5725520],"length":1,"stats":{"Line":1}},{"line":573,"address":[3201851],"length":1,"stats":{"Line":1}},{"line":574,"address":[5725658],"length":1,"stats":{"Line":1}},{"line":575,"address":[5924439,5924509],"length":1,"stats":{"Line":2}},{"line":576,"address":[6052869],"length":1,"stats":{"Line":1}},{"line":577,"address":[6052895],"length":1,"stats":{"Line":1}},{"line":578,"address":[5725791],"length":1,"stats":{"Line":1}},{"line":579,"address":[6052927,6052997],"length":1,"stats":{"Line":2}},{"line":580,"address":[5725947,5725885],"length":1,"stats":{"Line":2}},{"line":581,"address":[5924747],"length":1,"stats":{"Line":1}},{"line":596,"address":[6303294,6303400,6302352],"length":1,"stats":{"Line":1}},{"line":598,"address":[6302455],"length":1,"stats":{"Line":1}},{"line":599,"address":[6053742,6053812],"length":1,"stats":{"Line":2}},{"line":600,"address":[5535935,5535868],"length":1,"stats":{"Line":2}},{"line":601,"address":[5925575,5925642],"length":1,"stats":{"Line":2}},{"line":602,"address":[5726914],"length":1,"stats":{"Line":1}},{"line":603,"address":[6054060,6054130],"length":1,"stats":{"Line":2}},{"line":604,"address":[3203306],"length":1,"stats":{"Line":1}},{"line":605,"address":[5727122],"length":1,"stats":{"Line":1}},{"line":606,"address":[5925898],"length":1,"stats":{"Line":1}},{"line":615,"address":[5926304],"length":1,"stats":{"Line":1}},{"line":645,"address":[6305094,6305088,6303744],"length":1,"stats":{"Line":1}},{"line":646,"address":[3204157],"length":1,"stats":{"Line":1}},{"line":649,"address":[5926745,5926688],"length":1,"stats":{"Line":2}},{"line":652,"address":[6303940],"length":1,"stats":{"Line":1}},{"line":653,"address":[6055243],"length":1,"stats":{"Line":1}},{"line":654,"address":[5926982],"length":1,"stats":{"Line":1}},{"line":655,"address":[5537441],"length":1,"stats":{"Line":1}},{"line":656,"address":[6304303],"length":1,"stats":{"Line":1}},{"line":657,"address":[3204714],"length":1,"stats":{"Line":1}},{"line":658,"address":[5537740],"length":1,"stats":{"Line":1}},{"line":660,"address":[5728581],"length":1,"stats":{"Line":1}},{"line":662,"address":[6055792],"length":1,"stats":{"Line":1}},{"line":665,"address":[5537902],"length":1,"stats":{"Line":1}},{"line":668,"address":[5927628],"length":1,"stats":{"Line":1}},{"line":669,"address":[6056020],"length":1,"stats":{"Line":1}},{"line":671,"address":[5927637,5927762],"length":1,"stats":{"Line":2}},{"line":672,"address":[5538193],"length":1,"stats":{"Line":1}},{"line":674,"address":[5538292],"length":1,"stats":{"Line":1}},{"line":680,"address":[3206634,3205408,3206518],"length":1,"stats":{"Line":0}},{"line":682,"address":[5538382],"length":1,"stats":{"Line":0}},{"line":683,"address":[6056541,6056479],"length":1,"stats":{"Line":0}},{"line":684,"address":[6305365,6305431],"length":1,"stats":{"Line":0}},{"line":685,"address":[5538737,5538671],"length":1,"stats":{"Line":0}},{"line":686,"address":[5538843,5538777],"length":1,"stats":{"Line":0}},{"line":687,"address":[5538949,5538883],"length":1,"stats":{"Line":0}},{"line":688,"address":[3206045,3206114],"length":1,"stats":{"Line":0}},{"line":689,"address":[5730004,5729930],"length":1,"stats":{"Line":0}},{"line":690,"address":[6305940],"length":1,"stats":{"Line":0}},{"line":691,"address":[5539199],"length":1,"stats":{"Line":0}},{"line":698,"address":[6058247,6057600,6058213],"length":1,"stats":{"Line":1}},{"line":705,"address":[3206720,3206962],"length":1,"stats":{"Line":2}},{"line":715,"address":[5929936],"length":1,"stats":{"Line":1}},{"line":722,"address":[6058320],"length":1,"stats":{"Line":1}},{"line":723,"address":[6085546,6085536],"length":1,"stats":{"Line":3}},{"line":727,"address":[5930064],"length":1,"stats":{"Line":0}},{"line":728,"address":[3476858,3476848],"length":1,"stats":{"Line":0}},{"line":732,"address":[6307264],"length":1,"stats":{"Line":1}},{"line":733,"address":[6058485],"length":1,"stats":{"Line":1}},{"line":737,"address":[5930144],"length":1,"stats":{"Line":1}},{"line":738,"address":[6307285],"length":1,"stats":{"Line":3}},{"line":742,"address":[6307344],"length":1,"stats":{"Line":1}},{"line":743,"address":[5540581],"length":1,"stats":{"Line":1}},{"line":745,"address":[5333354,5333344],"length":1,"stats":{"Line":2}},{"line":750,"address":[3207648],"length":1,"stats":{"Line":1}},{"line":751,"address":[6058662],"length":1,"stats":{"Line":1}},{"line":752,"address":[6307462],"length":1,"stats":{"Line":1}},{"line":753,"address":[6058694],"length":1,"stats":{"Line":1}},{"line":755,"address":[5731585],"length":1,"stats":{"Line":1}},{"line":756,"address":[6058718],"length":1,"stats":{"Line":0}},{"line":759,"address":[5930386],"length":1,"stats":{"Line":1}},{"line":760,"address":[3207796],"length":1,"stats":{"Line":1}},{"line":761,"address":[6059194],"length":1,"stats":{"Line":1}},{"line":763,"address":[6059217],"length":1,"stats":{"Line":0}},{"line":765,"address":[6307549],"length":1,"stats":{"Line":1}},{"line":766,"address":[6307576],"length":1,"stats":{"Line":1}},{"line":767,"address":[5541057],"length":1,"stats":{"Line":1}},{"line":769,"address":[6059064],"length":1,"stats":{"Line":0}},{"line":772,"address":[5930457],"length":1,"stats":{"Line":0}},{"line":777,"address":[5732224],"length":1,"stats":{"Line":0}},{"line":778,"address":[5541392],"length":1,"stats":{"Line":0}},{"line":781,"address":[3476944,3477925,3477003,3477919],"length":1,"stats":{"Line":0}},{"line":782,"address":[5333451],"length":1,"stats":{"Line":0}},{"line":785,"address":[3477952,3477979],"length":1,"stats":{"Line":0}},{"line":788,"address":[6085787],"length":1,"stats":{"Line":0}},{"line":789,"address":[6086409,6085848],"length":1,"stats":{"Line":0}},{"line":791,"address":[5682553],"length":1,"stats":{"Line":0}},{"line":792,"address":[3477194,3477484],"length":1,"stats":{"Line":0}},{"line":794,"address":[5333655,5333607,5333751],"length":1,"stats":{"Line":0}},{"line":803,"address":[3208464],"length":1,"stats":{"Line":0}},{"line":804,"address":[6308245],"length":1,"stats":{"Line":0}},{"line":808,"address":[5732368],"length":1,"stats":{"Line":1}},{"line":809,"address":[6308277],"length":1,"stats":{"Line":1}},{"line":814,"address":[6308288],"length":1,"stats":{"Line":1}},{"line":815,"address":[5931171],"length":1,"stats":{"Line":1}},{"line":912,"address":[6059584],"length":1,"stats":{"Line":8}},{"line":930,"address":[6308464],"length":1,"stats":{"Line":1}},{"line":931,"address":[5541738,5541709],"length":1,"stats":{"Line":2}},{"line":932,"address":[5931354],"length":1,"stats":{"Line":1}},{"line":933,"address":[6308517],"length":1,"stats":{"Line":1}},{"line":934,"address":[5931401],"length":1,"stats":{"Line":1}},{"line":937,"address":[5497376,5497406],"length":1,"stats":{"Line":2}},{"line":941,"address":[5931472],"length":1,"stats":{"Line":2}},{"line":942,"address":[6059841],"length":1,"stats":{"Line":2}},{"line":946,"address":[6059872],"length":1,"stats":{"Line":2}},{"line":947,"address":[6308677],"length":1,"stats":{"Line":2}},{"line":969,"address":[6061783,6061777,6059920],"length":1,"stats":{"Line":11}},{"line":973,"address":[6308769,6308731,6309618,6309186,6309258,6309474,6309834,6308838,6309114,6309690,6310422,6308973,6309330,6309402,6310580,6309875,6308904,6309546,6309762,6309042],"length":1,"stats":{"Line":17}},{"line":991,"address":[5734499],"length":1,"stats":{"Line":8}},{"line":998,"address":[5933609,5933615,5933456],"length":1,"stats":{"Line":0}},{"line":1002,"address":[6061821],"length":1,"stats":{"Line":0}},{"line":1003,"address":[5933498],"length":1,"stats":{"Line":0}},{"line":1008,"address":[5933785,5933791,5933632],"length":1,"stats":{"Line":0}},{"line":1012,"address":[5933645],"length":1,"stats":{"Line":0}},{"line":1013,"address":[6062026],"length":1,"stats":{"Line":0}},{"line":1018,"address":[6062160],"length":1,"stats":{"Line":0}},{"line":1027,"address":[6311230,6311056],"length":1,"stats":{"Line":0}},{"line":1031,"address":[5735170],"length":1,"stats":{"Line":0}},{"line":1037,"address":[6311248,6311405],"length":1,"stats":{"Line":0}},{"line":1038,"address":[3211488,3211566],"length":1,"stats":{"Line":0}},{"line":1039,"address":[6062601],"length":1,"stats":{"Line":0}},{"line":1043,"address":[6311424,6311575],"length":1,"stats":{"Line":0}},{"line":1044,"address":[5934320,5934397],"length":1,"stats":{"Line":0}},{"line":1045,"address":[5934419],"length":1,"stats":{"Line":0}},{"line":1059,"address":[6062816],"length":1,"stats":{"Line":7}},{"line":1069,"address":[5544848],"length":1,"stats":{"Line":2}},{"line":1077,"address":[5544864],"length":1,"stats":{"Line":0}},{"line":1098,"address":[5544896],"length":1,"stats":{"Line":0}},{"line":1099,"address":[3211880],"length":1,"stats":{"Line":0}},{"line":1103,"address":[6063102,6062912,6063096],"length":1,"stats":{"Line":0}},{"line":1105,"address":[6311713],"length":1,"stats":{"Line":0}},{"line":1106,"address":[5934591],"length":1,"stats":{"Line":0}},{"line":1107,"address":[6062957],"length":1,"stats":{"Line":0}},{"line":1112,"address":[3212096,3212270,3212264],"length":1,"stats":{"Line":0}},{"line":1114,"address":[3212118],"length":1,"stats":{"Line":0}},{"line":1115,"address":[5736031],"length":1,"stats":{"Line":0}},{"line":1116,"address":[5736045],"length":1,"stats":{"Line":0}},{"line":1121,"address":[5736208,5736392,5736398],"length":1,"stats":{"Line":0}},{"line":1123,"address":[6063345],"length":1,"stats":{"Line":0}},{"line":1124,"address":[5736239],"length":1,"stats":{"Line":0}},{"line":1125,"address":[5935021],"length":1,"stats":{"Line":0}},{"line":1130,"address":[5935184,5935385,5935391],"length":1,"stats":{"Line":6}},{"line":1132,"address":[3212497],"length":1,"stats":{"Line":2}},{"line":1138,"address":[3212533],"length":1,"stats":{"Line":6}},{"line":1139,"address":[5736478],"length":1,"stats":{"Line":4}},{"line":1144,"address":[3212688],"length":1,"stats":{"Line":0}},{"line":1145,"address":[6312552],"length":1,"stats":{"Line":0}},{"line":1146,"address":[5935439],"length":1,"stats":{"Line":0}},{"line":1150,"address":[3212888,3212736],"length":1,"stats":{"Line":0}},{"line":1151,"address":[5935576,5935488],"length":1,"stats":{"Line":0}},{"line":1152,"address":[3212868],"length":1,"stats":{"Line":0}},{"line":1156,"address":[3212912],"length":1,"stats":{"Line":0}},{"line":1157,"address":[3212933],"length":1,"stats":{"Line":0}},{"line":1158,"address":[5935661],"length":1,"stats":{"Line":0}},{"line":1162,"address":[3212960],"length":1,"stats":{"Line":0}},{"line":1163,"address":[3212976],"length":1,"stats":{"Line":0}},{"line":1164,"address":[5546067],"length":1,"stats":{"Line":0}},{"line":1165,"address":[6312846],"length":1,"stats":{"Line":0}},{"line":1169,"address":[6064096],"length":1,"stats":{"Line":0}},{"line":1170,"address":[5546133],"length":1,"stats":{"Line":0}},{"line":1171,"address":[6312905],"length":1,"stats":{"Line":0}},{"line":1172,"address":[5935773],"length":1,"stats":{"Line":0}},{"line":1176,"address":[6313085,6312928],"length":1,"stats":{"Line":0}},{"line":1177,"address":[6313042,6312960],"length":1,"stats":{"Line":0}},{"line":1178,"address":[6064281],"length":1,"stats":{"Line":0}},{"line":1182,"address":[5935968],"length":1,"stats":{"Line":0}},{"line":1183,"address":[5546359],"length":1,"stats":{"Line":0}},{"line":1184,"address":[5737228],"length":1,"stats":{"Line":0}},{"line":1188,"address":[5936016],"length":1,"stats":{"Line":0}},{"line":1189,"address":[6064391],"length":1,"stats":{"Line":0}},{"line":1190,"address":[5737276],"length":1,"stats":{"Line":0}},{"line":1208,"address":[5936064],"length":1,"stats":{"Line":7}},{"line":1220,"address":[5546464],"length":1,"stats":{"Line":1}},{"line":1230,"address":[5546496],"length":1,"stats":{"Line":0}},{"line":1233,"address":[5737381],"length":1,"stats":{"Line":0}},{"line":1239,"address":[5936224],"length":1,"stats":{"Line":0}},{"line":1278,"address":[6064672,6065446,6065452],"length":1,"stats":{"Line":10}},{"line":1280,"address":[3213709,3214266,3214522],"length":1,"stats":{"Line":12}},{"line":1281,"address":[3213798],"length":1,"stats":{"Line":10}},{"line":1282,"address":[3213836,3213934,3214036],"length":1,"stats":{"Line":24}},{"line":1284,"address":[5547140],"length":1,"stats":{"Line":10}},{"line":1286,"address":[5758951,5758432,5758957],"length":1,"stats":{"Line":7}},{"line":1287,"address":[5334707],"length":1,"stats":{"Line":10}},{"line":1288,"address":[5758559],"length":1,"stats":{"Line":7}},{"line":1289,"address":[6087270,6087165,6087102],"length":1,"stats":{"Line":17}},{"line":1290,"address":[6087283,6087222],"length":1,"stats":{"Line":10}},{"line":1291,"address":[5684198,5683804,5684360],"length":1,"stats":{"Line":0}},{"line":1292,"address":[5498088,5498036],"length":1,"stats":{"Line":0}},{"line":1294,"address":[5498073],"length":1,"stats":{"Line":0}},{"line":1299,"address":[6065202],"length":1,"stats":{"Line":7}},{"line":1301,"address":[6065465,6064943],"length":1,"stats":{"Line":1}},{"line":1305,"address":[5738306,5738657,5738541],"length":1,"stats":{"Line":5}},{"line":1306,"address":[3214838,3214643],"length":1,"stats":{"Line":3}},{"line":1307,"address":[6066052,6066000],"length":1,"stats":{"Line":3}},{"line":1309,"address":[5548032,5548159],"length":1,"stats":{"Line":0}},{"line":1312,"address":[3214734],"length":1,"stats":{"Line":0}},{"line":1316,"address":[3214806],"length":1,"stats":{"Line":1}},{"line":1317,"address":[3215128],"length":1,"stats":{"Line":2}},{"line":1324,"address":[3215536,3216763,3216409],"length":1,"stats":{"Line":0}},{"line":1325,"address":[3215572],"length":1,"stats":{"Line":0}},{"line":1326,"address":[5548849,5548922],"length":1,"stats":{"Line":0}},{"line":1327,"address":[5938659,5938568],"length":1,"stats":{"Line":0}},{"line":1330,"address":[5335440,5335408],"length":1,"stats":{"Line":0}},{"line":1332,"address":[5938813,5938740],"length":1,"stats":{"Line":0}},{"line":1333,"address":[3216425,3216118],"length":1,"stats":{"Line":0}},{"line":1335,"address":[5938891,5938819],"length":1,"stats":{"Line":0}},{"line":1338,"address":[5548974],"length":1,"stats":{"Line":0}},{"line":1418,"address":[5939734,5939740,5939520],"length":1,"stats":{"Line":12}},{"line":1419,"address":[6316663],"length":1,"stats":{"Line":8}},{"line":1420,"address":[3216879],"length":1,"stats":{"Line":15}},{"line":1429,"address":[3217008,3217284,3217309],"length":1,"stats":{"Line":11}},{"line":1430,"address":[5741017,5741094],"length":1,"stats":{"Line":10}},{"line":1431,"address":[5550280],"length":1,"stats":{"Line":9}},{"line":1435,"address":[5550464],"length":1,"stats":{"Line":2}},{"line":1436,"address":[6317237],"length":1,"stats":{"Line":2}},{"line":1440,"address":[5550630,5550480,5550636],"length":1,"stats":{"Line":1}},{"line":1441,"address":[3217450,3217374],"length":1,"stats":{"Line":3}},{"line":1446,"address":[5741520],"length":1,"stats":{"Line":0}},{"line":1447,"address":[5550657],"length":1,"stats":{"Line":0}},{"line":1452,"address":[5741536],"length":1,"stats":{"Line":0}},{"line":1453,"address":[5550691,5550730],"length":1,"stats":{"Line":0}},{"line":1454,"address":[5550719],"length":1,"stats":{"Line":0}}],"covered":135,"coverable":323},{"path":["/","home","imalison","Projects","lastfm-edit","src","vcr_form_data.rs"],"content":"use std::collections::HashMap;\n\n/// Parse URL-encoded form data into key-value pairs\npub fn parse_form_data(data: \u0026str) -\u003e HashMap\u003cString, String\u003e {\n    let mut params = HashMap::new();\n\n    for pair in data.split('\u0026') {\n        if let Some((key, value)) = pair.split_once('=') {\n            // URL decode the key and value\n            let decoded_key = urlencoding::decode(key).unwrap_or_else(|_| key.into());\n            let decoded_value = urlencoding::decode(value).unwrap_or_else(|_| value.into());\n            params.insert(decoded_key.to_string(), decoded_value.to_string());\n        }\n    }\n\n    params\n}\n\n/// Encode form data back to URL-encoded string\npub fn encode_form_data(params: \u0026HashMap\u003cString, String\u003e) -\u003e String {\n    params\n        .iter()\n        .map(|(key, value)| {\n            format!(\n                \"{}={}\",\n                urlencoding::encode(key),\n                urlencoding::encode(value)\n            )\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\"\u0026\")\n}\n","traces":[{"line":4,"address":[3590048,3590987,3590993],"length":1,"stats":{"Line":0}},{"line":5,"address":[6097339],"length":1,"stats":{"Line":0}},{"line":7,"address":[6097436,6097371],"length":1,"stats":{"Line":0}},{"line":8,"address":[6097607,6097664],"length":1,"stats":{"Line":0}},{"line":10,"address":[5445019,5444992],"length":1,"stats":{"Line":0}},{"line":11,"address":[5445120,5445147],"length":1,"stats":{"Line":0}},{"line":12,"address":[3590776,3590811,3590705,3590965],"length":1,"stats":{"Line":0}},{"line":16,"address":[3590388],"length":1,"stats":{"Line":0}},{"line":20,"address":[3591217,3591223,3591008],"length":1,"stats":{"Line":0}},{"line":21,"address":[6098441,6098296],"length":1,"stats":{"Line":0}},{"line":23,"address":[5445681,5445248,5445307,5445675],"length":1,"stats":{"Line":0}},{"line":24,"address":[5445462,5445354],"length":1,"stats":{"Line":0}},{"line":26,"address":[5894923],"length":1,"stats":{"Line":0}},{"line":27,"address":[5895022],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","home","imalison","Projects","lastfm-edit","src","vcr_matcher.rs"],"content":"use http_client::Request;\nuse http_client_vcr::{RequestMatcher, SerializableRequest};\nuse std::fmt::Debug;\n\n/// Last.fm Edit VCR matcher that handles authentication flows properly\n/// Ignores cookies and session-related headers that change between test runs\n#[derive(Debug)]\npub struct LastFmEditVcrMatcher {\n    match_method: bool,\n    match_url: bool,\n    match_body: bool,\n}\n\nimpl LastFmEditVcrMatcher {\n    pub fn new() -\u003e Self {\n        Self {\n            match_method: true,\n            match_url: true,\n            match_body: false,\n        }\n    }\n\n    pub fn with_body(mut self, match_body: bool) -\u003e Self {\n        self.match_body = match_body;\n        self\n    }\n}\n\nimpl RequestMatcher for LastFmEditVcrMatcher {\n    fn matches(\u0026self, request: \u0026Request, recorded_request: \u0026SerializableRequest) -\u003e bool {\n        log::debug!(\n            \"Matching request: {} {} against recorded: {} {}\",\n            request.method(),\n            request.url(),\n            recorded_request.method,\n            recorded_request.url\n        );\n\n        if self.match_method \u0026\u0026 request.method().to_string() != recorded_request.method {\n            log::debug!(\n                \"Method mismatch: {} != {}\",\n                request.method(),\n                recorded_request.method\n            );\n            return false;\n        }\n\n        if self.match_url \u0026\u0026 request.url().to_string() != recorded_request.url {\n            log::debug!(\n                \"URL mismatch: {} != {}\",\n                request.url(),\n                recorded_request.url\n            );\n            return false;\n        }\n\n        // For Last.fm, we explicitly ignore unstable headers that change between sessions\n        // This includes cookies, session tokens, CSRF tokens, and other ephemeral data\n        let unstable_headers = [\n            \"cookie\",\n            \"set-cookie\",\n            \"authorization\",\n            \"x-csrf-token\",\n            \"csrf-token\",\n            \"sessionid\",\n            \"session\",\n            \"x-session-id\",\n            \"x-auth-token\",\n            \"auth-token\",\n        ];\n\n        // Match on all headers EXCEPT the unstable ones\n        log::debug!(\"Checking headers (ignoring unstable ones)\");\n        for (header_name, recorded_values) in \u0026recorded_request.headers {\n            let header_lower = header_name.to_lowercase();\n\n            // Skip unstable headers\n            if unstable_headers\n                .iter()\n                .any(|unstable| header_lower.contains(unstable))\n            {\n                log::debug!(\"Skipping unstable header: {header_name}\");\n                continue;\n            }\n\n            let request_header = request.header(header_name.as_str());\n            log::debug!(\n                \"Comparing stable header '{header_name}': request={:?}, recorded={recorded_values:?}\",\n                request_header.map(|v| v.iter().map(|h| h.as_str()).collect::\u003cVec\u003c_\u003e\u003e())\n            );\n\n            match request_header {\n                Some(req_val) =\u003e {\n                    let req_values: Vec\u003cString\u003e =\n                        req_val.iter().map(|v| v.as_str().to_string()).collect();\n                    if \u0026req_values != recorded_values {\n                        log::debug!(\n                            \"Header '{header_name}' values mismatch: {req_values:?} != {recorded_values:?}\"\n                        );\n                        return false;\n                    }\n                }\n                None =\u003e {\n                    // If the recorded request has a header but the current request doesn't,\n                    // that's a mismatch (unless it's an unstable header we're ignoring)\n                    log::debug!(\"Header '{header_name}' missing from request\");\n                    return false;\n                }\n            }\n        }\n\n        log::debug!(\"Request matched successfully\");\n\n        true\n    }\n\n    fn matches_serializable(\n        \u0026self,\n        request: \u0026SerializableRequest,\n        recorded_request: \u0026SerializableRequest,\n    ) -\u003e bool {\n        log::debug!(\n            \"Matching serializable request: {} {} vs {} {}\",\n            request.method,\n            request.url,\n            recorded_request.method,\n            recorded_request.url\n        );\n        if self.match_method \u0026\u0026 request.method != recorded_request.method {\n            return false;\n        }\n\n        if self.match_url \u0026\u0026 request.url != recorded_request.url {\n            return false;\n        }\n\n        // Same logic as above - ignore unstable headers\n        let unstable_headers = [\n            \"cookie\",\n            \"set-cookie\",\n            \"authorization\",\n            \"x-csrf-token\",\n            \"csrf-token\",\n            \"sessionid\",\n            \"session\",\n            \"x-session-id\",\n            \"x-auth-token\",\n            \"auth-token\",\n        ];\n\n        // Match on all headers EXCEPT the unstable ones\n        log::debug!(\n            \"Checking {} recorded headers\",\n            recorded_request.headers.len()\n        );\n        for (header_name, recorded_values) in \u0026recorded_request.headers {\n            let header_lower = header_name.to_lowercase();\n\n            // Skip unstable headers\n            if unstable_headers\n                .iter()\n                .any(|unstable| header_lower.contains(unstable))\n            {\n                log::debug!(\"Skipping unstable header: {header_name}\");\n                continue;\n            }\n\n            log::debug!(\"Checking stable header: {header_name} = {recorded_values:?}\");\n\n            let request_header = request.headers.get(header_name);\n\n            match request_header {\n                Some(req_values) =\u003e {\n                    log::debug!(\n                        \"Comparing header '{header_name}': request={req_values:?} vs recorded={recorded_values:?}\"\n                    );\n                    if req_values != recorded_values {\n                        log::debug!(\n                            \"Header '{header_name}' MISMATCH! request={req_values:?} != {recorded_values:?}\"\n                        );\n                        return false;\n                    }\n                }\n                None =\u003e {\n                    // Some headers like content-type are automatically added by HTTP clients\n                    // but may not be present during replay. For GET requests, content-type is often optional.\n                    if header_name.to_lowercase() == \"content-type\" \u0026\u0026 request.method == \"GET\" {\n                        log::debug!(\"Ignoring missing content-type header for GET request\");\n                        continue;\n                    }\n\n                    // If the recorded request has a header but the current request doesn't,\n                    // that's a mismatch (unless it's an unstable header we're ignoring)\n                    log::debug!(\n                        \"Header '{header_name}' missing from current request (recorded has: {recorded_values:?})\"\n                    );\n                    return false;\n                }\n            }\n        }\n\n        true\n    }\n}\n\nimpl Default for LastFmEditVcrMatcher {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[{"line":23,"address":[5509904],"length":1,"stats":{"Line":0}},{"line":24,"address":[3253293],"length":1,"stats":{"Line":0}},{"line":25,"address":[5509953],"length":1,"stats":{"Line":0}},{"line":30,"address":[5510000,5514131,5513829],"length":1,"stats":{"Line":0}},{"line":31,"address":[5510055,5510114,5510220,5510176],"length":1,"stats":{"Line":0}},{"line":39,"address":[5510100,5510588],"length":1,"stats":{"Line":0}},{"line":40,"address":[3257861],"length":1,"stats":{"Line":0}},{"line":45,"address":[5514471],"length":1,"stats":{"Line":0}},{"line":48,"address":[3254475,3253909],"length":1,"stats":{"Line":0}},{"line":49,"address":[5511296,5514220,5514157],"length":1,"stats":{"Line":0}},{"line":54,"address":[3257472],"length":1,"stats":{"Line":0}},{"line":59,"address":[5510807],"length":1,"stats":{"Line":0}},{"line":73,"address":[3254421,3254743],"length":1,"stats":{"Line":0}},{"line":74,"address":[3254915,3254694],"length":1,"stats":{"Line":0}},{"line":75,"address":[5511664],"length":1,"stats":{"Line":0}},{"line":78,"address":[5511697,5512039],"length":1,"stats":{"Line":0}},{"line":80,"address":[5738960,5738978],"length":1,"stats":{"Line":0}},{"line":82,"address":[5513842,5513867,5512133],"length":1,"stats":{"Line":0}},{"line":86,"address":[3255442,3255545],"length":1,"stats":{"Line":0}},{"line":87,"address":[5837456,5837577,5837481,5837552],"length":1,"stats":{"Line":0}},{"line":92,"address":[5512286],"length":1,"stats":{"Line":0}},{"line":93,"address":[5512814],"length":1,"stats":{"Line":0}},{"line":94,"address":[3256166,3256554],"length":1,"stats":{"Line":0}},{"line":96,"address":[5513264,5513351],"length":1,"stats":{"Line":0}},{"line":97,"address":[5513376,5513441,5513477],"length":1,"stats":{"Line":0}},{"line":100,"address":[3256775],"length":1,"stats":{"Line":0}},{"line":106,"address":[5512852,5512917],"length":1,"stats":{"Line":0}},{"line":107,"address":[5512904],"length":1,"stats":{"Line":0}},{"line":112,"address":[3255084,3255134],"length":1,"stats":{"Line":0}},{"line":114,"address":[5511777],"length":1,"stats":{"Line":0}},{"line":117,"address":[5514800,5517889,5519023],"length":1,"stats":{"Line":1}},{"line":122,"address":[3258183,3258242],"length":1,"stats":{"Line":2}},{"line":129,"address":[5515354,5514900],"length":1,"stats":{"Line":2}},{"line":130,"address":[5515366],"length":1,"stats":{"Line":0}},{"line":133,"address":[5515326,5515704],"length":1,"stats":{"Line":2}},{"line":134,"address":[3259055],"length":1,"stats":{"Line":2}},{"line":138,"address":[3258707],"length":1,"stats":{"Line":1}},{"line":152,"address":[5515846],"length":1,"stats":{"Line":0}},{"line":156,"address":[5515748,5516057],"length":1,"stats":{"Line":2}},{"line":157,"address":[5516150],"length":1,"stats":{"Line":1}},{"line":160,"address":[5516183,5516308],"length":1,"stats":{"Line":2}},{"line":162,"address":[3262832,3262850],"length":1,"stats":{"Line":2}},{"line":164,"address":[5516416,5518747],"length":1,"stats":{"Line":2}},{"line":168,"address":[5516371,5516471,5516519],"length":1,"stats":{"Line":3}},{"line":170,"address":[3259808,3260177],"length":1,"stats":{"Line":9}},{"line":172,"address":[5516862],"length":1,"stats":{"Line":9}},{"line":173,"address":[5516893],"length":1,"stats":{"Line":8}},{"line":174,"address":[5517902,5516909,5517942],"length":1,"stats":{"Line":22}},{"line":177,"address":[3261621,3261231],"length":1,"stats":{"Line":18}},{"line":178,"address":[3261646,3261711],"length":1,"stats":{"Line":0}},{"line":181,"address":[5518375],"length":1,"stats":{"Line":0}},{"line":187,"address":[5517200,5516957],"length":1,"stats":{"Line":4}},{"line":188,"address":[5517674,5517649,5517234],"length":1,"stats":{"Line":5}},{"line":194,"address":[5517147,5517289,5517308],"length":1,"stats":{"Line":0}},{"line":197,"address":[5517295],"length":1,"stats":{"Line":0}},{"line":202,"address":[5516223],"length":1,"stats":{"Line":8}},{"line":207,"address":[5519040],"length":1,"stats":{"Line":0}},{"line":208,"address":[5519041],"length":1,"stats":{"Line":0}}],"covered":20,"coverable":58},{"path":["/","home","imalison","Projects","lastfm-edit","src","vcr_test_utils.rs"],"content":"use crate::vcr_form_data::{encode_form_data, parse_form_data};\nuse http_client_vcr::{Filter, FilterChain, SerializableRequest, SerializableResponse};\n\n/// Last.fm-specific utilities for test cassette management.\n/// These helpers understand the Last.fm authentication flow and handle credential replacement appropriately.\n/// A custom filter that only filters passwords while preserving usernames and CSRF tokens\n#[derive(Debug)]\npub struct LastFmPasswordOnlyFilter;\n\nimpl Filter for LastFmPasswordOnlyFilter {\n    fn filter_request(\u0026self, request: \u0026mut SerializableRequest) {\n        // Filter passwords in form data\n        if let Some(body) = \u0026mut request.body {\n            if body.contains('=') \u0026\u0026 (body.contains('\u0026') || !body.contains(' ')) {\n                let mut params = parse_form_data(body);\n\n                // Only filter password field - keep username and CSRF token for request matching\n                if params.contains_key(\"password\") {\n                    params.insert(\"password\".to_string(), \"test_password\".to_string());\n                    *body = encode_form_data(\u0026params);\n                }\n            }\n        }\n\n        // Filter session cookies in request headers\n        if let Some(cookie_values) = request.headers.get_mut(\"cookie\") {\n            for cookie_header in cookie_values.iter_mut() {\n                *cookie_header = self.filter_session_cookies(cookie_header);\n            }\n        }\n    }\n\n    fn filter_response(\u0026self, response: \u0026mut SerializableResponse) {\n        // Filter session cookies in response set-cookie headers\n        if let Some(set_cookie_values) = response.headers.get_mut(\"set-cookie\") {\n            for set_cookie_header in set_cookie_values.iter_mut() {\n                if set_cookie_header.contains(\"sessionid=\") {\n                    *set_cookie_header = self.filter_set_cookie_session(set_cookie_header);\n                }\n            }\n        }\n    }\n}\n\nimpl LastFmPasswordOnlyFilter {\n    /// Filter session cookies from a cookie header string\n    fn filter_session_cookies(\u0026self, cookie_header: \u0026str) -\u003e String {\n        let mut filtered_cookies = Vec::new();\n\n        for cookie in cookie_header.split(';') {\n            let cookie = cookie.trim();\n            if cookie.starts_with(\"sessionid=\") {\n                // Replace session ID with test value\n                filtered_cookies.push(\"sessionid=test_session_id\");\n            } else {\n                filtered_cookies.push(cookie);\n            }\n        }\n\n        filtered_cookies.join(\"; \")\n    }\n\n    /// Filter session cookies from a set-cookie header string\n    fn filter_set_cookie_session(\u0026self, set_cookie_header: \u0026str) -\u003e String {\n        if set_cookie_header.starts_with(\"sessionid=\") {\n            // Extract everything after the session value up to the first semicolon or end\n            if let Some(semicolon_pos) = set_cookie_header.find(';') {\n                let attributes = \u0026set_cookie_header[semicolon_pos..];\n                format!(\"sessionid=test_session_id{attributes}\")\n            } else {\n                \"sessionid=test_session_id\".to_string()\n            }\n        } else {\n            set_cookie_header.to_string()\n        }\n    }\n}\n\n/// Create a Last.fm test filter chain that:\n/// - Keeps usernames and CSRF tokens intact (needed for proper request matching)\n/// - Filters passwords from request bodies with predictable test values\n/// - Filters session tokens with predictable test values\npub fn create_lastfm_test_filter_chain() -\u003e Result\u003cFilterChain, regex::Error\u003e {\n    let filter_chain = FilterChain::new().add_filter(Box::new(LastFmPasswordOnlyFilter));\n    Ok(filter_chain)\n}\n","traces":[{"line":11,"address":[3071506,3070768,3071512],"length":1,"stats":{"Line":0}},{"line":13,"address":[6010753],"length":1,"stats":{"Line":0}},{"line":14,"address":[6010925,6010819],"length":1,"stats":{"Line":0}},{"line":15,"address":[6010991],"length":1,"stats":{"Line":0}},{"line":18,"address":[3071479,3071066,3071134],"length":1,"stats":{"Line":0}},{"line":19,"address":[6011117,6011187,6011449],"length":1,"stats":{"Line":0}},{"line":20,"address":[6011297,6011342],"length":1,"stats":{"Line":0}},{"line":26,"address":[6010850,6011490],"length":1,"stats":{"Line":0}},{"line":27,"address":[6011506,6011562,6011795],"length":1,"stats":{"Line":0}},{"line":28,"address":[6011636,6011693],"length":1,"stats":{"Line":0}},{"line":33,"address":[6012135,6011808],"length":1,"stats":{"Line":0}},{"line":35,"address":[6011843],"length":1,"stats":{"Line":0}},{"line":36,"address":[6011958,6011908],"length":1,"stats":{"Line":0}},{"line":37,"address":[6012195,6012017],"length":1,"stats":{"Line":0}},{"line":38,"address":[6012109,6012057,6012169],"length":1,"stats":{"Line":0}},{"line":47,"address":[6012782,6012788,6012208],"length":1,"stats":{"Line":0}},{"line":48,"address":[6012259],"length":1,"stats":{"Line":0}},{"line":50,"address":[6012283,6012348],"length":1,"stats":{"Line":0}},{"line":51,"address":[3072551,3072663],"length":1,"stats":{"Line":0}},{"line":52,"address":[6012667],"length":1,"stats":{"Line":0}},{"line":54,"address":[3072805,3072765],"length":1,"stats":{"Line":0}},{"line":56,"address":[6012714,6012772],"length":1,"stats":{"Line":0}},{"line":60,"address":[3072568],"length":1,"stats":{"Line":0}},{"line":64,"address":[6012816],"length":1,"stats":{"Line":0}},{"line":65,"address":[6012881],"length":1,"stats":{"Line":0}},{"line":67,"address":[6012934,6012993],"length":1,"stats":{"Line":0}},{"line":68,"address":[6013006],"length":1,"stats":{"Line":0}},{"line":69,"address":[6013029],"length":1,"stats":{"Line":0}},{"line":71,"address":[6013147],"length":1,"stats":{"Line":0}},{"line":74,"address":[6012917],"length":1,"stats":{"Line":0}},{"line":83,"address":[6013184,6013381,6013355],"length":1,"stats":{"Line":0}},{"line":84,"address":[6013198,6013238,6013365],"length":1,"stats":{"Line":0}},{"line":85,"address":[6013316],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":33},{"path":["/","home","imalison","Projects","lastfm-edit","tests","event_broadcasting.rs"],"content":"use http_client_vcr::NoOpClient;\nuse lastfm_edit::{LastFmEditClientImpl, LastFmEditSession};\nuse std::time::Duration;\nuse tokio::time::timeout;\n\nfn create_test_session() -\u003e LastFmEditSession {\n    LastFmEditSession::new(\n        \"test_user\".to_string(),\n        vec![\"sessionid=.test_session_id_12345\".to_string()],\n        Some(\"test_csrf_token\".to_string()),\n        \"https://www.last.fm\".to_string(),\n    )\n}\n\n#[test_log::test(tokio::test)]\nasync fn test_shared_broadcaster_across_clients() {\n    // Create the first client\n    let http_client1 = NoOpClient::new();\n    let client1 = LastFmEditClientImpl::from_session(Box::new(http_client1), create_test_session());\n\n    // Create second client that shares the broadcaster with client1\n    let http_client2 = NoOpClient::new();\n    let client2 = client1.with_shared_broadcaster(Box::new(http_client2));\n\n    // Create third client with independent broadcaster\n    let http_client3 = NoOpClient::new();\n    let session = client1.get_session();\n    let client3 = LastFmEditClientImpl::from_session(Box::new(http_client3), session);\n\n    // Subscribe to events from all clients\n    let mut events1 = client1.subscribe();\n    let mut events2 = client2.subscribe();\n    let mut events3 = client3.subscribe();\n\n    // Test that clients start with no events\n    assert!(client1.latest_event().is_none());\n    assert!(client2.latest_event().is_none());\n    assert!(client3.latest_event().is_none());\n\n    // In a real scenario, rate limit events would be broadcast automatically\n    // when HTTP requests encounter rate limiting. Since we can't easily simulate\n    // that in a unit test, we verify the structure is correct by checking that:\n\n    // 1. Clients with shared broadcasters have the same latest event state\n    // 2. Clients with independent broadcasters maintain separate state\n\n    // For now, we can only test that the event subscriptions are properly set up\n    // and that no events are present initially (which is correct)\n\n    // Test that subscriptions don't immediately have events\n    let no_event_1 = timeout(Duration::from_millis(10), events1.recv()).await;\n    let no_event_2 = timeout(Duration::from_millis(10), events2.recv()).await;\n    let no_event_3 = timeout(Duration::from_millis(10), events3.recv()).await;\n\n    // All should timeout (no events received)\n    assert!(no_event_1.is_err());\n    assert!(no_event_2.is_err());\n    assert!(no_event_3.is_err());\n}\n\n#[test_log::test(tokio::test)]\nasync fn test_session_sharing_vs_broadcaster_sharing() {\n    // Create first client\n    let http_client1 = NoOpClient::new();\n    let client1 = LastFmEditClientImpl::from_session(Box::new(http_client1), create_test_session());\n\n    // Client2: shares session but NOT broadcaster\n    let http_client2 = NoOpClient::new();\n    let session = client1.get_session();\n    let client2 = LastFmEditClientImpl::from_session(Box::new(http_client2), session);\n\n    // Client3: shares BOTH session and broadcaster\n    let http_client3 = NoOpClient::new();\n    let client3 = client1.with_shared_broadcaster(Box::new(http_client3));\n\n    // Verify session sharing\n    assert_eq!(\n        client1.get_session().base_url,\n        client2.get_session().base_url\n    );\n    assert_eq!(\n        client1.get_session().base_url,\n        client3.get_session().base_url\n    );\n\n    // All clients should start with no events\n    assert!(client1.latest_event().is_none());\n    assert!(client2.latest_event().is_none());\n    assert!(client3.latest_event().is_none());\n\n    // Subscribe to verify broadcast setup\n    let _events1 = client1.subscribe();\n    let _events2 = client2.subscribe();\n    let _events3 = client3.subscribe();\n\n    // Test passes if no panics occur - the broadcaster sharing is working correctly\n    // In real usage, when client1 or client3 encounter rate limits, both would see the events\n    // while client2 would not (since it has an independent broadcaster)\n}\n\n#[test_log::test]\nfn test_client_creation_patterns() {\n    // Pattern 1: Independent clients\n    let http_client1 = NoOpClient::new();\n    let client1 = LastFmEditClientImpl::from_session(Box::new(http_client1), create_test_session());\n\n    let http_client2 = NoOpClient::new();\n    let session = client1.get_session();\n    let client2 = LastFmEditClientImpl::from_session(Box::new(http_client2), session);\n\n    // These should be independent - same session but different broadcasters\n    assert_eq!(\n        client1.get_session().base_url,\n        client2.get_session().base_url\n    );\n\n    // Pattern 2: Shared broadcaster\n    let http_client3 = NoOpClient::new();\n    let client3 = client1.with_shared_broadcaster(Box::new(http_client3));\n\n    // These should share both session and broadcaster\n    assert_eq!(\n        client1.get_session().base_url,\n        client3.get_session().base_url\n    );\n\n    // Test that we can create subscriptions without issues\n    let _sub1 = client1.subscribe();\n    let _sub2 = client2.subscribe();\n    let _sub3 = client3.subscribe();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","tests","mock_client.rs"],"content":"#[cfg(feature = \"mock\")]\nmod mock_tests {\n    use lastfm_edit::{\n        Album, AlbumPage, EditResponse, ExactScrobbleEdit, LastFmEditClient, MockLastFmEditClient,\n        Result, ScrobbleEdit, Track, TrackPage,\n    };\n    use mockall::predicate::*; // for eq(), any(), etc.\n\n    #[test_log::test(tokio::test)]\n    async fn test_mock_basic_functionality() -\u003e Result\u003c()\u003e {\n        let mut mock_client = MockLastFmEditClient::new();\n\n        mock_client\n            .expect_username()\n            .times(1)\n            .returning(|| \"testuser\".to_string());\n\n        // Use the mock as a trait object\n        let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n\n        // Test username retrieval\n        assert_eq!(client.username(), \"testuser\");\n\n        Ok(())\n    }\n\n    #[test_log::test(tokio::test)]\n    async fn test_mock_edit_scrobble() -\u003e Result\u003c()\u003e {\n        let mut mock_client = MockLastFmEditClient::new();\n\n        let edit = ScrobbleEdit::new(\n            Some(\"Old Track\".to_string()),\n            Some(\"Old Album\".to_string()),\n            \"Old Artist\".to_string(),\n            Some(\"Old Artist\".to_string()),\n            Some(\"New Track\".to_string()),\n            Some(\"New Album\".to_string()),\n            \"New Artist\".to_string(),\n            Some(\"New Artist\".to_string()),\n            Some(1640995200),\n            false,\n        );\n\n        let expected_exact_edit = ExactScrobbleEdit::new(\n            \"Old Track\".to_string(),\n            \"Old Album\".to_string(),\n            \"Old Artist\".to_string(),\n            \"Old Artist\".to_string(),\n            \"New Track\".to_string(),\n            \"New Album\".to_string(),\n            \"New Artist\".to_string(),\n            \"New Artist\".to_string(),\n            1640995200,\n            false,\n        );\n\n        let expected_response = EditResponse::single(\n            true,\n            Some(\"Edit completed successfully\".to_string()),\n            None,\n            expected_exact_edit,\n        );\n\n        // Set up expectation for edit_scrobble\n        mock_client\n            .expect_edit_scrobble()\n            .with(eq(edit.clone()))\n            .times(1)\n            .returning(move |_| Ok(expected_response.clone()));\n\n        // Use the mock\n        let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n        let response = client.edit_scrobble(\u0026edit).await?;\n\n        assert!(response.success());\n        assert_eq!(\n            response.message(),\n            Some(\"Edit completed successfully\".to_string())\n        );\n\n        Ok(())\n    }\n\n    #[test_log::test(tokio::test)]\n    async fn test_mock_get_recent_scrobbles() -\u003e Result\u003c()\u003e {\n        let mut mock_client = MockLastFmEditClient::new();\n\n        let expected_tracks = vec![\n            Track {\n                name: \"Test Track 1\".to_string(),\n                artist: \"Test Artist 1\".to_string(),\n                album: Some(\"Test Album 1\".to_string()),\n                album_artist: Some(\"Test Artist 1\".to_string()),\n                playcount: 5,\n                timestamp: Some(1640995200),\n            },\n            Track {\n                name: \"Test Track 2\".to_string(),\n                artist: \"Test Artist 2\".to_string(),\n                album: Some(\"Test Album 2\".to_string()),\n                album_artist: Some(\"Test Artist 2\".to_string()),\n                playcount: 3,\n                timestamp: Some(1640995100),\n            },\n        ];\n\n        // Set up expectation\n        mock_client\n            .expect_get_recent_scrobbles()\n            .with(eq(1))\n            .times(1)\n            .returning(move |_| Ok(expected_tracks.clone()));\n\n        // Use the mock\n        let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n        let tracks = client.get_recent_scrobbles(1).await?;\n\n        assert_eq!(tracks.len(), 2);\n        assert_eq!(tracks[0].name, \"Test Track 1\");\n        assert_eq!(tracks[1].name, \"Test Track 2\");\n\n        Ok(())\n    }\n\n    #[test_log::test(tokio::test)]\n    async fn test_mock_iterator_concept() -\u003e Result\u003c()\u003e {\n        // Note: Due to Rust's lifetime system, mocking iterators that borrow from\n        // the client is complex. In practice, you would typically mock the underlying\n        // pagination methods (like get_artist_tracks_page) rather than the iterators themselves.\n\n        let mut mock_client = MockLastFmEditClient::new();\n\n        // Mock the underlying pagination method that iterators use\n        mock_client\n            .expect_get_artist_tracks_page()\n            .with(eq(\"test_artist\"), eq(1))\n            .returning(|_, _| {\n                Ok(TrackPage {\n                    tracks: vec![Track {\n                        name: \"Mocked Track\".to_string(),\n                        artist: \"Mocked Artist\".to_string(),\n                        album: Some(\"Mocked Album\".to_string()),\n                        album_artist: Some(\"Mocked Artist\".to_string()),\n                        playcount: 10,\n                        timestamp: Some(1640995200),\n                    }],\n                    page_number: 1,\n                    has_next_page: false,\n                    total_pages: Some(1),\n                })\n            });\n\n        let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n\n        // Test that the underlying method works correctly\n        let page = client.get_artist_tracks_page(\"test_artist\", 1).await?;\n        assert_eq!(page.tracks.len(), 1);\n        assert_eq!(page.tracks[0].name, \"Mocked Track\");\n\n        Ok(())\n    }\n\n    #[test_log::test(tokio::test)]\n    async fn test_mock_iterator_trait_objects() -\u003e Result\u003c()\u003e {\n        // This test demonstrates that iterator methods return trait objects\n        // that can be used polymorphically, even though mocking the iterators\n        // themselves is complex due to lifetime constraints.\n\n        let mut mock_client = MockLastFmEditClient::new();\n\n        // Mock the underlying methods that the iterators use\n        mock_client\n            .expect_get_artist_tracks_page()\n            .with(eq(\"test_artist\"), eq(1))\n            .returning(|_, _| {\n                Ok(TrackPage {\n                    tracks: vec![Track {\n                        name: \"Iterator Track 1\".to_string(),\n                        artist: \"test_artist\".to_string(),\n                        album: Some(\"Test Album\".to_string()),\n                        album_artist: Some(\"test_artist\".to_string()),\n                        playcount: 5,\n                        timestamp: Some(1640995200),\n                    }],\n                    page_number: 1,\n                    has_next_page: false,\n                    total_pages: Some(1),\n                })\n            });\n\n        mock_client\n            .expect_get_recent_scrobbles()\n            .with(eq(1))\n            .returning(|_| {\n                Ok(vec![Track {\n                    name: \"Recent Track 1\".to_string(),\n                    artist: \"Recent Artist\".to_string(),\n                    album: Some(\"Recent Album\".to_string()),\n                    album_artist: Some(\"Recent Artist\".to_string()),\n                    playcount: 1,\n                    timestamp: Some(1640995300),\n                }])\n            });\n\n        mock_client\n            .expect_get_artist_albums_page()\n            .with(eq(\"test_artist\"), eq(1))\n            .returning(|_, _| {\n                Ok(AlbumPage {\n                    albums: vec![Album {\n                        name: \"Test Album\".to_string(),\n                        artist: \"test_artist\".to_string(),\n                        playcount: 10,\n                        timestamp: Some(1640995200),\n                    }],\n                    page_number: 1,\n                    has_next_page: false,\n                    total_pages: Some(1),\n                })\n            });\n\n        let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n\n        // Note: Iterator methods are now implemented on the concrete client type,\n        // not the trait. For testing purposes, we can cast back to the concrete type.\n        // In real code, you would typically create iterators using the concrete client.\n\n        // This demonstrates that the underlying pagination methods work\n        let tracks_page = client.get_artist_tracks_page(\"test_artist\", 1).await?;\n        assert_eq!(tracks_page.tracks.len(), 1);\n        assert_eq!(tracks_page.tracks[0].name, \"Iterator Track 1\");\n\n        let recent_page = client.get_recent_scrobbles(1).await?;\n        assert_eq!(recent_page.len(), 1);\n        assert_eq!(recent_page[0].name, \"Recent Track 1\");\n\n        let albums_page = client.get_artist_albums_page(\"test_artist\", 1).await?;\n        assert_eq!(albums_page.albums.len(), 1);\n        assert_eq!(albums_page.albums[0].name, \"Test Album\");\n\n        Ok(())\n    }\n}\n\n#[cfg(not(feature = \"mock\"))]\nmod no_mock_tests {\n    #[test]\n    fn test_mock_feature_disabled() {\n        // This test ensures the code compiles even when the mock feature is disabled\n        log::debug!(\"Mock feature is disabled - MockLastFmEditClient is not available\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","tests","parsing_send_sync.rs"],"content":"use http_client_vcr::NoOpClient;\nuse lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession};\n\nfn create_test_session() -\u003e LastFmEditSession {\n    LastFmEditSession::new(\n        \"test_user\".to_string(),\n        vec![\"sessionid=.test_session_id_12345\".to_string()],\n        Some(\"test_csrf_token\".to_string()),\n        \"https://www.last.fm\".to_string(),\n    )\n}\n\n/// Test to check if the parsing methods (non-async) are Send + Sync\n#[test_log::test]\nfn test_parsing_methods_are_send_sync() {\n    fn assert_send_sync\u003cT: Send + Sync\u003e(_: T) {}\n\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // Test that the client itself is Send + Sync (should be now that parsing is separate)\n    assert_send_sync(lastfm_client);\n}\n\n/// Test just the iterator creation without calling next() to isolate HTTP client issues\n#[test_log::test]\nfn test_iterator_creation_is_send_sync() {\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // Create iterators one at a time to avoid borrowing issues\n    let recent_tracks = lastfm_client.recent_tracks();\n    drop(recent_tracks);\n\n    let artist_tracks = lastfm_client.artist_tracks(\"test\");\n    drop(artist_tracks);\n\n    let artist_albums = lastfm_client.artist_albums(\"test\");\n    drop(artist_albums);\n}\n\n/// Test that the client itself is Send + Sync (structure-wise)\n#[test_log::test]\nfn test_client_is_send_sync() {\n    fn assert_send_sync\u003cT: Send + Sync + 'static\u003e(_: T) {}\n\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // The client should be Send + Sync at the structural level\n    assert_send_sync(lastfm_client);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","tests","thread_safety.rs"],"content":"use http_client_vcr::NoOpClient;\nuse lastfm_edit::{LastFmEditClientImpl, LastFmEditSession};\n\nfn create_test_session() -\u003e LastFmEditSession {\n    LastFmEditSession::new(\n        \"test_user\".to_string(),\n        vec![\"sessionid=.test_session_id_12345\".to_string()],\n        Some(\"test_csrf_token\".to_string()),\n        \"https://www.last.fm\".to_string(),\n    )\n}\n\n/// Test that futures from client operations are Send.\n/// This ensures they can be used across await boundaries in async contexts.\n#[test_log::test(tokio::test)]\nasync fn test_client_futures_are_send() {\n    fn assert_send\u003cT: Send\u003e(_: T) {}\n\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // Test that client get_recent_scrobbles future is Send\n    let get_scrobbles_future = lastfm_client.get_recent_scrobbles(1);\n    assert_send(get_scrobbles_future);\n\n    // Test that client get_artist_tracks_page future is Send\n    let get_tracks_future = lastfm_client.get_artist_tracks_page(\"test\", 1);\n    assert_send(get_tracks_future);\n}\n\n/// Test that iterator futures are Send.\n/// This ensures they can be used across await boundaries.\n/// Note: Current iterator implementation holds references to the client,\n/// so they are not Send. This is intentional for lifetime safety.\n#[test_log::test(tokio::test)]\nasync fn test_iterator_futures_are_send() {\n    // This test is commented out because iterators now hold references\n    // to the client, making them not Send. This is expected behavior.\n\n    // To use iterators across threads, create the iterator on the same\n    // thread where it will be used, or use the underlying pagination\n    // methods directly which are Send.\n}\n\n/// Test that we can spawn tasks with these futures.\n/// This is the most important practical test - futures must be Send to use with tokio::spawn.\n#[test_log::test(tokio::test)]\nasync fn test_futures_can_be_spawned() {\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // This should compile if futures are Send\n    let handle = tokio::spawn(async move {\n        let _ = lastfm_client.get_recent_scrobbles(1).await;\n        let _ = lastfm_client.get_artist_tracks_page(\"test\", 1).await;\n    });\n\n    // Don't actually await the handle since it will fail without proper credentials\n    handle.abort();\n}\n\n/// Test that pagination methods work across await boundaries.\n/// Note: Iterators are not Send due to holding client references.\n/// Use pagination methods directly for Send behavior.\n#[test_log::test(tokio::test)]\nasync fn test_pagination_methods_across_await_boundaries() {\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // This demonstrates using the underlying pagination methods which are Send\n    let handle = tokio::spawn(async move {\n        // Simulate some async work\n        tokio::time::sleep(std::time::Duration::from_millis(1)).await;\n\n        // Use pagination methods directly - these are Send\n        let _ = lastfm_client.get_recent_scrobbles(1).await;\n        let _ = lastfm_client.get_artist_tracks_page(\"test\", 1).await;\n    });\n\n    // Don't actually await since it will fail without credentials\n    handle.abort();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","tests","vcr_tests.rs"],"content":"mod vcr;\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","imalison","Projects","lastfm-edit","examples","artist_tracks_direct.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    let artist = \"The Beatles\";\n\n    println!(\"=== Artist Tracks Direct Example ===\\n\");\n    println!(\"ğŸµ Comparing album-based vs direct approach for: {artist}\");\n\n    // Test the direct approach\n    println!(\"\\nğŸ“„ Using direct paginated endpoint:\");\n    let mut direct_tracks = client.artist_tracks_direct(artist);\n    let direct_tracks_list = direct_tracks.take(10).await?;\n\n    println!(\n        \"âœ… Found {} tracks using direct approach:\",\n        direct_tracks_list.len()\n    );\n    for (i, track) in direct_tracks_list.iter().enumerate() {\n        println!(\n            \"  {}. {} (played {} times)\",\n            i + 1,\n            track.name,\n            track.playcount\n        );\n        if let Some(album) = \u0026track.album {\n            println!(\"     Album: {album}\");\n        }\n    }\n\n    // Compare with album-based approach\n    println!(\"\\nğŸ“€ Using album-based approach:\");\n    let mut album_tracks = client.artist_tracks(artist);\n    let album_tracks_list = album_tracks.take(10).await?;\n\n    println!(\n        \"âœ… Found {} tracks using album-based approach:\",\n        album_tracks_list.len()\n    );\n    for (i, track) in album_tracks_list.iter().enumerate() {\n        println!(\n            \"  {}. {} (played {} times)\",\n            i + 1,\n            track.name,\n            track.playcount\n        );\n        if let Some(album) = \u0026track.album {\n            println!(\"     Album: {album}\");\n        }\n    }\n\n    println!(\"\\nğŸ’¡ The direct approach is more efficient as it uses:\");\n    println!(\n        \"   /user/{{username}}/library/music/{}/+tracks?page=N\u0026ajax=true\",\n        artist.replace(\" \", \"+\")\n    );\n    println!(\"   Instead of iterating through albums first.\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","clean_artist_tracks.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\nuse regex::Regex;\nuse std::collections::HashSet;\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let args: Vec\u003cString\u003e = env::args().collect();\n\n    if args.len() != 3 {\n        eprintln!(\n            \"Usage: cargo run --example clean_artist_tracks -- \\\"Artist Name\\\" \\\"Regex Pattern\\\"\"\n        );\n        eprintln!(\"Examples:\");\n        eprintln!(\"  # Remove remastered suffixes:\");\n        eprintln!(\"  cargo run --example clean_artist_tracks -- \\\"The Beatles\\\" \\\" - Remastered( \\\\d{{4}})?$\\\"\");\n        eprintln!(\"  # Remove live suffixes:\");\n        eprintln!(\"  cargo run --example clean_artist_tracks -- \\\"Pink Floyd\\\" \\\" \\\\(Live\\\\)$\\\"\");\n        eprintln!(\"  # Remove explicit tags:\");\n        eprintln!(\"  cargo run --example clean_artist_tracks -- \\\"Eminem\\\" \\\" \\\\(Explicit\\\\)$\\\"\");\n        std::process::exit(1);\n    }\n\n    let artist = \u0026args[1];\n    let pattern = \u0026args[2];\n\n    let regex = match Regex::new(pattern) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            eprintln!(\"âŒ Invalid regex pattern '{pattern}': {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let client = common::setup_client().await?;\n\n    println!(\"=== Artist Catalog Cleanup Tool ===\\n\");\n    println!(\"ğŸ¨ ARTIST: {artist}\");\n    println!(\"ğŸ” PATTERN: {pattern}\");\n    println!(\"ğŸ“ This will clean track names by removing text matching the regex pattern\");\n    println!(\"\\nğŸš€ Starting catalog scan...\\n\");\n\n    // Track statistics\n    let mut total_tracks_scanned = 0;\n    let mut matching_tracks_found = 0;\n    let mut tracks_successfully_cleaned = 0;\n    let mut tracks_failed_to_clean = 0;\n    let mut already_cleaned_tracks = HashSet::new();\n\n    // Step 1: Collect all matching tracks first\n    println!(\"ğŸ” Step 1: Scanning entire {artist} catalog for matching tracks...\");\n    let mut all_matching_tracks = Vec::new();\n    let mut page = 1;\n\n    loop {\n        match client.get_artist_tracks_page(artist, page).await {\n            Ok(track_page) =\u003e {\n                if track_page.tracks.is_empty() {\n                    println!(\n                        \"ğŸ“š Reached end of {artist} catalog - scanned {total_tracks_scanned} tracks total\"\n                    );\n                    break;\n                }\n\n                for track in track_page.tracks {\n                    total_tracks_scanned += 1;\n\n                    // Print progress every 50 tracks\n                    if total_tracks_scanned % 50 == 0 {\n                        println!(\"ğŸ“– Scanned {total_tracks_scanned} tracks so far...\");\n                    }\n\n                    // Check if this track matches our pattern\n                    if regex.is_match(\u0026track.name) {\n                        let base_name = regex.replace(\u0026track.name, \"\").to_string();\n                        if !already_cleaned_tracks.contains(\u0026base_name) {\n                            all_matching_tracks.push(track);\n                            already_cleaned_tracks.insert(base_name);\n                            matching_tracks_found += 1;\n                        }\n                    }\n                }\n\n                if !track_page.has_next_page {\n                    println!(\n                        \"ğŸ“š Reached end of {artist} catalog - scanned {total_tracks_scanned} tracks total\"\n                    );\n                    break;\n                }\n\n                page += 1;\n            }\n            Err(e) =\u003e {\n                println!(\"âŒ Error fetching tracks page {page}: {e}\");\n                break;\n            }\n        }\n    }\n\n    // Step 2: Process all found matching tracks\n    if all_matching_tracks.is_empty() {\n        println!(\"\\nğŸ‰ No matching tracks found! Your {artist} catalog is already clean.\");\n        return Ok(());\n    }\n\n    println!(\n        \"\\nğŸ¯ Step 2: Processing {} matching tracks...\",\n        all_matching_tracks.len()\n    );\n    already_cleaned_tracks.clear(); // Reset for actual processing\n\n    for (index, track) in all_matching_tracks.iter().enumerate() {\n        let clean_name = regex.replace(\u0026track.name, \"\").to_string();\n\n        println!(\n            \"\\nğŸµ [{}/{}] Cleaning: '{}' â†’ '{}'\",\n            index + 1,\n            all_matching_tracks.len(),\n            track.name,\n            clean_name\n        );\n\n        // Skip if we've already processed this track name in this session\n        if already_cleaned_tracks.contains(\u0026clean_name) {\n            println!(\"   â­ï¸  Skipping - already processed in this session\");\n            continue;\n        }\n\n        // Load real edit form values from the track page\n        let edit_template = lastfm_edit::ScrobbleEdit::from_track_and_artist(\u0026track.name, artist);\n        match client\n            .discover_scrobble_edit_variations(\u0026edit_template)\n            .await\n        {\n            Ok(exact_edit_vec) =\u003e {\n                if let Some(exact_edit) = exact_edit_vec.into_iter().next() {\n                    let mut edit_data = exact_edit.to_scrobble_edit();\n                    println!(\n                        \"   ğŸ“‹ Loaded edit form data - Album: '{}'\",\n                        edit_data\n                            .album_name_original\n                            .as_deref()\n                            .unwrap_or(\"unknown\")\n                    );\n\n                    // Update the track name to the cleaned version\n                    edit_data.track_name = Some(clean_name.clone());\n\n                    println!(\"   ğŸ”§ Submitting edit...\");\n\n                    // Perform the edit\n                    match client.edit_scrobble(\u0026edit_data).await {\n                        Ok(_response) =\u003e {\n                            println!(\"   âœ… Successfully cleaned: '{clean_name}'\");\n                            tracks_successfully_cleaned += 1;\n                            already_cleaned_tracks.insert(clean_name);\n                        }\n                        Err(e) =\u003e {\n                            println!(\"   âŒ Error editing '{}': {}\", track.name, e);\n                            tracks_failed_to_clean += 1;\n                        }\n                    }\n                } else {\n                    println!(\"   âš ï¸  No edit data found for track\");\n                    tracks_failed_to_clean += 1;\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"   âš ï¸  Couldn't load edit form for '{}': {}\", track.name, e);\n                println!(\"      This track might not be in your recent scrobbles\");\n                tracks_failed_to_clean += 1;\n            }\n        }\n\n        // Add a small delay to be respectful to Last.fm servers\n        println!(\"   â³ Waiting 1.2s before next track...\");\n        tokio::time::sleep(tokio::time::Duration::from_millis(1200)).await;\n    }\n\n    // Print final statistics\n    println!(\"\\n{}\", \"=\".repeat(60));\n    println!(\"ğŸ¼ {} CATALOG CLEANUP COMPLETE\", artist.to_uppercase());\n    println!(\"{}\", \"=\".repeat(60));\n    println!(\"ğŸ“Š STATISTICS:\");\n    println!(\"   â€¢ Total tracks scanned: {total_tracks_scanned}\");\n    println!(\"   â€¢ Matching tracks found: {matching_tracks_found}\");\n    println!(\"   â€¢ Tracks successfully cleaned: {tracks_successfully_cleaned}\");\n    println!(\"   â€¢ Tracks failed to clean: {tracks_failed_to_clean}\");\n\n    if tracks_successfully_cleaned \u003e 0 {\n        println!(\n            \"\\nâœ¨ Your {artist} catalog is now cleaner! Pattern '{pattern}' has been removed from track names.\"\n        );\n    }\n\n    if tracks_failed_to_clean \u003e 0 {\n        println!(\"\\nâš ï¸  Some tracks couldn't be cleaned. This usually happens when:\");\n        println!(\"   â€¢ The track hasn't been scrobbled recently\");\n        println!(\"   â€¢ The track data isn't in your listening history\");\n        println!(\"   â€¢ There were temporary server issues\");\n        println!(\"\\nğŸ’¡ You can re-run this script later to try cleaning the remaining tracks.\");\n    }\n\n    println!(\"\\nğŸµ {artist} catalog cleanup completed!\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","custom_session_manager.rs"],"content":"/// Example demonstrating how to use SessionManager with custom app names.\n///\n/// This example shows how other libraries can use SessionManager to store\n/// Last.fm sessions with their own application prefix in XDG directories.\n///\n/// Usage:\n///   direnv exec . cargo run --example custom_session_manager\nuse lastfm_edit::{LastFmEditClientImpl, SessionManager};\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    env_logger::init();\n\n    println!(\"ğŸµ Custom SessionManager Example\");\n    println!(\"=================================\\n\");\n\n    // Create a custom session manager for your application\n    let session_manager = SessionManager::new(\"my-music-app\");\n    println!(\"ğŸ“ Using app name: '{}'\", session_manager.app_name());\n    println!(\"ğŸ“‚ Sessions will be stored in: ~/.local/share/my-music-app/users/{{username}}/session.json\\n\");\n\n    let username = env::var(\"LASTFM_EDIT_USERNAME\")\n        .expect(\"LASTFM_EDIT_USERNAME environment variable not set\");\n    let password = env::var(\"LASTFM_EDIT_PASSWORD\")\n        .expect(\"LASTFM_EDIT_PASSWORD environment variable not set\");\n\n    // Check if we have a saved session with our custom manager\n    if session_manager.session_exists(\u0026username) {\n        println!(\"ğŸ“ Found existing session for user '{username}', attempting to restore...\");\n\n        match session_manager.load_session(\u0026username) {\n            Ok(session) =\u003e {\n                println!(\"ğŸ“¥ Session loaded successfully\");\n\n                // Create client with loaded session\n                let http_client = http_client::native::NativeClient::new();\n                let client = LastFmEditClientImpl::from_session(Box::new(http_client), session);\n\n                // Validate the session\n                println!(\"ğŸ” Validating session...\");\n                if client.validate_session().await {\n                    println!(\"âœ… Session is valid, using saved session\");\n\n                    // Test the session by fetching recent tracks\n                    println!(\"ğŸ§ Testing session by fetching recent tracks...\");\n                    let tracks = client.get_recent_scrobbles(1).await?;\n                    let recent_tracks: Vec\u003c_\u003e = tracks.into_iter().take(3).collect();\n                    println!(\"ğŸ“Š Found {} recent tracks:\", recent_tracks.len());\n\n                    for track in recent_tracks {\n                        println!(\"   ğŸµ {} - {}\", track.artist, track.name);\n                    }\n\n                    return Ok(());\n                } else {\n                    println!(\"âŒ Session is invalid or expired\");\n                    // Remove invalid session file\n                    let _ = session_manager.remove_session(\u0026username);\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"âŒ Failed to load session: {e}\");\n                // Remove corrupted session file\n                let _ = session_manager.remove_session(\u0026username);\n            }\n        }\n    }\n\n    // No valid session found, perform fresh login\n    println!(\"ğŸ” No valid session found, performing fresh login...\");\n    let http_client = http_client::native::NativeClient::new();\n    let client =\n        LastFmEditClientImpl::login_with_credentials(Box::new(http_client), \u0026username, \u0026password)\n            .await?;\n\n    // Save the new session with our custom manager\n    println!(\"ğŸ’¾ Saving session with custom session manager...\");\n    let session = client.get_session();\n    if let Err(e) = session_manager.save_session(\u0026session) {\n        println!(\"âš ï¸  Warning: Failed to save session: {e}\");\n        println!(\"   (You'll need to login again next time)\");\n    } else {\n        println!(\"âœ… Session saved to custom location\");\n\n        // Show the session path\n        let session_path = session_manager.get_session_path(\u0026username)?;\n        println!(\"ğŸ“‚ Session saved to: {}\", session_path.display());\n    }\n\n    // Test the new session\n    println!(\"ğŸ§ Testing session by fetching recent tracks...\");\n    let tracks = client.get_recent_scrobbles(1).await?;\n    let recent_tracks: Vec\u003c_\u003e = tracks.into_iter().take(3).collect();\n    println!(\"ğŸ“Š Found {} recent tracks:\", recent_tracks.len());\n\n    for track in recent_tracks {\n        println!(\"   ğŸµ {} - {}\", track.artist, track.name);\n    }\n\n    // Demonstrate listing saved users\n    println!(\"\\nğŸ‘¥ Listing all saved users for this app:\");\n    let saved_users = session_manager.list_saved_users()?;\n    if saved_users.is_empty() {\n        println!(\"   No saved users found\");\n    } else {\n        for user in saved_users {\n            println!(\"   - {user}\");\n        }\n    }\n\n    println!(\"\\nğŸ‰ Example completed!\");\n    println!(\"ğŸ’¡ Your custom session is saved separately from the default lastfm-edit sessions.\");\n    println!(\n        \"ğŸ’¡ Other apps using SessionManager with different names won't interfere with each other.\"\n    );\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","debug_album_url.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::Result;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    let artist = \"Radiohead\";\n    let album = \"In Rainbows\";\n\n    println!(\"=== Debug Album URL Test ===\\n\");\n    println!(\"ğŸ” Testing URL construction for album tracks...\");\n    println!(\"Artist: {artist}\");\n    println!(\"Album: {album}\\n\");\n\n    // First, let's see if the artist has albums at all\n    println!(\"1. Testing artist albums page...\");\n    match client.get_artist_albums_page(artist, 1).await {\n        Ok(albums_page) =\u003e {\n            println!(\"âœ… Found {} albums for {artist}\", albums_page.albums.len());\n            for (i, album_item) in albums_page.albums.iter().enumerate().take(5) {\n                println!(\n                    \"   [{i}] '{}' ({} plays)\",\n                    album_item.name, album_item.playcount\n                );\n            }\n        }\n        Err(e) =\u003e {\n            println!(\"âŒ Error getting albums: {e}\");\n            return Ok(());\n        }\n    }\n\n    println!(\"\\n2. Testing album tracks page...\");\n    match client.get_album_tracks_page(album, artist, 1).await {\n        Ok(tracks_page) =\u003e {\n            println!(\n                \"âœ… Album tracks page returned {} tracks\",\n                tracks_page.tracks.len()\n            );\n            println!(\"   Has next page: {}\", tracks_page.has_next_page);\n            println!(\"   Total pages: {:?}\", tracks_page.total_pages);\n            for (i, track) in tracks_page.tracks.iter().enumerate().take(10) {\n                println!(\n                    \"   [{i}] '{}' - Album: '{}'\",\n                    track.name,\n                    track.album.as_deref().unwrap_or(\"(none)\")\n                );\n            }\n        }\n        Err(e) =\u003e {\n            println!(\"âŒ Error getting album tracks: {e}\");\n        }\n    }\n\n    // Let's also test with an album we know exists from the albums list\n    println!(\"\\n3. Testing with first album from albums list...\");\n    match client.get_artist_albums_page(artist, 1).await {\n        Ok(albums_page) =\u003e {\n            if let Some(first_album) = albums_page.albums.first() {\n                println!(\"Testing with album: '{}'\", first_album.name);\n                match client\n                    .get_album_tracks_page(\u0026first_album.name, artist, 1)\n                    .await\n                {\n                    Ok(tracks_page) =\u003e {\n                        println!(\n                            \"âœ… Found {} tracks for '{}'\",\n                            tracks_page.tracks.len(),\n                            first_album.name\n                        );\n                        for (i, track) in tracks_page.tracks.iter().enumerate().take(5) {\n                            println!(\"   [{i}] '{}'\", track.name);\n                        }\n                    }\n                    Err(e) =\u003e {\n                        println!(\"âŒ Error: {e}\");\n                    }\n                }\n            } else {\n                println!(\"No albums found in list\");\n            }\n        }\n        Err(e) =\u003e {\n            println!(\"âŒ Error getting albums: {e}\");\n        }\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","list_artist_tracks.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    let artist = std::env::args()\n        .nth(1)\n        .unwrap_or_else(|| \"Queen\".to_string());\n\n    println!(\"=== Artist Tracks Listing (using Iterator) ===\\n\");\n    println!(\"ğŸµ Listing all tracks for artist: {artist}\\n\");\n\n    // Use the iterator the same way as Case 4: Artist-specific discovery\n    let mut tracks_iterator = client.artist_tracks(\u0026artist);\n    let mut track_count = 0;\n\n    println!(\"ğŸ” Fetching tracks using iterator...\\n\");\n\n    while let Some(track) = tracks_iterator.next().await? {\n        track_count += 1;\n        println!(\n            \"[{:4}] '{}' | Album: '{}' | Plays: {} | Timestamp: {:?}\",\n            track_count,\n            track.name,\n            track.album.as_deref().unwrap_or(\"(no album)\"),\n            track.playcount,\n            track.timestamp\n        );\n\n        // Limit output for testing to avoid overwhelming output\n        if track_count \u003e= 50 {\n            println!(\"\\nâš ï¸  Limiting output to first 50 tracks for testing...\");\n            break;\n        }\n    }\n\n    println!(\"\\n=== Summary ===\");\n    println!(\"ğŸ“Š Total tracks displayed: {track_count}\");\n\n    if let Some(total_pages) = tracks_iterator.total_pages() {\n        println!(\"ğŸ“„ Total pages available: {total_pages}\");\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","list_recent_tracks.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    // Parse command line arguments\n    let args: Vec\u003cString\u003e = env::args().collect();\n    let num_tracks: usize = args.get(1).and_then(|s| s.parse().ok()).unwrap_or(20);\n    let starting_page: u32 = args.get(2).and_then(|s| s.parse().ok()).unwrap_or(1);\n\n    println!(\"Fetching {num_tracks} recent tracks starting from page {starting_page}...\");\n    println!();\n\n    // Create iterator starting from the specified page\n    let mut recent_tracks = client.recent_tracks_from_page(starting_page);\n    let mut count = 0;\n\n    // Use the iterator to fetch tracks\n    while count \u003c num_tracks {\n        match recent_tracks.next().await? {\n            Some(track) =\u003e {\n                let timestamp_str = if let Some(ts) = track.timestamp {\n                    format!(\n                        \" ({})\",\n                        chrono::DateTime::from_timestamp(ts as i64, 0)\n                            .map(|dt| dt.format(\"%Y-%m-%d %H:%M:%S\").to_string())\n                            .unwrap_or_else(|| format!(\"timestamp: {ts}\"))\n                    )\n                } else {\n                    \" (no timestamp)\".to_string()\n                };\n\n                let album_str = if let Some(album) = \u0026track.album {\n                    format!(\" [{album}]\")\n                } else {\n                    \"\".to_string()\n                };\n\n                println!(\n                    \"{}. {} - {}{}{}\",\n                    count + 1,\n                    track.artist,\n                    track.name,\n                    album_str,\n                    timestamp_str\n                );\n\n                count += 1;\n            }\n            None =\u003e {\n                println!(\"No more tracks available.\");\n                break;\n            }\n        }\n    }\n\n    println!();\n    println!(\"Fetched {count} tracks total.\");\n\n    println!();\n    println!(\"Usage: cargo run --example list_recent_tracks [num_tracks] [starting_page]\");\n    println!(\"  num_tracks    - Number of tracks to fetch (default: 20)\");\n    println!(\"  starting_page - Page number to start from (default: 1)\");\n    println!();\n    println!(\"Examples:\");\n    println!(\"  cargo run --example list_recent_tracks 50     # Fetch 50 tracks from page 1\");\n    println!(\n        \"  cargo run --example list_recent_tracks 20 5   # Fetch 20 tracks starting from page 5\"\n    );\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","rate_limit_monitoring.rs"],"content":"use lastfm_edit::{ClientEvent, LastFmEditClientImpl};\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    env_logger::init();\n\n    let username =\n        env::var(\"LASTFM_EDIT_USERNAME\").expect(\"Set LASTFM_EDIT_USERNAME environment variable\");\n    let password =\n        env::var(\"LASTFM_EDIT_PASSWORD\").expect(\"Set LASTFM_EDIT_PASSWORD environment variable\");\n\n    // Login and create client\n    let http_client = http_client::native::NativeClient::new();\n    println!(\"Logging in as {username}...\");\n    let client =\n        LastFmEditClientImpl::login_with_credentials(Box::new(http_client), \u0026username, \u0026password)\n            .await?;\n\n    // Subscribe to client events before any operations\n    let mut events = client.subscribe();\n\n    // Spawn a background task to monitor events\n    let event_monitor = tokio::spawn(async move {\n        println!(\"ğŸ” Monitoring client events...\");\n        while let Ok(event) = events.recv().await {\n            match event {\n                ClientEvent::RequestStarted { request } =\u003e {\n                    println!(\"ğŸš€ Starting request: {}\", request.short_description());\n                }\n                ClientEvent::RequestCompleted {\n                    request,\n                    status_code,\n                    duration_ms,\n                } =\u003e {\n                    println!(\n                        \"âœ… Completed request: {} - {} ({} ms)\",\n                        request.short_description(),\n                        status_code,\n                        duration_ms\n                    );\n                }\n                ClientEvent::RateLimited {\n                    delay_seconds,\n                    request,\n                    rate_limit_type,\n                    rate_limit_timestamp,\n                } =\u003e {\n                    let req_desc = request\n                        .as_ref()\n                        .map(|r| r.short_description())\n                        .unwrap_or_else(|| \"unknown request\".to_string());\n                    println!(\n                        \"â³ Rate limited ({rate_limit_type:?})! {req_desc} - Waiting {delay_seconds} seconds (at timestamp {rate_limit_timestamp})\"\n                    );\n                }\n                ClientEvent::RateLimitEnded {\n                    request,\n                    rate_limit_type,\n                    total_rate_limit_duration_seconds,\n                } =\u003e {\n                    println!(\n                        \"ğŸ‰ Rate limiting ended ({rate_limit_type:?}) after {total_rate_limit_duration_seconds} seconds - {}\",\n                        request.short_description()\n                    );\n                }\n                ClientEvent::EditAttempted {\n                    edit,\n                    success,\n                    error_message,\n                    duration_ms,\n                } =\u003e {\n                    if success {\n                        println!(\n                            \"âœ… Edit succeeded: '{}' -\u003e '{}' ({duration_ms} ms)\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    } else {\n                        let error_msg = error_message\n                            .as_ref()\n                            .map(|s| format!(\" - {s}\"))\n                            .unwrap_or_default();\n                        println!(\n                            \"âŒ Edit failed: '{}' -\u003e '{}' ({duration_ms} ms){error_msg}\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    }\n                }\n            }\n        }\n    });\n\n    println!(\"âœ… Successfully logged in as: {}\", client.username());\n\n    // Check latest event after login\n    if let Some(event) = client.latest_event() {\n        match event {\n            ClientEvent::RequestStarted { request } =\u003e {\n                println!(\n                    \"ğŸ“Š Latest event: Started request {}\",\n                    request.short_description()\n                );\n            }\n            ClientEvent::RequestCompleted {\n                request,\n                status_code,\n                duration_ms,\n            } =\u003e {\n                println!(\n                    \"ğŸ“Š Latest event: Completed request {} - {} ({} ms)\",\n                    request.short_description(),\n                    status_code,\n                    duration_ms\n                );\n            }\n            ClientEvent::RateLimited {\n                delay_seconds,\n                request,\n                rate_limit_type,\n                rate_limit_timestamp,\n            } =\u003e {\n                let req_desc = request\n                    .as_ref()\n                    .map(|r| r.short_description())\n                    .unwrap_or_else(|| \"unknown request\".to_string());\n                println!(\n                    \"ğŸ“Š Latest event: Rate limited ({rate_limit_type:?}) for {delay_seconds} seconds - {req_desc} (at timestamp {rate_limit_timestamp})\"\n                );\n            }\n            ClientEvent::RateLimitEnded {\n                request,\n                rate_limit_type,\n                total_rate_limit_duration_seconds,\n            } =\u003e {\n                println!(\n                    \"ğŸ“Š Latest event: Rate limiting ended ({rate_limit_type:?}) after {total_rate_limit_duration_seconds} seconds - {}\",\n                    request.short_description()\n                );\n            }\n            ClientEvent::EditAttempted {\n                edit,\n                success,\n                error_message,\n                duration_ms,\n            } =\u003e {\n                if success {\n                    println!(\n                        \"ğŸ“Š Latest event: Edit succeeded '{}' -\u003e '{}' ({duration_ms} ms)\",\n                        edit.track_name_original, edit.track_name\n                    );\n                } else {\n                    let error_msg = error_message\n                        .as_ref()\n                        .map(|s| format!(\" - {s}\"))\n                        .unwrap_or_default();\n                    println!(\n                        \"ğŸ“Š Latest event: Edit failed '{}' -\u003e '{}' ({duration_ms} ms){error_msg}\",\n                        edit.track_name_original, edit.track_name\n                    );\n                }\n            }\n        }\n    } else {\n        println!(\"ğŸ“Š No events have occurred yet\");\n    }\n\n    // Make some requests that might trigger rate limiting\n    println!(\"ğŸµ Fetching recent tracks to potentially trigger rate limiting...\");\n\n    for page in 1..=3 {\n        println!(\"ğŸ“„ Fetching page {page}...\");\n        match client.get_recent_scrobbles(page).await {\n            Ok(tracks) =\u003e {\n                println!(\"âœ… Got {} tracks from page {page}\", tracks.len());\n            }\n            Err(e) =\u003e {\n                println!(\"âŒ Error on page {page}: {e}\");\n            }\n        }\n\n        // Check if we're currently rate limited\n        if let Some(ClientEvent::RateLimited { delay_seconds, .. }) = client.latest_event() {\n            println!(\n                \"ğŸ›‘ Currently rate limited for {delay_seconds} seconds according to latest event\"\n            );\n        }\n\n        // Small delay between requests\n        tokio::time::sleep(std::time::Duration::from_millis(500)).await;\n    }\n\n    println!(\"ğŸ Done! Event monitor will continue running...\");\n\n    // Let the event monitor run for a bit longer to catch any final events\n    tokio::time::sleep(std::time::Duration::from_secs(2)).await;\n\n    // Cancel the event monitor\n    event_monitor.abort();\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","remove_remaster.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\nuse regex::Regex;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    println!(\"=== Remaster \u0026 Year Removal Tool ===\\n\");\n    println!(\"ğŸ¯ This will remove 'remastered' text and year suffixes from track names\");\n    println!(\"ğŸ“ Patterns include: '- 2009', '(2009)', '[2009]', '- Remaster', etc.\\n\");\n\n    let artist = std::env::args()\n        .nth(1)\n        .unwrap_or_else(|| \"The Beatles\".to_string());\n\n    println!(\"ğŸµ Processing tracks for artist: {artist}\\n\");\n\n    // Regex patterns to clean up remaster text and year suffixes\n    // Note: Order matters! More specific patterns should come first\n    let remaster_patterns = vec![\n        // Patterns with \"remaster\" word (most specific)\n        // \"Track Name - 2009 Remaster\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*-\\s*\\d{4}\\s*remaster(ed)?.*$\").unwrap(),\n        // \"Track Name - Remaster\" or \"Track Name - Remastered\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*-\\s*remaster(ed)?.*$\").unwrap(),\n        // \"Track Name (2009 Remaster)\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*\\(\\d{4}\\s*remaster(ed)?.*\\)\\s*$\").unwrap(),\n        // \"Track Name (Remaster)\" or \"Track Name (Remastered)\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*\\(remaster(ed)?.*\\)\\s*$\").unwrap(),\n        // \"Track Name [2009 Remaster]\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*\\[\\d{4}\\s*remaster(ed)?.*\\]\\s*$\").unwrap(),\n        // \"Track Name [Remaster]\" or \"Track Name [Remastered]\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*\\[remaster(ed)?.*\\]\\s*$\").unwrap(),\n        // \"Track Name Remastered\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*remaster(ed)?\\s*(\\d{4})?\\s*$\").unwrap(),\n        // Years that are likely remaster years (1980-2030) - be more conservative\n        // \"Track Name - 2009\" -\u003e \"Track Name\" (only for likely remaster years)\n        Regex::new(r\"(?i)\\s*-\\s*(19[8-9]\\d|20[0-3]\\d)\\s*$\").unwrap(),\n        // \"Track Name (2009)\" -\u003e \"Track Name\" (only for likely remaster years)\n        Regex::new(r\"(?i)\\s*\\((19[8-9]\\d|20[0-3]\\d)\\)\\s*$\").unwrap(),\n        // \"Track Name [2009]\" -\u003e \"Track Name\" (only for likely remaster years)\n        Regex::new(r\"(?i)\\s*\\[(19[8-9]\\d|20[0-3]\\d)\\]\\s*$\").unwrap(),\n        // Other common suffixes that should be removed\n        // \"Track Name - 2019 Mix\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*-\\s*\\d{4}\\s*mix.*$\").unwrap(),\n        // \"Track Name - Mix\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*-\\s*mix.*$\").unwrap(),\n    ];\n\n    // First, collect some tracks to process\n    let mut tracks_to_process = Vec::new();\n    let mut fetched_count = 0;\n    let mut page = 1;\n\n    loop {\n        match client.get_artist_tracks_page(\u0026artist, page).await {\n            Ok(track_page) =\u003e {\n                if track_page.tracks.is_empty() {\n                    println!(\"\\nğŸ“š Fetched all {fetched_count} tracks for {artist}\");\n                    break;\n                }\n\n                for track in track_page.tracks {\n                    fetched_count += 1;\n                    println!(\"ğŸ” [{:3}] Found track: '{}'\", fetched_count, track.name);\n\n                    // Check if track name contains remaster text\n                    let mut cleaned_name = track.name.clone();\n                    let mut needs_cleaning = false;\n\n                    for pattern in \u0026remaster_patterns {\n                        if pattern.is_match(\u0026cleaned_name) {\n                            cleaned_name = pattern.replace(\u0026cleaned_name, \"\").trim().to_string();\n                            needs_cleaning = true;\n                        }\n                    }\n\n                    if needs_cleaning \u0026\u0026 !cleaned_name.is_empty() {\n                        tracks_to_process.push((track, cleaned_name));\n                    }\n                }\n\n                if !track_page.has_next_page {\n                    println!(\"\\nğŸ“š Fetched all {fetched_count} tracks for {artist}\");\n                    break;\n                }\n\n                page += 1;\n            }\n            Err(e) =\u003e {\n                println!(\"âŒ Error fetching tracks page {page}: {e}\");\n                break;\n            }\n        }\n    }\n\n    println!(\n        \"\\nğŸ§¹ Starting remaster removal on {} tracks...\\n\",\n        tracks_to_process.len()\n    );\n\n    let mut processed_count = 0;\n    let mut edits_made = 0;\n    let mut rate_limit_hits = 0;\n\n    // Now process the collected tracks\n    for (track, cleaned_name) in tracks_to_process {\n        processed_count += 1;\n        println!(\n            \"ğŸ”§ [{:3}] Processing: '{}' -\u003e '{}'\",\n            processed_count, track.name, cleaned_name\n        );\n        println!(\"   ğŸ”„ Applying change...\");\n\n        // Load edit form - this makes an HTTP request\n        let edit_template =\n            lastfm_edit::ScrobbleEdit::from_track_and_artist(\u0026track.name, \u0026track.artist);\n        match client\n            .discover_scrobble_edit_variations(\u0026edit_template)\n            .await\n        {\n            Ok(exact_edit_vec) =\u003e {\n                if let Some(exact_edit) = exact_edit_vec.into_iter().next() {\n                    let mut edit_data = exact_edit.to_scrobble_edit();\n                    // Update track name\n                    edit_data.track_name = Some(cleaned_name.clone());\n\n                    // Submit edit - another HTTP request\n                    match client.edit_scrobble(\u0026edit_data).await {\n                        Ok(_) =\u003e {\n                            edits_made += 1;\n                            println!(\"   âœ… Successfully cleaned track\");\n                        }\n                        Err(e) =\u003e {\n                            println!(\"   âŒ Error editing track: {e}\");\n                            if e.to_string().contains(\"RateLimit\") {\n                                rate_limit_hits += 1;\n                                log::info!(\"Rate limit encountered during edit operation for track '{}' by '{}'\", track.name, track.artist);\n                                println!(\"   ğŸš¨ RATE LIMIT DETECTED during edit operation!\");\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    println!(\"   âš ï¸  No edit data found for track\");\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"   âš ï¸  Couldn't load edit form: {e}\");\n                if e.to_string().contains(\"RateLimit\") {\n                    rate_limit_hits += 1;\n                    log::info!(\n                        \"Rate limit encountered during form load for track '{}' by '{}'\",\n                        track.name,\n                        track.artist\n                    );\n                    println!(\"   ğŸš¨ RATE LIMIT DETECTED during form load!\");\n                    break;\n                }\n            }\n        }\n    }\n\n    println!(\"\\n=== Summary ===\");\n    println!(\"ğŸ“Š Tracks processed: {processed_count}\");\n    println!(\"âœï¸  Edits made: {edits_made}\");\n    println!(\"ğŸš¨ Rate limit hits: {rate_limit_hits}\");\n\n    if rate_limit_hits \u003e 0 {\n        println!(\"\\nğŸ¯ Rate limiting was triggered.\");\n    } else {\n        println!(\"\\nâœ¨ All changes completed successfully!\");\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","rename_album.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let args: Vec\u003cString\u003e = env::args().collect();\n\n    if args.len() != 4 {\n        eprintln!(\"Usage: cargo run --example rename_album -- \\\"Old Album Name\\\" \\\"New Album Name\\\" \\\"Artist Name\\\"\");\n        eprintln!(\"Example: cargo run --example rename_album -- \\\"Abbey Road - Remastered 2019\\\" \\\"Abbey Road\\\" \\\"The Beatles\\\"\");\n        std::process::exit(1);\n    }\n\n    let old_album_name = \u0026args[1];\n    let new_album_name = \u0026args[2];\n    let artist_name = \u0026args[3];\n\n    let client = common::setup_client().await?;\n\n    println!(\"=== Album Rename Tool ===\\n\");\n    println!(\"ğŸ¨ Artist: {artist_name}\");\n    println!(\"ğŸ’¿ Renaming: '{old_album_name}' â†’ '{new_album_name}'\");\n    println!();\n\n    println!(\"ğŸ” Loading album edit form data...\");\n    match client\n        .edit_album(old_album_name, new_album_name, artist_name)\n        .await\n    {\n        Ok(_response) =\u003e {\n            println!(\"âœ… Successfully renamed album!\");\n            println!(\"   From: '{old_album_name}'\");\n            println!(\"   To:   '{new_album_name}'\");\n            println!(\"   Artist: {artist_name}\");\n            println!(\n                \"\\nğŸ’¡ All scrobbles from this album have been updated with the new album name.\"\n            );\n        }\n        Err(e) =\u003e {\n            println!(\"âŒ Failed to rename album: {e}\");\n            println!(\"\\nThis might happen if:\");\n            println!(\"   â€¢ The album hasn't been scrobbled recently\");\n            println!(\"   â€¢ The album name doesn't match exactly\");\n            println!(\"   â€¢ There are temporary server issues\");\n        }\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","rename_artist.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::Result;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let mut client = common::setup_client().await?;\n\n    let args: Vec\u003cString\u003e = std::env::args().collect();\n    if args.len() \u003c 4 {\n        eprintln!(\"Usage:\");\n        eprintln!(\"  {} all \u003cold_artist\u003e \u003cnew_artist\u003e\", args[0]);\n        eprintln!(\"  {} track \u003ctrack_name\u003e \u003cold_artist\u003e \u003cnew_artist\u003e\", args[0]);\n        eprintln!(\"  {} album \u003calbum_name\u003e \u003cold_artist\u003e \u003cnew_artist\u003e\", args[0]);\n        eprintln!();\n        eprintln!(\"Examples:\");\n        eprintln!(\"  {} all \\\"The Beatles\\\" \\\"Beatles\\\"\", args[0]);\n        eprintln!(\n            \"  {} track \\\"Hey Jude\\\" \\\"The Beatles\\\" \\\"Beatles\\\"\",\n            args[0]\n        );\n        eprintln!(\n            \"  {} album \\\"Abbey Road\\\" \\\"The Beatles\\\" \\\"Beatles\\\"\",\n            args[0]\n        );\n        std::process::exit(1);\n    }\n\n    let mode = \u0026args[1];\n\n    match mode.as_str() {\n        \"all\" =\u003e {\n            if args.len() != 4 {\n                eprintln!(\"Usage: {} all \u003cold_artist\u003e \u003cnew_artist\u003e\", args[0]);\n                std::process::exit(1);\n            }\n            let old_artist = \u0026args[2];\n            let new_artist = \u0026args[3];\n            rename_all_tracks(\u0026mut client, old_artist, new_artist).await\n        }\n        \"track\" =\u003e {\n            if args.len() != 5 {\n                eprintln!(\n                    \"Usage: {} track \u003ctrack_name\u003e \u003cold_artist\u003e \u003cnew_artist\u003e\",\n                    args[0]\n                );\n                std::process::exit(1);\n            }\n            let track_name = \u0026args[2];\n            let old_artist = \u0026args[3];\n            let new_artist = \u0026args[4];\n            rename_single_track(\u0026mut client, track_name, old_artist, new_artist).await\n        }\n        \"album\" =\u003e {\n            if args.len() != 5 {\n                eprintln!(\n                    \"Usage: {} album \u003calbum_name\u003e \u003cold_artist\u003e \u003cnew_artist\u003e\",\n                    args[0]\n                );\n                std::process::exit(1);\n            }\n            let album_name = \u0026args[2];\n            let old_artist = \u0026args[3];\n            let new_artist = \u0026args[4];\n            rename_album_tracks(\u0026mut client, album_name, old_artist, new_artist).await\n        }\n        _ =\u003e {\n            eprintln!(\"Invalid mode '{mode}'. Use 'all', 'track', or 'album'\");\n            std::process::exit(1);\n        }\n    }\n}\n\nasync fn rename_all_tracks(\n    client: \u0026mut dyn lastfm_edit::LastFmEditClient,\n    old_artist: \u0026str,\n    new_artist: \u0026str,\n) -\u003e Result\u003c()\u003e {\n    println!(\"=== Artist Rename Tool - All Tracks ===\\n\");\n    println!(\"ğŸ¯ This will rename ALL tracks from one artist to another\");\n    println!(\"ğŸ“ Old artist: '{old_artist}'\");\n    println!(\"ğŸ“ New artist: '{new_artist}'\");\n    println!(\"âš ï¸  This will edit ALL tracks that are found in your recent scrobbles!\\n\");\n\n    if !confirm_operation()? {\n        return Ok(());\n    }\n\n    println!(\"\\nğŸ” Starting artist rename operation...\\n\");\n\n    match client.edit_artist(old_artist, new_artist).await {\n        Ok(response) =\u003e print_result(response),\n        Err(e) =\u003e println!(\"âŒ Error during artist rename: {e}\"),\n    }\n\n    Ok(())\n}\n\nasync fn rename_single_track(\n    client: \u0026mut dyn lastfm_edit::LastFmEditClient,\n    track_name: \u0026str,\n    old_artist: \u0026str,\n    new_artist: \u0026str,\n) -\u003e Result\u003c()\u003e {\n    println!(\"=== Artist Rename Tool - Single Track ===\\n\");\n    println!(\"ğŸ¯ This will rename the artist for a specific track\");\n    println!(\"ğŸµ Track: '{track_name}'\");\n    println!(\"ğŸ“ Old artist: '{old_artist}'\");\n    println!(\"ğŸ“ New artist: '{new_artist}'\");\n    println!(\"âš ï¸  This will only edit this specific track if found in recent scrobbles!\\n\");\n\n    if !confirm_operation()? {\n        return Ok(());\n    }\n\n    println!(\"\\nğŸ” Starting track artist rename...\\n\");\n\n    match client\n        .edit_artist_for_track(track_name, old_artist, new_artist)\n        .await\n    {\n        Ok(response) =\u003e print_result(response),\n        Err(e) =\u003e println!(\"âŒ Error during track artist rename: {e}\"),\n    }\n\n    Ok(())\n}\n\nasync fn rename_album_tracks(\n    client: \u0026mut dyn lastfm_edit::LastFmEditClient,\n    album_name: \u0026str,\n    old_artist: \u0026str,\n    new_artist: \u0026str,\n) -\u003e Result\u003c()\u003e {\n    println!(\"=== Artist Rename Tool - Album Tracks ===\\n\");\n    println!(\"ğŸ¯ This will rename the artist for all tracks in a specific album\");\n    println!(\"ğŸ’¿ Album: '{album_name}'\");\n    println!(\"ğŸ“ Old artist: '{old_artist}'\");\n    println!(\"ğŸ“ New artist: '{new_artist}'\");\n    println!(\"âš ï¸  This will edit all tracks in this album that are found in recent scrobbles!\\n\");\n\n    if !confirm_operation()? {\n        return Ok(());\n    }\n\n    println!(\"\\nğŸ” Starting album artist rename...\\n\");\n\n    match client\n        .edit_artist_for_album(album_name, old_artist, new_artist)\n        .await\n    {\n        Ok(response) =\u003e print_result(response),\n        Err(e) =\u003e println!(\"âŒ Error during album artist rename: {e}\"),\n    }\n\n    Ok(())\n}\n\nfn confirm_operation() -\u003e Result\u003cbool\u003e {\n    print!(\"Are you sure you want to continue? [y/N]: \");\n    std::io::Write::flush(\u0026mut std::io::stdout()).unwrap();\n\n    let mut input = String::new();\n    std::io::stdin().read_line(\u0026mut input).unwrap();\n    let response = input.trim().to_lowercase();\n\n    if response != \"y\" \u0026\u0026 response != \"yes\" {\n        println!(\"Operation cancelled.\");\n        return Ok(false);\n    }\n\n    Ok(true)\n}\n\nfn print_result(response: lastfm_edit::EditResponse) {\n    if response.success() {\n        println!(\"âœ… Success!\");\n        if let Some(message) = response.message() {\n            println!(\"ğŸ“‹ {message}\");\n        }\n    } else {\n        println!(\"âŒ Operation failed\");\n        if let Some(message) = response.message() {\n            println!(\"ğŸ“‹ {message}\");\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","save_album_response.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::Result;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    // Test the URL construction manually to see what's wrong\n    let artist = \"Radiohead\";\n    let album = \"In Rainbows\";\n\n    // Get the session details to construct URLs manually\n    let session = client.get_session();\n    println!(\"Username: {}\", session.username);\n    println!(\"Base URL: {}\", session.base_url);\n\n    // Construct the URL we're using\n    let url = format!(\n        \"{}/user/{}/library/music/{}/{}/+tracks?page=1\u0026ajax=true\",\n        session.base_url,\n        session.username,\n        artist.replace(\" \", \"+\"),\n        album.replace(\" \", \"+\")\n    );\n\n    println!(\"Constructed URL: {url}\");\n\n    // Let's also try some variations (manually encoded):\n    let artist_encoded = artist.replace(\" \", \"%20\");\n    let album_encoded = album.replace(\" \", \"%20\");\n    let url_encoded = format!(\n        \"{}/user/{}/library/music/{}/{}/+tracks?page=1\u0026ajax=true\",\n        session.base_url, session.username, artist_encoded, album_encoded\n    );\n\n    println!(\"URL encoded version: {url_encoded}\");\n\n    // Test with a manually constructed HTTP client to see what we get\n    println!(\"\\nMaking direct HTTP request to see response...\");\n\n    // Make the request using the client's internal HTTP client\n    // We'll access this by making the client call directly and examining response\n    match client.get_album_tracks_page(album, artist, 1).await {\n        Ok(tracks_page) =\u003e {\n            println!(\"Success: {} tracks\", tracks_page.tracks.len());\n        }\n        Err(e) =\u003e {\n            println!(\"Error: {e}\");\n        }\n    }\n\n    // Let's also check what a working artist tracks URL looks like for comparison\n    let artist_tracks_url = format!(\n        \"{}/user/{}/library/music/{}/+tracks?page=1\u0026ajax=true\",\n        session.base_url,\n        session.username,\n        artist.replace(\" \", \"+\")\n    );\n    println!(\"Artist tracks URL (working): {artist_tracks_url}\");\n\n    // And albums URL\n    let artist_albums_url = format!(\n        \"{}/user/{}/library/music/{}/+albums?page=1\u0026ajax=true\",\n        session.base_url,\n        session.username,\n        artist.replace(\" \", \"+\")\n    );\n    println!(\"Artist albums URL (working): {artist_albums_url}\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","session_event_sharing.rs"],"content":"use lastfm_edit::{ClientEvent, LastFmEditClientImpl};\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    env_logger::init();\n\n    let username =\n        env::var(\"LASTFM_EDIT_USERNAME\").expect(\"Set LASTFM_EDIT_USERNAME environment variable\");\n    let password =\n        env::var(\"LASTFM_EDIT_PASSWORD\").expect(\"Set LASTFM_EDIT_PASSWORD environment variable\");\n\n    println!(\"ğŸ”§ Demonstrating shared event broadcasting between clients...\");\n\n    // Create HTTP client and login to create first client\n    let http_client = http_client::native::NativeClient::new();\n    println!(\"ğŸ” Logging in with client1...\");\n    let client1 =\n        LastFmEditClientImpl::login_with_credentials(Box::new(http_client), \u0026username, \u0026password)\n            .await?;\n    println!(\"âœ… Successfully logged in as: {}\", client1.username());\n\n    // Create a second client that shares the broadcaster with client1\n    let http_client2 = http_client::native::NativeClient::new();\n    let client2 = client1.with_shared_broadcaster(Box::new(http_client2));\n    println!(\"ğŸ”„ Created client2 with shared broadcaster from client1\");\n\n    // Subscribe to events from both clients\n    let mut events1 = client1.subscribe();\n    let mut events2 = client2.subscribe();\n    println!(\"ğŸ“¡ Subscribed to events from both clients\");\n\n    // Spawn background tasks to monitor events from each client\n    let monitor1 = tokio::spawn(async move {\n        println!(\"ğŸ” Client1 monitor started\");\n        while let Ok(event) = events1.recv().await {\n            match event {\n                ClientEvent::RequestStarted { request } =\u003e {\n                    println!(\n                        \"ğŸš€ Client1 monitor: Started request {}\",\n                        request.short_description()\n                    );\n                }\n                ClientEvent::RequestCompleted {\n                    request,\n                    status_code,\n                    duration_ms,\n                } =\u003e {\n                    println!(\n                        \"âœ… Client1 monitor: Completed {} - {} ({} ms)\",\n                        request.short_description(),\n                        status_code,\n                        duration_ms\n                    );\n                }\n                ClientEvent::RateLimited {\n                    delay_seconds,\n                    request,\n                    rate_limit_type,\n                    rate_limit_timestamp,\n                } =\u003e {\n                    let req_desc = request\n                        .as_ref()\n                        .map(|r| r.short_description())\n                        .unwrap_or_else(|| \"unknown request\".to_string());\n                    println!(\n                        \"â³ Client1 monitor: Rate limited ({rate_limit_type:?}) for {delay_seconds} seconds - {req_desc} (at timestamp {rate_limit_timestamp})\"\n                    );\n                }\n                ClientEvent::RateLimitEnded {\n                    request,\n                    rate_limit_type,\n                    total_rate_limit_duration_seconds,\n                } =\u003e {\n                    println!(\n                        \"ğŸ‰ Client1 monitor: Rate limiting ended ({rate_limit_type:?}) after {total_rate_limit_duration_seconds} seconds - {}\",\n                        request.short_description()\n                    );\n                }\n                ClientEvent::EditAttempted {\n                    edit,\n                    success,\n                    error_message,\n                    duration_ms,\n                } =\u003e {\n                    if success {\n                        println!(\n                            \"âœ… Client1 monitor: Edit succeeded '{}' -\u003e '{}' ({duration_ms} ms)\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    } else {\n                        let error_msg = error_message\n                            .as_ref()\n                            .map(|s| format!(\" - {s}\"))\n                            .unwrap_or_default();\n                        println!(\n                            \"âŒ Client1 monitor: Edit failed '{}' -\u003e '{}' ({duration_ms} ms){error_msg}\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    }\n                }\n            }\n        }\n    });\n\n    let monitor2 = tokio::spawn(async move {\n        println!(\"ğŸ” Client2 monitor started\");\n        while let Ok(event) = events2.recv().await {\n            match event {\n                ClientEvent::RequestStarted { request } =\u003e {\n                    println!(\n                        \"ğŸš€ Client2 monitor: Started request {}\",\n                        request.short_description()\n                    );\n                }\n                ClientEvent::RequestCompleted {\n                    request,\n                    status_code,\n                    duration_ms,\n                } =\u003e {\n                    println!(\n                        \"âœ… Client2 monitor: Completed {} - {} ({} ms)\",\n                        request.short_description(),\n                        status_code,\n                        duration_ms\n                    );\n                }\n                ClientEvent::RateLimited {\n                    delay_seconds,\n                    request,\n                    rate_limit_type,\n                    rate_limit_timestamp,\n                } =\u003e {\n                    let req_desc = request\n                        .as_ref()\n                        .map(|r| r.short_description())\n                        .unwrap_or_else(|| \"unknown request\".to_string());\n                    println!(\n                        \"â³ Client2 monitor: Rate limited ({rate_limit_type:?}) for {delay_seconds} seconds - {req_desc} (at timestamp {rate_limit_timestamp})\"\n                    );\n                }\n                ClientEvent::RateLimitEnded {\n                    request,\n                    rate_limit_type,\n                    total_rate_limit_duration_seconds,\n                } =\u003e {\n                    println!(\n                        \"ğŸ‰ Client2 monitor: Rate limiting ended ({rate_limit_type:?}) after {total_rate_limit_duration_seconds} seconds - {}\",\n                        request.short_description()\n                    );\n                }\n                ClientEvent::EditAttempted {\n                    edit,\n                    success,\n                    error_message,\n                    duration_ms,\n                } =\u003e {\n                    if success {\n                        println!(\n                            \"âœ… Client2 monitor: Edit succeeded '{}' -\u003e '{}' ({duration_ms} ms)\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    } else {\n                        let error_msg = error_message\n                            .as_ref()\n                            .map(|s| format!(\" - {s}\"))\n                            .unwrap_or_default();\n                        println!(\n                            \"âŒ Client2 monitor: Edit failed '{}' -\u003e '{}' ({duration_ms} ms){error_msg}\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    }\n                }\n            }\n        }\n    });\n\n    // Make a request with client1 that might trigger rate limiting\n    println!(\"ğŸ“¡ Making request with client1...\");\n    match client1.get_recent_scrobbles(1).await {\n        Ok(tracks) =\u003e {\n            println!(\"âœ… Client1 got {} tracks\", tracks.len());\n        }\n        Err(e) =\u003e {\n            println!(\"âš ï¸ Client1 error: {e}\");\n        }\n    }\n\n    // Check latest event from both clients (should be the same due to shared broadcaster)\n    let event1 = client1.latest_event();\n    let event2 = client2.latest_event();\n\n    match (event1, event2) {\n        (\n            Some(ClientEvent::RateLimited {\n                delay_seconds: delay1,\n                ..\n            }),\n            Some(ClientEvent::RateLimited {\n                delay_seconds: delay2,\n                ..\n            }),\n        ) =\u003e {\n            println!(\"ğŸ¯ Both clients show rate limiting: {delay1}s and {delay2}s\");\n            if delay1 == delay2 {\n                println!(\n                    \"âœ… SUCCESS: Both clients report the same delay (shared broadcaster working!)\"\n                );\n            } else {\n                println!(\"âŒ UNEXPECTED: Different delays reported\");\n            }\n        }\n        (\n            Some(ClientEvent::RequestCompleted { .. }),\n            Some(ClientEvent::RequestCompleted { .. }),\n        ) =\u003e {\n            println!(\"âœ… Both clients show completed requests (shared broadcaster working!)\");\n        }\n        (\n            Some(ClientEvent::EditAttempted {\n                success: success1, ..\n            }),\n            Some(ClientEvent::EditAttempted {\n                success: success2, ..\n            }),\n        ) =\u003e {\n            if success1 == success2 {\n                println!(\"âœ… Both clients show same edit result (shared broadcaster working!)\");\n            } else {\n                println!(\"âŒ UNEXPECTED: Different edit results reported\");\n            }\n        }\n        (None, None) =\u003e {\n            println!(\"ğŸ“Š No events occurred yet - this is normal\");\n            println!(\"    In real usage, both clients would see the same events when they occur\");\n        }\n        _ =\u003e {\n            println!(\"ğŸ“Š Different event states between clients (could be due to timing)\");\n        }\n    }\n\n    // Let monitors run for a bit\n    tokio::time::sleep(std::time::Duration::from_secs(1)).await;\n\n    // Clean up\n    monitor1.abort();\n    monitor2.abort();\n\n    println!(\"ğŸ Demo completed!\");\n\n    println!(\"\\nğŸ“„ Key Points:\");\n    println!(\"  â€¢ client1.with_shared_broadcaster() creates clients that share event broadcasting\");\n    println!(\"  â€¢ When any shared client encounters rate limiting, all see the same events\");\n    println!(\"  â€¢ Use this pattern when you need multiple HTTP clients but want unified rate limit handling\");\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","session_management.rs"],"content":"/// Example demonstrating both login and session restore initialization methods.\n///\n/// This example shows how to:\n/// 1. Initialize a client with username/password login\n/// 2. Save the session state to a file\n/// 3. Restore the session from the saved file\n/// 4. Use both initialization patterns\n///\n/// Usage:\n///   # First run - will prompt for credentials and save session\n///   direnv exec . cargo run --example session_management\n///\n///   # Subsequent runs - will use saved session\n///   direnv exec . cargo run --example session_management\nuse lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, Result};\nuse std::env;\nuse std::fs;\nuse std::io::{self, Write};\nuse std::path::Path;\n\nconst SESSION_FILE: \u0026str = \"session.json\";\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    env_logger::init();\n\n    println!(\"ğŸµ Last.fm Session Management Example\");\n    println!(\"=====================================\\n\");\n\n    // Try to load existing session first\n    if Path::new(SESSION_FILE).exists() {\n        println!(\"ğŸ“ Found existing session file, attempting to restore...\");\n        match restore_from_session().await {\n            Ok(client) =\u003e {\n                println!(\"âœ… Session restored successfully!\");\n                println!(\"ğŸ‘¤ Logged in as: {}\", client.username());\n\n                // Test the restored session by fetching recent tracks\n                println!(\"ğŸ§ Testing session by fetching recent tracks...\");\n                let tracks = client.get_recent_scrobbles(1).await?;\n                let recent_tracks: Vec\u003c_\u003e = tracks.into_iter().take(3).collect();\n                println!(\"ğŸ“Š Found {} recent tracks:\", recent_tracks.len());\n\n                for track in recent_tracks {\n                    println!(\"   ğŸµ {} - {}\", track.artist, track.name);\n                }\n\n                return Ok(());\n            }\n            Err(e) =\u003e {\n                println!(\"âŒ Failed to restore session: {e}\");\n                println!(\"ğŸ”„ Falling back to fresh login...\\n\");\n                // Remove invalid session file\n                let _ = fs::remove_file(SESSION_FILE);\n            }\n        }\n    }\n\n    // No valid session found, perform fresh login\n    println!(\"ğŸ”‘ No valid session found, performing fresh login...\");\n    let client = login_with_credentials().await?;\n    println!(\"âœ… Login successful!\");\n    println!(\"ğŸ‘¤ Logged in as: {}\", client.username());\n\n    // Save session for future use\n    println!(\"ğŸ’¾ Saving session to {SESSION_FILE}...\");\n    save_session(\u0026client)?;\n    println!(\"âœ… Session saved!\");\n\n    // Test the new session\n    println!(\"ğŸ§ Testing session by fetching recent tracks...\");\n    let tracks = client.get_recent_scrobbles(1).await?;\n    let recent_tracks: Vec\u003c_\u003e = tracks.into_iter().take(3).collect();\n    println!(\"ğŸ“Š Found {} recent tracks:\", recent_tracks.len());\n\n    for track in recent_tracks {\n        println!(\"   ğŸµ {} - {}\", track.artist, track.name);\n    }\n\n    println!(\"\\nğŸ‰ Example completed!\");\n    println!(\"ğŸ’¡ Next time you run this example, it will use the saved session automatically.\");\n\n    Ok(())\n}\n\n/// Restore client from saved session file\nasync fn restore_from_session() -\u003e Result\u003cLastFmEditClientImpl\u003e {\n    let session_json = fs::read_to_string(SESSION_FILE)\n        .map_err(|e| lastfm_edit::LastFmError::Http(format!(\"Failed to read session file: {e}\")))?;\n\n    let session = LastFmEditSession::from_json(\u0026session_json)\n        .map_err(|e| lastfm_edit::LastFmError::Http(format!(\"Failed to parse session: {e}\")))?;\n\n    if !session.is_valid() {\n        return Err(lastfm_edit::LastFmError::Auth(\n            \"Invalid session data\".to_string(),\n        ));\n    }\n\n    let http_client = http_client::native::NativeClient::new();\n    Ok(LastFmEditClientImpl::from_session(\n        Box::new(http_client),\n        session,\n    ))\n}\n\n/// Perform fresh login with credentials\nasync fn login_with_credentials() -\u003e Result\u003cLastFmEditClientImpl\u003e {\n    println!(\"ğŸ”§ Using login with credentials pattern...\");\n    let username = get_username();\n    let password = get_password();\n\n    let http_client = http_client::native::NativeClient::new();\n    LastFmEditClientImpl::login_with_credentials(Box::new(http_client), \u0026username, \u0026password).await\n}\n\n/// Save current session to file\nfn save_session(client: \u0026dyn LastFmEditClient) -\u003e Result\u003c()\u003e {\n    let session = client.get_session();\n    let session_json = session\n        .to_json()\n        .map_err(|e| lastfm_edit::LastFmError::Http(format!(\"Failed to serialize session: {e}\")))?;\n\n    fs::write(SESSION_FILE, session_json).map_err(|e| {\n        lastfm_edit::LastFmError::Http(format!(\"Failed to write session file: {e}\"))\n    })?;\n\n    Ok(())\n}\n\n/// Get username from environment variable or prompt\nfn get_username() -\u003e String {\n    env::var(\"LASTFM_EDIT_USERNAME\").unwrap_or_else(|_| {\n        print!(\"Last.fm username: \");\n        io::stdout().flush().unwrap();\n        let mut input = String::new();\n        io::stdin().read_line(\u0026mut input).unwrap();\n        input.trim().to_string()\n    })\n}\n\n/// Get password from environment variable or prompt\nfn get_password() -\u003e String {\n    env::var(\"LASTFM_EDIT_PASSWORD\").unwrap_or_else(|_| {\n        print!(\"Last.fm password: \");\n        io::stdout().flush().unwrap();\n        let mut input = String::new();\n        io::stdin().read_line(\u0026mut input).unwrap();\n        input.trim().to_string()\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","shared","common.rs"],"content":"use lastfm_edit::{LastFmEditClientImpl, Result};\nuse std::env;\n\npub async fn setup_client() -\u003e Result\u003cLastFmEditClientImpl\u003e {\n    // Initialize logger to handle log::debug! calls\n    env_logger::init();\n\n    let username = env::var(\"LASTFM_EDIT_USERNAME\")\n        .expect(\"LASTFM_EDIT_USERNAME environment variable not set\");\n    let password = env::var(\"LASTFM_EDIT_PASSWORD\")\n        .expect(\"LASTFM_EDIT_PASSWORD environment variable not set\");\n\n    // Login and create client\n    let http_client = http_client::native::NativeClient::new();\n    println!(\"Logging in as {username}...\");\n    let client =\n        LastFmEditClientImpl::login_with_credentials(Box::new(http_client), \u0026username, \u0026password)\n            .await?;\n    println!(\"âœ“ Logged in successfully\");\n\n    Ok(client)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","smart_scrobble_display.rs"],"content":"use lastfm_edit::{ExactScrobbleEdit, ScrobbleEdit};\n\nfn main() {\n    println!(\"=== Smart ScrobbleEdit Display Examples ===\\n\");\n\n    // Example 1: Only changing the artist name\n    let edit1 = ScrobbleEdit {\n        artist_name_original: \"The Beatles\".to_string(),\n        track_name_original: Some(\"Yesterday\".to_string()),\n        album_name_original: Some(\"Help!\".to_string()),\n        album_artist_name_original: None,\n\n        artist_name: \"Beatles, The\".to_string(),   // Changed\n        track_name: Some(\"Yesterday\".to_string()), // Same\n        album_name: Some(\"Help!\".to_string()),     // Same\n        album_artist_name: None,                   // Same\n\n        timestamp: None,\n        edit_all: false,\n    };\n    println!(\"ğŸ“ Artist name change:\");\n    println!(\"   {edit1}\");\n\n    // Example 2: Changing track and album names\n    let edit2 = ScrobbleEdit {\n        artist_name_original: \"Pink Floyd\".to_string(),\n        track_name_original: Some(\"Shine on You Crazy Diamond\".to_string()),\n        album_name_original: Some(\"Wish You Were Here\".to_string()),\n        album_artist_name_original: None,\n\n        artist_name: \"Pink Floyd\".to_string(), // Same\n        track_name: Some(\"Shine On You Crazy Diamond\".to_string()), // Changed\n        album_name: Some(\"Wish You Were Here (Remastered)\".to_string()), // Changed\n        album_artist_name: None,               // Same\n\n        timestamp: Some(1640995200),\n        edit_all: true,\n    };\n    println!(\"\\nğŸ“ Track and album changes:\");\n    println!(\"   {edit2}\");\n\n    // Example 3: Adding album artist information\n    let edit3 = ScrobbleEdit {\n        artist_name_original: \"Various Artists\".to_string(),\n        track_name_original: Some(\"Hotel California\".to_string()),\n        album_name_original: Some(\"Greatest Hits Collection\".to_string()),\n        album_artist_name_original: None,\n\n        artist_name: \"Eagles\".to_string(),                // Changed\n        track_name: Some(\"Hotel California\".to_string()), // Same\n        album_name: Some(\"Hotel California\".to_string()), // Changed\n        album_artist_name: Some(\"Eagles\".to_string()),    // Added\n\n        timestamp: None,\n        edit_all: false,\n    };\n    println!(\"\\nğŸ“ Multiple changes including adding album artist:\");\n    println!(\"   {edit3}\");\n\n    // Example 4: No changes (should show \"No changes\")\n    let edit4 = ScrobbleEdit {\n        artist_name_original: \"Radiohead\".to_string(),\n        track_name_original: Some(\"Paranoid Android\".to_string()),\n        album_name_original: Some(\"OK Computer\".to_string()),\n        album_artist_name_original: Some(\"Radiohead\".to_string()),\n\n        artist_name: \"Radiohead\".to_string(),             // Same\n        track_name: Some(\"Paranoid Android\".to_string()), // Same\n        album_name: Some(\"OK Computer\".to_string()),      // Same\n        album_artist_name: Some(\"Radiohead\".to_string()), // Same\n\n        timestamp: None,\n        edit_all: false,\n    };\n    println!(\"\\nğŸ“ No changes:\");\n    println!(\"   {edit4}\");\n\n    // Example 5: ExactScrobbleEdit (all fields required)\n    let exact_edit = ExactScrobbleEdit {\n        artist_name_original: \"Led Zeppelin\".to_string(),\n        track_name_original: \"Stairway to Heaven\".to_string(),\n        album_name_original: \"Led Zeppelin IV\".to_string(),\n        album_artist_name_original: \"Led Zeppelin\".to_string(),\n\n        artist_name: \"Led Zeppelin\".to_string(),      // Same\n        track_name: \"Stairway To Heaven\".to_string(), // Changed (capitalization)\n        album_name: \"Led Zeppelin IV (Remaster)\".to_string(), // Changed\n        album_artist_name: \"Led Zeppelin\".to_string(), // Same\n\n        timestamp: 1640995200,\n        edit_all: true,\n    };\n    println!(\"\\nğŸ“ ExactScrobbleEdit changes:\");\n    println!(\"   {exact_edit}\");\n\n    println!(\"\\nâœ¨ Features demonstrated:\");\n    println!(\"   â€¢ Only shows fields that are actually changing\");\n    println!(\"   â€¢ Uses â†’ arrow to show old â†’ new values\");\n    println!(\"   â€¢ Handles optional fields (None to Some transitions)\");\n    println!(\"   â€¢ Shows scope with '(all instances)' when edit_all is true\");\n    println!(\"   â€¢ Shows 'No changes' when nothing is being modified\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","test_album_tracks.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    let artist = std::env::args()\n        .nth(1)\n        .unwrap_or_else(|| \"The Beatles\".to_string());\n    let album = std::env::args()\n        .nth(2)\n        .unwrap_or_else(|| \"Abbey Road\".to_string());\n\n    println!(\"=== Album Tracks Test ===\\n\");\n    println!(\"ğŸµ Testing get_album_tracks() with: '{album}' by '{artist}'\\n\");\n\n    // Test the fixed get_album_tracks method\n    match client.get_album_tracks(\u0026album, \u0026artist).await {\n        Ok(tracks) =\u003e {\n            println!(\"âœ… SUCCESS: Got {} tracks\", tracks.len());\n            if tracks.is_empty() {\n                println!(\"   (Album not found in your library, but no crash!)\");\n            } else {\n                println!(\"   Tracks:\");\n                for (i, track) in tracks.iter().enumerate().take(10) {\n                    println!(\"   [{:2}] {}\", i + 1, track.name);\n                }\n                if tracks.len() \u003e 10 {\n                    println!(\"   ... and {} more tracks\", tracks.len() - 10);\n                }\n            }\n        }\n        Err(e) =\u003e {\n            println!(\"âŒ ERROR: {e}\");\n        }\n    }\n\n    // Also test the iterator directly\n    println!(\"\\n=== Album Tracks Iterator Test ===\");\n    let mut tracks_iterator = client.album_tracks(\u0026album, \u0026artist);\n    let mut count = 0;\n\n    println!(\"ğŸ” Testing iterator...\");\n    while let Some(track) = tracks_iterator.next().await? {\n        count += 1;\n        if count \u003c= 5 {\n            println!(\"   [{count}] {}\", track.name);\n        }\n        if count \u003e= 5 {\n            break;\n        }\n    }\n\n    if count == 0 {\n        println!(\"   No tracks found via iterator (album not in library)\");\n    } else {\n        println!(\"   Iterator works - got {count} tracks\");\n    }\n\n    println!(\"\\nğŸ‰ Both methods completed without crashing!\");\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","test_artist_tracks_with_albums.rs"],"content":"use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    println!(\"=== Testing Artist Tracks with Album Information ===\\n\");\n\n    // Create a test session (this won't work without real credentials)\n    let test_session = LastFmEditSession::new(\n        \"test\".to_string(),\n        vec![\"sessionid=.test123\".to_string()],\n        Some(\"csrf\".to_string()),\n        \"https://www.last.fm\".to_string(),\n    );\n\n    let client = LastFmEditClientImpl::from_session(\n        Box::new(http_client::native::NativeClient::new()),\n        test_session,\n    );\n\n    println!(\"ğŸµ Testing artist tracks iteration (album-based approach)\");\n    println!(\"   This will get tracks by iterating through albums first\");\n    println!(\"   Each track should now have album information populated\");\n\n    let mut tracks_iterator = client.artist_tracks(\"The Beatles\");\n\n    // Get first 5 tracks\n    for i in 0..5 {\n        match tracks_iterator.next().await {\n            Ok(Some(track)) =\u003e {\n                let album_info = track.album.as_deref().unwrap_or(\"No album info\");\n                let album_artist_info = track\n                    .album_artist\n                    .as_deref()\n                    .unwrap_or(\"Same as track artist\");\n\n                println!(\n                    \"  [{:2}] {} - {} [{}]\",\n                    i + 1,\n                    track.artist,\n                    track.name,\n                    album_info\n                );\n                println!(\n                    \"       Album Artist: {} | Play Count: {}\",\n                    album_artist_info, track.playcount\n                );\n\n                if let Some(timestamp) = track.timestamp {\n                    println!(\"       Last Played: {timestamp}\");\n                }\n                println!();\n            }\n            Ok(None) =\u003e {\n                println!(\"  No more tracks found\");\n                break;\n            }\n            Err(e) =\u003e {\n                println!(\"  âŒ Error: {e}\");\n                break;\n            }\n        }\n    }\n\n    println!(\"âœ¨ Key improvements:\");\n    println!(\"   â€¢ Tracks now include complete album information\");\n    println!(\"   â€¢ Album artist information is available when different from track artist\");\n    println!(\"   â€¢ Implementation iterates through albums first, then gets tracks per album\");\n    println!(\"   â€¢ This provides richer metadata compared to the previous direct track approach\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","commands","delete.rs"],"content":"use super::utils::parse_range;\nuse lastfm_edit::LastFmEditClientImpl;\n\n/// Handle deletion of scrobbles from recent pages\npub async fn handle_delete_recent_pages(\n    client: \u0026LastFmEditClientImpl,\n    pages_range: \u0026str,\n    dry_run: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let (start_page, end_page) = parse_range(pages_range, \"pages\")?;\n\n    println!(\"ğŸ—‘ï¸  Delete recent scrobbles from pages {start_page}-{end_page}\");\n    if dry_run {\n        println!(\"ğŸ” DRY RUN - No actual deletions will be performed\");\n    }\n\n    let mut total_scrobbles = 0;\n    let mut successful_deletions = 0;\n    let mut failed_deletions = 0;\n    let mut scrobbles_to_delete = Vec::new();\n\n    // Collect scrobbles from the specified pages\n    for page in start_page..=end_page {\n        println!(\"\\nğŸ“„ Processing page {page}...\");\n\n        match client.get_recent_scrobbles(page.try_into().unwrap()).await {\n            Ok(scrobbles) =\u003e {\n                if scrobbles.is_empty() {\n                    println!(\"  No scrobbles found on page {page}\");\n                    break; // No more pages\n                }\n\n                println!(\"  Found {} scrobbles on page {page}\", scrobbles.len());\n                total_scrobbles += scrobbles.len();\n\n                for scrobble in scrobbles {\n                    if let Some(timestamp) = scrobble.timestamp {\n                        scrobbles_to_delete.push((\n                            scrobble.artist.clone(),\n                            scrobble.name.clone(),\n                            timestamp,\n                        ));\n\n                        if dry_run {\n                            println!(\n                                \"    Would delete: '{}' by '{}' ({})\",\n                                scrobble.name, scrobble.artist, timestamp\n                            );\n                        }\n                    } else {\n                        println!(\n                            \"    âš ï¸  Skipping scrobble without timestamp: '{}' by '{}'\",\n                            scrobble.name, scrobble.artist\n                        );\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"  âŒ Error fetching page {page}: {e}\");\n                break;\n            }\n        }\n    }\n\n    if scrobbles_to_delete.is_empty() {\n        println!(\"\\nâŒ No scrobbles with timestamps found in the specified page range\");\n        return Ok(());\n    }\n\n    println!(\"\\nğŸ“Š Summary:\");\n    println!(\"  Total scrobbles found: {total_scrobbles}\");\n    println!(\"  Scrobbles with timestamps: {}\", scrobbles_to_delete.len());\n\n    if dry_run {\n        println!(\"\\nğŸ” DRY RUN - No actual deletions performed\");\n        println!(\"Use --apply to execute these deletions\");\n        return Ok(());\n    }\n\n    // Actually delete the scrobbles\n    println!(\"\\nğŸ—‘ï¸  Deleting scrobbles...\");\n\n    for (i, (artist, track, timestamp)) in scrobbles_to_delete.iter().enumerate() {\n        println!(\n            \"  {}/{}: Deleting '{}' by '{}'\",\n            i + 1,\n            scrobbles_to_delete.len(),\n            track,\n            artist\n        );\n\n        match client.delete_scrobble(artist, track, *timestamp).await {\n            Ok(true) =\u003e {\n                successful_deletions += 1;\n                println!(\"    âœ… Deleted successfully\");\n            }\n            Ok(false) =\u003e {\n                failed_deletions += 1;\n                println!(\"    âŒ Deletion failed\");\n            }\n            Err(e) =\u003e {\n                failed_deletions += 1;\n                println!(\"    âŒ Error: {e}\");\n            }\n        }\n\n        // Add delay between deletions to be respectful to the server\n        if i \u003c scrobbles_to_delete.len() - 1 {\n            tokio::time::sleep(std::time::Duration::from_millis(1000)).await;\n        }\n    }\n\n    println!(\"\\nğŸ“Š Final Summary:\");\n    println!(\"  Successful deletions: {successful_deletions}\");\n    println!(\"  Failed deletions: {failed_deletions}\");\n\n    if successful_deletions \u003e 0 {\n        println!(\"\\nâœ… Deletion session completed!\");\n    } else if failed_deletions \u003e 0 {\n        println!(\"\\nâŒ All deletions failed!\");\n    }\n\n    Ok(())\n}\n\n/// Handle deletion of scrobbles from timestamp range\npub async fn handle_delete_timestamp_range(\n    client: \u0026LastFmEditClientImpl,\n    timestamp_range: \u0026str,\n    dry_run: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let (start_ts, end_ts) = parse_range(timestamp_range, \"timestamp\")?;\n\n    println!(\"ğŸ—‘ï¸  Delete scrobbles from timestamp range {start_ts}-{end_ts}\");\n    if dry_run {\n        println!(\"ğŸ” DRY RUN - No actual deletions will be performed\");\n    }\n\n    let mut successful_deletions = 0;\n    let mut failed_deletions = 0;\n    let mut scrobbles_to_delete = Vec::new();\n\n    // Search through recent scrobbles to find ones in the timestamp range\n    let max_pages = 20; // Search up to 20 pages of recent scrobbles\n\n    for page in 1..=max_pages {\n        println!(\"ğŸ“„ Searching page {page} for scrobbles in timestamp range...\");\n\n        match client.get_recent_scrobbles(page).await {\n            Ok(scrobbles) =\u003e {\n                if scrobbles.is_empty() {\n                    println!(\"  No more scrobbles found, stopping search\");\n                    break;\n                }\n\n                let mut found_in_range = 0;\n                for scrobble in scrobbles {\n                    if let Some(timestamp) = scrobble.timestamp {\n                        if timestamp \u003e= start_ts \u0026\u0026 timestamp \u003c= end_ts {\n                            found_in_range += 1;\n                            scrobbles_to_delete.push((\n                                scrobble.artist.clone(),\n                                scrobble.name.clone(),\n                                timestamp,\n                            ));\n\n                            if dry_run {\n                                println!(\n                                    \"    Would delete: '{}' by '{}' ({})\",\n                                    scrobble.name, scrobble.artist, timestamp\n                                );\n                            }\n                        }\n                    }\n                }\n\n                if found_in_range \u003e 0 {\n                    println!(\"  Found {found_in_range} scrobbles in range on page {page}\");\n                } else {\n                    println!(\"  No scrobbles in range on page {page}\");\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"  âŒ Error fetching page {page}: {e}\");\n                break;\n            }\n        }\n    }\n\n    if scrobbles_to_delete.is_empty() {\n        println!(\"\\nâŒ No scrobbles found in the specified timestamp range\");\n        return Ok(());\n    }\n\n    println!(\"\\nğŸ“Š Summary:\");\n    println!(\n        \"  Scrobbles in timestamp range: {}\",\n        scrobbles_to_delete.len()\n    );\n\n    if dry_run {\n        println!(\"\\nğŸ” DRY RUN - No actual deletions performed\");\n        println!(\"Use --apply to execute these deletions\");\n        return Ok(());\n    }\n\n    // Actually delete the scrobbles\n    println!(\"\\nğŸ—‘ï¸  Deleting scrobbles...\");\n\n    for (i, (artist, track, timestamp)) in scrobbles_to_delete.iter().enumerate() {\n        println!(\n            \"  {}/{}: Deleting '{}' by '{}'\",\n            i + 1,\n            scrobbles_to_delete.len(),\n            track,\n            artist\n        );\n\n        match client.delete_scrobble(artist, track, *timestamp).await {\n            Ok(true) =\u003e {\n                successful_deletions += 1;\n                println!(\"    âœ… Deleted successfully\");\n            }\n            Ok(false) =\u003e {\n                failed_deletions += 1;\n                println!(\"    âŒ Deletion failed\");\n            }\n            Err(e) =\u003e {\n                failed_deletions += 1;\n                println!(\"    âŒ Error: {e}\");\n            }\n        }\n\n        // Add delay between deletions to be respectful to the server\n        if i \u003c scrobbles_to_delete.len() - 1 {\n            tokio::time::sleep(std::time::Duration::from_millis(1000)).await;\n        }\n    }\n\n    println!(\"\\nğŸ“Š Final Summary:\");\n    println!(\"  Successful deletions: {successful_deletions}\");\n    println!(\"  Failed deletions: {failed_deletions}\");\n\n    if successful_deletions \u003e 0 {\n        println!(\"\\nâœ… Deletion session completed!\");\n    } else if failed_deletions \u003e 0 {\n        println!(\"\\nâŒ All deletions failed!\");\n    }\n\n    Ok(())\n}\n\n/// Handle deletion of scrobbles by offset from most recent\npub async fn handle_delete_recent_offset(\n    client: \u0026LastFmEditClientImpl,\n    offset_range: \u0026str,\n    dry_run: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let (start_offset, end_offset) = parse_range(offset_range, \"offset\")?;\n\n    // Offsets are already 0-based, so use directly\n    let start_index = start_offset;\n    let end_index = end_offset;\n\n    println!(\"ğŸ—‘ï¸  Delete scrobbles by offset: {start_offset}-{end_offset} ({start_offset}th to {end_offset}th most recent, 0-indexed)\");\n    if dry_run {\n        println!(\"ğŸ” DRY RUN - No actual deletions will be performed\");\n    }\n\n    let mut all_scrobbles = Vec::new();\n    let mut successful_deletions = 0;\n    let mut failed_deletions = 0;\n\n    // Collect scrobbles until we have enough to cover the offset range\n    let mut page = 1;\n    let needed_scrobbles = (end_offset + 1) as usize; // +1 because 0-indexed\n\n    println!(\"\\nğŸ“„ Collecting recent scrobbles to reach offset {end_offset}...\");\n\n    while all_scrobbles.len() \u003c needed_scrobbles {\n        match client.get_recent_scrobbles(page.try_into().unwrap()).await {\n            Ok(scrobbles) =\u003e {\n                if scrobbles.is_empty() {\n                    println!(\"  No more scrobbles found on page {page}\");\n                    break;\n                }\n\n                println!(\n                    \"  Page {page}: Found {} scrobbles (total: {})\",\n                    scrobbles.len(),\n                    all_scrobbles.len() + scrobbles.len()\n                );\n                all_scrobbles.extend(scrobbles);\n                page += 1;\n\n                // Stop if we've collected enough\n                if all_scrobbles.len() \u003e= needed_scrobbles {\n                    break;\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"  âŒ Error fetching page {page}: {e}\");\n                break;\n            }\n        }\n    }\n\n    if all_scrobbles.len() \u003c= start_offset as usize {\n        println!(\"\\nâŒ Not enough recent scrobbles found. You have {} scrobbles, but requested offset starts at {} (0-indexed)\", all_scrobbles.len(), start_offset);\n        return Ok(());\n    }\n\n    // Extract the scrobbles in the specified offset range\n    let actual_end_index = std::cmp::min(end_index as usize, all_scrobbles.len() - 1);\n    let scrobbles_in_range = \u0026all_scrobbles[start_index as usize..=actual_end_index];\n\n    println!(\"\\nğŸ“Š Summary:\");\n    println!(\n        \"  Total recent scrobbles collected: {}\",\n        all_scrobbles.len()\n    );\n    println!(\n        \"  Scrobbles in offset range {}-{}: {}\",\n        start_offset,\n        std::cmp::min(end_offset, (all_scrobbles.len() as u64).saturating_sub(1)),\n        scrobbles_in_range.len()\n    );\n\n    if dry_run {\n        println!(\"\\nğŸ” Scrobbles that would be deleted:\");\n        for (i, scrobble) in scrobbles_in_range.iter().enumerate() {\n            let offset_number = start_offset + i as u64;\n            if let Some(timestamp) = scrobble.timestamp {\n                println!(\n                    \"    {}: '{}' by '{}' ({})\",\n                    offset_number, scrobble.name, scrobble.artist, timestamp\n                );\n            } else {\n                println!(\n                    \"    {}: '{}' by '{}' (no timestamp - cannot delete)\",\n                    offset_number, scrobble.name, scrobble.artist\n                );\n            }\n        }\n\n        println!(\"\\nğŸ” DRY RUN - No actual deletions performed\");\n        println!(\"Use --apply to execute these deletions\");\n        return Ok(());\n    }\n\n    // Actually delete the scrobbles\n    println!(\"\\nğŸ—‘ï¸  Deleting scrobbles by offset...\");\n\n    for (i, scrobble) in scrobbles_in_range.iter().enumerate() {\n        let offset_number = start_offset + i as u64;\n\n        if let Some(timestamp) = scrobble.timestamp {\n            println!(\n                \"  {}/{}: Deleting offset {} - '{}' by '{}'\",\n                i + 1,\n                scrobbles_in_range.len(),\n                offset_number,\n                scrobble.name,\n                scrobble.artist\n            );\n\n            match client\n                .delete_scrobble(\u0026scrobble.artist, \u0026scrobble.name, timestamp)\n                .await\n            {\n                Ok(true) =\u003e {\n                    successful_deletions += 1;\n                    println!(\"    âœ… Deleted successfully\");\n                }\n                Ok(false) =\u003e {\n                    failed_deletions += 1;\n                    println!(\"    âŒ Deletion failed\");\n                }\n                Err(e) =\u003e {\n                    failed_deletions += 1;\n                    println!(\"    âŒ Error: {e}\");\n                }\n            }\n        } else {\n            failed_deletions += 1;\n            println!(\n                \"  {}/{}: Skipping offset {} - '{}' by '{}' (no timestamp)\",\n                i + 1,\n                scrobbles_in_range.len(),\n                offset_number,\n                scrobble.name,\n                scrobble.artist\n            );\n        }\n\n        // Add delay between deletions to be respectful to the server\n        if i \u003c scrobbles_in_range.len() - 1 {\n            tokio::time::sleep(std::time::Duration::from_millis(1000)).await;\n        }\n    }\n\n    println!(\"\\nğŸ“Š Final Summary:\");\n    println!(\"  Successful deletions: {successful_deletions}\");\n    println!(\"  Failed deletions: {failed_deletions}\");\n\n    if successful_deletions \u003e 0 {\n        println!(\"\\nâœ… Deletion session completed!\");\n    } else if failed_deletions \u003e 0 {\n        println!(\"\\nâŒ All deletions failed!\");\n    }\n\n    Ok(())\n}\n","traces":[{"line":5,"address":[3564672],"length":1,"stats":{"Line":0}},{"line":10,"address":[3172590,3173222,3172408],"length":1,"stats":{"Line":0}},{"line":12,"address":[3172732],"length":1,"stats":{"Line":0}},{"line":13,"address":[3172879],"length":1,"stats":{"Line":0}},{"line":14,"address":[3172967],"length":1,"stats":{"Line":0}},{"line":17,"address":[3172896],"length":1,"stats":{"Line":0}},{"line":18,"address":[3172912],"length":1,"stats":{"Line":0}},{"line":19,"address":[3172930],"length":1,"stats":{"Line":0}},{"line":20,"address":[3172948],"length":1,"stats":{"Line":0}},{"line":23,"address":[3173105,3174437,3173014],"length":1,"stats":{"Line":0}},{"line":24,"address":[3174574,3174511],"length":1,"stats":{"Line":0}},{"line":26,"address":[3172469,3173368,3173334,3174643],"length":1,"stats":{"Line":0}},{"line":27,"address":[3173683],"length":1,"stats":{"Line":0}},{"line":28,"address":[3173723,3173797],"length":1,"stats":{"Line":0}},{"line":29,"address":[3173830,3175497],"length":1,"stats":{"Line":0}},{"line":33,"address":[3173803,3173875],"length":1,"stats":{"Line":0}},{"line":34,"address":[3174178,3174029],"length":1,"stats":{"Line":0}},{"line":36,"address":[3174198,3174111,3174333],"length":1,"stats":{"Line":0}},{"line":37,"address":[3174387,3174833],"length":1,"stats":{"Line":0}},{"line":38,"address":[3175046,3174849],"length":1,"stats":{"Line":0}},{"line":39,"address":[3174869],"length":1,"stats":{"Line":0}},{"line":40,"address":[3174970],"length":1,"stats":{"Line":0}},{"line":44,"address":[3175148],"length":1,"stats":{"Line":0}},{"line":45,"address":[3175187],"length":1,"stats":{"Line":0}},{"line":51,"address":[3174896,3175380],"length":1,"stats":{"Line":0}},{"line":58,"address":[3173614],"length":1,"stats":{"Line":0}},{"line":59,"address":[3173646,3175696],"length":1,"stats":{"Line":0}},{"line":65,"address":[3174545,3175837],"length":1,"stats":{"Line":0}},{"line":66,"address":[3176555,3175869],"length":1,"stats":{"Line":0}},{"line":67,"address":[3176574],"length":1,"stats":{"Line":0}},{"line":70,"address":[3175898,3175843],"length":1,"stats":{"Line":0}},{"line":71,"address":[3175917],"length":1,"stats":{"Line":0}},{"line":72,"address":[3176017],"length":1,"stats":{"Line":0}},{"line":74,"address":[3176156],"length":1,"stats":{"Line":0}},{"line":75,"address":[3176457,3176199],"length":1,"stats":{"Line":0}},{"line":76,"address":[3176476],"length":1,"stats":{"Line":0}},{"line":77,"address":[3176521],"length":1,"stats":{"Line":0}},{"line":81,"address":[3176228,3176173],"length":1,"stats":{"Line":0}},{"line":83,"address":[3176419,3176247,3176855],"length":1,"stats":{"Line":0}},{"line":84,"address":[3177491,3176998,3177456],"length":1,"stats":{"Line":0}},{"line":92,"address":[3177761,3172490,3176588,3178320,3177974],"length":1,"stats":{"Line":0}},{"line":94,"address":[3178359,3178518,3178558],"length":1,"stats":{"Line":0}},{"line":95,"address":[3178579,3178532],"length":1,"stats":{"Line":0}},{"line":98,"address":[3178436,3178396,3178330],"length":1,"stats":{"Line":0}},{"line":99,"address":[3178410,3178457],"length":1,"stats":{"Line":0}},{"line":101,"address":[3178220],"length":1,"stats":{"Line":0}},{"line":102,"address":[3178645,3178284,3178604],"length":1,"stats":{"Line":0}},{"line":103,"address":[3178710,3178618],"length":1,"stats":{"Line":0}},{"line":108,"address":[3178806,3178478],"length":1,"stats":{"Line":0}},{"line":109,"address":[3176659,3176625,3178870,3172511],"length":1,"stats":{"Line":0}},{"line":113,"address":[3177036],"length":1,"stats":{"Line":0}},{"line":114,"address":[3177081],"length":1,"stats":{"Line":0}},{"line":115,"address":[3177181],"length":1,"stats":{"Line":0}},{"line":117,"address":[3177284],"length":1,"stats":{"Line":0}},{"line":118,"address":[3177427,3177320],"length":1,"stats":{"Line":0}},{"line":119,"address":[3177301],"length":1,"stats":{"Line":0}},{"line":120,"address":[3177380],"length":1,"stats":{"Line":0}},{"line":123,"address":[3177346],"length":1,"stats":{"Line":0}},{"line":127,"address":[3564768],"length":1,"stats":{"Line":0}},{"line":132,"address":[3180014,3179235,3179417],"length":1,"stats":{"Line":0}},{"line":134,"address":[3179559],"length":1,"stats":{"Line":0}},{"line":135,"address":[3179706],"length":1,"stats":{"Line":0}},{"line":136,"address":[3179772],"length":1,"stats":{"Line":0}},{"line":139,"address":[3179723],"length":1,"stats":{"Line":0}},{"line":140,"address":[3179738],"length":1,"stats":{"Line":0}},{"line":141,"address":[3179753],"length":1,"stats":{"Line":0}},{"line":144,"address":[3179084],"length":1,"stats":{"Line":0}},{"line":146,"address":[3179892,3179819,3181083,3181226],"length":1,"stats":{"Line":0}},{"line":147,"address":[3181276,3181339],"length":1,"stats":{"Line":0}},{"line":149,"address":[3180160,3179296,3180126,3181408],"length":1,"stats":{"Line":0}},{"line":150,"address":[3180475],"length":1,"stats":{"Line":0}},{"line":151,"address":[3180515,3180589],"length":1,"stats":{"Line":0}},{"line":152,"address":[3180673,3182130],"length":1,"stats":{"Line":0}},{"line":156,"address":[3180595],"length":1,"stats":{"Line":0}},{"line":157,"address":[3180702,3180606,3180837],"length":1,"stats":{"Line":0}},{"line":158,"address":[3180891,3181510],"length":1,"stats":{"Line":0}},{"line":159,"address":[3181526,3181570],"length":1,"stats":{"Line":0}},{"line":160,"address":[3181674,3181592],"length":1,"stats":{"Line":0}},{"line":161,"address":[3181627,3181814],"length":1,"stats":{"Line":0}},{"line":162,"address":[3181647],"length":1,"stats":{"Line":0}},{"line":163,"address":[3181738],"length":1,"stats":{"Line":0}},{"line":167,"address":[3181916],"length":1,"stats":{"Line":0}},{"line":168,"address":[3181937],"length":1,"stats":{"Line":0}},{"line":177,"address":[3180933],"length":1,"stats":{"Line":0}},{"line":178,"address":[3180977,3181088],"length":1,"stats":{"Line":0}},{"line":180,"address":[3181004,3180943],"length":1,"stats":{"Line":0}},{"line":183,"address":[3180406],"length":1,"stats":{"Line":0}},{"line":184,"address":[3182279,3180438],"length":1,"stats":{"Line":0}},{"line":190,"address":[3181310,3182420],"length":1,"stats":{"Line":0}},{"line":191,"address":[3183038,3182452],"length":1,"stats":{"Line":0}},{"line":192,"address":[3183057],"length":1,"stats":{"Line":0}},{"line":195,"address":[3182481,3182426],"length":1,"stats":{"Line":0}},{"line":196,"address":[3182543],"length":1,"stats":{"Line":0}},{"line":201,"address":[3182639],"length":1,"stats":{"Line":0}},{"line":202,"address":[3182940,3182682],"length":1,"stats":{"Line":0}},{"line":203,"address":[3182959],"length":1,"stats":{"Line":0}},{"line":204,"address":[3183004],"length":1,"stats":{"Line":0}},{"line":208,"address":[3182656,3182711],"length":1,"stats":{"Line":0}},{"line":210,"address":[3183338,3182730,3182902],"length":1,"stats":{"Line":0}},{"line":211,"address":[3183986],"length":1,"stats":{"Line":0}},{"line":219,"address":[3184448,3183071,3179317,3184791,3184235],"length":1,"stats":{"Line":0}},{"line":221,"address":[3185017,3184827,3184980],"length":1,"stats":{"Line":0}},{"line":222,"address":[3184991,3185038],"length":1,"stats":{"Line":0}},{"line":225,"address":[3184861,3184801,3184898],"length":1,"stats":{"Line":0}},{"line":226,"address":[3184919,3184872],"length":1,"stats":{"Line":0}},{"line":228,"address":[3184694],"length":1,"stats":{"Line":0}},{"line":229,"address":[3185101,3184758,3185063],"length":1,"stats":{"Line":0}},{"line":230,"address":[3185074,3185166],"length":1,"stats":{"Line":0}},{"line":235,"address":[3185262,3184940],"length":1,"stats":{"Line":0}},{"line":236,"address":[3183142,3185326,3179338,3183108],"length":1,"stats":{"Line":0}},{"line":240,"address":[3183519],"length":1,"stats":{"Line":0}},{"line":241,"address":[3183564],"length":1,"stats":{"Line":0}},{"line":242,"address":[3183664],"length":1,"stats":{"Line":0}},{"line":244,"address":[3183764],"length":1,"stats":{"Line":0}},{"line":245,"address":[3183901,3183794],"length":1,"stats":{"Line":0}},{"line":246,"address":[3183778],"length":1,"stats":{"Line":0}},{"line":247,"address":[3183854],"length":1,"stats":{"Line":0}},{"line":250,"address":[3183820],"length":1,"stats":{"Line":0}},{"line":254,"address":[3564864],"length":1,"stats":{"Line":0}},{"line":259,"address":[3186636,3185692,3185874],"length":1,"stats":{"Line":0}},{"line":262,"address":[3186016],"length":1,"stats":{"Line":0}},{"line":263,"address":[3186032],"length":1,"stats":{"Line":0}},{"line":265,"address":[3186048],"length":1,"stats":{"Line":0}},{"line":266,"address":[3186226],"length":1,"stats":{"Line":0}},{"line":267,"address":[3186266],"length":1,"stats":{"Line":0}},{"line":270,"address":[3186243],"length":1,"stats":{"Line":0}},{"line":271,"address":[3186313],"length":1,"stats":{"Line":0}},{"line":272,"address":[3186331],"length":1,"stats":{"Line":0}},{"line":275,"address":[3186349],"length":1,"stats":{"Line":0}},{"line":276,"address":[3186447,3186367],"length":1,"stats":{"Line":0}},{"line":278,"address":[3186515,3186416],"length":1,"stats":{"Line":0}},{"line":280,"address":[3187899,3187867,3186586],"length":1,"stats":{"Line":0}},{"line":281,"address":[3186748,3185753,3186782,3187947],"length":1,"stats":{"Line":0}},{"line":282,"address":[3187097],"length":1,"stats":{"Line":0}},{"line":283,"address":[3187211,3187137],"length":1,"stats":{"Line":0}},{"line":284,"address":[3188136,3187244],"length":1,"stats":{"Line":0}},{"line":288,"address":[3187289,3187217],"length":1,"stats":{"Line":0}},{"line":293,"address":[3187660],"length":1,"stats":{"Line":0}},{"line":294,"address":[3187816,3187734],"length":1,"stats":{"Line":0}},{"line":297,"address":[3187785,3187845],"length":1,"stats":{"Line":0}},{"line":301,"address":[3187028],"length":1,"stats":{"Line":0}},{"line":302,"address":[3187060,3188346],"length":1,"stats":{"Line":0}},{"line":308,"address":[3187913,3188488],"length":1,"stats":{"Line":0}},{"line":309,"address":[3188545,3190575],"length":1,"stats":{"Line":0}},{"line":310,"address":[3190726],"length":1,"stats":{"Line":0}},{"line":314,"address":[3188587,3188502],"length":1,"stats":{"Line":0}},{"line":315,"address":[3188680],"length":1,"stats":{"Line":0}},{"line":317,"address":[3188803],"length":1,"stats":{"Line":0}},{"line":318,"address":[3188848],"length":1,"stats":{"Line":0}},{"line":322,"address":[3189171],"length":1,"stats":{"Line":0}},{"line":329,"address":[3189319],"length":1,"stats":{"Line":0}},{"line":330,"address":[3189592,3189362],"length":1,"stats":{"Line":0}},{"line":331,"address":[3189611],"length":1,"stats":{"Line":0}},{"line":332,"address":[3189893,3190090,3190071],"length":1,"stats":{"Line":0}},{"line":333,"address":[3190119,3190079],"length":1,"stats":{"Line":0}},{"line":334,"address":[3190196,3190131],"length":1,"stats":{"Line":0}},{"line":339,"address":[3190158,3190407],"length":1,"stats":{"Line":0}},{"line":346,"address":[3189927],"length":1,"stats":{"Line":0}},{"line":347,"address":[3189972],"length":1,"stats":{"Line":0}},{"line":348,"address":[3190017],"length":1,"stats":{"Line":0}},{"line":352,"address":[3189391,3189336],"length":1,"stats":{"Line":0}},{"line":354,"address":[3191010,3189410,3189550],"length":1,"stats":{"Line":0}},{"line":355,"address":[3191104,3191588,3191614],"length":1,"stats":{"Line":0}},{"line":357,"address":[3191643,3191603],"length":1,"stats":{"Line":0}},{"line":358,"address":[3191800],"length":1,"stats":{"Line":0}},{"line":367,"address":[3192084,3192512,3192256,3192454,3192204,3192640],"length":1,"stats":{"Line":0}},{"line":368,"address":[3192101],"length":1,"stats":{"Line":0}},{"line":369,"address":[3192486,3185774,3192289,3190743,3192294,3192229],"length":1,"stats":{"Line":0}},{"line":372,"address":[3192679,3192904,3192864],"length":1,"stats":{"Line":0}},{"line":373,"address":[3192878,3192925],"length":1,"stats":{"Line":0}},{"line":376,"address":[3192650,3192719,3192759],"length":1,"stats":{"Line":0}},{"line":377,"address":[3192780,3192733],"length":1,"stats":{"Line":0}},{"line":379,"address":[3192540],"length":1,"stats":{"Line":0}},{"line":380,"address":[3192953,3192994,3192604],"length":1,"stats":{"Line":0}},{"line":381,"address":[3193059,3192967],"length":1,"stats":{"Line":0}},{"line":385,"address":[3193202,3193157,3191697],"length":1,"stats":{"Line":0}},{"line":386,"address":[3193304,3193236],"length":1,"stats":{"Line":0}},{"line":397,"address":[3192801,3193575],"length":1,"stats":{"Line":0}},{"line":398,"address":[3190814,3190780,3193611,3185795],"length":1,"stats":{"Line":0}},{"line":402,"address":[3191153],"length":1,"stats":{"Line":0}},{"line":403,"address":[3191198],"length":1,"stats":{"Line":0}},{"line":404,"address":[3191301],"length":1,"stats":{"Line":0}},{"line":406,"address":[3191404],"length":1,"stats":{"Line":0}},{"line":407,"address":[3191440,3191551],"length":1,"stats":{"Line":0}},{"line":408,"address":[3191421],"length":1,"stats":{"Line":0}},{"line":409,"address":[3191504],"length":1,"stats":{"Line":0}},{"line":412,"address":[3191466],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":187},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","commands","edit.rs"],"content":"use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, ScrobbleEdit};\n\n/// Create a ScrobbleEdit from command line arguments\n#[allow(clippy::too_many_arguments)]\npub fn create_scrobble_edit_from_args(\n    artist: \u0026str,\n    track: Option\u003c\u0026str\u003e,\n    album: Option\u003c\u0026str\u003e,\n    album_artist: Option\u003c\u0026str\u003e,\n    new_track: Option\u003c\u0026str\u003e,\n    new_album: Option\u003c\u0026str\u003e,\n    new_artist: Option\u003c\u0026str\u003e,\n    new_album_artist: Option\u003c\u0026str\u003e,\n    timestamp: Option\u003cu64\u003e,\n    edit_all: bool,\n) -\u003e ScrobbleEdit {\n    // Determine the new artist name (use provided new_artist or original artist)\n    let new_artist = new_artist.unwrap_or(artist);\n\n    ScrobbleEdit::new(\n        track.map(|s| s.to_string()),\n        album.map(|s| s.to_string()),\n        artist.to_string(),\n        album_artist.map(|s| s.to_string()),\n        new_track.map(|s| s.to_string()),\n        new_album.map(|s| s.to_string()),\n        new_artist.to_string(),\n        new_album_artist.map(|s| s.to_string()),\n        timestamp,\n        edit_all,\n    )\n}\n\n/// Handle the edit command\npub async fn handle_edit_command(\n    client: \u0026LastFmEditClientImpl,\n    edit: \u0026ScrobbleEdit,\n    dry_run: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Show the ScrobbleEdit that will be sent\n    println!(\"\\nğŸ“¦ ScrobbleEdit to be sent:\");\n    println!(\"{edit:#?}\");\n\n    // Discover and apply/show variations\n    discover_and_handle_edits(client, edit, dry_run).await\n}\n\nasync fn discover_and_handle_edits(\n    client: \u0026LastFmEditClientImpl,\n    edit: \u0026ScrobbleEdit,\n    dry_run: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    println!(\"\\nğŸ” Discovering scrobble edit variations...\");\n\n    // Use the discovery iterator for incremental results\n    let mut discovery_iterator = client.discover_scrobbles(edit.clone());\n    let mut discovered_edits = Vec::new();\n    let mut edit_results = Vec::new();\n    let mut count = 0;\n    let mut successful_edits = 0;\n    let mut failed_edits = 0;\n\n    // Process results incrementally\n    while let Some(discovered_edit) = discovery_iterator.next().await? {\n        count += 1;\n        println!(\"\\n  {count}. Found scrobble:\");\n        println!(\"     Track: '{}'\", discovered_edit.track_name_original);\n        println!(\"     Album: '{}'\", discovered_edit.album_name_original);\n        println!(\"     Artist: '{}'\", discovered_edit.artist_name_original);\n        println!(\n            \"     Album Artist: '{}'\",\n            discovered_edit.album_artist_name_original\n        );\n        println!(\"     Timestamp: {}\", discovered_edit.timestamp);\n\n        // Show what this would change to\n        println!(\"     Would change to:\");\n        println!(\"       Track: '{}'\", discovered_edit.track_name);\n        println!(\"       Album: '{}'\", discovered_edit.album_name);\n        println!(\"       Artist: '{}'\", discovered_edit.artist_name);\n        println!(\n            \"       Album Artist: '{}'\",\n            discovered_edit.album_artist_name\n        );\n\n        if dry_run {\n            println!(\"     DRY RUN - proceeding without submitting edit\");\n            discovered_edits.push(discovered_edit);\n        } else {\n            // Apply edit immediately\n            println!(\"     ğŸ”„ Applying edit...\");\n\n            // Apply the user's changes to create the final exact edit\n            let mut final_edit = discovered_edit.clone();\n            if let Some(new_track_name) = \u0026edit.track_name {\n                final_edit.track_name = new_track_name.clone();\n            }\n            if let Some(new_album_name) = \u0026edit.album_name {\n                final_edit.album_name = new_album_name.clone();\n            }\n            final_edit.artist_name = edit.artist_name.clone();\n            if let Some(new_album_artist_name) = \u0026edit.album_artist_name {\n                final_edit.album_artist_name = new_album_artist_name.clone();\n            }\n            final_edit.edit_all = edit.edit_all;\n\n            match client.edit_scrobble_single(\u0026final_edit, 3).await {\n                Ok(response) =\u003e {\n                    if response.all_successful() {\n                        successful_edits += 1;\n                        println!(\"     âœ… Edit applied successfully!\");\n                    } else {\n                        failed_edits += 1;\n                        println!(\"     âŒ Edit failed: {}\", response.summary_message());\n                    }\n                    edit_results.push(response);\n                }\n                Err(e) =\u003e {\n                    failed_edits += 1;\n                    println!(\"     âŒ Error applying edit: {e}\");\n                }\n            }\n        }\n    }\n\n    if count == 0 {\n        println!(\"No matching scrobbles found. This might mean:\");\n        println!(\"  - The specified metadata is not in your recent scrobbles\");\n        println!(\"  - The names don't match exactly\");\n        println!(\"  - There's a network or parsing issue\");\n        return Ok(());\n    }\n\n    println!(\"\\nğŸ“Š Summary:\");\n    println!(\"  Total variations found: {count}\");\n\n    if dry_run {\n        // Group by unique original metadata combinations for dry run summary\n        let mut unique_tracks = std::collections::HashSet::new();\n        let mut unique_albums = std::collections::HashSet::new();\n\n        for edit in \u0026discovered_edits {\n            unique_tracks.insert(\u0026edit.track_name_original);\n            unique_albums.insert(\u0026edit.album_name_original);\n        }\n\n        println!(\"  Unique tracks: {}\", unique_tracks.len());\n        println!(\"  Unique albums: {}\", unique_albums.len());\n        println!(\"\\nğŸ” DRY RUN - No actual edits performed\");\n        println!(\"Use --apply to execute these edits\");\n    } else {\n        println!(\"  Successful edits: {successful_edits}\");\n        println!(\"  Failed edits: {failed_edits}\");\n\n        if successful_edits \u003e 0 {\n            println!(\"\\nâœ… Edit session completed!\");\n        } else if failed_edits \u003e 0 {\n            println!(\"\\nâŒ All edits failed!\");\n        }\n\n        if failed_edits \u003e 0 {\n            println!(\"\\nâš ï¸  Failed edit details:\");\n            for (i, response) in edit_results.iter().enumerate() {\n                if !response.all_successful() {\n                    println!(\"    {}: {}\", i + 1, response.summary_message());\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":5,"address":[3387616,3389028,3389144],"length":1,"stats":{"Line":0}},{"line":18,"address":[3388073],"length":1,"stats":{"Line":0}},{"line":21,"address":[3160598,3160576],"length":1,"stats":{"Line":0}},{"line":22,"address":[3160624,3160646],"length":1,"stats":{"Line":0}},{"line":23,"address":[3388315,3388382],"length":1,"stats":{"Line":0}},{"line":24,"address":[3160672,3160694],"length":1,"stats":{"Line":0}},{"line":25,"address":[3160720,3160742],"length":1,"stats":{"Line":0}},{"line":26,"address":[3160768,3160790],"length":1,"stats":{"Line":0}},{"line":27,"address":[3388609,3388676],"length":1,"stats":{"Line":0}},{"line":28,"address":[3160838,3160816],"length":1,"stats":{"Line":0}},{"line":35,"address":[3389184],"length":1,"stats":{"Line":0}},{"line":41,"address":[3161154,3161044],"length":1,"stats":{"Line":0}},{"line":42,"address":[3161170],"length":1,"stats":{"Line":0}},{"line":45,"address":[3161425,3161094,3161299],"length":1,"stats":{"Line":0}},{"line":48,"address":[3389248],"length":1,"stats":{"Line":0}},{"line":53,"address":[3161869,3162006],"length":1,"stats":{"Line":0}},{"line":56,"address":[3162025],"length":1,"stats":{"Line":0}},{"line":57,"address":[3162154],"length":1,"stats":{"Line":0}},{"line":58,"address":[3162221],"length":1,"stats":{"Line":0}},{"line":59,"address":[3162285],"length":1,"stats":{"Line":0}},{"line":60,"address":[3162300],"length":1,"stats":{"Line":0}},{"line":61,"address":[3162315],"length":1,"stats":{"Line":0}},{"line":64,"address":[3164006,3162398,3161925,3162330,3163942,3163815,3169397],"length":1,"stats":{"Line":0}},{"line":65,"address":[3164606,3164648,3164541],"length":1,"stats":{"Line":0}},{"line":66,"address":[3164617,3164669],"length":1,"stats":{"Line":0}},{"line":67,"address":[3164738],"length":1,"stats":{"Line":0}},{"line":68,"address":[3164841],"length":1,"stats":{"Line":0}},{"line":69,"address":[3164944],"length":1,"stats":{"Line":0}},{"line":70,"address":[3165047],"length":1,"stats":{"Line":0}},{"line":74,"address":[3165150],"length":1,"stats":{"Line":0}},{"line":77,"address":[3165253],"length":1,"stats":{"Line":0}},{"line":78,"address":[3165298],"length":1,"stats":{"Line":0}},{"line":79,"address":[3165401],"length":1,"stats":{"Line":0}},{"line":80,"address":[3165504],"length":1,"stats":{"Line":0}},{"line":81,"address":[3165607],"length":1,"stats":{"Line":0}},{"line":86,"address":[3165710],"length":1,"stats":{"Line":0}},{"line":87,"address":[3165750,3167062],"length":1,"stats":{"Line":0}},{"line":88,"address":[3167081],"length":1,"stats":{"Line":0}},{"line":91,"address":[3165724,3165779],"length":1,"stats":{"Line":0}},{"line":94,"address":[3165798],"length":1,"stats":{"Line":0}},{"line":95,"address":[3165830,3166214],"length":1,"stats":{"Line":0}},{"line":96,"address":[3166081,3165911,3166055],"length":1,"stats":{"Line":0}},{"line":98,"address":[3166451,3165930,3166227],"length":1,"stats":{"Line":0}},{"line":99,"address":[3166318,3166292,3166235],"length":1,"stats":{"Line":0}},{"line":101,"address":[3166456,3166482,3166254],"length":1,"stats":{"Line":0}},{"line":102,"address":[3166944,3166615],"length":1,"stats":{"Line":0}},{"line":103,"address":[3166696,3166811,3166785],"length":1,"stats":{"Line":0}},{"line":105,"address":[3166715],"length":1,"stats":{"Line":0}},{"line":107,"address":[3162463,3161946,3167000,3162432,3166739,3162723],"length":1,"stats":{"Line":0}},{"line":108,"address":[3162851],"length":1,"stats":{"Line":0}},{"line":109,"address":[3162965,3162891],"length":1,"stats":{"Line":0}},{"line":110,"address":[3163000,3163347,3163384],"length":1,"stats":{"Line":0}},{"line":111,"address":[3163358,3163405],"length":1,"stats":{"Line":0}},{"line":113,"address":[3163081,3163043,3162971],"length":1,"stats":{"Line":0}},{"line":114,"address":[3163054,3163101],"length":1,"stats":{"Line":0}},{"line":116,"address":[3163260],"length":1,"stats":{"Line":0}},{"line":118,"address":[3162751],"length":1,"stats":{"Line":0}},{"line":119,"address":[3162815,3163569,3163531],"length":1,"stats":{"Line":0}},{"line":120,"address":[3163631,3163542],"length":1,"stats":{"Line":0}},{"line":126,"address":[3167192],"length":1,"stats":{"Line":0}},{"line":127,"address":[3167261,3167206],"length":1,"stats":{"Line":0}},{"line":128,"address":[3167280],"length":1,"stats":{"Line":0}},{"line":129,"address":[3167325],"length":1,"stats":{"Line":0}},{"line":130,"address":[3167370],"length":1,"stats":{"Line":0}},{"line":131,"address":[3167415],"length":1,"stats":{"Line":0}},{"line":134,"address":[3167232,3167449],"length":1,"stats":{"Line":0}},{"line":135,"address":[3167468],"length":1,"stats":{"Line":0}},{"line":137,"address":[3167568],"length":1,"stats":{"Line":0}},{"line":139,"address":[3167621],"length":1,"stats":{"Line":0}},{"line":140,"address":[3168618],"length":1,"stats":{"Line":0}},{"line":142,"address":[3168665,3168741],"length":1,"stats":{"Line":0}},{"line":143,"address":[3168854],"length":1,"stats":{"Line":0}},{"line":144,"address":[3169357],"length":1,"stats":{"Line":0}},{"line":147,"address":[3168872],"length":1,"stats":{"Line":0}},{"line":148,"address":[3169001],"length":1,"stats":{"Line":0}},{"line":149,"address":[3169120],"length":1,"stats":{"Line":0}},{"line":150,"address":[3169165],"length":1,"stats":{"Line":0}},{"line":152,"address":[3167582,3167631],"length":1,"stats":{"Line":0}},{"line":153,"address":[3167700],"length":1,"stats":{"Line":0}},{"line":155,"address":[3167800],"length":1,"stats":{"Line":0}},{"line":156,"address":[3167830,3167919],"length":1,"stats":{"Line":0}},{"line":157,"address":[3167814],"length":1,"stats":{"Line":0}},{"line":158,"address":[3167872],"length":1,"stats":{"Line":0}},{"line":161,"address":[3167856],"length":1,"stats":{"Line":0}},{"line":162,"address":[3167974],"length":1,"stats":{"Line":0}},{"line":163,"address":[3168019],"length":1,"stats":{"Line":0}},{"line":164,"address":[3168299],"length":1,"stats":{"Line":0}},{"line":165,"address":[3168333],"length":1,"stats":{"Line":0}},{"line":171,"address":[3167940],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":89},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","commands","list.rs"],"content":"use super::list_output::{HumanReadableListHandler, JsonListHandler, ListEvent, ListOutputHandler};\nuse lastfm_edit::{LastFmEditClient, LastFmEditClientImpl};\n\n/// Handle the list artists command\npub async fn handle_list_artists(\n    client: \u0026LastFmEditClientImpl,\n    limit: usize,\n    verbose: bool,\n    format: bool,\n    json_output: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create appropriate handler based on output format\n    let mut handler: Box\u003cdyn ListOutputHandler\u003e = if json_output {\n        Box::new(JsonListHandler::new())\n    } else {\n        Box::new(HumanReadableListHandler::new(verbose, format))\n    };\n\n    // Emit start event\n    handler.handle_event(ListEvent::Started {\n        command: \"artists\".to_string(),\n        artist: None,\n        album: None,\n    });\n\n    let mut artists_iterator = client.artists();\n    let mut count = 0;\n\n    while let Some(artist) = artists_iterator.next().await? {\n        count += 1;\n\n        // Emit artist found event\n        handler.handle_event(ListEvent::ArtistFound {\n            index: count,\n            artist,\n        });\n\n        if limit \u003e 0 \u0026\u0026 count \u003e= limit {\n            break;\n        }\n    }\n\n    // Emit summary event\n    handler.handle_event(ListEvent::Summary {\n        command: \"artists\".to_string(),\n        total_items: count,\n        artist: None,\n        album: None,\n    });\n\n    Ok(())\n}\n\n/// Handle the list albums command\npub async fn handle_list_albums(\n    client: \u0026LastFmEditClientImpl,\n    artist: \u0026str,\n    limit: usize,\n    verbose: bool,\n    format: bool,\n    json_output: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create appropriate handler based on output format\n    let mut handler: Box\u003cdyn ListOutputHandler\u003e = if json_output {\n        Box::new(JsonListHandler::new())\n    } else {\n        Box::new(HumanReadableListHandler::new(verbose, format))\n    };\n\n    // Emit start event\n    handler.handle_event(ListEvent::Started {\n        command: \"albums\".to_string(),\n        artist: Some(artist.to_string()),\n        album: None,\n    });\n\n    let mut albums_iterator = client.artist_albums(artist);\n    let mut count = 0;\n\n    while let Some(album) = albums_iterator.next().await? {\n        count += 1;\n\n        // Emit album found event\n        handler.handle_event(ListEvent::AlbumFound {\n            index: count,\n            album,\n        });\n\n        if limit \u003e 0 \u0026\u0026 count \u003e= limit {\n            break;\n        }\n    }\n\n    // Emit summary event\n    handler.handle_event(ListEvent::Summary {\n        command: \"albums\".to_string(),\n        total_items: count,\n        artist: Some(artist.to_string()),\n        album: None,\n    });\n\n    Ok(())\n}\n\n/// Handle the list tracks by album command\npub async fn handle_list_tracks_by_album(\n    client: \u0026LastFmEditClientImpl,\n    artist: \u0026str,\n    limit: usize,\n    verbose: bool,\n    format: bool,\n    json_output: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create appropriate handler based on output format\n    let mut handler: Box\u003cdyn ListOutputHandler\u003e = if json_output {\n        Box::new(JsonListHandler::new())\n    } else {\n        Box::new(HumanReadableListHandler::new(verbose, format))\n    };\n\n    // Emit start event\n    handler.handle_event(ListEvent::Started {\n        command: \"tracks-by-album\".to_string(),\n        artist: Some(artist.to_string()),\n        album: None,\n    });\n\n    let mut albums_iterator = client.artist_albums(artist);\n    let mut album_count = 0;\n\n    while let Some(album) = albums_iterator.next().await? {\n        album_count += 1;\n\n        // Emit album section event\n        handler.handle_event(ListEvent::AlbumSection {\n            album_index: album_count,\n            album: album.clone(),\n        });\n\n        // Get tracks for this album\n        match client.get_album_tracks(\u0026album.name, artist).await {\n            Ok(tracks) =\u003e {\n                if tracks.is_empty() {\n                    handler.handle_event(ListEvent::Error {\n                        message: \"No tracks found in your library for this album\".to_string(),\n                    });\n                } else {\n                    for (track_idx, track) in tracks.iter().enumerate() {\n                        handler.handle_event(ListEvent::AlbumTrackFound {\n                            album_index: album_count,\n                            track_index: track_idx + 1,\n                            track: track.clone(),\n                        });\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                handler.handle_event(ListEvent::Error {\n                    message: format!(\"Error getting tracks: {e}\"),\n                });\n            }\n        }\n\n        if limit \u003e 0 \u0026\u0026 album_count \u003e= limit {\n            break;\n        }\n    }\n\n    // Emit summary event\n    handler.handle_event(ListEvent::Summary {\n        command: \"tracks-by-album\".to_string(),\n        total_items: album_count,\n        artist: Some(artist.to_string()),\n        album: None,\n    });\n\n    Ok(())\n}\n\n/// Handle the list tracks command\npub async fn handle_list_tracks(\n    client: \u0026LastFmEditClientImpl,\n    artist: \u0026str,\n    limit: usize,\n    verbose: bool,\n    format: bool,\n    json_output: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create appropriate handler based on output format\n    let mut handler: Box\u003cdyn ListOutputHandler\u003e = if json_output {\n        Box::new(JsonListHandler::new())\n    } else {\n        Box::new(HumanReadableListHandler::new(verbose, format))\n    };\n\n    // Emit start event\n    handler.handle_event(ListEvent::Started {\n        command: \"tracks\".to_string(),\n        artist: Some(artist.to_string()),\n        album: None,\n    });\n\n    let mut tracks_iterator = client.artist_tracks(artist);\n    let mut count = 0;\n\n    while let Some(track) = tracks_iterator.next().await? {\n        count += 1;\n\n        // Emit track found event\n        handler.handle_event(ListEvent::TrackFound {\n            index: count,\n            track,\n        });\n\n        if limit \u003e 0 \u0026\u0026 count \u003e= limit {\n            break;\n        }\n    }\n\n    // Emit summary event\n    handler.handle_event(ListEvent::Summary {\n        command: \"tracks\".to_string(),\n        total_items: count,\n        artist: Some(artist.to_string()),\n        album: None,\n    });\n\n    Ok(())\n}\n\n/// Handle the list tracks direct command\npub async fn handle_list_tracks_direct(\n    client: \u0026LastFmEditClientImpl,\n    artist: \u0026str,\n    limit: usize,\n    verbose: bool,\n    format: bool,\n    json_output: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create appropriate handler based on output format\n    let mut handler: Box\u003cdyn ListOutputHandler\u003e = if json_output {\n        Box::new(JsonListHandler::new())\n    } else {\n        Box::new(HumanReadableListHandler::new(verbose, format))\n    };\n\n    // Emit start event\n    handler.handle_event(ListEvent::Started {\n        command: \"tracks-direct\".to_string(),\n        artist: Some(artist.to_string()),\n        album: None,\n    });\n\n    let mut tracks_iterator = client.artist_tracks_direct(artist);\n    let mut count = 0;\n\n    while let Some(track) = tracks_iterator.next().await? {\n        count += 1;\n\n        // Emit track found event\n        handler.handle_event(ListEvent::TrackFound {\n            index: count,\n            track,\n        });\n\n        if limit \u003e 0 \u0026\u0026 count \u003e= limit {\n            break;\n        }\n    }\n\n    // Emit summary event\n    handler.handle_event(ListEvent::Summary {\n        command: \"tracks-direct\".to_string(),\n        total_items: count,\n        artist: Some(artist.to_string()),\n        album: None,\n    });\n\n    Ok(())\n}\n\n/// Handle the list album tracks command\npub async fn handle_list_album_tracks(\n    client: \u0026LastFmEditClientImpl,\n    album: \u0026str,\n    artist: \u0026str,\n    details: bool,\n    format: bool,\n    json_output: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create appropriate handler based on output format\n    let mut handler: Box\u003cdyn ListOutputHandler\u003e = if json_output {\n        Box::new(JsonListHandler::new())\n    } else {\n        Box::new(HumanReadableListHandler::new(details, format))\n    };\n\n    // Emit start event\n    handler.handle_event(ListEvent::Started {\n        command: \"album-tracks\".to_string(),\n        artist: Some(artist.to_string()),\n        album: Some(album.to_string()),\n    });\n\n    let mut tracks_iterator = client.album_tracks(album, artist);\n    let mut count = 0;\n\n    while let Some(track) = tracks_iterator.next().await? {\n        count += 1;\n\n        // Emit track found event\n        handler.handle_event(ListEvent::TrackFound {\n            index: count,\n            track,\n        });\n    }\n\n    // Emit summary event\n    handler.handle_event(ListEvent::Summary {\n        command: \"album-tracks\".to_string(),\n        total_items: count,\n        artist: Some(artist.to_string()),\n        album: Some(album.to_string()),\n    });\n\n    Ok(())\n}\n","traces":[{"line":5,"address":[3383760],"length":1,"stats":{"Line":0}},{"line":13,"address":[3565727,3565502,3565857],"length":1,"stats":{"Line":0}},{"line":14,"address":[3565817,3565598],"length":1,"stats":{"Line":0}},{"line":16,"address":[3565669,3565565],"length":1,"stats":{"Line":0}},{"line":20,"address":[3565758,3565941],"length":1,"stats":{"Line":0}},{"line":21,"address":[3565786],"length":1,"stats":{"Line":0}},{"line":22,"address":[3565925],"length":1,"stats":{"Line":0}},{"line":23,"address":[3565933],"length":1,"stats":{"Line":0}},{"line":26,"address":[3566073],"length":1,"stats":{"Line":0}},{"line":27,"address":[3566133],"length":1,"stats":{"Line":0}},{"line":29,"address":[3566497,3566240,3567672,3567088,3566212,3566149,3567142,3565538],"length":1,"stats":{"Line":0}},{"line":30,"address":[3566749,3566825,3566996],"length":1,"stats":{"Line":0}},{"line":33,"address":[3566837,3566912],"length":1,"stats":{"Line":0}},{"line":34,"address":[3566852],"length":1,"stats":{"Line":0}},{"line":35,"address":[3566856],"length":1,"stats":{"Line":0}},{"line":38,"address":[3567057,3567093],"length":1,"stats":{"Line":0}},{"line":44,"address":[3567250,3567417],"length":1,"stats":{"Line":0}},{"line":45,"address":[3567275],"length":1,"stats":{"Line":0}},{"line":46,"address":[3567379],"length":1,"stats":{"Line":0}},{"line":47,"address":[3567401],"length":1,"stats":{"Line":0}},{"line":48,"address":[3567409],"length":1,"stats":{"Line":0}},{"line":51,"address":[3567549],"length":1,"stats":{"Line":0}},{"line":55,"address":[3383872],"length":1,"stats":{"Line":0}},{"line":64,"address":[3568254,3568386,3568029],"length":1,"stats":{"Line":0}},{"line":65,"address":[3568346,3568125],"length":1,"stats":{"Line":0}},{"line":67,"address":[3568092,3568196],"length":1,"stats":{"Line":0}},{"line":71,"address":[3568286,3568573],"length":1,"stats":{"Line":0}},{"line":72,"address":[3568315],"length":1,"stats":{"Line":0}},{"line":73,"address":[3568523,3568435],"length":1,"stats":{"Line":0}},{"line":74,"address":[3568565],"length":1,"stats":{"Line":0}},{"line":77,"address":[3568705],"length":1,"stats":{"Line":0}},{"line":78,"address":[3568772],"length":1,"stats":{"Line":0}},{"line":80,"address":[3568065,3569884,3569174,3570512,3569830,3568788,3568857,3568885],"length":1,"stats":{"Line":0}},{"line":81,"address":[3569502,3569738,3569426],"length":1,"stats":{"Line":0}},{"line":84,"address":[3569514,3569622],"length":1,"stats":{"Line":0}},{"line":85,"address":[3569530],"length":1,"stats":{"Line":0}},{"line":86,"address":[3569534],"length":1,"stats":{"Line":0}},{"line":89,"address":[3569835,3569799],"length":1,"stats":{"Line":0}},{"line":95,"address":[3570253,3569986],"length":1,"stats":{"Line":0}},{"line":96,"address":[3570012],"length":1,"stats":{"Line":0}},{"line":97,"address":[3570106],"length":1,"stats":{"Line":0}},{"line":98,"address":[3570203,3570122],"length":1,"stats":{"Line":0}},{"line":99,"address":[3570245],"length":1,"stats":{"Line":0}},{"line":102,"address":[3570385],"length":1,"stats":{"Line":0}},{"line":106,"address":[3384000],"length":1,"stats":{"Line":0}},{"line":115,"address":[3571256,3571115,3570869],"length":1,"stats":{"Line":0}},{"line":116,"address":[3571210,3570986],"length":1,"stats":{"Line":0}},{"line":118,"address":[3571057,3570953],"length":1,"stats":{"Line":0}},{"line":122,"address":[3571147,3571446],"length":1,"stats":{"Line":0}},{"line":123,"address":[3571179],"length":1,"stats":{"Line":0}},{"line":124,"address":[3571396,3571305],"length":1,"stats":{"Line":0}},{"line":125,"address":[3571438],"length":1,"stats":{"Line":0}},{"line":128,"address":[3571570],"length":1,"stats":{"Line":0}},{"line":129,"address":[3571659],"length":1,"stats":{"Line":0}},{"line":131,"address":[3573517,3570905,3571750,3573602,3574630,3571675],"length":1,"stats":{"Line":0}},{"line":132,"address":[3574305,3574160,3574236],"length":1,"stats":{"Line":0}},{"line":135,"address":[3574248,3574341],"length":1,"stats":{"Line":0}},{"line":136,"address":[3574274],"length":1,"stats":{"Line":0}},{"line":137,"address":[3574283],"length":1,"stats":{"Line":0}},{"line":141,"address":[3616066],"length":1,"stats":{"Line":0}},{"line":142,"address":[3572206],"length":1,"stats":{"Line":0}},{"line":143,"address":[3572238,3572315],"length":1,"stats":{"Line":0}},{"line":144,"address":[3572356,3573054],"length":1,"stats":{"Line":0}},{"line":145,"address":[3572388],"length":1,"stats":{"Line":0}},{"line":148,"address":[3572321,3572438],"length":1,"stats":{"Line":0}},{"line":149,"address":[3572705,3572873],"length":1,"stats":{"Line":0}},{"line":150,"address":[3572737],"length":1,"stats":{"Line":0}},{"line":151,"address":[3572757,3572821],"length":1,"stats":{"Line":0}},{"line":152,"address":[3572814],"length":1,"stats":{"Line":0}},{"line":157,"address":[3572112],"length":1,"stats":{"Line":0}},{"line":158,"address":[3573303,3572144],"length":1,"stats":{"Line":0}},{"line":159,"address":[3572176,3573187],"length":1,"stats":{"Line":0}},{"line":164,"address":[3573119,3573411],"length":1,"stats":{"Line":0}},{"line":170,"address":[3575062,3574789],"length":1,"stats":{"Line":0}},{"line":171,"address":[3574815],"length":1,"stats":{"Line":0}},{"line":172,"address":[3574913],"length":1,"stats":{"Line":0}},{"line":173,"address":[3574930,3575012],"length":1,"stats":{"Line":0}},{"line":174,"address":[3575054],"length":1,"stats":{"Line":0}},{"line":177,"address":[3575194],"length":1,"stats":{"Line":0}},{"line":181,"address":[3384128],"length":1,"stats":{"Line":0}},{"line":190,"address":[3575533,3575890,3575758],"length":1,"stats":{"Line":0}},{"line":191,"address":[3575850,3575629],"length":1,"stats":{"Line":0}},{"line":193,"address":[3575596,3575700],"length":1,"stats":{"Line":0}},{"line":197,"address":[3576077,3575790],"length":1,"stats":{"Line":0}},{"line":198,"address":[3575819],"length":1,"stats":{"Line":0}},{"line":199,"address":[3576027,3575939],"length":1,"stats":{"Line":0}},{"line":200,"address":[3576069],"length":1,"stats":{"Line":0}},{"line":203,"address":[3576209],"length":1,"stats":{"Line":0}},{"line":204,"address":[3576276],"length":1,"stats":{"Line":0}},{"line":206,"address":[3576292,3578168,3577478,3576389,3577532,3576726,3575569,3576361],"length":1,"stats":{"Line":0}},{"line":207,"address":[3577386,3576978,3577054],"length":1,"stats":{"Line":0}},{"line":210,"address":[3577066,3577222],"length":1,"stats":{"Line":0}},{"line":211,"address":[3577082],"length":1,"stats":{"Line":0}},{"line":212,"address":[3577086],"length":1,"stats":{"Line":0}},{"line":215,"address":[3577447,3577483],"length":1,"stats":{"Line":0}},{"line":221,"address":[3577634,3577905],"length":1,"stats":{"Line":0}},{"line":222,"address":[3577660],"length":1,"stats":{"Line":0}},{"line":223,"address":[3577758],"length":1,"stats":{"Line":0}},{"line":224,"address":[3577774,3577855],"length":1,"stats":{"Line":0}},{"line":225,"address":[3577897],"length":1,"stats":{"Line":0}},{"line":228,"address":[3578037],"length":1,"stats":{"Line":0}},{"line":232,"address":[3384256],"length":1,"stats":{"Line":0}},{"line":241,"address":[3578525,3578882,3578750],"length":1,"stats":{"Line":0}},{"line":242,"address":[3578842,3578621],"length":1,"stats":{"Line":0}},{"line":244,"address":[3578692,3578588],"length":1,"stats":{"Line":0}},{"line":248,"address":[3578782,3579069],"length":1,"stats":{"Line":0}},{"line":249,"address":[3578811],"length":1,"stats":{"Line":0}},{"line":250,"address":[3579019,3578931],"length":1,"stats":{"Line":0}},{"line":251,"address":[3579061],"length":1,"stats":{"Line":0}},{"line":254,"address":[3579201],"length":1,"stats":{"Line":0}},{"line":255,"address":[3579268],"length":1,"stats":{"Line":0}},{"line":257,"address":[3615764],"length":1,"stats":{"Line":0}},{"line":258,"address":[3580046,3580378,3579970],"length":1,"stats":{"Line":0}},{"line":261,"address":[3580058,3580214],"length":1,"stats":{"Line":0}},{"line":262,"address":[3580074],"length":1,"stats":{"Line":0}},{"line":263,"address":[3580078],"length":1,"stats":{"Line":0}},{"line":266,"address":[3580475,3580439],"length":1,"stats":{"Line":0}},{"line":272,"address":[3580897,3580626],"length":1,"stats":{"Line":0}},{"line":273,"address":[3580652],"length":1,"stats":{"Line":0}},{"line":274,"address":[3580750],"length":1,"stats":{"Line":0}},{"line":275,"address":[3580847,3580766],"length":1,"stats":{"Line":0}},{"line":276,"address":[3580889],"length":1,"stats":{"Line":0}},{"line":279,"address":[3581029],"length":1,"stats":{"Line":0}},{"line":283,"address":[3384384],"length":1,"stats":{"Line":0}},{"line":292,"address":[3581889,3581529,3581757],"length":1,"stats":{"Line":0}},{"line":293,"address":[3581625,3581849],"length":1,"stats":{"Line":0}},{"line":295,"address":[3581699,3581592],"length":1,"stats":{"Line":0}},{"line":299,"address":[3581789,3582166],"length":1,"stats":{"Line":0}},{"line":300,"address":[3581818],"length":1,"stats":{"Line":0}},{"line":301,"address":[3581938,3582014],"length":1,"stats":{"Line":0}},{"line":302,"address":[3582046,3582134],"length":1,"stats":{"Line":0}},{"line":305,"address":[3582298],"length":1,"stats":{"Line":0}},{"line":306,"address":[3582373],"length":1,"stats":{"Line":0}},{"line":308,"address":[3583530,3584195,3582486,3581565,3582458,3582389,3582839],"length":1,"stats":{"Line":0}},{"line":309,"address":[3583075,3583136,3583468],"length":1,"stats":{"Line":0}},{"line":312,"address":[3583148,3583304],"length":1,"stats":{"Line":0}},{"line":313,"address":[3583164],"length":1,"stats":{"Line":0}},{"line":314,"address":[3583168],"length":1,"stats":{"Line":0}},{"line":319,"address":[3583929,3583629],"length":1,"stats":{"Line":0}},{"line":320,"address":[3583655],"length":1,"stats":{"Line":0}},{"line":321,"address":[3583686],"length":1,"stats":{"Line":0}},{"line":322,"address":[3583773,3583702],"length":1,"stats":{"Line":0}},{"line":323,"address":[3583897,3583805],"length":1,"stats":{"Line":0}},{"line":326,"address":[3584061],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":144},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","commands","list_output.rs"],"content":"use lastfm_edit::{Album, Artist, Track};\nuse serde::{Deserialize, Serialize};\n\n/// Events emitted by list commands\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(tag = \"type\")]\npub enum ListEvent {\n    /// Starting to list items\n    Started {\n        command: String,\n        artist: Option\u003cString\u003e,\n        album: Option\u003cString\u003e,\n    },\n    /// Found an artist\n    ArtistFound { index: usize, artist: Artist },\n    /// Found an album\n    AlbumFound { index: usize, album: Album },\n    /// Found a track\n    TrackFound { index: usize, track: Track },\n    /// Starting a new album section (for tracks-by-album)\n    AlbumSection { album_index: usize, album: Album },\n    /// Found a track within an album section\n    AlbumTrackFound {\n        album_index: usize,\n        track_index: usize,\n        track: Track,\n    },\n    /// Command completed with summary\n    Summary {\n        command: String,\n        total_items: usize,\n        artist: Option\u003cString\u003e,\n        album: Option\u003cString\u003e,\n    },\n    /// Error occurred\n    Error { message: String },\n}\n\n/// Trait for handling list command output\npub trait ListOutputHandler {\n    fn handle_event(\u0026mut self, event: ListEvent);\n}\n\n/// Human-readable output handler for list commands\npub struct HumanReadableListHandler {\n    verbose: bool,\n    format: bool,\n}\n\nimpl HumanReadableListHandler {\n    pub fn new(verbose: bool, format: bool) -\u003e Self {\n        Self { verbose, format }\n    }\n}\n\nimpl ListOutputHandler for HumanReadableListHandler {\n    fn handle_event(\u0026mut self, event: ListEvent) {\n        match event {\n            ListEvent::Started {\n                command,\n                artist,\n                album,\n            } =\u003e match command.as_str() {\n                \"artists\" =\u003e println!(\"ğŸµ Listing artists in your library\"),\n                \"albums\" =\u003e {\n                    if let Some(artist) = artist {\n                        println!(\"ğŸµ Listing albums for artist: '{artist}'\");\n                    }\n                }\n                \"tracks\" =\u003e {\n                    if let Some(artist) = artist {\n                        println!(\"ğŸµ Listing tracks for artist: '{artist}'\");\n                        println!(\"   (with complete album information)\");\n                    }\n                }\n                \"tracks-by-album\" =\u003e {\n                    if let Some(artist) = artist {\n                        println!(\"ğŸµ Listing tracks by album for artist: '{artist}'\");\n                    }\n                }\n                \"album-tracks\" =\u003e {\n                    if let (Some(album), Some(artist)) = (album, artist) {\n                        println!(\"ğŸµ Listing tracks for album: '{album}' by '{artist}'\");\n                    }\n                }\n                _ =\u003e {}\n            },\n            ListEvent::ArtistFound { index, artist } =\u003e {\n                if self.format {\n                    if self.verbose {\n                        println!(\"  [{index:3}] {artist} ({} plays)\", artist.playcount);\n                    } else {\n                        println!(\"  [{index:3}] {artist}\");\n                    }\n                } else if self.verbose {\n                    println!(\"  [{index:3}] {} ({} plays)\", artist.name, artist.playcount);\n                } else {\n                    println!(\"  [{index:3}] {}\", artist.name);\n                }\n            }\n            ListEvent::AlbumFound { index, album } =\u003e {\n                if self.format {\n                    if self.verbose {\n                        println!(\"  [{index:3}] {album} ({} plays)\", album.playcount);\n                    } else {\n                        println!(\"  [{index:3}] {album}\");\n                    }\n                } else if self.verbose {\n                    println!(\"  [{index:3}] {} ({} plays)\", album.name, album.playcount);\n                } else {\n                    println!(\"  [{index:3}] {}\", album.name);\n                }\n            }\n            ListEvent::TrackFound { index, track } =\u003e {\n                if self.format {\n                    if self.verbose {\n                        let album_artist_info = track\n                            .album_artist\n                            .as_deref()\n                            .unwrap_or(\"Same as track artist\");\n                        println!(\"  [{index:3}] {track} ({} plays)\", track.playcount);\n                        println!(\"       Album Artist: {album_artist_info}\");\n                        if let Some(timestamp) = track.timestamp {\n                            println!(\"       Last Played: {timestamp}\");\n                        }\n                    } else {\n                        println!(\"  [{index:3}] {track}\");\n                    }\n                } else if self.verbose {\n                    let album_info = track.album.as_deref().unwrap_or(\"Unknown Album\");\n                    let album_artist_info = track\n                        .album_artist\n                        .as_deref()\n                        .unwrap_or(\"Same as track artist\");\n                    println!(\"  [{index:3}] {} ({} plays)\", track.name, track.playcount);\n                    println!(\"       Album: {album_info}\");\n                    println!(\"       Album Artist: {album_artist_info}\");\n                    if let Some(timestamp) = track.timestamp {\n                        println!(\"       Last Played: {timestamp}\");\n                    }\n                } else {\n                    let album_info = track.album.as_deref().unwrap_or(\"Unknown Album\");\n                    println!(\"  [{index:3}] {} [{}]\", track.name, album_info);\n                }\n\n                if self.verbose {\n                    println!();\n                }\n            }\n            ListEvent::AlbumSection { album_index, album } =\u003e {\n                if self.verbose {\n                    println!(\n                        \"\\nğŸ“€ Album {}: {} ({} plays)\",\n                        album_index, album.name, album.playcount\n                    );\n                } else {\n                    println!(\"\\nğŸ“€ Album {}: {}\", album_index, album.name);\n                }\n            }\n            ListEvent::AlbumTrackFound {\n                track_index, track, ..\n            } =\u003e {\n                if self.format {\n                    if self.verbose {\n                        println!(\n                            \"    [{:2}] {track} ({} plays)\",\n                            track_index, track.playcount\n                        );\n                        if let Some(timestamp) = track.timestamp {\n                            println!(\"         Last Played: {timestamp}\");\n                        }\n                    } else {\n                        println!(\"    [{track_index:2}] {track}\");\n                    }\n                } else if self.verbose {\n                    println!(\n                        \"    [{:2}] {} ({} plays)\",\n                        track_index, track.name, track.playcount\n                    );\n                    if let Some(timestamp) = track.timestamp {\n                        println!(\"         Last Played: {timestamp}\");\n                    }\n                } else {\n                    println!(\"    [{:2}] {}\", track_index, track.name);\n                }\n            }\n            ListEvent::Summary {\n                command,\n                total_items,\n                artist,\n                ..\n            } =\u003e match command.as_str() {\n                \"artists\" =\u003e {\n                    if total_items == 0 {\n                        println!(\"  No artists found in your library.\");\n                    } else {\n                        println!(\n                            \"\\nFound {} artist{} in your library\",\n                            total_items,\n                            if total_items == 1 { \"\" } else { \"s\" }\n                        );\n                    }\n                }\n                \"albums\" =\u003e {\n                    if let Some(artist) = artist {\n                        if total_items == 0 {\n                            println!(\"  No albums found for this artist.\");\n                        } else {\n                            println!(\n                                \"\\nFound {} album{} for '{artist}'\",\n                                total_items,\n                                if total_items == 1 { \"\" } else { \"s\" }\n                            );\n                        }\n                    }\n                }\n                \"tracks\" =\u003e {\n                    if let Some(artist) = artist {\n                        if total_items == 0 {\n                            println!(\"  No tracks found for this artist.\");\n                        } else {\n                            println!(\n                                \"\\nFound {} track{} for '{artist}'\",\n                                total_items,\n                                if total_items == 1 { \"\" } else { \"s\" }\n                            );\n                        }\n                    }\n                }\n                \"tracks-by-album\" =\u003e {\n                    if let Some(artist) = artist {\n                        if total_items == 0 {\n                            println!(\"  No albums found for this artist.\");\n                        } else {\n                            println!(\n                                \"\\nListed {} album{} for '{artist}'\",\n                                total_items,\n                                if total_items == 1 { \"\" } else { \"s\" }\n                            );\n                        }\n                    }\n                }\n                \"album-tracks\" =\u003e {\n                    if total_items == 0 {\n                        println!(\"  No tracks found for this album.\");\n                    }\n                }\n                _ =\u003e {}\n            },\n            ListEvent::Error { message } =\u003e {\n                println!(\"    âŒ Error: {message}\");\n            }\n        }\n    }\n}\n\n/// JSON output handler for list commands (JSONL format)\npub struct JsonListHandler;\n\nimpl JsonListHandler {\n    pub fn new() -\u003e Self {\n        Self\n    }\n}\n\nimpl ListOutputHandler for JsonListHandler {\n    fn handle_event(\u0026mut self, event: ListEvent) {\n        // Output each event as a single line of JSON\n        if let Ok(json) = serde_json::to_string(\u0026event) {\n            println!(\"{json}\");\n        } else {\n            eprintln!(\"âŒ Failed to serialize event to JSON\");\n        }\n    }\n}\n","traces":[{"line":51,"address":[3412320],"length":1,"stats":{"Line":0}},{"line":57,"address":[3412352,3414357,3423841],"length":1,"stats":{"Line":0}},{"line":58,"address":[3412398],"length":1,"stats":{"Line":0}},{"line":59,"address":[3412535],"length":1,"stats":{"Line":0}},{"line":64,"address":[3413218,3413299,3415230],"length":1,"stats":{"Line":0}},{"line":65,"address":[3413273,3413335],"length":1,"stats":{"Line":0}},{"line":66,"address":[3415028,3413383],"length":1,"stats":{"Line":0}},{"line":67,"address":[3415139,3415068],"length":1,"stats":{"Line":0}},{"line":70,"address":[3413436,3413357],"length":1,"stats":{"Line":0}},{"line":71,"address":[3414781,3413484],"length":1,"stats":{"Line":0}},{"line":72,"address":[3414821,3414892],"length":1,"stats":{"Line":0}},{"line":73,"address":[3414961],"length":1,"stats":{"Line":0}},{"line":76,"address":[3413534,3413458],"length":1,"stats":{"Line":0}},{"line":77,"address":[3413582,3414579],"length":1,"stats":{"Line":0}},{"line":78,"address":[3414619,3414690],"length":1,"stats":{"Line":0}},{"line":81,"address":[3413556,3413632],"length":1,"stats":{"Line":0}},{"line":82,"address":[3414009,3413657],"length":1,"stats":{"Line":0}},{"line":83,"address":[3414160,3414089],"length":1,"stats":{"Line":0}},{"line":88,"address":[3412649],"length":1,"stats":{"Line":0}},{"line":89,"address":[3412691],"length":1,"stats":{"Line":0}},{"line":90,"address":[3415715],"length":1,"stats":{"Line":0}},{"line":91,"address":[3416517,3416295],"length":1,"stats":{"Line":0}},{"line":93,"address":[3416268,3416389],"length":1,"stats":{"Line":0}},{"line":95,"address":[3415700],"length":1,"stats":{"Line":0}},{"line":96,"address":[3416077,3415788],"length":1,"stats":{"Line":0}},{"line":98,"address":[3415910,3415729],"length":1,"stats":{"Line":0}},{"line":101,"address":[3412714],"length":1,"stats":{"Line":0}},{"line":102,"address":[3412756],"length":1,"stats":{"Line":0}},{"line":103,"address":[3416727],"length":1,"stats":{"Line":0}},{"line":104,"address":[3417529,3417307],"length":1,"stats":{"Line":0}},{"line":106,"address":[3417401,3417280],"length":1,"stats":{"Line":0}},{"line":108,"address":[3416712],"length":1,"stats":{"Line":0}},{"line":109,"address":[3416800,3417089],"length":1,"stats":{"Line":0}},{"line":111,"address":[3416741,3416922],"length":1,"stats":{"Line":0}},{"line":114,"address":[3412779],"length":1,"stats":{"Line":0}},{"line":115,"address":[3412824],"length":1,"stats":{"Line":0}},{"line":116,"address":[3417739],"length":1,"stats":{"Line":0}},{"line":117,"address":[3419210,3419024],"length":1,"stats":{"Line":0}},{"line":121,"address":[3419269],"length":1,"stats":{"Line":0}},{"line":122,"address":[3419526],"length":1,"stats":{"Line":0}},{"line":123,"address":[3419622],"length":1,"stats":{"Line":0}},{"line":124,"address":[3419656],"length":1,"stats":{"Line":0}},{"line":127,"address":[3419072,3418997],"length":1,"stats":{"Line":0}},{"line":129,"address":[3417724],"length":1,"stats":{"Line":0}},{"line":130,"address":[3417788,3418252],"length":1,"stats":{"Line":0}},{"line":131,"address":[3418311],"length":1,"stats":{"Line":0}},{"line":135,"address":[3418409],"length":1,"stats":{"Line":0}},{"line":136,"address":[3418670],"length":1,"stats":{"Line":0}},{"line":137,"address":[3418766],"length":1,"stats":{"Line":0}},{"line":138,"address":[3418862],"length":1,"stats":{"Line":0}},{"line":139,"address":[3418896],"length":1,"stats":{"Line":0}},{"line":142,"address":[3417753,3417886],"length":1,"stats":{"Line":0}},{"line":143,"address":[3417951],"length":1,"stats":{"Line":0}},{"line":146,"address":[3418222],"length":1,"stats":{"Line":0}},{"line":147,"address":[3419779],"length":1,"stats":{"Line":0}},{"line":150,"address":[3412847],"length":1,"stats":{"Line":0}},{"line":151,"address":[3412889],"length":1,"stats":{"Line":0}},{"line":152,"address":[3419853,3420063],"length":1,"stats":{"Line":0}},{"line":157,"address":[3419927,3419826],"length":1,"stats":{"Line":0}},{"line":160,"address":[3412911],"length":1,"stats":{"Line":0}},{"line":163,"address":[3412952],"length":1,"stats":{"Line":0}},{"line":164,"address":[3420246],"length":1,"stats":{"Line":0}},{"line":165,"address":[3421098,3420876],"length":1,"stats":{"Line":0}},{"line":169,"address":[3421280],"length":1,"stats":{"Line":0}},{"line":170,"address":[3421314],"length":1,"stats":{"Line":0}},{"line":173,"address":[3420970,3420849],"length":1,"stats":{"Line":0}},{"line":175,"address":[3420231],"length":1,"stats":{"Line":0}},{"line":176,"address":[3420528,3420287],"length":1,"stats":{"Line":0}},{"line":180,"address":[3420714],"length":1,"stats":{"Line":0}},{"line":181,"address":[3420748],"length":1,"stats":{"Line":0}},{"line":184,"address":[3420260,3420361],"length":1,"stats":{"Line":0}},{"line":187,"address":[3421497,3413051],"length":1,"stats":{"Line":0}},{"line":193,"address":[3421513],"length":1,"stats":{"Line":0}},{"line":194,"address":[3421579],"length":1,"stats":{"Line":0}},{"line":195,"address":[3423266,3423319],"length":1,"stats":{"Line":0}},{"line":197,"address":[3423343],"length":1,"stats":{"Line":0}},{"line":204,"address":[3421603,3421556],"length":1,"stats":{"Line":0}},{"line":205,"address":[3422834,3421642],"length":1,"stats":{"Line":0}},{"line":206,"address":[3422890],"length":1,"stats":{"Line":0}},{"line":207,"address":[3422901,3422998],"length":1,"stats":{"Line":0}},{"line":209,"address":[3423106,3422927],"length":1,"stats":{"Line":0}},{"line":217,"address":[3421619,3421692],"length":1,"stats":{"Line":0}},{"line":218,"address":[3421731,3422402],"length":1,"stats":{"Line":0}},{"line":219,"address":[3422458],"length":1,"stats":{"Line":0}},{"line":220,"address":[3422566,3422469],"length":1,"stats":{"Line":0}},{"line":222,"address":[3422609],"length":1,"stats":{"Line":0}},{"line":230,"address":[3421708,3421778],"length":1,"stats":{"Line":0}},{"line":231,"address":[3421970,3421817],"length":1,"stats":{"Line":0}},{"line":232,"address":[3422026],"length":1,"stats":{"Line":0}},{"line":233,"address":[3422037,3422134],"length":1,"stats":{"Line":0}},{"line":235,"address":[3422242,3422063],"length":1,"stats":{"Line":0}},{"line":243,"address":[3421794,3421860],"length":1,"stats":{"Line":0}},{"line":244,"address":[3421912],"length":1,"stats":{"Line":0}},{"line":245,"address":[3421923],"length":1,"stats":{"Line":0}},{"line":250,"address":[3413085],"length":1,"stats":{"Line":0}},{"line":251,"address":[3423701,3413109],"length":1,"stats":{"Line":0}},{"line":267,"address":[3423872,3424280,3424427],"length":1,"stats":{"Line":0}},{"line":269,"address":[3423891,3423947,3424018],"length":1,"stats":{"Line":0}},{"line":270,"address":[3424046,3424108],"length":1,"stats":{"Line":0}},{"line":272,"address":[3424286,3423989],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":100},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","commands","mod.rs"],"content":"pub mod delete;\npub mod edit;\npub mod list;\npub mod list_output;\npub mod search;\npub mod search_output;\npub mod show;\npub mod show_output;\npub mod utils;\n\nuse clap::{arg, Subcommand, ValueEnum};\nuse lastfm_edit::LastFmEditClientImpl;\n\n#[derive(ValueEnum, Clone)]\npub enum SearchType {\n    /// Search for tracks\n    Tracks,\n    /// Search for albums\n    Albums,\n}\n\n#[derive(Subcommand)]\npub enum ListCommands {\n    /// List all artists in your library\n    ///\n    /// This command lists all artists in your Last.fm library, sorted by play count\n    /// (highest first). Shows artist names and scrobble counts.\n    ///\n    /// Usage examples:\n    /// # List all artists\n    /// lastfm-edit list artists\n    ///\n    /// # List first 20 artists with play counts\n    /// lastfm-edit list artists --limit 20 --details\n    ///\n    /// # List artists with formatted display\n    /// lastfm-edit list artists --format\n    Artists {\n        /// Maximum number of artists to show (0 for no limit)\n        #[arg(long, default_value = \"0\")]\n        limit: usize,\n\n        /// Show additional details like play counts\n        #[arg(long)]\n        details: bool,\n\n        /// Show formatted output\n        #[arg(long)]\n        format: bool,\n    },\n\n    /// List albums for an artist\n    ///\n    /// This command lists all albums in your library for a specified artist.\n    /// The albums are sorted by play count (highest first).\n    ///\n    /// Usage examples:\n    /// # List all albums for The Beatles\n    /// lastfm-edit list albums \"The Beatles\"\n    ///\n    /// # List first 10 albums with play counts\n    /// lastfm-edit list albums \"Radiohead\" --limit 10 --details\n    ///\n    /// # List albums with formatted display (Artist - Album Name)\n    /// lastfm-edit list albums \"The Beatles\" --format\n    Albums {\n        /// Artist name\n        artist: String,\n\n        /// Maximum number of albums to show (0 for no limit)\n        #[arg(long, default_value = \"0\")]\n        limit: usize,\n\n        /// Show additional details like play counts\n        #[arg(long)]\n        details: bool,\n\n        /// Show formatted output (Artist - Album/Track Name [Album Name])\n        #[arg(long)]\n        format: bool,\n    },\n\n    /// List all tracks for an artist with album information (album-based iteration)\n    ///\n    /// This command lists all tracks in your library for a specified artist,\n    /// with complete album information included. Unlike tracks-by-album, this\n    /// shows tracks in a flat list with album details for each track.\n    /// Note: This uses album-based iteration, so tracks without album metadata may be missed.\n    ///\n    /// Usage examples:\n    /// # List all tracks for The Beatles with album info\n    /// lastfm-edit list tracks \"The Beatles\"\n    ///\n    /// # List first 20 tracks with play counts and details\n    /// lastfm-edit list tracks \"Radiohead\" --limit 20 --details\n    ///\n    /// # List tracks with formatted display (Artist - Track Name [Album Name])\n    /// lastfm-edit list tracks \"The Beatles\" --format\n    Tracks {\n        /// Artist name\n        artist: String,\n\n        /// Maximum number of tracks to show (0 for no limit)\n        #[arg(long, default_value = \"0\")]\n        limit: usize,\n\n        /// Show additional details like play counts and album artist\n        #[arg(long)]\n        details: bool,\n\n        /// Show formatted output (Artist - Track Name [Album Name])\n        #[arg(long)]\n        format: bool,\n    },\n\n    /// List all tracks for an artist using direct track iteration\n    ///\n    /// This command lists all tracks in your library for a specified artist using\n    /// direct track iteration. This approach finds ALL tracks, including those\n    /// without album metadata (singles, B-sides, etc.) that may be missed by the\n    /// regular tracks command.\n    ///\n    /// Usage examples:\n    /// # List all tracks including those without albums\n    /// lastfm-edit list tracks-direct \"The Beatles\"\n    ///\n    /// # Compare with regular tracks command to find missing tracks\n    /// lastfm-edit list tracks-direct \"The Beatles\" --limit 20 --details\n    TracksDirect {\n        /// Artist name\n        artist: String,\n\n        /// Maximum number of tracks to show (0 for no limit)\n        #[arg(long, default_value = \"0\")]\n        limit: usize,\n\n        /// Show additional details like play counts and album artist\n        #[arg(long)]\n        details: bool,\n\n        /// Show formatted output (Artist - Track Name [Album Name])\n        #[arg(long)]\n        format: bool,\n    },\n\n    /// List tracks organized by album for an artist\n    ///\n    /// This command lists all tracks in your library for a specified artist,\n    /// organized by album. For each album, it shows all tracks from that album.\n    ///\n    /// Usage examples:\n    /// # List all tracks by album for The Beatles\n    /// lastfm-edit list tracks-by-album \"The Beatles\"\n    ///\n    /// # List tracks for first 5 albums with play counts\n    /// lastfm-edit list tracks-by-album \"Pink Floyd\" --limit 5 --details\n    ///\n    /// # List tracks with formatted display (Artist - Track Name [Album Name])\n    /// lastfm-edit list tracks-by-album \"The Beatles\" --format\n    TracksByAlbum {\n        /// Artist name\n        artist: String,\n\n        /// Maximum number of albums to show (0 for no limit)\n        #[arg(long, default_value = \"0\")]\n        limit: usize,\n\n        /// Show additional details like play counts\n        #[arg(long)]\n        details: bool,\n\n        /// Show formatted output (Artist - Album/Track Name [Album Name])\n        #[arg(long)]\n        format: bool,\n    },\n\n    /// List tracks for a specific album\n    ///\n    /// This command lists all tracks for a specific album by a specific artist.\n    /// This is useful for albums with special characters like slashes in their names.\n    ///\n    /// Usage examples:\n    /// # List all tracks for AC/DC's \"Back in Black\" album\n    /// lastfm-edit list album-tracks \"Back in Black\" \"AC/DC\"\n    ///\n    /// # List tracks with details and formatted output\n    /// lastfm-edit list album-tracks \"The Dark Side of the Moon\" \"Pink Floyd\" --details --format\n    AlbumTracks {\n        /// Album name\n        album: String,\n\n        /// Artist name\n        artist: String,\n\n        /// Show additional details like play counts\n        #[arg(long)]\n        details: bool,\n\n        /// Show formatted output (Artist - Track Name [Album Name])\n        #[arg(long)]\n        format: bool,\n    },\n}\n\n#[derive(Subcommand)]\npub enum Commands {\n    /// Edit scrobble metadata\n    ///\n    /// This command allows you to edit scrobble metadata by specifying what to search for\n    /// and what to change it to. You can specify any combination of fields to search for,\n    /// and any combination of new values to change them to.\n    ///\n    /// Usage examples:\n    /// # Discover variations for an artist (dry run by default)\n    /// lastfm-edit edit --artist \"Jimi Hendrix\"\n    ///\n    /// # Discover variations with optional track name\n    /// lastfm-edit edit --artist \"Radiohead\" --track \"Creep\"\n    ///\n    /// # Actually apply edits (change artist name)\n    /// lastfm-edit edit --artist \"The Beatles\" --new-artist \"Beatles, The\" --apply\n    ///\n    /// # Change track name for specific track\n    /// lastfm-edit edit --artist \"Jimi Hendrix\" --track \"Lover Man\" --new-track \"Lover Man (Live)\" --apply\n    Edit {\n        /// Artist name (required)\n        #[arg(long)]\n        artist: String,\n\n        /// Track name (optional)\n        #[arg(long)]\n        track: Option\u003cString\u003e,\n\n        /// Album name (optional)\n        #[arg(long)]\n        album: Option\u003cString\u003e,\n\n        /// Album artist name (optional)\n        #[arg(long)]\n        album_artist: Option\u003cString\u003e,\n\n        /// New track name (optional)\n        #[arg(long)]\n        new_track: Option\u003cString\u003e,\n\n        /// New album name (optional)\n        #[arg(long)]\n        new_album: Option\u003cString\u003e,\n\n        /// New artist name (optional)\n        #[arg(long)]\n        new_artist: Option\u003cString\u003e,\n\n        /// New album artist name (optional)\n        #[arg(long)]\n        new_album_artist: Option\u003cString\u003e,\n\n        /// Timestamp for specific scrobble (optional)\n        #[arg(long)]\n        timestamp: Option\u003cu64\u003e,\n\n        /// Disable editing all instances (edit only specific scrobble, defaults to editing all)\n        #[arg(long)]\n        no_edit_all: bool,\n\n        /// Actually apply the edits (default is dry-run mode)\n        #[arg(long)]\n        apply: bool,\n\n        /// Perform a dry run without actually submitting edits (default behavior)\n        #[arg(long)]\n        dry_run: bool,\n    },\n    /// Delete scrobbles in a range\n    ///\n    /// This command allows you to delete scrobbles from your library. You can specify\n    /// timestamp ranges, delete recent scrobbles from specific pages, or use offsets\n    /// from the most recent scrobble.\n    ///\n    /// Usage examples:\n    /// # Show recent scrobbles that would be deleted (dry run)\n    /// lastfm-edit delete --recent-pages 1-3\n    ///\n    /// # Delete scrobbles from timestamp range\n    /// lastfm-edit delete --timestamp-range 1640995200-1641000000 --apply\n    ///\n    /// # Delete scrobbles by offset from most recent (0-indexed)\n    /// lastfm-edit delete --recent-offset 0-4 --apply\n    Delete {\n        /// Delete scrobbles from recent pages (format: start-end, 0-indexed)\n        #[arg(long, conflicts_with_all = [\"timestamp_range\", \"recent_offset\"])]\n        recent_pages: Option\u003cString\u003e,\n\n        /// Delete scrobbles from timestamp range (format: start_ts-end_ts)\n        #[arg(long, conflicts_with_all = [\"recent_pages\", \"recent_offset\"])]\n        timestamp_range: Option\u003cString\u003e,\n\n        /// Delete scrobbles by offset from most recent (format: start-end, 0-indexed)\n        #[arg(long, conflicts_with_all = [\"recent_pages\", \"timestamp_range\"])]\n        recent_offset: Option\u003cString\u003e,\n\n        /// Actually perform the deletions (default is dry-run mode)\n        #[arg(long)]\n        apply: bool,\n\n        /// Perform a dry run without actually deleting (default behavior)\n        #[arg(long)]\n        dry_run: bool,\n    },\n    /// Search tracks and albums in your library\n    ///\n    /// This command allows you to search through your Last.fm library for tracks or albums\n    /// that match a specific query. You can limit the number of results and specify whether\n    /// to search for tracks or albums.\n    ///\n    /// Usage examples:\n    /// # Search for tracks containing \"remaster\"\n    /// lastfm-edit search tracks \"remaster\"\n    ///\n    /// # Search for first 20 albums containing \"deluxe\"\n    /// lastfm-edit search albums \"deluxe\" --limit 20\n    ///\n    /// # Search for tracks with unlimited results\n    /// lastfm-edit search tracks \"live\" --limit 0\n    ///\n    /// # Skip first 10 results and show next 20\n    /// lastfm-edit search tracks \"live\" --offset 10 --limit 20\n    Search {\n        /// Type of search: tracks or albums\n        #[arg(value_enum)]\n        search_type: SearchType,\n\n        /// Search query\n        query: String,\n\n        /// Maximum number of results to show (0 for no limit)\n        #[arg(long, default_value = \"50\")]\n        limit: usize,\n\n        /// Number of results to skip from the beginning (0-indexed)\n        #[arg(long, default_value = \"0\")]\n        offset: usize,\n\n        /// Show additional details like play counts\n        #[arg(long)]\n        details: bool,\n    },\n\n    /// Show scrobble details for specific offsets\n    ///\n    /// This command displays detailed information for scrobbles at the specified\n    /// offsets from your most recent scrobbles.\n    ///\n    /// Usage examples:\n    /// # Show details for the most recent scrobble (offset 0)\n    /// lastfm-edit show 0\n    ///\n    /// # Show details for multiple scrobbles (0-indexed)\n    /// lastfm-edit show 0 1 2 5 10\n    Show {\n        /// Offsets of scrobbles to show (0-indexed, 0 = most recent)\n        offsets: Vec\u003cu64\u003e,\n    },\n\n    /// List artists, albums, and tracks from your library\n    ///\n    /// This command allows you to browse your Last.fm library by listing artists,\n    /// albums, and tracks.\n    ///\n    /// Usage examples:\n    /// # List all artists in your library\n    /// lastfm-edit list artists --limit 20 --details\n    ///\n    /// # List all albums for The Beatles\n    /// lastfm-edit list albums \"The Beatles\"\n    ///\n    /// # List all tracks with album information\n    /// lastfm-edit list tracks \"Radiohead\" --limit 20 --details\n    ///\n    /// # List tracks organized by album\n    /// lastfm-edit list tracks-by-album \"Pink Floyd\" --limit 5 --details\n    List {\n        #[command(subcommand)]\n        command: ListCommands,\n    },\n}\n\n/// Execute the appropriate command handler based on the parsed command\npub async fn execute_command(\n    command: Commands,\n    client: \u0026LastFmEditClientImpl,\n    json_output: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    match command {\n        Commands::Edit {\n            artist,\n            track,\n            album,\n            album_artist,\n            new_track,\n            new_album,\n            new_artist,\n            new_album_artist,\n            timestamp,\n            no_edit_all,\n            apply,\n            dry_run,\n        } =\u003e {\n            // Determine whether this is a dry run or actual edit\n            let is_dry_run = dry_run || !apply;\n\n            let edit = edit::create_scrobble_edit_from_args(\n                \u0026artist,\n                track.as_deref(),\n                album.as_deref(),\n                album_artist.as_deref(),\n                new_track.as_deref(),\n                new_album.as_deref(),\n                new_artist.as_deref(),\n                new_album_artist.as_deref(),\n                timestamp,\n                !no_edit_all, // edit_all is true by default, false only if --no-edit-all is provided\n            );\n\n            edit::handle_edit_command(client, \u0026edit, is_dry_run).await\n        }\n\n        Commands::Delete {\n            recent_pages,\n            timestamp_range,\n            recent_offset,\n            apply,\n            dry_run,\n        } =\u003e {\n            // Determine whether this is a dry run or actual deletion\n            let is_dry_run = dry_run || !apply;\n\n            if let Some(pages_range) = recent_pages {\n                delete::handle_delete_recent_pages(client, \u0026pages_range, is_dry_run).await\n            } else if let Some(ts_range) = timestamp_range {\n                delete::handle_delete_timestamp_range(client, \u0026ts_range, is_dry_run).await\n            } else if let Some(offset_range) = recent_offset {\n                delete::handle_delete_recent_offset(client, \u0026offset_range, is_dry_run).await\n            } else {\n                Err(\n                    \"Must specify one of: --recent-pages, --timestamp-range, or --recent-offset\"\n                        .into(),\n                )\n            }\n        }\n\n        Commands::Search {\n            search_type,\n            query,\n            limit,\n            offset,\n            details,\n        } =\u003e {\n            search::handle_search_command(\n                client,\n                search_type,\n                \u0026query,\n                limit,\n                offset,\n                details,\n                json_output,\n            )\n            .await\n        }\n\n        Commands::Show { offsets } =\u003e {\n            if offsets.is_empty() {\n                return Err(\"Must specify at least one offset to show\".into());\n            }\n\n            show::handle_show_scrobbles(client, \u0026offsets, json_output).await\n        }\n\n        Commands::List { command } =\u003e match command {\n            ListCommands::Artists {\n                limit,\n                details,\n                format,\n            } =\u003e list::handle_list_artists(client, limit, details, format, json_output).await,\n            ListCommands::Albums {\n                artist,\n                limit,\n                details,\n                format,\n            } =\u003e {\n                list::handle_list_albums(client, \u0026artist, limit, details, format, json_output).await\n            }\n            ListCommands::Tracks {\n                artist,\n                limit,\n                details,\n                format,\n            } =\u003e {\n                list::handle_list_tracks(client, \u0026artist, limit, details, format, json_output).await\n            }\n            ListCommands::TracksDirect {\n                artist,\n                limit,\n                details,\n                format,\n            } =\u003e {\n                list::handle_list_tracks_direct(\n                    client,\n                    \u0026artist,\n                    limit,\n                    details,\n                    format,\n                    json_output,\n                )\n                .await\n            }\n            ListCommands::TracksByAlbum {\n                artist,\n                limit,\n                details,\n                format,\n            } =\u003e {\n                list::handle_list_tracks_by_album(\n                    client,\n                    \u0026artist,\n                    limit,\n                    details,\n                    format,\n                    json_output,\n                )\n                .await\n            }\n            ListCommands::AlbumTracks {\n                album,\n                artist,\n                details,\n                format,\n            } =\u003e {\n                list::handle_list_album_tracks(\n                    client,\n                    \u0026album,\n                    \u0026artist,\n                    details,\n                    format,\n                    json_output,\n                )\n                .await\n            }\n        },\n    }\n}\n","traces":[{"line":389,"address":[3429296],"length":1,"stats":{"Line":0}},{"line":394,"address":[3658144],"length":1,"stats":{"Line":0}},{"line":395,"address":[3659003],"length":1,"stats":{"Line":0}},{"line":410,"address":[3659808,3659089],"length":1,"stats":{"Line":0}},{"line":413,"address":[3659829],"length":1,"stats":{"Line":0}},{"line":414,"address":[3659950],"length":1,"stats":{"Line":0}},{"line":415,"address":[3660024],"length":1,"stats":{"Line":0}},{"line":416,"address":[3660098],"length":1,"stats":{"Line":0}},{"line":417,"address":[3660172],"length":1,"stats":{"Line":0}},{"line":418,"address":[3660246],"length":1,"stats":{"Line":0}},{"line":419,"address":[3660320],"length":1,"stats":{"Line":0}},{"line":420,"address":[3660394],"length":1,"stats":{"Line":0}},{"line":422,"address":[3660539],"length":1,"stats":{"Line":0}},{"line":425,"address":[3625518],"length":1,"stats":{"Line":0}},{"line":428,"address":[3659248],"length":1,"stats":{"Line":0}},{"line":436,"address":[3660881,3659377],"length":1,"stats":{"Line":0}},{"line":438,"address":[3660902],"length":1,"stats":{"Line":0}},{"line":439,"address":[3625540],"length":1,"stats":{"Line":0}},{"line":440,"address":[3626533,3626572],"length":1,"stats":{"Line":0}},{"line":441,"address":[3625562],"length":1,"stats":{"Line":0}},{"line":442,"address":[3626711,3626750],"length":1,"stats":{"Line":0}},{"line":443,"address":[3625584],"length":1,"stats":{"Line":0}},{"line":446,"address":[3661695],"length":1,"stats":{"Line":0}},{"line":452,"address":[3659485],"length":1,"stats":{"Line":0}},{"line":462,"address":[3659544],"length":1,"stats":{"Line":0}},{"line":468,"address":[3625606],"length":1,"stats":{"Line":0}},{"line":471,"address":[3659585],"length":1,"stats":{"Line":0}},{"line":472,"address":[3659621,3662393],"length":1,"stats":{"Line":0}},{"line":473,"address":[3662437,3662641],"length":1,"stats":{"Line":0}},{"line":476,"address":[3667632,3658346,3662399,3662513],"length":1,"stats":{"Line":0}},{"line":479,"address":[3659653],"length":1,"stats":{"Line":0}},{"line":480,"address":[3625650],"length":1,"stats":{"Line":0}},{"line":485,"address":[3662926],"length":1,"stats":{"Line":0}},{"line":491,"address":[3663946,3668096,3658388,3663049],"length":1,"stats":{"Line":0}},{"line":493,"address":[3663126],"length":1,"stats":{"Line":0}},{"line":499,"address":[3625694],"length":1,"stats":{"Line":0}},{"line":501,"address":[3663254],"length":1,"stats":{"Line":0}},{"line":509,"address":[3663377],"length":1,"stats":{"Line":0}},{"line":515,"address":[3668786,3664539,3658430,3668590,3664499],"length":1,"stats":{"Line":0}},{"line":517,"address":[3663418],"length":1,"stats":{"Line":0}},{"line":525,"address":[3663541],"length":1,"stats":{"Line":0}},{"line":531,"address":[3625738],"length":1,"stats":{"Line":0}},{"line":533,"address":[3663582],"length":1,"stats":{"Line":0}},{"line":541,"address":[3663710],"length":1,"stats":{"Line":0}},{"line":542,"address":[3664896],"length":1,"stats":{"Line":0}},{"line":547,"address":[3625760],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","commands","search.rs"],"content":"use super::search_output::{\n    HumanReadableSearchHandler, JsonSearchHandler, SearchEvent, SearchOutputHandler,\n};\nuse super::SearchType;\nuse lastfm_edit::{LastFmEditClient, LastFmEditClientImpl};\n\n/// Number of items per page in Last.fm search results\nconst ITEMS_PER_PAGE: usize = 30;\n\n/// Handle the search command for tracks or albums in the user's library\npub async fn handle_search_command(\n    client: \u0026LastFmEditClientImpl,\n    search_type: SearchType,\n    query: \u0026str,\n    limit: usize,\n    offset: usize,\n    details: bool,\n    json_output: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create appropriate handler based on output format\n    let mut handler: Box\u003cdyn SearchOutputHandler\u003e = if json_output {\n        Box::new(JsonSearchHandler::new())\n    } else {\n        Box::new(HumanReadableSearchHandler::new(details))\n    };\n\n    let search_type_str = match search_type {\n        SearchType::Tracks =\u003e \"tracks\",\n        SearchType::Albums =\u003e \"albums\",\n    };\n\n    // Emit start event\n    handler.handle_event(SearchEvent::Started {\n        search_type: search_type_str.to_string(),\n        query: query.to_string(),\n        offset,\n        limit,\n    });\n\n    // Calculate starting page and within-page offset\n    let starting_page = if offset \u003e 0 {\n        (offset / ITEMS_PER_PAGE) + 1\n    } else {\n        1\n    };\n    let within_page_offset = offset % ITEMS_PER_PAGE;\n\n    match search_type {\n        SearchType::Tracks =\u003e {\n            // Create iterator starting from the calculated page\n            let mut search_iterator = if starting_page \u003e 1 {\n                Box::new(lastfm_edit::SearchTracksIterator::with_starting_page(\n                    client.clone(),\n                    query.to_string(),\n                    starting_page as u32,\n                ))\n            } else {\n                client.search_tracks(query)\n            };\n\n            let mut total_count = 0;\n            let mut displayed_count = 0;\n            let should_limit = limit \u003e 0;\n\n            // Process results incrementally\n            while let Some(track) = search_iterator.next().await? {\n                total_count += 1;\n\n                // Skip items until we reach the desired within-page offset\n                if total_count \u003c= within_page_offset {\n                    continue;\n                }\n\n                displayed_count += 1;\n                let display_number = offset + displayed_count;\n\n                // Emit track found event\n                handler.handle_event(SearchEvent::TrackFound {\n                    index: display_number,\n                    track,\n                });\n\n                if should_limit \u0026\u0026 displayed_count \u003e= limit {\n                    break;\n                }\n            }\n\n            if displayed_count == 0 {\n                handler.handle_event(SearchEvent::NoResults {\n                    search_type: search_type_str.to_string(),\n                    query: query.to_string(),\n                });\n            } else {\n                handler.handle_event(SearchEvent::Summary {\n                    search_type: search_type_str.to_string(),\n                    query: query.to_string(),\n                    total_displayed: displayed_count,\n                    offset,\n                    limit,\n                });\n            }\n        }\n\n        SearchType::Albums =\u003e {\n            // Create iterator starting from the calculated page\n            let mut search_iterator = if starting_page \u003e 1 {\n                Box::new(lastfm_edit::SearchAlbumsIterator::with_starting_page(\n                    client.clone(),\n                    query.to_string(),\n                    starting_page as u32,\n                ))\n            } else {\n                client.search_albums(query)\n            };\n\n            let mut total_count = 0;\n            let mut displayed_count = 0;\n            let should_limit = limit \u003e 0;\n\n            // Process results incrementally\n            while let Some(album) = search_iterator.next().await? {\n                total_count += 1;\n\n                // Skip items until we reach the desired within-page offset\n                if total_count \u003c= within_page_offset {\n                    continue;\n                }\n\n                displayed_count += 1;\n                let display_number = offset + displayed_count;\n\n                // Emit album found event\n                handler.handle_event(SearchEvent::AlbumFound {\n                    index: display_number,\n                    album,\n                });\n\n                if should_limit \u0026\u0026 displayed_count \u003e= limit {\n                    break;\n                }\n            }\n\n            if displayed_count == 0 {\n                handler.handle_event(SearchEvent::NoResults {\n                    search_type: search_type_str.to_string(),\n                    query: query.to_string(),\n                });\n            } else {\n                handler.handle_event(SearchEvent::Summary {\n                    search_type: search_type_str.to_string(),\n                    query: query.to_string(),\n                    total_displayed: displayed_count,\n                    offset,\n                    limit,\n                });\n            }\n        }\n    }\n\n    // Emit finished event\n    handler.handle_event(SearchEvent::Finished {\n        search_type: search_type_str.to_string(),\n        query: query.to_string(),\n    });\n\n    Ok(())\n}\n","traces":[{"line":11,"address":[3671648],"length":1,"stats":{"Line":0}},{"line":21,"address":[3396757,3396850,3396517],"length":1,"stats":{"Line":0}},{"line":22,"address":[3396804,3396621],"length":1,"stats":{"Line":0}},{"line":24,"address":[3396692,3396594],"length":1,"stats":{"Line":0}},{"line":27,"address":[3396789],"length":1,"stats":{"Line":0}},{"line":28,"address":[3396881],"length":1,"stats":{"Line":0}},{"line":29,"address":[3396852],"length":1,"stats":{"Line":0}},{"line":33,"address":[3397118,3396908],"length":1,"stats":{"Line":0}},{"line":34,"address":[3396940],"length":1,"stats":{"Line":0}},{"line":35,"address":[3397011],"length":1,"stats":{"Line":0}},{"line":36,"address":[3397102,3397114],"length":1,"stats":{"Line":0}},{"line":37,"address":[3397110],"length":1,"stats":{"Line":0}},{"line":41,"address":[3397350,3397253,3397226],"length":1,"stats":{"Line":0}},{"line":42,"address":[3397255,3397307,3397352],"length":1,"stats":{"Line":0}},{"line":44,"address":[3397241],"length":1,"stats":{"Line":0}},{"line":46,"address":[3397277,3397380],"length":1,"stats":{"Line":0}},{"line":48,"address":[3397409],"length":1,"stats":{"Line":0}},{"line":51,"address":[3397883,3397442],"length":1,"stats":{"Line":0}},{"line":52,"address":[3397819,3397772],"length":1,"stats":{"Line":0}},{"line":53,"address":[3397685,3397533],"length":1,"stats":{"Line":0}},{"line":54,"address":[3397693],"length":1,"stats":{"Line":0}},{"line":55,"address":[3397765],"length":1,"stats":{"Line":0}},{"line":58,"address":[3397461,3397567],"length":1,"stats":{"Line":0}},{"line":61,"address":[3397574],"length":1,"stats":{"Line":0}},{"line":62,"address":[3397593],"length":1,"stats":{"Line":0}},{"line":63,"address":[3397612],"length":1,"stats":{"Line":0}},{"line":66,"address":[3398877,3399962,3397645,3397888,3398497,3396553,3399843,3398531,3400795],"length":1,"stats":{"Line":0}},{"line":67,"address":[3399135,3399216,3399262],"length":1,"stats":{"Line":0}},{"line":70,"address":[3399231],"length":1,"stats":{"Line":0}},{"line":74,"address":[3399451,3399324,3399390],"length":1,"stats":{"Line":0}},{"line":75,"address":[3399480,3399405,3399792],"length":1,"stats":{"Line":0}},{"line":78,"address":[3399640,3399488],"length":1,"stats":{"Line":0}},{"line":80,"address":[3399504],"length":1,"stats":{"Line":0}},{"line":83,"address":[3399813,3399848],"length":1,"stats":{"Line":0}},{"line":88,"address":[3400072],"length":1,"stats":{"Line":0}},{"line":89,"address":[3400111,3400368],"length":1,"stats":{"Line":0}},{"line":90,"address":[3400143],"length":1,"stats":{"Line":0}},{"line":91,"address":[3400277],"length":1,"stats":{"Line":0}},{"line":94,"address":[3400170,3400602],"length":1,"stats":{"Line":0}},{"line":95,"address":[3400196],"length":1,"stats":{"Line":0}},{"line":96,"address":[3400491],"length":1,"stats":{"Line":0}},{"line":97,"address":[3400579],"length":1,"stats":{"Line":0}},{"line":98,"address":[3400598],"length":1,"stats":{"Line":0}},{"line":99,"address":[3400594],"length":1,"stats":{"Line":0}},{"line":106,"address":[3398395,3397422],"length":1,"stats":{"Line":0}},{"line":107,"address":[3398331,3398284],"length":1,"stats":{"Line":0}},{"line":108,"address":[3398045,3398197],"length":1,"stats":{"Line":0}},{"line":109,"address":[3398205],"length":1,"stats":{"Line":0}},{"line":110,"address":[3398277],"length":1,"stats":{"Line":0}},{"line":113,"address":[3397973,3398079],"length":1,"stats":{"Line":0}},{"line":116,"address":[3398086],"length":1,"stats":{"Line":0}},{"line":117,"address":[3398105],"length":1,"stats":{"Line":0}},{"line":118,"address":[3398124],"length":1,"stats":{"Line":0}},{"line":121,"address":[3614408],"length":1,"stats":{"Line":0}},{"line":122,"address":[3401520,3401445,3401566],"length":1,"stats":{"Line":0}},{"line":125,"address":[3401535],"length":1,"stats":{"Line":0}},{"line":129,"address":[3401688,3401628,3401746],"length":1,"stats":{"Line":0}},{"line":130,"address":[3401772,3402000,3401703],"length":1,"stats":{"Line":0}},{"line":133,"address":[3401884,3401780],"length":1,"stats":{"Line":0}},{"line":135,"address":[3401796],"length":1,"stats":{"Line":0}},{"line":138,"address":[3402056,3402021],"length":1,"stats":{"Line":0}},{"line":143,"address":[3402268],"length":1,"stats":{"Line":0}},{"line":144,"address":[3402547,3402307],"length":1,"stats":{"Line":0}},{"line":145,"address":[3402333],"length":1,"stats":{"Line":0}},{"line":146,"address":[3402462],"length":1,"stats":{"Line":0}},{"line":149,"address":[3402776,3402360],"length":1,"stats":{"Line":0}},{"line":150,"address":[3402385],"length":1,"stats":{"Line":0}},{"line":151,"address":[3402666],"length":1,"stats":{"Line":0}},{"line":152,"address":[3402753],"length":1,"stats":{"Line":0}},{"line":153,"address":[3402772],"length":1,"stats":{"Line":0}},{"line":154,"address":[3402768],"length":1,"stats":{"Line":0}},{"line":161,"address":[3400723,3402985],"length":1,"stats":{"Line":0}},{"line":162,"address":[3400749],"length":1,"stats":{"Line":0}},{"line":163,"address":[3402897],"length":1,"stats":{"Line":0}},{"line":166,"address":[3403077],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":75},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","commands","search_output.rs"],"content":"use lastfm_edit::{Album, Track};\nuse serde::{Deserialize, Serialize};\n\n/// Events emitted by search commands\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(tag = \"type\")]\npub enum SearchEvent {\n    /// Starting to search for items\n    Started {\n        search_type: String, // \"tracks\" or \"albums\"\n        query: String,\n        offset: usize,\n        limit: usize,\n    },\n    /// Found a track in search results\n    TrackFound { index: usize, track: Track },\n    /// Found an album in search results\n    AlbumFound { index: usize, album: Album },\n    /// Search completed with summary\n    Summary {\n        search_type: String,\n        query: String,\n        total_displayed: usize,\n        offset: usize,\n        limit: usize,\n    },\n    /// No results found\n    NoResults { search_type: String, query: String },\n    /// Search command finished\n    Finished { search_type: String, query: String },\n}\n\n/// Trait for handling search command output\npub trait SearchOutputHandler {\n    fn handle_event(\u0026mut self, event: SearchEvent);\n}\n\n/// Human-readable output handler for search commands\npub struct HumanReadableSearchHandler {\n    details: bool,\n    found_any: bool,\n}\n\nimpl HumanReadableSearchHandler {\n    pub fn new(details: bool) -\u003e Self {\n        Self {\n            details,\n            found_any: false,\n        }\n    }\n}\n\nimpl SearchOutputHandler for HumanReadableSearchHandler {\n    fn handle_event(\u0026mut self, event: SearchEvent) {\n        match event {\n            SearchEvent::Started {\n                search_type,\n                query,\n                offset,\n                ..\n            } =\u003e {\n                if offset \u003e 0 {\n                    println!(\n                        \"ğŸ” Searching for {} containing '{}' (starting from #{})...\",\n                        search_type,\n                        query,\n                        offset + 1\n                    );\n                } else {\n                    println!(\"ğŸ” Searching for {search_type} containing '{query}'...\");\n                }\n            }\n            SearchEvent::TrackFound { index, track } =\u003e {\n                // Add blank line before first result\n                if !self.found_any {\n                    self.found_any = true;\n                    println!();\n                }\n\n                if self.details {\n                    println!(\n                        \"{}. {} - {} (played {} time{})\",\n                        index,\n                        track.artist,\n                        track.name,\n                        track.playcount,\n                        if track.playcount == 1 { \"\" } else { \"s\" }\n                    );\n\n                    if let Some(album) = \u0026track.album {\n                        println!(\"   Album: {album}\");\n                    }\n\n                    if let Some(album_artist) = \u0026track.album_artist {\n                        if album_artist != \u0026track.artist {\n                            println!(\"   Album Artist: {album_artist}\");\n                        }\n                    }\n                    println!(); // Blank line between verbose entries\n                } else {\n                    println!(\"{}. {} - {}\", index, track.artist, track.name);\n                }\n            }\n            SearchEvent::AlbumFound { index, album } =\u003e {\n                // Add blank line before first result\n                if !self.found_any {\n                    self.found_any = true;\n                    println!();\n                }\n\n                if self.details {\n                    println!(\n                        \"{}. {} - {} (played {} time{})\",\n                        index,\n                        album.artist,\n                        album.name,\n                        album.playcount,\n                        if album.playcount == 1 { \"\" } else { \"s\" }\n                    );\n                    println!(); // Blank line between verbose entries\n                } else {\n                    println!(\"{}. {} - {}\", index, album.artist, album.name);\n                }\n            }\n            SearchEvent::Summary {\n                total_displayed,\n                offset,\n                limit,\n                ..\n            } =\u003e {\n                println!(\n                    \"âœ… Displayed {} result{}\",\n                    total_displayed,\n                    if total_displayed == 1 { \"\" } else { \"s\" }\n                );\n\n                if offset \u003e 0 {\n                    println!(\"   (Starting from result #{})\", offset + 1);\n                }\n                if limit \u003e 0 \u0026\u0026 total_displayed \u003e= limit {\n                    println!(\"   (Limited to {limit} results)\");\n                }\n            }\n            SearchEvent::NoResults { query, .. } =\u003e {\n                println!(\"âŒ No results found matching '{query}'\");\n            }\n            SearchEvent::Finished { .. } =\u003e {\n                // Nothing needed for human-readable output - summary already printed\n            }\n        }\n    }\n}\n\n/// JSON output handler for search commands (JSONL format)\npub struct JsonSearchHandler;\n\nimpl JsonSearchHandler {\n    pub fn new() -\u003e Self {\n        Self\n    }\n}\n\nimpl SearchOutputHandler for JsonSearchHandler {\n    fn handle_event(\u0026mut self, event: SearchEvent) {\n        // Output each event as a single line of JSON\n        if let Ok(json) = serde_json::to_string(\u0026event) {\n            println!(\"{json}\");\n        } else {\n            eprintln!(\"âŒ Failed to serialize event to JSON\");\n        }\n    }\n}\n","traces":[{"line":45,"address":[3196992],"length":1,"stats":{"Line":0}},{"line":54,"address":[3198086,3200526,3197024],"length":1,"stats":{"Line":0}},{"line":55,"address":[3197049],"length":1,"stats":{"Line":0}},{"line":56,"address":[3197165],"length":1,"stats":{"Line":0}},{"line":62,"address":[3197182],"length":1,"stats":{"Line":0}},{"line":63,"address":[3197733,3197535,3197789,3197836],"length":1,"stats":{"Line":0}},{"line":70,"address":[3197603,3197511],"length":1,"stats":{"Line":0}},{"line":73,"address":[3197202],"length":1,"stats":{"Line":0}},{"line":75,"address":[3197237],"length":1,"stats":{"Line":0}},{"line":76,"address":[3198097],"length":1,"stats":{"Line":0}},{"line":77,"address":[3198101,3198183],"length":1,"stats":{"Line":0}},{"line":80,"address":[3198132],"length":1,"stats":{"Line":0}},{"line":81,"address":[3198440,3198585,3198231],"length":1,"stats":{"Line":0}},{"line":90,"address":[3198745],"length":1,"stats":{"Line":0}},{"line":91,"address":[3198898,3198812],"length":1,"stats":{"Line":0}},{"line":94,"address":[3198977,3198839],"length":1,"stats":{"Line":0}},{"line":95,"address":[3198985,3199062],"length":1,"stats":{"Line":0}},{"line":96,"address":[3199068],"length":1,"stats":{"Line":0}},{"line":99,"address":[3199032,3199169],"length":1,"stats":{"Line":0}},{"line":101,"address":[3198204,3198261],"length":1,"stats":{"Line":0}},{"line":104,"address":[3197257],"length":1,"stats":{"Line":0}},{"line":106,"address":[3197296],"length":1,"stats":{"Line":0}},{"line":107,"address":[3199198],"length":1,"stats":{"Line":0}},{"line":108,"address":[3199284,3199202],"length":1,"stats":{"Line":0}},{"line":111,"address":[3199233],"length":1,"stats":{"Line":0}},{"line":112,"address":[3199686,3199541,3199332],"length":1,"stats":{"Line":0}},{"line":120,"address":[3199846],"length":1,"stats":{"Line":0}},{"line":122,"address":[3199305,3199362],"length":1,"stats":{"Line":0}},{"line":125,"address":[3197345],"length":1,"stats":{"Line":0}},{"line":131,"address":[3199896],"length":1,"stats":{"Line":0}},{"line":137,"address":[3200078],"length":1,"stats":{"Line":0}},{"line":138,"address":[3200109],"length":1,"stats":{"Line":0}},{"line":140,"address":[3200084,3200256],"length":1,"stats":{"Line":0}},{"line":141,"address":[3200278],"length":1,"stats":{"Line":0}},{"line":144,"address":[3197392],"length":1,"stats":{"Line":0}},{"line":145,"address":[3197416,3200423],"length":1,"stats":{"Line":0}},{"line":164,"address":[3201032,3200624,3201179],"length":1,"stats":{"Line":0}},{"line":166,"address":[3200643,3200699,3200770],"length":1,"stats":{"Line":0}},{"line":167,"address":[3200860,3200798],"length":1,"stats":{"Line":0}},{"line":169,"address":[3201038,3200741],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":40},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","commands","show.rs"],"content":"use super::show_output::{HumanReadableShowHandler, JsonShowHandler, ShowEvent, ShowOutputHandler};\nuse lastfm_edit::LastFmEditClientImpl;\n\n/// Handle showing details for specific scrobbles by offset\npub async fn handle_show_scrobbles(\n    client: \u0026LastFmEditClientImpl,\n    offsets: \u0026[u64],\n    json_output: bool,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // No validation needed for 0-based indexing - all u64 values are valid\n\n    // Create appropriate handler based on output format\n    let mut handler: Box\u003cdyn ShowOutputHandler\u003e = if json_output {\n        Box::new(JsonShowHandler::new())\n    } else {\n        Box::new(HumanReadableShowHandler::new())\n    };\n\n    let max_offset = *offsets.iter().max().unwrap();\n\n    // Emit start event\n    handler.handle_event(ShowEvent::Started {\n        offsets: offsets.to_vec(),\n        max_offset,\n    });\n\n    // Sort offsets for better output organization\n    let mut sorted_offsets = offsets.to_vec();\n    sorted_offsets.sort_unstable();\n\n    let mut all_scrobbles = Vec::new();\n\n    // Collect scrobbles until we have enough to cover the maximum offset\n    let mut page = 1u32;\n    let needed_scrobbles = (max_offset + 1) as usize; // +1 because 0-indexed\n\n    while all_scrobbles.len() \u003c needed_scrobbles {\n        match client.get_recent_scrobbles(page).await {\n            Ok(scrobbles) =\u003e {\n                let scrobbles_found = scrobbles.len();\n                if scrobbles_found == 0 {\n                    handler.handle_event(ShowEvent::CollectingPage {\n                        page,\n                        scrobbles_found: 0,\n                        total_collected: all_scrobbles.len(),\n                    });\n                    break;\n                }\n\n                all_scrobbles.extend(scrobbles);\n                handler.handle_event(ShowEvent::CollectingPage {\n                    page,\n                    scrobbles_found,\n                    total_collected: all_scrobbles.len(),\n                });\n                page += 1;\n\n                // Stop if we've collected enough\n                if all_scrobbles.len() \u003e= needed_scrobbles {\n                    break;\n                }\n            }\n            Err(_e) =\u003e {\n                handler.handle_event(ShowEvent::CollectingPage {\n                    page,\n                    scrobbles_found: 0,\n                    total_collected: all_scrobbles.len(),\n                });\n                break;\n            }\n        }\n    }\n\n    // Check if we have enough scrobbles for all requested offsets\n    let unavailable_offsets: Vec\u003cu64\u003e = offsets\n        .iter()\n        .filter(|\u0026\u0026offset| offset \u003e= all_scrobbles.len() as u64)\n        .copied()\n        .collect();\n\n    // Emit collection complete event\n    handler.handle_event(ShowEvent::CollectionComplete {\n        total_scrobbles: all_scrobbles.len(),\n        unavailable_offsets: unavailable_offsets.clone(),\n    });\n\n    let mut shown_count = 0;\n\n    // Show details for each requested offset\n    for \u0026offset in \u0026sorted_offsets {\n        if offset \u003c all_scrobbles.len() as u64 {\n            let scrobble = \u0026all_scrobbles[offset as usize];\n            handler.handle_event(ShowEvent::ScrobbleDetails {\n                offset,\n                scrobble: scrobble.clone(),\n            });\n            shown_count += 1;\n        }\n    }\n\n    // Emit finished event\n    handler.handle_event(ShowEvent::Finished {\n        total_shown: shown_count,\n        unavailable_count: unavailable_offsets.len(),\n    });\n\n    Ok(())\n}\n","traces":[{"line":5,"address":[3609520],"length":1,"stats":{"Line":0}},{"line":13,"address":[3654054,3653892,3654174],"length":1,"stats":{"Line":0}},{"line":14,"address":[3653948,3654128],"length":1,"stats":{"Line":0}},{"line":16,"address":[3653941,3654008],"length":1,"stats":{"Line":0}},{"line":19,"address":[3654086,3654236],"length":1,"stats":{"Line":0}},{"line":22,"address":[3654308,3654386],"length":1,"stats":{"Line":0}},{"line":23,"address":[3654340],"length":1,"stats":{"Line":0}},{"line":28,"address":[3654454],"length":1,"stats":{"Line":0}},{"line":29,"address":[3654584,3654483],"length":1,"stats":{"Line":0}},{"line":31,"address":[3654591],"length":1,"stats":{"Line":0}},{"line":34,"address":[3654625],"length":1,"stats":{"Line":0}},{"line":35,"address":[3654685,3654643],"length":1,"stats":{"Line":0}},{"line":37,"address":[3654756,3655886,3654683],"length":1,"stats":{"Line":0}},{"line":38,"address":[3613591],"length":1,"stats":{"Line":0}},{"line":39,"address":[3655196],"length":1,"stats":{"Line":0}},{"line":40,"address":[3655312,3655236],"length":1,"stats":{"Line":0}},{"line":41,"address":[3655320],"length":1,"stats":{"Line":0}},{"line":42,"address":[3655505,3655326],"length":1,"stats":{"Line":0}},{"line":43,"address":[3655358],"length":1,"stats":{"Line":0}},{"line":45,"address":[3655371],"length":1,"stats":{"Line":0}},{"line":50,"address":[3655397],"length":1,"stats":{"Line":0}},{"line":51,"address":[3655691,3655581],"length":1,"stats":{"Line":0}},{"line":52,"address":[3655613],"length":1,"stats":{"Line":0}},{"line":54,"address":[3655626],"length":1,"stats":{"Line":0}},{"line":56,"address":[3655742,3655828],"length":1,"stats":{"Line":0}},{"line":59,"address":[3655794,3655857],"length":1,"stats":{"Line":0}},{"line":63,"address":[3655090],"length":1,"stats":{"Line":0}},{"line":64,"address":[3655122,3656230],"length":1,"stats":{"Line":0}},{"line":65,"address":[3655154],"length":1,"stats":{"Line":0}},{"line":67,"address":[3655167],"length":1,"stats":{"Line":0}},{"line":75,"address":[3656346,3655916],"length":1,"stats":{"Line":0}},{"line":77,"address":[3657454,3657440,3656323],"length":1,"stats":{"Line":0}},{"line":82,"address":[3656539,3656399],"length":1,"stats":{"Line":0}},{"line":83,"address":[3656425],"length":1,"stats":{"Line":0}},{"line":84,"address":[3656491],"length":1,"stats":{"Line":0}},{"line":87,"address":[3656607],"length":1,"stats":{"Line":0}},{"line":90,"address":[3656619],"length":1,"stats":{"Line":0}},{"line":91,"address":[3656769,3657408,3657100],"length":1,"stats":{"Line":0}},{"line":92,"address":[3657114],"length":1,"stats":{"Line":0}},{"line":93,"address":[3657221,3657165],"length":1,"stats":{"Line":0}},{"line":95,"address":[3657199],"length":1,"stats":{"Line":0}},{"line":97,"address":[3657413,3657373],"length":1,"stats":{"Line":0}},{"line":102,"address":[3656803,3656882],"length":1,"stats":{"Line":0}},{"line":103,"address":[3656829],"length":1,"stats":{"Line":0}},{"line":104,"address":[3656850],"length":1,"stats":{"Line":0}},{"line":107,"address":[3656926],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","commands","show_output.rs"],"content":"use lastfm_edit::Track;\nuse serde::{Deserialize, Serialize};\n\n/// Events emitted by show commands\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(tag = \"type\")]\npub enum ShowEvent {\n    /// Starting to collect scrobbles for the requested offsets\n    Started { offsets: Vec\u003cu64\u003e, max_offset: u64 },\n    /// Collecting scrobbles from a specific page\n    CollectingPage {\n        page: u32,\n        scrobbles_found: usize,\n        total_collected: usize,\n    },\n    /// Finished collecting, showing summary\n    CollectionComplete {\n        total_scrobbles: usize,\n        unavailable_offsets: Vec\u003cu64\u003e,\n    },\n    /// Showing details for a specific scrobble\n    ScrobbleDetails { offset: u64, scrobble: Track },\n    /// Requested offset is not available (beyond available scrobbles)\n    OffsetUnavailable { offset: u64, total_available: usize },\n    /// Show command finished\n    Finished {\n        total_shown: usize,\n        unavailable_count: usize,\n    },\n}\n\n/// Trait for handling show command output\npub trait ShowOutputHandler {\n    fn handle_event(\u0026mut self, event: ShowEvent);\n}\n\n/// Human-readable output handler for show commands\npub struct HumanReadableShowHandler;\n\nimpl HumanReadableShowHandler {\n    pub fn new() -\u003e Self {\n        Self\n    }\n}\n\nimpl ShowOutputHandler for HumanReadableShowHandler {\n    fn handle_event(\u0026mut self, event: ShowEvent) {\n        match event {\n            ShowEvent::Started {\n                offsets,\n                max_offset,\n            } =\u003e {\n                println!(\n                    \"ğŸ“‹ Showing details for scrobbles at offsets: {}\",\n                    offsets\n                        .iter()\n                        .map(|n| n.to_string())\n                        .collect::\u003cVec\u003c_\u003e\u003e()\n                        .join(\", \")\n                );\n                println!(\"\\nğŸ“„ Collecting recent scrobbles to reach offset {max_offset}...\");\n            }\n            ShowEvent::CollectingPage {\n                page,\n                scrobbles_found,\n                total_collected,\n            } =\u003e {\n                if scrobbles_found \u003e 0 {\n                    println!(\n                        \"  Page {page}: Found {scrobbles_found} scrobbles (total: {total_collected})\"\n                    );\n                } else {\n                    println!(\"  No more scrobbles found on page {page}\");\n                }\n            }\n            ShowEvent::CollectionComplete {\n                total_scrobbles,\n                unavailable_offsets,\n            } =\u003e {\n                println!(\"\\nğŸ“Š Total scrobbles collected: {total_scrobbles}\");\n\n                if !unavailable_offsets.is_empty() {\n                    println!(\n                        \"\\nâš ï¸  The following offsets are not available (you only have {total_scrobbles} scrobbles):\"\n                    );\n                    for offset in \u0026unavailable_offsets {\n                        println!(\"    - Offset {offset}\");\n                    }\n                    println!();\n                }\n\n                println!(\"ğŸµ Scrobble Details:\");\n                println!(\"{}\", \"=\".repeat(80));\n            }\n            ShowEvent::ScrobbleDetails { offset, scrobble } =\u003e {\n                println!(\n                    \"\\nğŸ“ Offset {offset} ({}{})\",\n                    offset,\n                    match offset {\n                        0 =\u003e \"st most recent (index 0)\",\n                        1 =\u003e \"nd most recent (index 1)\",\n                        2 =\u003e \"rd most recent (index 2)\",\n                        _ =\u003e \"th most recent\",\n                    }\n                );\n\n                println!(\"   ğŸ¤ Artist: {}\", scrobble.artist);\n                println!(\"   ğŸµ Track:  {}\", scrobble.name);\n                println!(\"   ğŸ”¢ Play Count: {}\", scrobble.playcount);\n\n                if let Some(album) = \u0026scrobble.album {\n                    println!(\"   ğŸ’¿ Album:  {album}\");\n                } else {\n                    println!(\"   ğŸ’¿ Album:  (no album info)\");\n                }\n\n                if let Some(album_artist) = \u0026scrobble.album_artist {\n                    if album_artist != \u0026scrobble.artist {\n                        println!(\"   ğŸ‘¥ Album Artist: {album_artist}\");\n                    }\n                }\n\n                if let Some(timestamp) = scrobble.timestamp {\n                    use super::utils::format_timestamp;\n                    println!(\n                        \"   ğŸ• Timestamp: {} ({})\",\n                        timestamp,\n                        format_timestamp(timestamp)\n                    );\n                } else {\n                    println!(\"   ğŸ• Timestamp: (no timestamp)\");\n                }\n            }\n            ShowEvent::OffsetUnavailable { .. } =\u003e {\n                // This is handled in CollectionComplete for better grouping\n            }\n            ShowEvent::Finished {\n                unavailable_count, ..\n            } =\u003e {\n                if unavailable_count \u003e 0 {\n                    println!(\n                        \"\\nâŒ Could not show {unavailable_count} offset(s) due to insufficient scrobbles\"\n                    );\n                }\n                println!(\"\\nâœ… Finished showing scrobble details\");\n            }\n        }\n    }\n}\n\n/// JSON output handler for show commands (JSONL format)\npub struct JsonShowHandler;\n\nimpl JsonShowHandler {\n    pub fn new() -\u003e Self {\n        Self\n    }\n}\n\nimpl ShowOutputHandler for JsonShowHandler {\n    fn handle_event(\u0026mut self, event: ShowEvent) {\n        // Output each event as a single line of JSON\n        if let Ok(json) = serde_json::to_string(\u0026event) {\n            println!(\"{json}\");\n        } else {\n            eprintln!(\"âŒ Failed to serialize event to JSON\");\n        }\n    }\n}\n","traces":[{"line":47,"address":[3153776,3154818],"length":1,"stats":{"Line":0}},{"line":48,"address":[3153799],"length":1,"stats":{"Line":0}},{"line":49,"address":[3153888],"length":1,"stats":{"Line":0}},{"line":53,"address":[3154494,3153908,3154338],"length":1,"stats":{"Line":0}},{"line":61,"address":[3154704],"length":1,"stats":{"Line":0}},{"line":63,"address":[3153946],"length":1,"stats":{"Line":0}},{"line":68,"address":[3153970],"length":1,"stats":{"Line":0}},{"line":69,"address":[3154939],"length":1,"stats":{"Line":0}},{"line":73,"address":[3154837],"length":1,"stats":{"Line":0}},{"line":76,"address":[3153998],"length":1,"stats":{"Line":0}},{"line":80,"address":[3154034,3155189],"length":1,"stats":{"Line":0}},{"line":82,"address":[3155266],"length":1,"stats":{"Line":0}},{"line":83,"address":[3155343,3155287],"length":1,"stats":{"Line":0}},{"line":86,"address":[3155420],"length":1,"stats":{"Line":0}},{"line":87,"address":[3155624,3155547],"length":1,"stats":{"Line":0}},{"line":89,"address":[3155574],"length":1,"stats":{"Line":0}},{"line":92,"address":[3155314,3155698],"length":1,"stats":{"Line":0}},{"line":93,"address":[3155717],"length":1,"stats":{"Line":0}},{"line":95,"address":[3154072],"length":1,"stats":{"Line":0}},{"line":96,"address":[3155926],"length":1,"stats":{"Line":0}},{"line":107,"address":[3156306],"length":1,"stats":{"Line":0}},{"line":108,"address":[3156402],"length":1,"stats":{"Line":0}},{"line":109,"address":[3156498],"length":1,"stats":{"Line":0}},{"line":111,"address":[3156594],"length":1,"stats":{"Line":0}},{"line":112,"address":[3156714,3156661],"length":1,"stats":{"Line":0}},{"line":114,"address":[3156841,3156688],"length":1,"stats":{"Line":0}},{"line":117,"address":[3156867,3156785],"length":1,"stats":{"Line":0}},{"line":118,"address":[3156945,3156875],"length":1,"stats":{"Line":0}},{"line":119,"address":[3156951],"length":1,"stats":{"Line":0}},{"line":123,"address":[3157049,3156922],"length":1,"stats":{"Line":0}},{"line":125,"address":[3157121],"length":1,"stats":{"Line":0}},{"line":131,"address":[3157338,3157092],"length":1,"stats":{"Line":0}},{"line":137,"address":[3154256],"length":1,"stats":{"Line":0}},{"line":140,"address":[3154268],"length":1,"stats":{"Line":0}},{"line":141,"address":[3157399],"length":1,"stats":{"Line":0}},{"line":145,"address":[3157359],"length":1,"stats":{"Line":0}},{"line":161,"address":[3157928,3157520,3158075],"length":1,"stats":{"Line":0}},{"line":163,"address":[3157666,3157539,3157595],"length":1,"stats":{"Line":0}},{"line":164,"address":[3157694,3157756],"length":1,"stats":{"Line":0}},{"line":166,"address":[3157934,3157637],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":40},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","commands","utils.rs"],"content":"use lastfm_edit::{LastFmEditClientImpl, SessionPersistence};\nuse std::env;\nuse std::io::{self, Write};\n\n/// Print to stdout in normal mode, suppress in JSON mode\nfn output_message(json_mode: bool, message: \u0026str) {\n    if !json_mode {\n        println!(\"{message}\");\n    }\n    // In JSON mode, suppress all session messages completely\n}\n\n/// Load existing session or create a new client with fresh login.\n///\n/// This function implements the session management logic:\n/// 1. Try to load a saved session from XDG directory\n/// 2. Validate the loaded session\n/// 3. If session is invalid or doesn't exist, perform fresh login\n/// 4. Save the new session for future use\npub async fn load_or_create_client(\n    username: \u0026str,\n    password: \u0026str,\n    json_mode: bool,\n) -\u003e Result\u003cLastFmEditClientImpl, Box\u003cdyn std::error::Error\u003e\u003e {\n    // Check if we have a saved session\n    if SessionPersistence::session_exists(username) {\n        output_message(\n            json_mode,\n            \u0026format!(\"ğŸ“ Found existing session for user '{username}', attempting to restore...\"),\n        );\n\n        match SessionPersistence::load_session(username) {\n            Ok(session) =\u003e {\n                output_message(json_mode, \"ğŸ“¥ Session loaded successfully\");\n\n                // Create client with loaded session\n                let http_client = http_client::native::NativeClient::new();\n                let client = LastFmEditClientImpl::from_session(Box::new(http_client), session);\n\n                // Validate the session\n                output_message(json_mode, \"ğŸ” Validating session...\");\n                if client.validate_session().await {\n                    output_message(json_mode, \"âœ… Session is valid, using saved session\");\n                    return Ok(client);\n                } else {\n                    output_message(json_mode, \"âŒ Session is invalid or expired\");\n                    // Remove invalid session file\n                    let _ = SessionPersistence::remove_session(username);\n                }\n            }\n            Err(e) =\u003e {\n                output_message(json_mode, \u0026format!(\"âŒ Failed to load session: {e}\"));\n                // Remove corrupted session file\n                let _ = SessionPersistence::remove_session(username);\n            }\n        }\n    }\n\n    // No valid session found, perform fresh login\n    output_message(\n        json_mode,\n        \"ğŸ” No valid session found, performing fresh login...\",\n    );\n    let http_client = http_client::native::NativeClient::new();\n    let client =\n        LastFmEditClientImpl::login_with_credentials(Box::new(http_client), username, password)\n            .await?;\n\n    // Save the new session\n    output_message(json_mode, \"ğŸ’¾ Saving session for future use...\");\n    let session = client.get_session();\n    if let Err(e) = SessionPersistence::save_session(\u0026session) {\n        output_message(\n            json_mode,\n            \u0026format!(\"âš ï¸  Warning: Failed to save session: {e}\"),\n        );\n        output_message(json_mode, \"   (You'll need to login again next time)\");\n    } else {\n        output_message(json_mode, \"âœ… Session saved successfully\");\n    }\n\n    Ok(client)\n}\n\n/// Get username and password from environment variables\npub fn get_credentials() -\u003e Result\u003c(String, String), Box\u003cdyn std::error::Error\u003e\u003e {\n    let username = env::var(\"LASTFM_EDIT_USERNAME\")\n        .map_err(|_| \"LASTFM_EDIT_USERNAME environment variable not set\")?;\n    let password = env::var(\"LASTFM_EDIT_PASSWORD\")\n        .map_err(|_| \"LASTFM_EDIT_PASSWORD environment variable not set\")?;\n    Ok((username, password))\n}\n\n/// Format a Unix timestamp into a human-readable string\npub fn format_timestamp(timestamp: u64) -\u003e String {\n    // This is a simple formatter - in a full implementation you might want to use chrono\n    // For now, just show it as \"X seconds ago\" or the raw timestamp\n    let now = std::time::SystemTime::now()\n        .duration_since(std::time::UNIX_EPOCH)\n        .unwrap()\n        .as_secs();\n\n    if timestamp \u003c= now {\n        let ago = now - timestamp;\n        if ago \u003c 60 {\n            format!(\"{ago} seconds ago\")\n        } else if ago \u003c 3600 {\n            format!(\"{} minutes ago\", ago / 60)\n        } else if ago \u003c 86400 {\n            format!(\"{} hours ago\", ago / 3600)\n        } else {\n            format!(\"{} days ago\", ago / 86400)\n        }\n    } else {\n        format!(\"{timestamp} (future timestamp)\")\n    }\n}\n\n/// Parse a range string like \"1-3\" or \"1640995200-1641000000\"\npub fn parse_range(\n    range_str: \u0026str,\n    range_type: \u0026str,\n) -\u003e Result\u003c(u64, u64), Box\u003cdyn std::error::Error\u003e\u003e {\n    let parts: Vec\u003c\u0026str\u003e = range_str.split('-').collect();\n    if parts.len() != 2 {\n        return Err(format!(\n            \"Invalid {range_type} range format. Expected 'start-end', got '{range_str}'\"\n        )\n        .into());\n    }\n\n    let start: u64 = parts[0]\n        .parse()\n        .map_err(|_| format!(\"Invalid start {range_type}: '{}'\", parts[0]))?;\n    let end: u64 = parts[1]\n        .parse()\n        .map_err(|_| format!(\"Invalid end {range_type}: '{}'\", parts[1]))?;\n\n    if start \u003e end {\n        return Err(format!(\n            \"Start {range_type} ({start}) cannot be greater than end {range_type} ({end})\"\n        )\n        .into());\n    }\n\n    Ok((start, end))\n}\n\n/// Try to restore the most recent session from available saved sessions.\n///\n/// This function looks for all saved sessions and attempts to restore the most recent valid one.\n/// Returns Some(client) if a valid session was found and restored, None otherwise.\npub async fn try_restore_most_recent_session(json_mode: bool) -\u003e Option\u003cLastFmEditClientImpl\u003e {\n    // Get list of all saved users\n    let saved_users = match SessionPersistence::list_saved_users() {\n        Ok(users) =\u003e users,\n        Err(_) =\u003e return None,\n    };\n\n    if saved_users.is_empty() {\n        return None;\n    }\n\n    // Try each saved user session, starting with the first one found\n    // In a more sophisticated implementation, we could sort by last modified time\n    for username in saved_users {\n        output_message(\n            json_mode,\n            \u0026format!(\"ğŸ“ Attempting to restore session for user '{username}'...\"),\n        );\n\n        match SessionPersistence::load_session(\u0026username) {\n            Ok(session) =\u003e {\n                output_message(json_mode, \"ğŸ“¥ Session loaded successfully\");\n\n                // Create client with loaded session\n                let http_client = http_client::native::NativeClient::new();\n                let client = LastFmEditClientImpl::from_session(Box::new(http_client), session);\n\n                // Validate the session\n                output_message(json_mode, \"ğŸ” Validating session...\");\n                if client.validate_session().await {\n                    output_message(\n                        json_mode,\n                        \u0026format!(\"âœ… Session is valid for user '{username}'\"),\n                    );\n                    return Some(client);\n                } else {\n                    output_message(\n                        json_mode,\n                        \u0026format!(\"âŒ Session is invalid or expired for user '{username}'\"),\n                    );\n                    // Remove invalid session file\n                    let _ = SessionPersistence::remove_session(\u0026username);\n                }\n            }\n            Err(e) =\u003e {\n                output_message(\n                    json_mode,\n                    \u0026format!(\"âŒ Failed to load session for user '{username}': {e}\"),\n                );\n                // Remove corrupted session file\n                let _ = SessionPersistence::remove_session(\u0026username);\n            }\n        }\n    }\n\n    None\n}\n\n/// Prompt the user for their Last.fm credentials interactively.\n///\n/// This function prompts for username and password via stdin, hiding password input.\n/// Returns (username, password) tuple.\npub fn prompt_for_credentials() -\u003e (String, String) {\n    print!(\"Last.fm username: \");\n    io::stdout().flush().unwrap();\n\n    let mut username = String::new();\n    io::stdin().read_line(\u0026mut username).unwrap();\n    let username = username.trim().to_string();\n\n    // For password, we'll use a simple prompt for now\n    // In a more sophisticated implementation, we could use a crate like `rpassword` to hide input\n    print!(\"Last.fm password: \");\n    io::stdout().flush().unwrap();\n\n    let mut password = String::new();\n    io::stdin().read_line(\u0026mut password).unwrap();\n    let password = password.trim().to_string();\n\n    (username, password)\n}\n","traces":[{"line":6,"address":[3643824],"length":1,"stats":{"Line":0}},{"line":7,"address":[3643849],"length":1,"stats":{"Line":0}},{"line":8,"address":[3643853],"length":1,"stats":{"Line":0}},{"line":20,"address":[3643936],"length":1,"stats":{"Line":0}},{"line":26,"address":[3306502,3306363],"length":1,"stats":{"Line":0}},{"line":28,"address":[3306542],"length":1,"stats":{"Line":0}},{"line":29,"address":[3306557],"length":1,"stats":{"Line":0}},{"line":32,"address":[3306791],"length":1,"stats":{"Line":0}},{"line":33,"address":[3306951],"length":1,"stats":{"Line":0}},{"line":34,"address":[3307061],"length":1,"stats":{"Line":0}},{"line":37,"address":[3307137],"length":1,"stats":{"Line":0}},{"line":38,"address":[3307164],"length":1,"stats":{"Line":0}},{"line":41,"address":[3307330],"length":1,"stats":{"Line":0}},{"line":42,"address":[3613951],"length":1,"stats":{"Line":0}},{"line":43,"address":[3308141],"length":1,"stats":{"Line":0}},{"line":44,"address":[3308481],"length":1,"stats":{"Line":0}},{"line":46,"address":[3308110],"length":1,"stats":{"Line":0}},{"line":48,"address":[3308175],"length":1,"stats":{"Line":0}},{"line":51,"address":[3306868],"length":1,"stats":{"Line":0}},{"line":52,"address":[3306906,3307578],"length":1,"stats":{"Line":0}},{"line":54,"address":[3307793],"length":1,"stats":{"Line":0}},{"line":61,"address":[3306508],"length":1,"stats":{"Line":0}},{"line":64,"address":[3308267],"length":1,"stats":{"Line":0}},{"line":65,"address":[3308804,3308346,3308967,3308424,3309043,3308294],"length":1,"stats":{"Line":0}},{"line":67,"address":[3308417,3309011,3308932,3308454,3308642,3306438],"length":1,"stats":{"Line":0}},{"line":70,"address":[3309340],"length":1,"stats":{"Line":0}},{"line":71,"address":[3309412],"length":1,"stats":{"Line":0}},{"line":72,"address":[3309515,3309439],"length":1,"stats":{"Line":0}},{"line":74,"address":[3309591],"length":1,"stats":{"Line":0}},{"line":75,"address":[3309711,3309606],"length":1,"stats":{"Line":0}},{"line":77,"address":[3309926],"length":1,"stats":{"Line":0}},{"line":79,"address":[3309633,3310063],"length":1,"stats":{"Line":0}},{"line":82,"address":[3310087],"length":1,"stats":{"Line":0}},{"line":86,"address":[3644032,3644679,3644673],"length":1,"stats":{"Line":0}},{"line":87,"address":[3644048,3644165],"length":1,"stats":{"Line":0}},{"line":88,"address":[3644139],"length":1,"stats":{"Line":0}},{"line":89,"address":[3644322,3644425,3644234],"length":1,"stats":{"Line":0}},{"line":90,"address":[3310512,3310513],"length":1,"stats":{"Line":0}},{"line":91,"address":[3644494],"length":1,"stats":{"Line":0}},{"line":95,"address":[3644704],"length":1,"stats":{"Line":0}},{"line":98,"address":[3644726],"length":1,"stats":{"Line":0}},{"line":103,"address":[3644812],"length":1,"stats":{"Line":0}},{"line":104,"address":[3645002,3644946,3644987],"length":1,"stats":{"Line":0}},{"line":105,"address":[3644992],"length":1,"stats":{"Line":0}},{"line":106,"address":[3645032],"length":1,"stats":{"Line":0}},{"line":107,"address":[3645015],"length":1,"stats":{"Line":0}},{"line":108,"address":[3645171],"length":1,"stats":{"Line":0}},{"line":109,"address":[3645151],"length":1,"stats":{"Line":0}},{"line":110,"address":[3645473],"length":1,"stats":{"Line":0}},{"line":112,"address":[3645322],"length":1,"stats":{"Line":0}},{"line":115,"address":[3644819],"length":1,"stats":{"Line":0}},{"line":120,"address":[3647035,3645632,3647029],"length":1,"stats":{"Line":0}},{"line":124,"address":[3645669],"length":1,"stats":{"Line":0}},{"line":125,"address":[3645738,3645803],"length":1,"stats":{"Line":0}},{"line":126,"address":[3646822,3645844],"length":1,"stats":{"Line":0}},{"line":132,"address":[3646820,3645876,3645809,3646035],"length":1,"stats":{"Line":0}},{"line":134,"address":[3310544,3310580],"length":1,"stats":{"Line":0}},{"line":135,"address":[3646818,3646292,3646092],"length":1,"stats":{"Line":0}},{"line":137,"address":[3310836,3310800],"length":1,"stats":{"Line":0}},{"line":139,"address":[3646349],"length":1,"stats":{"Line":0}},{"line":140,"address":[3646483,3646520],"length":1,"stats":{"Line":0}},{"line":146,"address":[3646404],"length":1,"stats":{"Line":0}},{"line":153,"address":[3314418,3311943,3311056,3311237,3311295,3311103],"length":1,"stats":{"Line":0}},{"line":155,"address":[3311218,3311345],"length":1,"stats":{"Line":0}},{"line":156,"address":[3311428],"length":1,"stats":{"Line":0}},{"line":157,"address":[3311373],"length":1,"stats":{"Line":0}},{"line":160,"address":[3311675,3311587],"length":1,"stats":{"Line":0}},{"line":161,"address":[3311761],"length":1,"stats":{"Line":0}},{"line":166,"address":[3311849,3312853,3311681,3311781],"length":1,"stats":{"Line":0}},{"line":168,"address":[3312933],"length":1,"stats":{"Line":0}},{"line":169,"address":[3313144,3312951],"length":1,"stats":{"Line":0}},{"line":172,"address":[3313359],"length":1,"stats":{"Line":0}},{"line":173,"address":[3313556],"length":1,"stats":{"Line":0}},{"line":174,"address":[3313669],"length":1,"stats":{"Line":0}},{"line":177,"address":[3313703],"length":1,"stats":{"Line":0}},{"line":178,"address":[3313730],"length":1,"stats":{"Line":0}},{"line":181,"address":[3313892],"length":1,"stats":{"Line":0}},{"line":182,"address":[3312003,3313926,3311969,3312279,3311267],"length":1,"stats":{"Line":0}},{"line":184,"address":[3312332],"length":1,"stats":{"Line":0}},{"line":185,"address":[3312353,3314424],"length":1,"stats":{"Line":0}},{"line":187,"address":[3314642],"length":1,"stats":{"Line":0}},{"line":190,"address":[3312285],"length":1,"stats":{"Line":0}},{"line":191,"address":[3312306,3312382],"length":1,"stats":{"Line":0}},{"line":194,"address":[3312612],"length":1,"stats":{"Line":0}},{"line":197,"address":[3313471],"length":1,"stats":{"Line":0}},{"line":199,"address":[3313509],"length":1,"stats":{"Line":0}},{"line":200,"address":[3314062,3313527],"length":1,"stats":{"Line":0}},{"line":203,"address":[3314320],"length":1,"stats":{"Line":0}},{"line":208,"address":[3313003],"length":1,"stats":{"Line":0}},{"line":215,"address":[3648007,3648035,3647088],"length":1,"stats":{"Line":0}},{"line":216,"address":[3647111],"length":1,"stats":{"Line":0}},{"line":217,"address":[3647168],"length":1,"stats":{"Line":0}},{"line":219,"address":[3647229],"length":1,"stats":{"Line":0}},{"line":220,"address":[3647305,3647234],"length":1,"stats":{"Line":0}},{"line":221,"address":[3647382],"length":1,"stats":{"Line":0}},{"line":225,"address":[3647463,3647530],"length":1,"stats":{"Line":0}},{"line":226,"address":[3647549],"length":1,"stats":{"Line":0}},{"line":228,"address":[3647633],"length":1,"stats":{"Line":0}},{"line":229,"address":[3647640,3647705],"length":1,"stats":{"Line":0}},{"line":230,"address":[3647782],"length":1,"stats":{"Line":0}},{"line":232,"address":[3647863],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":101},{"path":["/","home","imalison","Projects","lastfm-edit","src","bin","lastfm-edit.rs"],"content":"use clap::Parser;\nuse log::LevelFilter;\n\nmod commands;\nuse commands::{\n    execute_command, utils::get_credentials, utils::load_or_create_client,\n    utils::prompt_for_credentials, utils::try_restore_most_recent_session, Commands,\n};\n\n/// Last.fm scrobble metadata editor\n#[derive(Parser)]\n#[command(\n    name = \"lastfm-edit\",\n    about = \"Last.fm scrobble metadata editor\",\n    long_about = None\n)]\nstruct Cli {\n    /// Increase verbosity level (use multiple times for more verbose output)\n    /// -v: info for lastfm-edit, -vv: debug for lastfm-edit, -vvv: trace for lastfm-edit\n    /// -vvvv: trace for lastfm-edit + info for all, -vvvvv: trace for lastfm-edit + debug for all, -vvvvvv: trace for all\n    #[arg(short, long, action = clap::ArgAction::Count, global = true)]\n    verbose: u8,\n\n    /// Last.fm username (overrides LASTFM_EDIT_USERNAME environment variable)\n    #[arg(short, long, global = true)]\n    username: Option\u003cString\u003e,\n\n    /// Last.fm password (overrides LASTFM_EDIT_PASSWORD environment variable)\n    #[arg(short, long, global = true)]\n    password: Option\u003cString\u003e,\n\n    /// Output results in JSON format instead of human-readable text\n    #[arg(long, global = true)]\n    json: bool,\n\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let args = Cli::parse();\n\n    // Configure logging based on verbosity level (cumulative)\n    let mut builder = env_logger::Builder::from_default_env();\n    builder.filter_level(LevelFilter::Off); // Start with everything off\n\n    match args.verbose {\n        0 =\u003e {\n            // Default: only warnings and errors for all\n            builder.filter_level(LevelFilter::Warn);\n        }\n        1 =\u003e {\n            // Info for lastfm-edit\n            builder.filter_module(\"lastfm_edit\", LevelFilter::Info);\n        }\n        2 =\u003e {\n            // Info + Debug for lastfm-edit\n            builder.filter_module(\"lastfm_edit\", LevelFilter::Debug);\n        }\n        3 =\u003e {\n            // Info + Debug + Trace for lastfm-edit\n            builder.filter_module(\"lastfm_edit\", LevelFilter::Trace);\n        }\n        4 =\u003e {\n            // Trace for lastfm-edit + Info for all others\n            builder.filter_module(\"lastfm_edit\", LevelFilter::Trace);\n            builder.filter_level(LevelFilter::Info);\n        }\n        5 =\u003e {\n            // Trace for lastfm-edit + Debug for all others\n            builder.filter_module(\"lastfm_edit\", LevelFilter::Trace);\n            builder.filter_level(LevelFilter::Debug);\n        }\n        _ =\u003e {\n            // Trace for everything (6+)\n            builder.filter_level(LevelFilter::Trace);\n        }\n    }\n\n    builder.init();\n\n    if args.verbose \u003e 0 {\n        log::info!(\"ğŸ” Verbose mode enabled (level {})\", args.verbose);\n    }\n\n    // Try to get credentials from command line args or environment first\n    let (username, password) = if let (Some(u), Some(p)) = (\u0026args.username, \u0026args.password) {\n        (Some(u.clone()), Some(p.clone()))\n    } else if args.username.is_some() || args.password.is_some() {\n        eprintln!(\"âŒ Error: Both username and password must be provided together\");\n        eprintln!(\"Either provide both --username and --password, or set environment variables\");\n        std::process::exit(1);\n    } else {\n        match get_credentials() {\n            Ok((u, p)) =\u003e (Some(u), Some(p)),\n            Err(_) =\u003e (None, None), // No credentials provided\n        }\n    };\n\n    // First, try to restore the most recent session if no credentials were provided\n    let client = if username.is_none() \u0026\u0026 password.is_none() {\n        match try_restore_most_recent_session(args.json).await {\n            Some(client) =\u003e {\n                if !args.json {\n                    println!(\"âœ… Restored most recent session\");\n                }\n                client\n            }\n            None =\u003e {\n                // No valid session found, prompt for credentials\n                if !args.json {\n                    println!(\"ğŸ” No valid saved session found. Please provide credentials:\");\n                }\n                let (prompted_username, prompted_password) = prompt_for_credentials();\n                log::info!(\"ğŸ” Using username: {prompted_username}\");\n\n                match load_or_create_client(\u0026prompted_username, \u0026prompted_password, args.json).await\n                {\n                    Ok(client) =\u003e client,\n                    Err(e) =\u003e {\n                        eprintln!(\"âŒ Failed to create client: {e}\");\n                        std::process::exit(1);\n                    }\n                }\n            }\n        }\n    } else {\n        // Credentials were provided, use them directly\n        let username = username.unwrap();\n        let password = password.unwrap();\n        log::info!(\"ğŸ” Using username: {username}\");\n\n        match load_or_create_client(\u0026username, \u0026password, args.json).await {\n            Ok(client) =\u003e client,\n            Err(e) =\u003e {\n                eprintln!(\"âŒ Failed to create client: {e}\");\n                std::process::exit(1);\n            }\n        }\n    };\n\n    log::info!(\"âœ… Client ready\");\n\n    // Execute the command\n    if let Err(e) = execute_command(args.command, \u0026client, args.json).await {\n        eprintln!(\"âŒ Command failed: {e}\");\n        std::process::exit(1);\n    }\n\n    Ok(())\n}\n","traces":[{"line":41,"address":[3328245,3328251,3327776],"length":1,"stats":{"Line":0}},{"line":42,"address":[3266442],"length":1,"stats":{"Line":0}},{"line":45,"address":[3266683],"length":1,"stats":{"Line":0}},{"line":46,"address":[3266775],"length":1,"stats":{"Line":0}},{"line":48,"address":[3266869],"length":1,"stats":{"Line":0}},{"line":51,"address":[3266971,3267319],"length":1,"stats":{"Line":0}},{"line":55,"address":[3267020,3267347],"length":1,"stats":{"Line":0}},{"line":59,"address":[3267081,3267349],"length":1,"stats":{"Line":0}},{"line":63,"address":[3267351,3267142],"length":1,"stats":{"Line":0}},{"line":67,"address":[3267203],"length":1,"stats":{"Line":0}},{"line":68,"address":[3267353],"length":1,"stats":{"Line":0}},{"line":72,"address":[3267261],"length":1,"stats":{"Line":0}},{"line":73,"address":[3267401],"length":1,"stats":{"Line":0}},{"line":77,"address":[3267449,3266922],"length":1,"stats":{"Line":0}},{"line":81,"address":[3267321],"length":1,"stats":{"Line":0}},{"line":83,"address":[3267454],"length":1,"stats":{"Line":0}},{"line":84,"address":[3267578],"length":1,"stats":{"Line":0}},{"line":88,"address":[3268315,3267471,3267933,3268009],"length":1,"stats":{"Line":0}},{"line":89,"address":[3268049],"length":1,"stats":{"Line":0}},{"line":90,"address":[3268545,3267973,3268470],"length":1,"stats":{"Line":0}},{"line":91,"address":[3268509,3270382],"length":1,"stats":{"Line":0}},{"line":92,"address":[3270401],"length":1,"stats":{"Line":0}},{"line":93,"address":[3270446],"length":1,"stats":{"Line":0}},{"line":95,"address":[3268559],"length":1,"stats":{"Line":0}},{"line":96,"address":[3268744],"length":1,"stats":{"Line":0}},{"line":97,"address":[3268607],"length":1,"stats":{"Line":0}},{"line":102,"address":[3269146,3268421,3269246],"length":1,"stats":{"Line":0}},{"line":103,"address":[3622948],"length":1,"stats":{"Line":0}},{"line":104,"address":[3270981],"length":1,"stats":{"Line":0}},{"line":105,"address":[3271014],"length":1,"stats":{"Line":0}},{"line":106,"address":[3272100,3272002],"length":1,"stats":{"Line":0}},{"line":108,"address":[3272028],"length":1,"stats":{"Line":0}},{"line":112,"address":[3271040],"length":1,"stats":{"Line":0}},{"line":113,"address":[3271098,3271057],"length":1,"stats":{"Line":0}},{"line":115,"address":[3271091,3271119],"length":1,"stats":{"Line":0}},{"line":116,"address":[3271195,3271345,3271298],"length":1,"stats":{"Line":0}},{"line":118,"address":[3271798,3272525,3266563,3271304,3272166,3271695],"length":1,"stats":{"Line":0}},{"line":120,"address":[3272624],"length":1,"stats":{"Line":0}},{"line":121,"address":[3272562],"length":1,"stats":{"Line":0}},{"line":122,"address":[3272594,3273007],"length":1,"stats":{"Line":0}},{"line":123,"address":[3273076],"length":1,"stats":{"Line":0}},{"line":130,"address":[3269152],"length":1,"stats":{"Line":0}},{"line":131,"address":[3269328],"length":1,"stats":{"Line":0}},{"line":132,"address":[3269573,3269473,3269620],"length":1,"stats":{"Line":0}},{"line":134,"address":[3269579,3270115,3269994,3266584,3273153,3273515],"length":1,"stats":{"Line":0}},{"line":135,"address":[3273614],"length":1,"stats":{"Line":0}},{"line":136,"address":[3273552],"length":1,"stats":{"Line":0}},{"line":137,"address":[3274449,3273584],"length":1,"stats":{"Line":0}},{"line":138,"address":[3274518],"length":1,"stats":{"Line":0}},{"line":143,"address":[3272121,3274004,3274105],"length":1,"stats":{"Line":0}},{"line":146,"address":[3274339,3266605,3274595,3274010],"length":1,"stats":{"Line":0}},{"line":147,"address":[3274951,3274862],"length":1,"stats":{"Line":0}},{"line":148,"address":[3275020],"length":1,"stats":{"Line":0}},{"line":151,"address":[3275039],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":54},{"path":["/","home","imalison","Projects","lastfm-edit","src","client.rs"],"content":"use crate::edit_analysis;\nuse crate::headers;\nuse crate::login::extract_cookies_from_response;\nuse crate::parsing::LastFmParser;\nuse crate::r#trait::LastFmEditClient;\nuse crate::retry;\nuse crate::types::{\n    AlbumPage, ClientConfig, ClientEvent, ClientEventReceiver, EditResponse, ExactScrobbleEdit,\n    LastFmEditSession, LastFmError, OperationalDelayConfig, RateLimitConfig, RateLimitType,\n    RequestInfo, RetryConfig, ScrobbleEdit, SharedEventBroadcaster, SingleEditResponse, Track,\n    TrackPage,\n};\nuse crate::Result;\nuse async_trait::async_trait;\nuse http_client::{HttpClient, Request, Response};\nuse http_types::{Method, Url};\nuse scraper::{Html, Selector};\nuse std::sync::{Arc, Mutex};\n\n#[derive(Clone)]\npub struct LastFmEditClientImpl {\n    client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n    session: Arc\u003cMutex\u003cLastFmEditSession\u003e\u003e,\n    parser: LastFmParser,\n    broadcaster: Arc\u003cSharedEventBroadcaster\u003e,\n    config: ClientConfig,\n}\n\nimpl LastFmEditClientImpl {\n    /// Custom URL encoding for Last.fm paths\n    fn lastfm_encode(\u0026self, input: \u0026str) -\u003e String {\n        urlencoding::encode(input).to_string()\n    }\n\n    /// Detect if the response content indicates a login redirect\n    fn is_login_redirect(\u0026self, content: \u0026str) -\u003e bool {\n        // Check for common login redirect indicators\n        content.contains(\"login\") \n            || content.contains(\"sign in\") \n            || content.contains(\"signin\")\n            || content.contains(\"Log in to Last.fm\")\n            || content.contains(\"Please sign in\")\n            // Check for login form elements\n            || (content.contains(\"\u003cform\") \u0026\u0026 content.contains(\"password\"))\n            // Check for authentication-related classes or IDs\n            || content.contains(\"auth-form\")\n            || content.contains(\"login-form\")\n    }\n\n    /// Check if a specific endpoint requires authentication that our session doesn't provide\n    pub async fn validate_endpoint_access(\u0026self, url: \u0026str) -\u003e Result\u003cbool\u003e {\n        let mut response = self.get(url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        Ok(!self.is_login_redirect(\u0026content))\n    }\n    pub fn from_session(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n    ) -\u003e Self {\n        Self::from_session_with_arc(Arc::from(client), session)\n    }\n\n    fn from_session_with_arc(\n        client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n    ) -\u003e Self {\n        Self::from_session_with_broadcaster_arc(\n            client,\n            session,\n            Arc::new(SharedEventBroadcaster::new()),\n        )\n    }\n\n    pub fn from_session_with_rate_limit_patterns(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        rate_limit_patterns: Vec\u003cString\u003e,\n    ) -\u003e Self {\n        let config = ClientConfig::default()\n            .with_rate_limit_config(RateLimitConfig::default().with_patterns(rate_limit_patterns));\n        Self::from_session_with_client_config(client, session, config)\n    }\n\n    pub async fn login_with_credentials(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        username: \u0026str,\n        password: \u0026str,\n    ) -\u003e Result\u003cSelf\u003e {\n        let client_arc: Arc\u003cdyn HttpClient + Send + Sync\u003e = Arc::from(client);\n        let login_manager =\n            crate::login::LoginManager::new(client_arc.clone(), \"https://www.last.fm\".to_string());\n        let session = login_manager.login(username, password).await?;\n        Ok(Self::from_session_with_arc(client_arc, session))\n    }\n\n    pub fn from_session_with_client_config(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        config: ClientConfig,\n    ) -\u003e Self {\n        Self::from_session_with_client_config_arc(Arc::from(client), session, config)\n    }\n\n    pub async fn login_with_credentials_and_client_config(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        username: \u0026str,\n        password: \u0026str,\n        config: ClientConfig,\n    ) -\u003e Result\u003cSelf\u003e {\n        let client_arc: Arc\u003cdyn HttpClient + Send + Sync\u003e = Arc::from(client);\n        let login_manager =\n            crate::login::LoginManager::new(client_arc.clone(), \"https://www.last.fm\".to_string());\n        let session = login_manager.login(username, password).await?;\n        Ok(Self::from_session_with_client_config_arc(\n            client_arc, session, config,\n        ))\n    }\n\n    pub fn from_session_with_config(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        retry_config: RetryConfig,\n        rate_limit_config: RateLimitConfig,\n    ) -\u003e Self {\n        Self::from_session_with_config_arc(\n            Arc::from(client),\n            session,\n            retry_config,\n            rate_limit_config,\n        )\n    }\n\n    pub async fn login_with_credentials_and_config(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        username: \u0026str,\n        password: \u0026str,\n        retry_config: RetryConfig,\n        rate_limit_config: RateLimitConfig,\n    ) -\u003e Result\u003cSelf\u003e {\n        let client_arc: Arc\u003cdyn HttpClient + Send + Sync\u003e = Arc::from(client);\n        let login_manager =\n            crate::login::LoginManager::new(client_arc.clone(), \"https://www.last.fm\".to_string());\n        let session = login_manager.login(username, password).await?;\n        Ok(Self::from_session_with_config_arc(\n            client_arc,\n            session,\n            retry_config,\n            rate_limit_config,\n        ))\n    }\n\n    fn from_session_with_broadcaster(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        broadcaster: Arc\u003cSharedEventBroadcaster\u003e,\n    ) -\u003e Self {\n        Self::from_session_with_broadcaster_arc(Arc::from(client), session, broadcaster)\n    }\n\n    fn from_session_with_client_config_arc(\n        client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        config: ClientConfig,\n    ) -\u003e Self {\n        Self::from_session_with_client_config_and_broadcaster_arc(\n            client,\n            session,\n            config,\n            Arc::new(SharedEventBroadcaster::new()),\n        )\n    }\n\n    fn from_session_with_config_arc(\n        client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        retry_config: RetryConfig,\n        rate_limit_config: RateLimitConfig,\n    ) -\u003e Self {\n        let config = ClientConfig {\n            retry: retry_config,\n            rate_limit: rate_limit_config,\n            operational_delays: OperationalDelayConfig::default(),\n        };\n        Self::from_session_with_client_config_arc(client, session, config)\n    }\n\n    fn from_session_with_broadcaster_arc(\n        client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        broadcaster: Arc\u003cSharedEventBroadcaster\u003e,\n    ) -\u003e Self {\n        Self::from_session_with_client_config_and_broadcaster_arc(\n            client,\n            session,\n            ClientConfig::default(),\n            broadcaster,\n        )\n    }\n\n    fn from_session_with_client_config_and_broadcaster_arc(\n        client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        config: ClientConfig,\n        broadcaster: Arc\u003cSharedEventBroadcaster\u003e,\n    ) -\u003e Self {\n        Self {\n            client,\n            session: Arc::new(Mutex::new(session)),\n            parser: LastFmParser::new(),\n            broadcaster,\n            config,\n        }\n    }\n\n    pub fn get_session(\u0026self) -\u003e LastFmEditSession {\n        self.session.lock().unwrap().clone()\n    }\n\n    pub fn restore_session(\u0026self, session: LastFmEditSession) {\n        *self.session.lock().unwrap() = session;\n    }\n\n    pub fn with_shared_broadcaster(\u0026self, client: Box\u003cdyn HttpClient + Send + Sync\u003e) -\u003e Self {\n        let session = self.get_session();\n        Self::from_session_with_broadcaster(client, session, self.broadcaster.clone())\n    }\n\n    pub fn username(\u0026self) -\u003e String {\n        self.session.lock().unwrap().username.clone()\n    }\n\n    pub async fn validate_session(\u0026self) -\u003e bool {\n        let test_url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/settings/subscription/automatic-edits/tracks\",\n                session.base_url\n            )\n        };\n\n        let mut request = Request::new(Method::Get, test_url.parse::\u003cUrl\u003e().unwrap());\n\n        {\n            let session = self.session.lock().unwrap();\n            headers::add_cookies(\u0026mut request, \u0026session.cookies);\n        }\n\n        headers::add_get_headers(\u0026mut request, false, None);\n\n        match self.client.send(request).await {\n            Ok(response) =\u003e {\n                if response.status() == 302 || response.status() == 301 {\n                    if let Some(location) = response.header(\"location\") {\n                        if let Some(redirect_url) = location.get(0) {\n                            let redirect_url_str = redirect_url.as_str();\n                            let is_valid = !redirect_url_str.contains(\"/login\");\n\n                            return is_valid;\n                        }\n                    }\n                }\n                true\n            }\n            Err(_e) =\u003e false,\n        }\n    }\n\n    pub async fn delete_scrobble(\n        \u0026self,\n        artist_name: \u0026str,\n        track_name: \u0026str,\n        timestamp: u64,\n    ) -\u003e Result\u003cbool\u003e {\n        let config = RetryConfig {\n            max_retries: 3,\n            base_delay: 5,\n            max_delay: 300,\n            enabled: true,\n        };\n\n        let artist_name = artist_name.to_string();\n        let track_name = track_name.to_string();\n        let client = self.clone();\n\n        match retry::retry_with_backoff(\n            config,\n            \"Delete scrobble\",\n            || client.delete_scrobble_impl(\u0026artist_name, \u0026track_name, timestamp),\n            |delay, rate_limit_timestamp, operation_name| {\n                self.broadcast_event(ClientEvent::RateLimited {\n                    delay_seconds: delay,\n                    request: None,\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    rate_limit_timestamp,\n                });\n                log::debug!(\"{operation_name} rate limited, waiting {delay} seconds\");\n            },\n            |total_duration, _operation_name| {\n                self.broadcast_event(ClientEvent::RateLimitEnded {\n                    request: crate::types::RequestInfo::from_url_and_method(\n                        \u0026format!(\"delete_scrobble/{artist_name}/{track_name}/{timestamp}\"),\n                        \"POST\",\n                    ),\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    total_rate_limit_duration_seconds: total_duration,\n                });\n            },\n        )\n        .await\n        {\n            Ok(retry_result) =\u003e Ok(retry_result.result),\n            Err(_) =\u003e Ok(false),\n        }\n    }\n\n    async fn delete_scrobble_impl(\n        \u0026self,\n        artist_name: \u0026str,\n        track_name: \u0026str,\n        timestamp: u64,\n    ) -\u003e Result\u003cbool\u003e {\n        let delete_url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/delete\",\n                session.base_url, session.username\n            )\n        };\n\n        log::debug!(\"Getting fresh CSRF token for delete\");\n        let library_url = {\n            let session = self.session.lock().unwrap();\n            format!(\"{}/user/{}/library\", session.base_url, session.username)\n        };\n\n        let mut response = self.get(\u0026library_url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        let document = Html::parse_document(\u0026content);\n        let fresh_csrf_token = self.extract_csrf_token(\u0026document)?;\n\n        log::debug!(\"Submitting delete request with fresh token\");\n\n        let mut request = Request::new(Method::Post, delete_url.parse::\u003cUrl\u003e().unwrap());\n\n        let referer_url = {\n            let session = self.session.lock().unwrap();\n            headers::add_cookies(\u0026mut request, \u0026session.cookies);\n            format!(\"{}/user/{}\", session.base_url, session.username)\n        };\n\n        headers::add_edit_headers(\u0026mut request, \u0026referer_url);\n\n        let form_data = [\n            (\"csrfmiddlewaretoken\", fresh_csrf_token.as_str()),\n            (\"artist_name\", artist_name),\n            (\"track_name\", track_name),\n            (\"timestamp\", \u0026timestamp.to_string()),\n            (\"ajax\", \"1\"),\n        ];\n\n        let form_string: String = form_data\n            .iter()\n            .map(|(k, v)| format!(\"{}={}\", urlencoding::encode(k), urlencoding::encode(v)))\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\u0026\");\n\n        request.set_body(form_string);\n\n        log::debug!(\n            \"Deleting scrobble: '{track_name}' by '{artist_name}' with timestamp {timestamp}\"\n        );\n\n        let request_info = RequestInfo::from_url_and_method(\u0026delete_url, \"POST\");\n        let request_start = std::time::Instant::now();\n\n        self.broadcast_event(ClientEvent::RequestStarted {\n            request: request_info.clone(),\n        });\n\n        let mut response = self\n            .client\n            .send(request)\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        self.broadcast_event(ClientEvent::RequestCompleted {\n            request: request_info.clone(),\n            status_code: response.status().into(),\n            duration_ms: request_start.elapsed().as_millis() as u64,\n        });\n\n        log::debug!(\"Delete response status: {}\", response.status());\n\n        let response_text = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        let success = response.status().is_success();\n\n        if success {\n            log::debug!(\"Successfully deleted scrobble\");\n        } else {\n            log::debug!(\"Delete failed with response: {response_text}\");\n        }\n\n        Ok(success)\n    }\n\n    pub fn subscribe(\u0026self) -\u003e ClientEventReceiver {\n        self.broadcaster.subscribe()\n    }\n\n    pub fn latest_event(\u0026self) -\u003e Option\u003cClientEvent\u003e {\n        self.broadcaster.latest_event()\n    }\n\n    fn broadcast_event(\u0026self, event: ClientEvent) {\n        self.broadcaster.broadcast_event(event);\n    }\n\n    pub async fn get_recent_scrobbles(\u0026self, page: u32) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library?page={}\",\n                session.base_url, session.username, page\n            )\n        };\n\n        log::debug!(\"Fetching recent scrobbles page {page}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"Recent scrobbles response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        let document = Html::parse_document(\u0026content);\n        self.parser.parse_recent_scrobbles(\u0026document)\n    }\n\n    pub async fn get_recent_tracks_page(\u0026self, page: u32) -\u003e Result\u003cTrackPage\u003e {\n        let tracks = self.get_recent_scrobbles(page).await?;\n\n        let has_next_page = !tracks.is_empty();\n\n        Ok(TrackPage {\n            tracks,\n            page_number: page,\n            has_next_page,\n            total_pages: None,\n        })\n    }\n\n    pub async fn find_recent_scrobble_for_track(\n        \u0026self,\n        track_name: \u0026str,\n        artist_name: \u0026str,\n        max_pages: u32,\n    ) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        log::debug!(\"Searching for recent scrobble: '{track_name}' by '{artist_name}'\");\n\n        for page in 1..=max_pages {\n            let scrobbles = self.get_recent_scrobbles(page).await?;\n\n            for scrobble in scrobbles {\n                if scrobble.name == track_name \u0026\u0026 scrobble.artist == artist_name {\n                    log::debug!(\n                        \"Found recent scrobble: '{}' with timestamp {:?}\",\n                        scrobble.name,\n                        scrobble.timestamp\n                    );\n                    return Ok(Some(scrobble));\n                }\n            }\n        }\n\n        log::debug!(\n            \"No recent scrobble found for '{track_name}' by '{artist_name}' in {max_pages} pages\"\n        );\n        Ok(None)\n    }\n\n    pub async fn edit_scrobble(\u0026self, edit: \u0026ScrobbleEdit) -\u003e Result\u003cEditResponse\u003e {\n        let discovered_edits = self.discover_scrobble_edit_variations(edit).await?;\n\n        if discovered_edits.is_empty() {\n            let context = match (\u0026edit.track_name_original, \u0026edit.album_name_original) {\n                (Some(track_name), _) =\u003e {\n                    format!(\"track '{}' by '{}'\", track_name, edit.artist_name_original)\n                }\n                (None, Some(album_name)) =\u003e {\n                    format!(\"album '{}' by '{}'\", album_name, edit.artist_name_original)\n                }\n                (None, None) =\u003e format!(\"artist '{}'\", edit.artist_name_original),\n            };\n            return Err(LastFmError::Parse(format!(\n                \"No scrobbles found for {context}. Make sure the names are correct and that you have scrobbled recently.\"\n            )));\n        }\n\n        log::info!(\n            \"Discovered {} scrobble instances to edit\",\n            discovered_edits.len()\n        );\n\n        let mut all_results = Vec::new();\n\n        for (index, discovered_edit) in discovered_edits.iter().enumerate() {\n            log::debug!(\n                \"Processing scrobble {}/{}: '{}' from '{}'\",\n                index + 1,\n                discovered_edits.len(),\n                discovered_edit.track_name_original,\n                discovered_edit.album_name_original\n            );\n\n            let mut modified_exact_edit = discovered_edit.clone();\n\n            if let Some(new_track_name) = \u0026edit.track_name {\n                modified_exact_edit.track_name = new_track_name.clone();\n            }\n            if let Some(new_album_name) = \u0026edit.album_name {\n                modified_exact_edit.album_name = new_album_name.clone();\n            }\n            modified_exact_edit.artist_name = edit.artist_name.clone();\n            if let Some(new_album_artist_name) = \u0026edit.album_artist_name {\n                modified_exact_edit.album_artist_name = new_album_artist_name.clone();\n            }\n            modified_exact_edit.edit_all = edit.edit_all;\n\n            let album_info = format!(\n                \"{} by {}\",\n                modified_exact_edit.album_name_original,\n                modified_exact_edit.album_artist_name_original\n            );\n\n            let single_response = self.edit_scrobble_single(\u0026modified_exact_edit, 3).await?;\n            let success = single_response.success();\n            let message = single_response.message();\n\n            all_results.push(SingleEditResponse {\n                success,\n                message,\n                album_info: Some(album_info),\n                exact_scrobble_edit: modified_exact_edit.clone(),\n            });\n\n            if index \u003c discovered_edits.len() - 1\n                \u0026\u0026 self.config.operational_delays.edit_delay_ms \u003e 0\n            {\n                tokio::time::sleep(std::time::Duration::from_millis(\n                    self.config.operational_delays.edit_delay_ms,\n                ))\n                .await;\n            }\n        }\n\n        Ok(EditResponse::from_results(all_results))\n    }\n\n    pub async fn edit_scrobble_single(\n        \u0026self,\n        exact_edit: \u0026ExactScrobbleEdit,\n        max_retries: u32,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        let config = RetryConfig {\n            max_retries,\n            base_delay: 5,\n            max_delay: 300,\n            enabled: true,\n        };\n\n        let edit_clone = exact_edit.clone();\n        let client = self.clone();\n\n        match retry::retry_with_backoff(\n            config,\n            \"Edit scrobble\",\n            || client.edit_scrobble_impl(\u0026edit_clone),\n            |delay, rate_limit_timestamp, operation_name| {\n                self.broadcast_event(ClientEvent::RateLimited {\n                    delay_seconds: delay,\n                    request: None, // No specific request context in retry callback\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    rate_limit_timestamp,\n                });\n                log::debug!(\"{operation_name} rate limited, waiting {delay} seconds\");\n            },\n            |total_duration, _operation_name| {\n                self.broadcast_event(ClientEvent::RateLimitEnded {\n                    request: crate::types::RequestInfo::from_url_and_method(\n                        \u0026format!(\n                            \"edit_scrobble/{}/{}\",\n                            edit_clone.artist_name, edit_clone.track_name\n                        ),\n                        \"POST\",\n                    ),\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    total_rate_limit_duration_seconds: total_duration,\n                });\n            },\n        )\n        .await\n        {\n            Ok(retry_result) =\u003e Ok(EditResponse::single(\n                retry_result.result,\n                None,\n                None,\n                exact_edit.clone(),\n            )),\n            Err(LastFmError::RateLimit { .. }) =\u003e Ok(EditResponse::single(\n                false,\n                Some(format!(\"Rate limit exceeded after {max_retries} retries\")),\n                None,\n                exact_edit.clone(),\n            )),\n            Err(other_error) =\u003e Ok(EditResponse::single(\n                false,\n                Some(other_error.to_string()),\n                None,\n                exact_edit.clone(),\n            )),\n        }\n    }\n\n    async fn edit_scrobble_impl(\u0026self, exact_edit: \u0026ExactScrobbleEdit) -\u003e Result\u003cbool\u003e {\n        let start_time = std::time::Instant::now();\n        let result = self.edit_scrobble_impl_internal(exact_edit).await;\n        let duration_ms = start_time.elapsed().as_millis() as u64;\n\n        match \u0026result {\n            Ok(success) =\u003e {\n                self.broadcast_event(ClientEvent::EditAttempted {\n                    edit: exact_edit.clone(),\n                    success: *success,\n                    error_message: None,\n                    duration_ms,\n                });\n            }\n            Err(error) =\u003e {\n                self.broadcast_event(ClientEvent::EditAttempted {\n                    edit: exact_edit.clone(),\n                    success: false,\n                    error_message: Some(error.to_string()),\n                    duration_ms,\n                });\n            }\n        }\n\n        result\n    }\n\n    async fn edit_scrobble_impl_internal(\u0026self, exact_edit: \u0026ExactScrobbleEdit) -\u003e Result\u003cbool\u003e {\n        let edit_url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/edit?edited-variation=library-track-scrobble\",\n                session.base_url, session.username\n            )\n        };\n\n        log::debug!(\"Getting fresh CSRF token for edit\");\n        let form_html = self.get_edit_form_html(\u0026edit_url).await?;\n\n        let form_document = Html::parse_document(\u0026form_html);\n        let fresh_csrf_token = self.extract_csrf_token(\u0026form_document)?;\n\n        log::debug!(\"Submitting edit with fresh token\");\n\n        let form_data = exact_edit.build_form_data(\u0026fresh_csrf_token);\n\n        log::debug!(\n            \"Editing scrobble: '{}' -\u003e '{}'\",\n            exact_edit.track_name_original,\n            exact_edit.track_name\n        );\n        {\n            let session = self.session.lock().unwrap();\n            log::trace!(\"Session cookies count: {}\", session.cookies.len());\n        }\n\n        let mut request = Request::new(Method::Post, edit_url.parse::\u003cUrl\u003e().unwrap());\n\n        let referer_url = {\n            let session = self.session.lock().unwrap();\n            headers::add_cookies(\u0026mut request, \u0026session.cookies);\n            format!(\"{}/user/{}/library\", session.base_url, session.username)\n        };\n\n        headers::add_edit_headers(\u0026mut request, \u0026referer_url);\n\n        let form_string: String = form_data\n            .iter()\n            .map(|(k, v)| format!(\"{}={}\", urlencoding::encode(k), urlencoding::encode(v)))\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\u0026\");\n\n        request.set_body(form_string);\n\n        let request_info = RequestInfo::from_url_and_method(\u0026edit_url, \"POST\");\n        let request_start = std::time::Instant::now();\n\n        self.broadcast_event(ClientEvent::RequestStarted {\n            request: request_info.clone(),\n        });\n\n        let mut response = self\n            .client\n            .send(request)\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        self.broadcast_event(ClientEvent::RequestCompleted {\n            request: request_info.clone(),\n            status_code: response.status().into(),\n            duration_ms: request_start.elapsed().as_millis() as u64,\n        });\n\n        log::debug!(\"Edit response status: {}\", response.status());\n\n        let response_text = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        let analysis = edit_analysis::analyze_edit_response(\u0026response_text, response.status());\n\n        Ok(analysis.success)\n    }\n\n    async fn get_edit_form_html(\u0026self, edit_url: \u0026str) -\u003e Result\u003cString\u003e {\n        let mut form_response = self.get(edit_url).await?;\n        let form_html = form_response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\"Edit form response status: {}\", form_response.status());\n        Ok(form_html)\n    }\n\n    pub async fn load_edit_form_values_internal(\n        \u0026self,\n        track_name: \u0026str,\n        artist_name: \u0026str,\n    ) -\u003e Result\u003cVec\u003cExactScrobbleEdit\u003e\u003e {\n        log::debug!(\"Loading edit form values for '{track_name}' by '{artist_name}'\");\n\n        let base_track_url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/music/+noredirect/{}/_/{}\",\n                session.base_url,\n                session.username,\n                urlencoding::encode(artist_name),\n                urlencoding::encode(track_name)\n            )\n        };\n\n        log::debug!(\"Fetching track page: {base_track_url}\");\n\n        let mut response = self.get(\u0026base_track_url).await?;\n        let html = response\n            .body_string()\n            .await\n            .map_err(|e| crate::LastFmError::Http(e.to_string()))?;\n\n        let document = Html::parse_document(\u0026html);\n\n        let mut all_scrobble_edits = Vec::new();\n        let mut unique_albums = std::collections::HashSet::new();\n        let max_pages = 5;\n\n        let page_edits = self.extract_scrobble_edits_from_page(\n            \u0026document,\n            track_name,\n            artist_name,\n            \u0026mut unique_albums,\n        )?;\n        all_scrobble_edits.extend(page_edits);\n\n        log::debug!(\n            \"Page 1: found {} unique album variations\",\n            all_scrobble_edits.len()\n        );\n\n        let pagination_selector = Selector::parse(\".pagination .pagination-next\").unwrap();\n        let mut has_next_page = document.select(\u0026pagination_selector).next().is_some();\n        let mut page = 2;\n\n        while has_next_page \u0026\u0026 page \u003c= max_pages {\n            let page_url = {\n                let session = self.session.lock().unwrap();\n                format!(\n                    \"{}/user/{}/library/music/{}/_/{}?page={page}\",\n                    session.base_url,\n                    session.username,\n                    urlencoding::encode(artist_name),\n                    urlencoding::encode(track_name)\n                )\n            };\n\n            log::debug!(\"Fetching page {page} for additional album variations\");\n\n            let mut response = self.get(\u0026page_url).await?;\n            let html = response\n                .body_string()\n                .await\n                .map_err(|e| crate::LastFmError::Http(e.to_string()))?;\n\n            let document = Html::parse_document(\u0026html);\n\n            let page_edits = self.extract_scrobble_edits_from_page(\n                \u0026document,\n                track_name,\n                artist_name,\n                \u0026mut unique_albums,\n            )?;\n\n            let initial_count = all_scrobble_edits.len();\n            all_scrobble_edits.extend(page_edits);\n            let found_new_unique_albums = all_scrobble_edits.len() \u003e initial_count;\n\n            has_next_page = document.select(\u0026pagination_selector).next().is_some();\n\n            log::debug!(\n                \"Page {page}: found {} total unique albums ({})\",\n                all_scrobble_edits.len(),\n                if found_new_unique_albums {\n                    \"new albums found\"\n                } else {\n                    \"no new unique albums\"\n                }\n            );\n\n            page += 1;\n        }\n\n        if all_scrobble_edits.is_empty() {\n            return Err(crate::LastFmError::Parse(format!(\n                \"No scrobble forms found for track '{track_name}' by '{artist_name}'\"\n            )));\n        }\n\n        log::debug!(\n            \"Final result: found {} unique album variations for '{track_name}' by '{artist_name}'\",\n            all_scrobble_edits.len(),\n        );\n\n        Ok(all_scrobble_edits)\n    }\n\n    fn extract_scrobble_edits_from_page(\n        \u0026self,\n        document: \u0026Html,\n        expected_track: \u0026str,\n        expected_artist: \u0026str,\n        unique_albums: \u0026mut std::collections::HashSet\u003c(String, String)\u003e,\n    ) -\u003e Result\u003cVec\u003cExactScrobbleEdit\u003e\u003e {\n        let mut scrobble_edits = Vec::new();\n        let table_selector =\n            Selector::parse(\"table.chartlist:not(.chartlist__placeholder)\").unwrap();\n        let table = document.select(\u0026table_selector).next().ok_or_else(|| {\n            crate::LastFmError::Parse(\"No chartlist table found on track page\".to_string())\n        })?;\n\n        let row_selector = Selector::parse(\"tr\").unwrap();\n        for row in table.select(\u0026row_selector) {\n            let count_bar_link_selector = Selector::parse(\".chartlist-count-bar-link\").unwrap();\n            if row.select(\u0026count_bar_link_selector).next().is_some() {\n                log::debug!(\"Found count bar link, skipping aggregated row\");\n                continue;\n            }\n\n            let form_selector = Selector::parse(\"form[data-edit-scrobble]\").unwrap();\n            if let Some(form) = row.select(\u0026form_selector).next() {\n                let extract_form_value = |name: \u0026str| -\u003e Option\u003cString\u003e {\n                    let selector = Selector::parse(\u0026format!(\"input[name='{name}']\")).unwrap();\n                    form.select(\u0026selector)\n                        .next()\n                        .and_then(|input| input.value().attr(\"value\"))\n                        .map(|s| s.to_string())\n                };\n\n                let form_track = extract_form_value(\"track_name\").unwrap_or_default();\n                let form_artist = extract_form_value(\"artist_name\").unwrap_or_default();\n                let form_album = extract_form_value(\"album_name\").unwrap_or_default();\n                let form_album_artist =\n                    extract_form_value(\"album_artist_name\").unwrap_or_else(|| form_artist.clone());\n                let form_timestamp = extract_form_value(\"timestamp\").unwrap_or_default();\n\n                if form_track == expected_track \u0026\u0026 form_artist == expected_artist {\n                    let album_key = (form_album.clone(), form_album_artist.clone());\n                    if unique_albums.insert(album_key) {\n                        let timestamp = if form_timestamp.is_empty() {\n                            None\n                        } else {\n                            form_timestamp.parse::\u003cu64\u003e().ok()\n                        };\n\n                        if let Some(timestamp) = timestamp {\n                            let scrobble_edit = ExactScrobbleEdit::new(\n                                form_track.clone(),\n                                form_album.clone(),\n                                form_artist.clone(),\n                                form_album_artist.clone(),\n                                form_track,\n                                form_album,\n                                form_artist,\n                                form_album_artist,\n                                timestamp,\n                                true,\n                            );\n                            scrobble_edits.push(scrobble_edit);\n                        } else {\n                            log::warn!(\n                                \"âš ï¸ Skipping form without valid timestamp: '{form_album}' by '{form_album_artist}'\"\n                            );\n                        }\n                    }\n                }\n            }\n        }\n\n        Ok(scrobble_edits)\n    }\n\n    pub async fn get_artist_tracks_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003cTrackPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/music/{}/+tracks?page={}\u0026ajax=true\",\n                session.base_url,\n                session.username,\n                urlencoding::encode(artist),\n                page\n            )\n        };\n\n        log::debug!(\"Fetching tracks page {page} for artist: {artist}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"AJAX response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        log::debug!(\"Parsing HTML response from AJAX endpoint\");\n        let document = Html::parse_document(\u0026content);\n        self.parser.parse_tracks_page(\u0026document, page, artist, None)\n    }\n\n    pub fn extract_tracks_from_document(\n        \u0026self,\n        document: \u0026Html,\n        artist: \u0026str,\n        album: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        self.parser\n            .extract_tracks_from_document(document, artist, album)\n    }\n\n    pub fn parse_tracks_page(\n        \u0026self,\n        document: \u0026Html,\n        page_number: u32,\n        artist: \u0026str,\n        album: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cTrackPage\u003e {\n        self.parser\n            .parse_tracks_page(document, page_number, artist, album)\n    }\n\n    pub fn parse_recent_scrobbles(\u0026self, document: \u0026Html) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        self.parser.parse_recent_scrobbles(document)\n    }\n\n    fn extract_csrf_token(\u0026self, document: \u0026Html) -\u003e Result\u003cString\u003e {\n        let csrf_selector = Selector::parse(\"input[name=\\\"csrfmiddlewaretoken\\\"]\").unwrap();\n\n        document\n            .select(\u0026csrf_selector)\n            .next()\n            .and_then(|input| input.value().attr(\"value\"))\n            .map(|token| token.to_string())\n            .ok_or(LastFmError::CsrfNotFound)\n    }\n\n    pub async fn get(\u0026self, url: \u0026str) -\u003e Result\u003cResponse\u003e {\n        self.get_with_retry(url).await\n    }\n\n    async fn get_with_retry(\u0026self, url: \u0026str) -\u003e Result\u003cResponse\u003e {\n        let config = self.config.retry.clone();\n\n        let url_string = url.to_string();\n        let client = self.clone();\n\n        let retry_result = retry::retry_with_backoff(\n            config,\n            \u0026format!(\"GET {url}\"),\n            || async {\n                let mut response = client.get_with_redirects(\u0026url_string, 0).await?;\n\n                let body = client\n                    .extract_response_body(\u0026url_string, \u0026mut response)\n                    .await?;\n\n                if response.status().is_success() \u0026\u0026 client.is_rate_limit_response(\u0026body) {\n                    log::debug!(\"Response body contains rate limit patterns\");\n                    return Err(LastFmError::RateLimit { retry_after: 60 });\n                }\n\n                let mut new_response = http_types::Response::new(response.status());\n                for (name, values) in response.iter() {\n                    for value in values {\n                        let _ = new_response.insert_header(name.clone(), value.clone());\n                    }\n                }\n                new_response.set_body(body);\n\n                Ok(new_response)\n            },\n            |delay, rate_limit_timestamp, operation_name| {\n                self.broadcast_event(ClientEvent::RateLimited {\n                    delay_seconds: delay,\n                    request: None, // No specific request context in retry callback\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    rate_limit_timestamp,\n                });\n                log::debug!(\"{operation_name} rate limited, waiting {delay} seconds\");\n            },\n            |total_duration, _operation_name| {\n                self.broadcast_event(ClientEvent::RateLimitEnded {\n                    request: crate::types::RequestInfo::from_url_and_method(\u0026url_string, \"GET\"),\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    total_rate_limit_duration_seconds: total_duration,\n                });\n            },\n        )\n        .await?;\n\n        Ok(retry_result.result)\n    }\n\n    async fn get_with_redirects(\u0026self, url: \u0026str, redirect_count: u32) -\u003e Result\u003cResponse\u003e {\n        if redirect_count \u003e 5 {\n            return Err(LastFmError::Http(\"Too many redirects\".to_string()));\n        }\n\n        let mut request = Request::new(Method::Get, url.parse::\u003cUrl\u003e().unwrap());\n\n        {\n            let session = self.session.lock().unwrap();\n            headers::add_cookies(\u0026mut request, \u0026session.cookies);\n            if session.cookies.is_empty() \u0026\u0026 url.contains(\"page=\") {\n                log::debug!(\"No cookies available for paginated request!\");\n            }\n        }\n\n        let is_ajax = url.contains(\"ajax=true\");\n        let referer_url = if url.contains(\"page=\") {\n            Some(url.split('?').next().unwrap_or(url))\n        } else {\n            None\n        };\n\n        headers::add_get_headers(\u0026mut request, is_ajax, referer_url);\n\n        let request_info = RequestInfo::from_url_and_method(url, \"GET\");\n        let request_start = std::time::Instant::now();\n\n        self.broadcast_event(ClientEvent::RequestStarted {\n            request: request_info.clone(),\n        });\n\n        let response = self\n            .client\n            .send(request)\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        self.broadcast_event(ClientEvent::RequestCompleted {\n            request: request_info.clone(),\n            status_code: response.status().into(),\n            duration_ms: request_start.elapsed().as_millis() as u64,\n        });\n\n        self.extract_cookies(\u0026response);\n\n        if response.status() == 302 || response.status() == 301 {\n            if let Some(location) = response.header(\"location\") {\n                if let Some(redirect_url) = location.get(0) {\n                    let redirect_url_str = redirect_url.as_str();\n                    if url.contains(\"page=\") {\n                        log::debug!(\"Following redirect from {url} to {redirect_url_str}\");\n\n                        if redirect_url_str.contains(\"/login\") {\n                            log::debug!(\"Redirect to login page - authentication failed for paginated request\");\n                            return Err(LastFmError::Auth(\n                                \"Session expired or invalid for paginated request\".to_string(),\n                            ));\n                        }\n                    }\n\n                    let full_redirect_url = if redirect_url_str.starts_with('/') {\n                        let base_url = self.session.lock().unwrap().base_url.clone();\n                        format!(\"{base_url}{redirect_url_str}\")\n                    } else if redirect_url_str.starts_with(\"http\") {\n                        redirect_url_str.to_string()\n                    } else {\n                        let base_url = url\n                            .rsplit('/')\n                            .skip(1)\n                            .collect::\u003cVec\u003c_\u003e\u003e()\n                            .into_iter()\n                            .rev()\n                            .collect::\u003cVec\u003c_\u003e\u003e()\n                            .join(\"/\");\n                        format!(\"{base_url}/{redirect_url_str}\")\n                    };\n\n                    return Box::pin(\n                        self.get_with_redirects(\u0026full_redirect_url, redirect_count + 1),\n                    )\n                    .await;\n                }\n            }\n        }\n\n        if self.config.rate_limit.detect_by_status \u0026\u0026 response.status() == 429 {\n            let retry_after = response\n                .header(\"retry-after\")\n                .and_then(|h| h.get(0))\n                .and_then(|v| v.as_str().parse::\u003cu64\u003e().ok())\n                .unwrap_or(60);\n            self.broadcast_event(ClientEvent::RateLimited {\n                delay_seconds: retry_after,\n                request: Some(request_info.clone()),\n                rate_limit_type: RateLimitType::Http429,\n                rate_limit_timestamp: std::time::SystemTime::now()\n                    .duration_since(std::time::UNIX_EPOCH)\n                    .unwrap_or_default()\n                    .as_secs(),\n            });\n            return Err(LastFmError::RateLimit { retry_after });\n        }\n\n        if self.config.rate_limit.detect_by_status \u0026\u0026 response.status() == 403 {\n            log::debug!(\"Got 403 response, checking if it's a rate limit\");\n            {\n                let session = self.session.lock().unwrap();\n                if !session.cookies.is_empty() {\n                    log::debug!(\"403 on authenticated request - likely rate limit\");\n                    self.broadcast_event(ClientEvent::RateLimited {\n                        delay_seconds: 60,\n                        request: Some(request_info.clone()),\n                        rate_limit_type: RateLimitType::Http403,\n                        rate_limit_timestamp: std::time::SystemTime::now()\n                            .duration_since(std::time::UNIX_EPOCH)\n                            .unwrap_or_default()\n                            .as_secs(),\n                    });\n                    return Err(LastFmError::RateLimit { retry_after: 60 });\n                }\n            }\n        }\n\n        Ok(response)\n    }\n\n    fn is_rate_limit_response(\u0026self, response_body: \u0026str) -\u003e bool {\n        let rate_limit_config = \u0026self.config.rate_limit;\n\n        if !rate_limit_config.detect_by_patterns \u0026\u0026 rate_limit_config.custom_patterns.is_empty() {\n            return false;\n        }\n\n        let body_lower = response_body.to_lowercase();\n\n        for pattern in \u0026rate_limit_config.custom_patterns {\n            if body_lower.contains(\u0026pattern.to_lowercase()) {\n                log::debug!(\"Rate limit detected (custom pattern: '{pattern}')\");\n                return true;\n            }\n        }\n\n        if rate_limit_config.detect_by_patterns {\n            for pattern in \u0026rate_limit_config.patterns {\n                let pattern_lower = pattern.to_lowercase();\n                if body_lower.contains(\u0026pattern_lower) {\n                    log::debug!(\"Rate limit detected (pattern: '{pattern}')\");\n                    return true;\n                }\n            }\n        }\n\n        false\n    }\n\n    fn extract_cookies(\u0026self, response: \u0026Response) {\n        let mut session = self.session.lock().unwrap();\n        extract_cookies_from_response(response, \u0026mut session.cookies);\n    }\n\n    async fn extract_response_body(\u0026self, _url: \u0026str, response: \u0026mut Response) -\u003e Result\u003cString\u003e {\n        let body = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        Ok(body)\n    }\n\n    pub async fn get_artists_page(\u0026self, page: u32) -\u003e Result\u003ccrate::ArtistPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/artists?page={}\",\n                session.base_url, session.username, page\n            )\n        };\n\n        log::debug!(\"Fetching artists page {page}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"Artist library response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        log::debug!(\"Parsing HTML response from artist library endpoint\");\n        let document = Html::parse_document(\u0026content);\n        self.parser.parse_artists_page(\u0026document, page)\n    }\n\n    pub async fn get_artist_albums_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003cAlbumPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/music/{}/+albums?page={}\u0026ajax=true\",\n                session.base_url,\n                session.username,\n                urlencoding::encode(artist),\n                page\n            )\n        };\n\n        log::debug!(\"Fetching albums page {page} for artist: {artist}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"AJAX response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        log::debug!(\"Parsing HTML response from AJAX endpoint\");\n        let document = Html::parse_document(\u0026content);\n        self.parser.parse_albums_page(\u0026document, page, artist)\n    }\n\n    pub async fn get_album_tracks_page(\n        \u0026self,\n        album_name: \u0026str,\n        artist_name: \u0026str,\n        page: u32,\n    ) -\u003e Result\u003cTrackPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/music/{}/{}?page={}\u0026ajax=true\",\n                session.base_url,\n                session.username,\n                self.lastfm_encode(artist_name),\n                self.lastfm_encode(album_name),\n                page\n            )\n        };\n\n        log::debug!(\"Fetching tracks page {page} for album '{album_name}' by '{artist_name}'\");\n        log::debug!(\"ğŸ”— Album URL: {url}\");\n\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"AJAX response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        log::debug!(\"Parsing HTML response from AJAX endpoint\");\n        let document = Html::parse_document(\u0026content);\n        let result =\n            self.parser\n                .parse_tracks_page(\u0026document, page, artist_name, Some(album_name))?;\n\n        // Debug logging for albums that return 0 tracks\n        if result.tracks.is_empty() {\n            if content.contains(\"404\") || content.contains(\"Not Found\") {\n                log::warn!(\"ğŸš¨ 404 ERROR for album '{album_name}' by '{artist_name}': {url}\");\n            } else if content.contains(\"no tracks\") || content.contains(\"no music\") {\n                log::debug!(\"â„¹ï¸  Album '{album_name}' by '{artist_name}' explicitly has no tracks in user's library\");\n            } else {\n                log::warn!(\n                    \"ğŸš¨ UNKNOWN EMPTY RESPONSE for album '{album_name}' by '{artist_name}': {url}\"\n                );\n                log::debug!(\"ğŸ” Response length: {} chars\", content.len());\n                log::debug!(\n                    \"ğŸ” Response preview (first 200 chars): {}\",\n                    \u0026content.chars().take(200).collect::\u003cString\u003e()\n                );\n            }\n        } else {\n            log::debug!(\n                \"âœ… SUCCESS: Album '{album_name}' by '{artist_name}' returned {} tracks\",\n                result.tracks.len()\n            );\n        }\n\n        Ok(result)\n    }\n\n    pub async fn search_tracks_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003cTrackPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/tracks/search?page={}\u0026query={}\u0026ajax=1\",\n                session.base_url,\n                session.username,\n                page,\n                urlencoding::encode(query)\n            )\n        };\n\n        log::debug!(\"Searching tracks for query '{query}' on page {page}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"Track search response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        let document = Html::parse_document(\u0026content);\n        let tracks = self.parser.parse_track_search_results(\u0026document)?;\n\n        // For search results, we need to determine pagination differently\n        // since we don't have the same pagination structure as regular library pages\n        let (has_next_page, total_pages) = self.parser.parse_pagination(\u0026document, page)?;\n\n        Ok(TrackPage {\n            tracks,\n            page_number: page,\n            has_next_page,\n            total_pages,\n        })\n    }\n\n    pub async fn search_albums_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003cAlbumPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/albums/search?page={}\u0026query={}\u0026ajax=1\",\n                session.base_url,\n                session.username,\n                page,\n                urlencoding::encode(query)\n            )\n        };\n\n        log::debug!(\"Searching albums for query '{query}' on page {page}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"Album search response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        let document = Html::parse_document(\u0026content);\n        let albums = self.parser.parse_album_search_results(\u0026document)?;\n\n        // For search results, we need to determine pagination differently\n        let (has_next_page, total_pages) = self.parser.parse_pagination(\u0026document, page)?;\n\n        Ok(AlbumPage {\n            albums,\n            page_number: page,\n            has_next_page,\n            total_pages,\n        })\n    }\n\n    /// Expose the inner HTTP client for advanced use cases like VCR cassette management\n    pub fn inner_client(\u0026self) -\u003e Arc\u003cdyn HttpClient + Send + Sync\u003e {\n        self.client.clone()\n    }\n}\n\n#[async_trait(?Send)]\nimpl LastFmEditClient for LastFmEditClientImpl {\n    fn username(\u0026self) -\u003e String {\n        self.username()\n    }\n\n    async fn get_recent_scrobbles(\u0026self, page: u32) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        self.get_recent_scrobbles(page).await\n    }\n\n    async fn find_recent_scrobble_for_track(\n        \u0026self,\n        track_name: \u0026str,\n        artist_name: \u0026str,\n        max_pages: u32,\n    ) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        self.find_recent_scrobble_for_track(track_name, artist_name, max_pages)\n            .await\n    }\n\n    async fn edit_scrobble(\u0026self, edit: \u0026ScrobbleEdit) -\u003e Result\u003cEditResponse\u003e {\n        self.edit_scrobble(edit).await\n    }\n\n    async fn edit_scrobble_single(\n        \u0026self,\n        exact_edit: \u0026ExactScrobbleEdit,\n        max_retries: u32,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        self.edit_scrobble_single(exact_edit, max_retries).await\n    }\n\n    fn get_session(\u0026self) -\u003e LastFmEditSession {\n        self.get_session()\n    }\n\n    fn restore_session(\u0026self, session: LastFmEditSession) {\n        self.restore_session(session)\n    }\n\n    fn subscribe(\u0026self) -\u003e ClientEventReceiver {\n        self.subscribe()\n    }\n\n    fn latest_event(\u0026self) -\u003e Option\u003cClientEvent\u003e {\n        self.latest_event()\n    }\n\n    fn discover_scrobbles(\n        \u0026self,\n        edit: ScrobbleEdit,\n    ) -\u003e Box\u003cdyn crate::AsyncDiscoveryIterator\u003ccrate::ExactScrobbleEdit\u003e\u003e {\n        let track_name = edit.track_name_original.clone();\n        let album_name = edit.album_name_original.clone();\n\n        match (\u0026track_name, \u0026album_name) {\n            (Some(track_name), Some(album_name)) =\u003e Box::new(crate::ExactMatchDiscovery::new(\n                self.clone(),\n                edit,\n                track_name.clone(),\n                album_name.clone(),\n            )),\n\n            (Some(track_name), None) =\u003e Box::new(crate::TrackVariationsDiscovery::new(\n                self.clone(),\n                edit,\n                track_name.clone(),\n            )),\n\n            (None, Some(album_name)) =\u003e Box::new(crate::AlbumTracksDiscovery::new(\n                self.clone(),\n                edit,\n                album_name.clone(),\n            )),\n\n            (None, None) =\u003e Box::new(crate::ArtistTracksDiscovery::new(self.clone(), edit)),\n        }\n    }\n\n    async fn get_artists_page(\u0026self, page: u32) -\u003e Result\u003ccrate::ArtistPage\u003e {\n        self.get_artists_page(page).await\n    }\n\n    async fn get_artist_tracks_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003cTrackPage\u003e {\n        self.get_artist_tracks_page(artist, page).await\n    }\n\n    async fn get_artist_albums_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003cAlbumPage\u003e {\n        self.get_artist_albums_page(artist, page).await\n    }\n\n    async fn get_album_tracks_page(\n        \u0026self,\n        album_name: \u0026str,\n        artist_name: \u0026str,\n        page: u32,\n    ) -\u003e Result\u003cTrackPage\u003e {\n        self.get_album_tracks_page(album_name, artist_name, page)\n            .await\n    }\n\n    fn artists(\u0026self) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003ccrate::Artist\u003e\u003e {\n        Box::new(crate::iterator::ArtistsIterator::new(self.clone()))\n    }\n\n    fn artist_tracks(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::ArtistTracksIterator::new(\n            self.clone(),\n            artist.to_string(),\n        ))\n    }\n\n    fn artist_tracks_direct(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::iterator::ArtistTracksDirectIterator::new(\n            self.clone(),\n            artist.to_string(),\n        ))\n    }\n\n    fn artist_albums(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003ccrate::Album\u003e\u003e {\n        Box::new(crate::ArtistAlbumsIterator::new(\n            self.clone(),\n            artist.to_string(),\n        ))\n    }\n\n    fn album_tracks(\n        \u0026self,\n        album_name: \u0026str,\n        artist_name: \u0026str,\n    ) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::AlbumTracksIterator::new(\n            self.clone(),\n            album_name.to_string(),\n            artist_name.to_string(),\n        ))\n    }\n\n    fn recent_tracks(\u0026self) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::RecentTracksIterator::new(self.clone()))\n    }\n\n    fn recent_tracks_from_page(\n        \u0026self,\n        starting_page: u32,\n    ) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::RecentTracksIterator::with_starting_page(\n            self.clone(),\n            starting_page,\n        ))\n    }\n\n    fn search_tracks(\u0026self, query: \u0026str) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::SearchTracksIterator::new(\n            self.clone(),\n            query.to_string(),\n        ))\n    }\n\n    fn search_albums(\u0026self, query: \u0026str) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003ccrate::Album\u003e\u003e {\n        Box::new(crate::SearchAlbumsIterator::new(\n            self.clone(),\n            query.to_string(),\n        ))\n    }\n\n    async fn search_tracks_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003ccrate::TrackPage\u003e {\n        self.search_tracks_page(query, page).await\n    }\n\n    async fn search_albums_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003ccrate::AlbumPage\u003e {\n        self.search_albums_page(query, page).await\n    }\n\n    async fn validate_session(\u0026self) -\u003e bool {\n        self.validate_session().await\n    }\n\n    async fn delete_scrobble(\n        \u0026self,\n        artist_name: \u0026str,\n        track_name: \u0026str,\n        timestamp: u64,\n    ) -\u003e Result\u003cbool\u003e {\n        self.delete_scrobble(artist_name, track_name, timestamp)\n            .await\n    }\n}\n","traces":[{"line":31,"address":[5875918,5875924,5875776],"length":1,"stats":{"Line":3}},{"line":32,"address":[5875839],"length":1,"stats":{"Line":1}},{"line":36,"address":[5480960],"length":1,"stats":{"Line":0}},{"line":38,"address":[5312327,5312383],"length":1,"stats":{"Line":0}},{"line":39,"address":[5403671],"length":1,"stats":{"Line":0}},{"line":40,"address":[21014784],"length":1,"stats":{"Line":0}},{"line":41,"address":[20856913],"length":1,"stats":{"Line":0}},{"line":42,"address":[5486259],"length":1,"stats":{"Line":0}},{"line":44,"address":[5403811,5403881],"length":1,"stats":{"Line":0}},{"line":46,"address":[20916079],"length":1,"stats":{"Line":0}},{"line":47,"address":[5403919],"length":1,"stats":{"Line":0}},{"line":51,"address":[5312656,5312674],"length":1,"stats":{"Line":0}},{"line":52,"address":[5646301,5646428,5646533,5647069,5646356],"length":1,"stats":{"Line":0}},{"line":53,"address":[5652516,5652076,5652461,5652630,5652176],"length":1,"stats":{"Line":0}},{"line":55,"address":[5647151,5646371,5646981,5647325,5647038],"length":1,"stats":{"Line":0}},{"line":56,"address":[6044534,6044928,6044946],"length":1,"stats":{"Line":0}},{"line":58,"address":[5478875,5478970],"length":1,"stats":{"Line":0}},{"line":60,"address":[5404016,5404303,5404274],"length":1,"stats":{"Line":9}},{"line":64,"address":[3555312,3555406],"length":1,"stats":{"Line":18}},{"line":67,"address":[5486800,5487124],"length":1,"stats":{"Line":9}},{"line":72,"address":[3555569],"length":1,"stats":{"Line":9}},{"line":73,"address":[3555603],"length":1,"stats":{"Line":9}},{"line":74,"address":[5876875,5876806],"length":1,"stats":{"Line":18}},{"line":78,"address":[3555888,3556422,3556365],"length":1,"stats":{"Line":0}},{"line":83,"address":[5487204,5487451],"length":1,"stats":{"Line":0}},{"line":84,"address":[5487643,5487501,5487316],"length":1,"stats":{"Line":0}},{"line":85,"address":[5313717],"length":1,"stats":{"Line":0}},{"line":88,"address":[20916104],"length":1,"stats":{"Line":0}},{"line":93,"address":[5479687,5479536],"length":1,"stats":{"Line":0}},{"line":94,"address":[6045628,6045498,6045903,6045531],"length":1,"stats":{"Line":0}},{"line":96,"address":[6045749,6045833,6045392,6045984],"length":1,"stats":{"Line":0}},{"line":97,"address":[21015622,21015633,21014992],"length":1,"stats":{"Line":0}},{"line":100,"address":[21328624],"length":1,"stats":{"Line":5}},{"line":105,"address":[5487956,5488074],"length":1,"stats":{"Line":6}},{"line":108,"address":[5878192],"length":1,"stats":{"Line":1}},{"line":114,"address":[5655586,5655744],"length":1,"stats":{"Line":2}},{"line":115,"address":[5577978,5577942,5578392,5578078],"length":1,"stats":{"Line":1}},{"line":117,"address":[5482173,5482266,5481797,5482447],"length":1,"stats":{"Line":2}},{"line":118,"address":[5483322,5483398],"length":1,"stats":{"Line":2}},{"line":119,"address":[5579100],"length":1,"stats":{"Line":1}},{"line":123,"address":[5878708,5878320],"length":1,"stats":{"Line":0}},{"line":130,"address":[5488522],"length":1,"stats":{"Line":0}},{"line":131,"address":[5406166],"length":1,"stats":{"Line":0}},{"line":133,"address":[3557384],"length":1,"stats":{"Line":0}},{"line":137,"address":[5483776],"length":1,"stats":{"Line":0}},{"line":144,"address":[6050100,6050258],"length":1,"stats":{"Line":0}},{"line":145,"address":[6050280,6050316,6050416,6050730],"length":1,"stats":{"Line":0}},{"line":147,"address":[5653439,5653713,5653532,5653063],"length":1,"stats":{"Line":0}},{"line":148,"address":[6051700,6051784],"length":1,"stats":{"Line":0}},{"line":149,"address":[5581678],"length":1,"stats":{"Line":0}},{"line":150,"address":[5581715],"length":1,"stats":{"Line":0}},{"line":151,"address":[5581819],"length":1,"stats":{"Line":0}},{"line":152,"address":[5485825],"length":1,"stats":{"Line":0}},{"line":156,"address":[5489040,5489354],"length":1,"stats":{"Line":3}},{"line":161,"address":[5406741,5406628],"length":1,"stats":{"Line":6}},{"line":164,"address":[5489839,5489392,5489873],"length":1,"stats":{"Line":5}},{"line":170,"address":[5489425],"length":1,"stats":{"Line":3}},{"line":171,"address":[18772325],"length":1,"stats":{"Line":4}},{"line":172,"address":[5879406],"length":1,"stats":{"Line":3}},{"line":173,"address":[5484587,5484515],"length":1,"stats":{"Line":5}},{"line":177,"address":[5490367,5490401,5489904],"length":1,"stats":{"Line":0}},{"line":186,"address":[3558646],"length":1,"stats":{"Line":0}},{"line":188,"address":[3558815],"length":1,"stats":{"Line":0}},{"line":191,"address":[3559040,3559362,3559392],"length":1,"stats":{"Line":9}},{"line":197,"address":[3559078],"length":1,"stats":{"Line":9}},{"line":198,"address":[5316728],"length":1,"stats":{"Line":9}},{"line":199,"address":[5485488],"length":1,"stats":{"Line":9}},{"line":200,"address":[5485538],"length":1,"stats":{"Line":9}},{"line":204,"address":[5408658,5408696,5408352],"length":1,"stats":{"Line":15}},{"line":212,"address":[3559544,3559495],"length":1,"stats":{"Line":22}},{"line":213,"address":[21009703,21009784],"length":1,"stats":{"Line":13}},{"line":219,"address":[5317597,5317408,5317603],"length":1,"stats":{"Line":2}},{"line":220,"address":[5486126,5486257],"length":1,"stats":{"Line":5}},{"line":223,"address":[5318068,5317616],"length":1,"stats":{"Line":0}},{"line":224,"address":[3560352,3559967],"length":1,"stats":{"Line":0}},{"line":227,"address":[5487221,5486784,5487249],"length":1,"stats":{"Line":1}},{"line":228,"address":[5409448],"length":1,"stats":{"Line":1}},{"line":229,"address":[20917341,20917429],"length":1,"stats":{"Line":3}},{"line":232,"address":[20858423,20858315],"length":1,"stats":{"Line":0}},{"line":233,"address":[5487441,5487310],"length":1,"stats":{"Line":0}},{"line":236,"address":[5492608,5492616],"length":1,"stats":{"Line":0}},{"line":238,"address":[5655471,5655347],"length":1,"stats":{"Line":0}},{"line":239,"address":[5655642],"length":1,"stats":{"Line":0}},{"line":241,"address":[5486875],"length":1,"stats":{"Line":0}},{"line":245,"address":[5655903,5655788],"length":1,"stats":{"Line":0}},{"line":248,"address":[20858499],"length":1,"stats":{"Line":0}},{"line":249,"address":[20917585],"length":1,"stats":{"Line":0}},{"line":252,"address":[5487678],"length":1,"stats":{"Line":0}},{"line":254,"address":[5490375],"length":1,"stats":{"Line":0}},{"line":255,"address":[6054259],"length":1,"stats":{"Line":0}},{"line":256,"address":[5488652,5488474,5488539],"length":1,"stats":{"Line":0}},{"line":257,"address":[6054403,6054527],"length":1,"stats":{"Line":0}},{"line":258,"address":[2887458],"length":1,"stats":{"Line":0}},{"line":259,"address":[5584906],"length":1,"stats":{"Line":0}},{"line":260,"address":[5584953],"length":1,"stats":{"Line":0}},{"line":262,"address":[2887631],"length":1,"stats":{"Line":0}},{"line":266,"address":[5584732],"length":1,"stats":{"Line":0}},{"line":268,"address":[5662228],"length":1,"stats":{"Line":0}},{"line":272,"address":[5410160],"length":1,"stats":{"Line":0}},{"line":285,"address":[5585436],"length":1,"stats":{"Line":0}},{"line":286,"address":[5585553],"length":1,"stats":{"Line":0}},{"line":287,"address":[5663444],"length":1,"stats":{"Line":0}},{"line":289,"address":[5585959,5586366,5585832,5586237],"length":1,"stats":{"Line":0}},{"line":292,"address":[5585683,5586872,5586848],"length":1,"stats":{"Line":0}},{"line":293,"address":[6056736],"length":1,"stats":{"Line":0}},{"line":294,"address":[2889611,2889645],"length":1,"stats":{"Line":0}},{"line":296,"address":[6056787],"length":1,"stats":{"Line":0}},{"line":297,"address":[5491013],"length":1,"stats":{"Line":0}},{"line":300,"address":[5665020,5664975],"length":1,"stats":{"Line":0}},{"line":302,"address":[5665872,5663601,5665312,5665866],"length":1,"stats":{"Line":0}},{"line":303,"address":[5491504,5491848],"length":1,"stats":{"Line":0}},{"line":304,"address":[5587831],"length":1,"stats":{"Line":0}},{"line":305,"address":[5660200],"length":1,"stats":{"Line":0}},{"line":308,"address":[5665696],"length":1,"stats":{"Line":0}},{"line":313,"address":[5658645,5658748,5658954,5658588,5658139],"length":1,"stats":{"Line":0}},{"line":315,"address":[5490381],"length":1,"stats":{"Line":0}},{"line":316,"address":[18773187,18773099],"length":1,"stats":{"Line":0}},{"line":320,"address":[3561200],"length":1,"stats":{"Line":0}},{"line":327,"address":[5661228,5661023],"length":1,"stats":{"Line":0}},{"line":328,"address":[5661457,5661399],"length":1,"stats":{"Line":0}},{"line":330,"address":[5492632,5492734],"length":1,"stats":{"Line":0}},{"line":334,"address":[6058825,6058722,6058872],"length":1,"stats":{"Line":0}},{"line":336,"address":[5661727,5662009],"length":1,"stats":{"Line":0}},{"line":337,"address":[2892068,2892005],"length":1,"stats":{"Line":0}},{"line":340,"address":[5962386],"length":1,"stats":{"Line":0}},{"line":341,"address":[6060323,6060753,6060639,6060211,6064794,6060581],"length":1,"stats":{"Line":0}},{"line":343,"address":[5661115,5663317,5663252,5663192,5663509],"length":1,"stats":{"Line":0}},{"line":344,"address":[5494929,5502336,5502354],"length":1,"stats":{"Line":0}},{"line":346,"address":[5591100,5591205],"length":1,"stats":{"Line":0}},{"line":347,"address":[2893723,2897411,2893827],"length":1,"stats":{"Line":0}},{"line":349,"address":[5664276,5664331,5664173],"length":1,"stats":{"Line":0}},{"line":351,"address":[5669450,5669790],"length":1,"stats":{"Line":0}},{"line":354,"address":[6061836,6061930],"length":1,"stats":{"Line":0}},{"line":355,"address":[6062022,6062123],"length":1,"stats":{"Line":0}},{"line":356,"address":[5665085],"length":1,"stats":{"Line":0}},{"line":359,"address":[5665339,5665469],"length":1,"stats":{"Line":0}},{"line":361,"address":[5665945],"length":1,"stats":{"Line":0}},{"line":362,"address":[2895260],"length":1,"stats":{"Line":0}},{"line":363,"address":[2895357],"length":1,"stats":{"Line":0}},{"line":364,"address":[5670810],"length":1,"stats":{"Line":0}},{"line":365,"address":[2895487,2895628],"length":1,"stats":{"Line":0}},{"line":366,"address":[6062995],"length":1,"stats":{"Line":0}},{"line":369,"address":[5666184,5666341,5666086],"length":1,"stats":{"Line":0}},{"line":371,"address":[5502480,5502513],"length":1,"stats":{"Line":0}},{"line":375,"address":[5497767],"length":1,"stats":{"Line":0}},{"line":377,"address":[2896299,2896398],"length":1,"stats":{"Line":0}},{"line":381,"address":[5666589,5667037],"length":1,"stats":{"Line":0}},{"line":382,"address":[2896840,2896958],"length":1,"stats":{"Line":0}},{"line":384,"address":[6064361,6064308],"length":1,"stats":{"Line":0}},{"line":385,"address":[5594571],"length":1,"stats":{"Line":0}},{"line":388,"address":[2897355,2897661,2897705,2897795,2897146,2897272,2898886],"length":1,"stats":{"Line":0}},{"line":390,"address":[6064540],"length":1,"stats":{"Line":0}},{"line":391,"address":[5667721,5667911,5667625,5661136,5667560],"length":1,"stats":{"Line":0}},{"line":392,"address":[5673187,5676770,5676752],"length":1,"stats":{"Line":0}},{"line":394,"address":[2897923,2898255],"length":1,"stats":{"Line":0}},{"line":395,"address":[5499518],"length":1,"stats":{"Line":0}},{"line":396,"address":[5673447,5673524],"length":1,"stats":{"Line":0}},{"line":397,"address":[5668382,5668470],"length":1,"stats":{"Line":0}},{"line":400,"address":[5673840,5673929],"length":1,"stats":{"Line":0}},{"line":402,"address":[2899144,2899070,2898822,2899234,2898452],"length":1,"stats":{"Line":0}},{"line":404,"address":[5500443,5500505,5492469,5500694,5500383],"length":1,"stats":{"Line":0}},{"line":405,"address":[5596834,5599072,5599090],"length":1,"stats":{"Line":0}},{"line":407,"address":[5597047,5596967],"length":1,"stats":{"Line":0}},{"line":409,"address":[2899458],"length":1,"stats":{"Line":0}},{"line":410,"address":[5597512,5597140],"length":1,"stats":{"Line":0}},{"line":412,"address":[5597242,5597189,5597098],"length":1,"stats":{"Line":0}},{"line":415,"address":[5675023],"length":1,"stats":{"Line":0}},{"line":418,"address":[5882720],"length":1,"stats":{"Line":2}},{"line":419,"address":[5492853],"length":1,"stats":{"Line":2}},{"line":422,"address":[5882752],"length":1,"stats":{"Line":1}},{"line":423,"address":[5410432],"length":1,"stats":{"Line":1}},{"line":426,"address":[5493145,5492960,5493116],"length":1,"stats":{"Line":4}},{"line":427,"address":[5487876,5487951],"length":1,"stats":{"Line":5}},{"line":430,"address":[5488060,5488048],"length":1,"stats":{"Line":6}},{"line":432,"address":[5677347,5677193],"length":1,"stats":{"Line":2}},{"line":433,"address":[5503720,5503662],"length":1,"stats":{"Line":2}},{"line":435,"address":[5677541,5677439],"length":1,"stats":{"Line":2}},{"line":439,"address":[5672713,5672769,5672613],"length":1,"stats":{"Line":3}},{"line":440,"address":[5599434,5600407,5600543,5600063,5601115],"length":1,"stats":{"Line":2}},{"line":441,"address":[18773413],"length":1,"stats":{"Line":4}},{"line":443,"address":[5673740,5673799,5673985,5673680,5672111],"length":1,"stats":{"Line":3}},{"line":444,"address":[5602528,5602546,5601437],"length":1,"stats":{"Line":0}},{"line":446,"address":[5679660],"length":1,"stats":{"Line":0}},{"line":452,"address":[2903970,2904379],"length":1,"stats":{"Line":2}},{"line":453,"address":[20918130],"length":1,"stats":{"Line":1}},{"line":456,"address":[6073442,6072583,6072620,6072467,6072432,6072746],"length":1,"stats":{"Line":0}},{"line":457,"address":[5603012,5602850,5603688,5602907,5602793],"length":1,"stats":{"Line":0}},{"line":459,"address":[21331047,21330622,21330946,21331783],"length":1,"stats":{"Line":0}},{"line":461,"address":[5507484],"length":1,"stats":{"Line":0}},{"line":462,"address":[5681279],"length":1,"stats":{"Line":0}},{"line":463,"address":[21331147],"length":1,"stats":{"Line":0}},{"line":464,"address":[21331215],"length":1,"stats":{"Line":0}},{"line":465,"address":[21331278],"length":1,"stats":{"Line":0}},{"line":469,"address":[5883088],"length":1,"stats":{"Line":0}},{"line":475,"address":[6073804,6073851,6073668],"length":1,"stats":{"Line":0}},{"line":477,"address":[6074168,6073810,6075226],"length":1,"stats":{"Line":0}},{"line":478,"address":[5508774,5509490,5507945,5510043,5511037,5508502,5508530],"length":1,"stats":{"Line":0}},{"line":480,"address":[5677658,5677766,5677901],"length":1,"stats":{"Line":0}},{"line":481,"address":[18774453],"length":1,"stats":{"Line":0}},{"line":482,"address":[20919287,20919094,20918053,20919159,20919329],"length":1,"stats":{"Line":0}},{"line":487,"address":[2908502],"length":1,"stats":{"Line":0}},{"line":492,"address":[5605651,5605556],"length":1,"stats":{"Line":0}},{"line":495,"address":[5509576],"length":1,"stats":{"Line":0}},{"line":498,"address":[21334119,21332694,21334881,21333600,21334245,21332965,21335033,21333481,21333345,21334753,21333729,21332553,21334501,21332841,21333097,21333989,21334624,21335159,21333223,21334377,21333861],"length":1,"stats":{"Line":4}},{"line":499,"address":[5607616,5607491,5609887,5607288,5607370],"length":1,"stats":{"Line":2}},{"line":501,"address":[6077788,6077879],"length":1,"stats":{"Line":2}},{"line":502,"address":[5513010,5512138],"length":1,"stats":{"Line":0}},{"line":503,"address":[18778144],"length":1,"stats":{"Line":0}},{"line":504,"address":[6079217,6078772],"length":1,"stats":{"Line":0}},{"line":506,"address":[6078842],"length":1,"stats":{"Line":0}},{"line":507,"address":[5609098,5609298],"length":1,"stats":{"Line":0}},{"line":509,"address":[5681784],"length":1,"stats":{"Line":0}},{"line":511,"address":[2911392,2911784],"length":1,"stats":{"Line":0}},{"line":516,"address":[5681049],"length":1,"stats":{"Line":1}},{"line":521,"address":[5608286],"length":1,"stats":{"Line":1}},{"line":523,"address":[5686633,5688222,5686775,5686515],"length":1,"stats":{"Line":4}},{"line":524,"address":[5514787,5514856],"length":1,"stats":{"Line":0}},{"line":532,"address":[6080489],"length":1,"stats":{"Line":1}},{"line":534,"address":[5515226,5515576],"length":1,"stats":{"Line":2}},{"line":535,"address":[6081256,6081233,6081096],"length":1,"stats":{"Line":2}},{"line":537,"address":[2913920,2913702,2913443],"length":1,"stats":{"Line":3}},{"line":538,"address":[5611626,5611686,5611709],"length":1,"stats":{"Line":2}},{"line":540,"address":[5611867,5611841,5611645],"length":1,"stats":{"Line":2}},{"line":541,"address":[5612317,5612000],"length":1,"stats":{"Line":2}},{"line":542,"address":[5684814,5684734,5684840],"length":1,"stats":{"Line":2}},{"line":544,"address":[5684753],"length":1,"stats":{"Line":1}},{"line":546,"address":[6082124,6081884],"length":1,"stats":{"Line":2}},{"line":552,"address":[3096247],"length":1,"stats":{"Line":2}},{"line":553,"address":[5690873],"length":1,"stats":{"Line":1}},{"line":554,"address":[5517060],"length":1,"stats":{"Line":1}},{"line":556,"address":[5691157,5690950],"length":1,"stats":{"Line":2}},{"line":558,"address":[5685801],"length":1,"stats":{"Line":1}},{"line":559,"address":[2915225],"length":1,"stats":{"Line":1}},{"line":560,"address":[6083022],"length":1,"stats":{"Line":1}},{"line":563,"address":[5691293],"length":1,"stats":{"Line":1}},{"line":564,"address":[5686232],"length":1,"stats":{"Line":1}},{"line":566,"address":[6083381,6083459],"length":1,"stats":{"Line":0}},{"line":567,"address":[5691426],"length":1,"stats":{"Line":0}},{"line":569,"address":[2915768,2912158,2912128,2909600,2915728],"length":1,"stats":{"Line":0}},{"line":573,"address":[6080300],"length":1,"stats":{"Line":1}},{"line":576,"address":[5488256],"length":1,"stats":{"Line":1}},{"line":588,"address":[5614184],"length":1,"stats":{"Line":1}},{"line":589,"address":[5692120],"length":1,"stats":{"Line":1}},{"line":591,"address":[5614455,5614849,5614989,5614581],"length":1,"stats":{"Line":4}},{"line":594,"address":[5616752,5614362,5616772],"length":1,"stats":{"Line":3}},{"line":595,"address":[5694624],"length":1,"stats":{"Line":0}},{"line":596,"address":[5616877,5616843],"length":1,"stats":{"Line":0}},{"line":597,"address":[18791696,18791707],"length":1,"stats":{"Line":0}},{"line":598,"address":[5520819],"length":1,"stats":{"Line":0}},{"line":599,"address":[21348757],"length":1,"stats":{"Line":0}},{"line":602,"address":[2918894,2918939],"length":1,"stats":{"Line":0}},{"line":604,"address":[5692237,5695654,5695136,5695648],"length":1,"stats":{"Line":1}},{"line":605,"address":[6087120,6087422],"length":1,"stats":{"Line":0}},{"line":606,"address":[5521581],"length":1,"stats":{"Line":0}},{"line":607,"address":[2919288],"length":1,"stats":{"Line":0}},{"line":613,"address":[2919570],"length":1,"stats":{"Line":0}},{"line":618,"address":[6083991,6084678,6084464,6084371,6084314],"length":1,"stats":{"Line":3}},{"line":620,"address":[5615166,5615031,5615247],"length":1,"stats":{"Line":3}},{"line":621,"address":[5519012],"length":1,"stats":{"Line":1}},{"line":622,"address":[2917031],"length":1,"stats":{"Line":1}},{"line":623,"address":[5615081],"length":1,"stats":{"Line":1}},{"line":624,"address":[18778208],"length":1,"stats":{"Line":1}},{"line":626,"address":[21021702],"length":1,"stats":{"Line":0}},{"line":628,"address":[5693384,5693251],"length":1,"stats":{"Line":0}},{"line":629,"address":[5519668],"length":1,"stats":{"Line":0}},{"line":630,"address":[5693550],"length":1,"stats":{"Line":0}},{"line":632,"address":[5688114,5688913,5688836],"length":1,"stats":{"Line":0}},{"line":633,"address":[18778272,18778277],"length":1,"stats":{"Line":0}},{"line":634,"address":[2917998,2917475],"length":1,"stats":{"Line":0}},{"line":635,"address":[2918038],"length":1,"stats":{"Line":0}},{"line":636,"address":[5688771],"length":1,"stats":{"Line":0}},{"line":641,"address":[21335394],"length":1,"stats":{"Line":4}},{"line":642,"address":[5618149,5618008],"length":1,"stats":{"Line":2}},{"line":643,"address":[6087832,6088061,6087915],"length":1,"stats":{"Line":1}},{"line":644,"address":[5691283,5691198],"length":1,"stats":{"Line":2}},{"line":646,"address":[5618680],"length":1,"stats":{"Line":1}},{"line":647,"address":[5691419],"length":1,"stats":{"Line":1}},{"line":648,"address":[5618784,5618882],"length":1,"stats":{"Line":2}},{"line":649,"address":[2920677],"length":1,"stats":{"Line":1}},{"line":650,"address":[5696649],"length":1,"stats":{"Line":1}},{"line":651,"address":[5696665],"length":1,"stats":{"Line":1}},{"line":655,"address":[5522684],"length":1,"stats":{"Line":0}},{"line":656,"address":[5523217,5522692],"length":1,"stats":{"Line":0}},{"line":657,"address":[5696565],"length":1,"stats":{"Line":0}},{"line":659,"address":[5697008,5696937],"length":1,"stats":{"Line":0}},{"line":665,"address":[6088739],"length":1,"stats":{"Line":1}},{"line":668,"address":[2921538,2921200,2922488,2921277,2921453],"length":1,"stats":{"Line":4}},{"line":670,"address":[2921416,2921604],"length":1,"stats":{"Line":2}},{"line":671,"address":[5692629,5692571],"length":1,"stats":{"Line":2}},{"line":673,"address":[5523804,5523906],"length":1,"stats":{"Line":2}},{"line":677,"address":[2921962,2922065,2922127],"length":1,"stats":{"Line":3}},{"line":678,"address":[5496562],"length":1,"stats":{"Line":2}},{"line":680,"address":[5698940,5699045],"length":1,"stats":{"Line":2}},{"line":681,"address":[5525215,5529052,5525307],"length":1,"stats":{"Line":2}},{"line":683,"address":[2923317,2923420,2923482],"length":1,"stats":{"Line":3}},{"line":685,"address":[6091718,6091402],"length":1,"stats":{"Line":2}},{"line":687,"address":[5699805,5699952,5699905],"length":1,"stats":{"Line":3}},{"line":693,"address":[5699911,5700305],"length":1,"stats":{"Line":2}},{"line":694,"address":[5526665,5526541,5526637],"length":1,"stats":{"Line":3}},{"line":697,"address":[5623159,5623055],"length":1,"stats":{"Line":2}},{"line":700,"address":[2925017,2925115],"length":1,"stats":{"Line":2}},{"line":701,"address":[6093316,6093215],"length":1,"stats":{"Line":2}},{"line":702,"address":[5696278],"length":1,"stats":{"Line":1}},{"line":705,"address":[5696662,5696532],"length":1,"stats":{"Line":2}},{"line":707,"address":[5696895,5696746,5696673],"length":1,"stats":{"Line":3}},{"line":709,"address":[5627792,5627838],"length":1,"stats":{"Line":2}},{"line":713,"address":[5624353],"length":1,"stats":{"Line":1}},{"line":715,"address":[5528397],"length":1,"stats":{"Line":1}},{"line":716,"address":[5697171,5697286],"length":1,"stats":{"Line":2}},{"line":718,"address":[5702506,5702460],"length":1,"stats":{"Line":2}},{"line":719,"address":[6094427],"length":1,"stats":{"Line":1}},{"line":722,"address":[2927145,2928223,2926622,2926496,2926705,2927011,2927055],"length":1,"stats":{"Line":5}},{"line":724,"address":[5528829],"length":1,"stats":{"Line":1}},{"line":725,"address":[5966472],"length":1,"stats":{"Line":3}},{"line":726,"address":[6098018,6098000,6095204],"length":1,"stats":{"Line":0}},{"line":728,"address":[6095362,6095695],"length":1,"stats":{"Line":2}},{"line":729,"address":[5625633],"length":1,"stats":{"Line":1}},{"line":730,"address":[5625768,5625691],"length":1,"stats":{"Line":2}},{"line":731,"address":[5703618,5703706],"length":1,"stats":{"Line":2}},{"line":734,"address":[5698740,5698829],"length":1,"stats":{"Line":2}},{"line":736,"address":[5704637,5703960,5704334,5704579,5704751],"length":1,"stats":{"Line":4}},{"line":738,"address":[3105834],"length":1,"stats":{"Line":3}},{"line":739,"address":[2930023,2930000,2928532],"length":1,"stats":{"Line":0}},{"line":741,"address":[5531085,5531004],"length":1,"stats":{"Line":2}},{"line":743,"address":[5627185],"length":1,"stats":{"Line":1}},{"line":746,"address":[2930144,2930359,2930304,2930474,2930194,2931092],"length":1,"stats":{"Line":4}},{"line":747,"address":[5960607],"length":1,"stats":{"Line":2}},{"line":748,"address":[5707535,5707480,5707195,5707095,5707649],"length":1,"stats":{"Line":4}},{"line":750,"address":[5702170,5701390,5702000,5702344,5702057],"length":1,"stats":{"Line":3}},{"line":751,"address":[5708306,5708288,5707617],"length":1,"stats":{"Line":0}},{"line":753,"address":[6099686,6099776,6099881],"length":1,"stats":{"Line":3}},{"line":754,"address":[5630022],"length":1,"stats":{"Line":1}},{"line":757,"address":[5883408],"length":1,"stats":{"Line":2}},{"line":762,"address":[5703525,5703780,5703736],"length":1,"stats":{"Line":6}},{"line":765,"address":[6101223,6100846],"length":1,"stats":{"Line":4}},{"line":766,"address":[5704348,5704499,5704398,5704290],"length":1,"stats":{"Line":6}},{"line":768,"address":[2933119],"length":1,"stats":{"Line":2}},{"line":769,"address":[2933213],"length":1,"stats":{"Line":2}},{"line":770,"address":[5704367],"length":1,"stats":{"Line":1}},{"line":771,"address":[5704469],"length":1,"stats":{"Line":1}},{"line":775,"address":[5536088,5536188,5536244],"length":1,"stats":{"Line":3}},{"line":777,"address":[5705244,5706003,5704882,5705389,5703603],"length":1,"stats":{"Line":3}},{"line":778,"address":[5711531,5710992,5711359,5713234,5711104,5711417],"length":1,"stats":{"Line":4}},{"line":780,"address":[2935075,2934883,2934761,2934821,2932536],"length":1,"stats":{"Line":3}},{"line":781,"address":[2935175,2942240,2942263],"length":1,"stats":{"Line":0}},{"line":783,"address":[2935310,2935415],"length":1,"stats":{"Line":2}},{"line":785,"address":[5711769],"length":1,"stats":{"Line":1}},{"line":786,"address":[2935529],"length":1,"stats":{"Line":1}},{"line":787,"address":[6103880],"length":1,"stats":{"Line":1}},{"line":789,"address":[6103939,6103898,6104031,6105127,6104118],"length":1,"stats":{"Line":3}},{"line":790,"address":[5538118],"length":1,"stats":{"Line":1}},{"line":791,"address":[5538128],"length":1,"stats":{"Line":1}},{"line":792,"address":[5538135],"length":1,"stats":{"Line":1}},{"line":793,"address":[2935663],"length":1,"stats":{"Line":1}},{"line":795,"address":[5538442],"length":1,"stats":{"Line":1}},{"line":797,"address":[5538665,5538573,5538793],"length":1,"stats":{"Line":0}},{"line":802,"address":[5707687,5707319],"length":1,"stats":{"Line":2}},{"line":803,"address":[5713025,5712930],"length":1,"stats":{"Line":2}},{"line":804,"address":[5713154],"length":1,"stats":{"Line":1}},{"line":806,"address":[5710359,5708004],"length":1,"stats":{"Line":2}},{"line":808,"address":[5715557,5716801],"length":1,"stats":{"Line":2}},{"line":809,"address":[5543150,5543098,5543301,5543200],"length":1,"stats":{"Line":4}},{"line":811,"address":[5543025],"length":1,"stats":{"Line":1}},{"line":812,"address":[6108913],"length":1,"stats":{"Line":1}},{"line":813,"address":[5543169],"length":1,"stats":{"Line":1}},{"line":814,"address":[2940671],"length":1,"stats":{"Line":1}},{"line":818,"address":[2941119,2941023],"length":1,"stats":{"Line":2}},{"line":820,"address":[6110407,6105201,6109475,6100749,6109807,6109891],"length":1,"stats":{"Line":3}},{"line":821,"address":[2941880,2941941,2937335,2937120,2937245,2942100],"length":1,"stats":{"Line":4}},{"line":823,"address":[5575434],"length":1,"stats":{"Line":4}},{"line":824,"address":[5713728,5713746,5708519],"length":1,"stats":{"Line":0}},{"line":826,"address":[5539972,5540055],"length":1,"stats":{"Line":2}},{"line":828,"address":[5713961,5714137,5713930,5714050],"length":1,"stats":{"Line":3}},{"line":830,"address":[6105878],"length":1,"stats":{"Line":1}},{"line":831,"address":[2937561],"length":1,"stats":{"Line":1}},{"line":832,"address":[5713957],"length":1,"stats":{"Line":1}},{"line":835,"address":[5709161,5709078],"length":1,"stats":{"Line":2}},{"line":836,"address":[5540481],"length":1,"stats":{"Line":1}},{"line":837,"address":[6106354],"length":1,"stats":{"Line":1}},{"line":839,"address":[5540633],"length":1,"stats":{"Line":1}},{"line":841,"address":[5709731],"length":1,"stats":{"Line":2}},{"line":851,"address":[5636897,5637525,5637484],"length":1,"stats":{"Line":2}},{"line":854,"address":[5637778,5637670],"length":1,"stats":{"Line":2}},{"line":855,"address":[2939225,2940057],"length":1,"stats":{"Line":0}},{"line":860,"address":[5715907],"length":1,"stats":{"Line":0}},{"line":865,"address":[5710532],"length":1,"stats":{"Line":1}},{"line":868,"address":[5887074,5883472,5888176],"length":1,"stats":{"Line":1}},{"line":875,"address":[5883575],"length":1,"stats":{"Line":1}},{"line":876,"address":[3562308,3562236],"length":1,"stats":{"Line":2}},{"line":878,"address":[5493922,5494061,5494183,5493993],"length":1,"stats":{"Line":3}},{"line":879,"address":[5719054],"length":1,"stats":{"Line":0}},{"line":882,"address":[5320503],"length":1,"stats":{"Line":1}},{"line":883,"address":[5884327,5884248,5884451],"length":1,"stats":{"Line":3}},{"line":884,"address":[3563253,3563059],"length":1,"stats":{"Line":2}},{"line":885,"address":[5494883,5494962],"length":1,"stats":{"Line":2}},{"line":886,"address":[5887896,5887822],"length":1,"stats":{"Line":0}},{"line":890,"address":[5495110],"length":1,"stats":{"Line":1}},{"line":891,"address":[5885213,5885063,5885142,5887584],"length":1,"stats":{"Line":4}},{"line":892,"address":[5545280,5545877,5545871],"length":1,"stats":{"Line":2}},{"line":893,"address":[5545320],"length":1,"stats":{"Line":1}},{"line":894,"address":[5719496,5719588],"length":1,"stats":{"Line":2}},{"line":896,"address":[5641936,5641937],"length":1,"stats":{"Line":2}},{"line":897,"address":[5641984,5642006],"length":1,"stats":{"Line":2}},{"line":900,"address":[5490370,5490313],"length":1,"stats":{"Line":2}},{"line":901,"address":[5321793,5321717],"length":1,"stats":{"Line":2}},{"line":902,"address":[5495620,5495693],"length":1,"stats":{"Line":2}},{"line":903,"address":[3564124,3564197],"length":1,"stats":{"Line":4}},{"line":905,"address":[3564335,3564243],"length":1,"stats":{"Line":2}},{"line":907,"address":[5322178,5322284,5322240],"length":1,"stats":{"Line":3}},{"line":908,"address":[3564491],"length":1,"stats":{"Line":1}},{"line":909,"address":[5491169],"length":1,"stats":{"Line":1}},{"line":910,"address":[5496323,5496393],"length":1,"stats":{"Line":1}},{"line":911,"address":[3564765],"length":1,"stats":{"Line":0}},{"line":913,"address":[3564795,3564742],"length":1,"stats":{"Line":2}},{"line":916,"address":[5886363],"length":1,"stats":{"Line":1}},{"line":918,"address":[5414118,5414046],"length":1,"stats":{"Line":2}},{"line":919,"address":[5496606,5496674],"length":1,"stats":{"Line":2}},{"line":920,"address":[3565066,3565131],"length":1,"stats":{"Line":2}},{"line":921,"address":[5496755],"length":1,"stats":{"Line":1}},{"line":922,"address":[3565209],"length":1,"stats":{"Line":1}},{"line":923,"address":[5414385],"length":1,"stats":{"Line":1}},{"line":924,"address":[5414425],"length":1,"stats":{"Line":1}},{"line":925,"address":[5323153],"length":1,"stats":{"Line":1}},{"line":929,"address":[5492037],"length":1,"stats":{"Line":1}},{"line":931,"address":[5887128,5886425],"length":1,"stats":{"Line":0}},{"line":940,"address":[3563120],"length":1,"stats":{"Line":1}},{"line":943,"address":[5643604,5642080,5642356,5642142,5642292],"length":1,"stats":{"Line":6}},{"line":945,"address":[5720081,5720235],"length":1,"stats":{"Line":2}},{"line":946,"address":[5715296,5715238,5715346],"length":1,"stats":{"Line":3}},{"line":948,"address":[2943795],"length":1,"stats":{"Line":1}},{"line":949,"address":[5546573],"length":1,"stats":{"Line":1}},{"line":950,"address":[2943931],"length":1,"stats":{"Line":1}},{"line":955,"address":[5642982,5643082,5643138],"length":1,"stats":{"Line":3}},{"line":956,"address":[6113977,6113396,6112082,6112848,6113257],"length":1,"stats":{"Line":2}},{"line":957,"address":[5644047,5644153,5644405,5644577,5644463],"length":1,"stats":{"Line":6}},{"line":959,"address":[5399874],"length":1,"stats":{"Line":5}},{"line":960,"address":[6114305,6115698,6115680],"length":1,"stats":{"Line":0}},{"line":962,"address":[5548787,5548646,5548736,5548894,5548954],"length":1,"stats":{"Line":0}},{"line":968,"address":[5645240,5645206,5644774],"length":1,"stats":{"Line":4}},{"line":969,"address":[5549433,5549188],"length":1,"stats":{"Line":3}},{"line":970,"address":[5645484],"length":1,"stats":{"Line":1}},{"line":973,"address":[5324592],"length":1,"stats":{"Line":0}},{"line":979,"address":[5324639],"length":1,"stats":{"Line":0}},{"line":983,"address":[5888336],"length":1,"stats":{"Line":0}},{"line":990,"address":[5493416],"length":1,"stats":{"Line":0}},{"line":994,"address":[5888432],"length":1,"stats":{"Line":0}},{"line":995,"address":[5416101],"length":1,"stats":{"Line":0}},{"line":998,"address":[5499027,5498608,5499021],"length":1,"stats":{"Line":1}},{"line":999,"address":[5493542],"length":1,"stats":{"Line":1}},{"line":1001,"address":[5416433,5416361,5416293,5416228],"length":1,"stats":{"Line":4}},{"line":1004,"address":[5646064,5646065],"length":1,"stats":{"Line":2}},{"line":1005,"address":[5723936,5723958],"length":1,"stats":{"Line":2}},{"line":1006,"address":[3567270],"length":1,"stats":{"Line":1}},{"line":1009,"address":[5646748,5646483,5646210,5646364,5646327,5646160],"length":1,"stats":{"Line":8}},{"line":1010,"address":[5550477,5550276,5550379,5550322],"length":1,"stats":{"Line":4}},{"line":1013,"address":[5550789,5551540,5550958,5552204,5550918,5550736],"length":1,"stats":{"Line":8}},{"line":1014,"address":[5550899],"length":1,"stats":{"Line":1}},{"line":1016,"address":[6116800],"length":1,"stats":{"Line":3}},{"line":1017,"address":[5724900],"length":1,"stats":{"Line":1}},{"line":1020,"address":[21336504,21335488,21335712,21335529,21335443,21336906],"length":1,"stats":{"Line":0}},{"line":1021,"address":[5719796,5719872],"length":1,"stats":{"Line":4}},{"line":1022,"address":[5725245,5726238,5726426,5726362,5726176,5726152,5726607,5726144,5727363],"length":1,"stats":{"Line":10}},{"line":1023,"address":[5649483,5648476,5648809,5648673,5648568],"length":1,"stats":{"Line":7}},{"line":1025,"address":[5724079,5722026,5722072,5722503,5721888,5722358,5722416],"length":1,"stats":{"Line":11}},{"line":1026,"address":[5727075,5727182],"length":1,"stats":{"Line":6}},{"line":1027,"address":[5727213,5726413,5727639,5727369,5727273,5727558],"length":1,"stats":{"Line":11}},{"line":1029,"address":[5727860,5727780,5727938],"length":1,"stats":{"Line":9}},{"line":1030,"address":[5723805,5723709,5722851],"length":1,"stats":{"Line":3}},{"line":1031,"address":[5723715],"length":1,"stats":{"Line":1}},{"line":1034,"address":[21022523],"length":1,"stats":{"Line":2}},{"line":1035,"address":[5728169,5728094],"length":1,"stats":{"Line":2}},{"line":1036,"address":[5650710,5650529],"length":1,"stats":{"Line":2}},{"line":1037,"address":[21335752,21336745,21336363,21336934,21335477,21336796],"length":1,"stats":{"Line":1}},{"line":1040,"address":[6120299],"length":1,"stats":{"Line":2}},{"line":1042,"address":[2951717],"length":1,"stats":{"Line":1}},{"line":1044,"address":[2952496],"length":1,"stats":{"Line":1}},{"line":1045,"address":[2952573,2952539],"length":1,"stats":{"Line":2}},{"line":1047,"address":[5555459],"length":1,"stats":{"Line":1}},{"line":1048,"address":[5724165],"length":1,"stats":{"Line":1}},{"line":1051,"address":[5724316,5724271],"length":1,"stats":{"Line":2}},{"line":1053,"address":[6121712],"length":1,"stats":{"Line":1}},{"line":1054,"address":[5724652,5724707],"length":1,"stats":{"Line":2}},{"line":1055,"address":[2953060],"length":1,"stats":{"Line":1}},{"line":1056,"address":[5729867],"length":1,"stats":{"Line":1}},{"line":1061,"address":[5551509,5551566,5551828,5551323,5551747,5551449,5551967,5552210,5550945],"length":1,"stats":{"Line":14}},{"line":1063,"address":[5725936],"length":1,"stats":{"Line":1}},{"line":1066,"address":[5654456,5654462,5652144,5654705,5652416,5652221],"length":1,"stats":{"Line":8}},{"line":1067,"address":[20925750],"length":1,"stats":{"Line":2}},{"line":1068,"address":[5730347,5732336],"length":1,"stats":{"Line":0}},{"line":1071,"address":[5652480,5652599],"length":1,"stats":{"Line":5}},{"line":1074,"address":[5556749,5556655],"length":1,"stats":{"Line":5}},{"line":1075,"address":[5730796,5730697],"length":1,"stats":{"Line":2}},{"line":1076,"address":[5653038,5653130],"length":1,"stats":{"Line":4}},{"line":1077,"address":[6122949],"length":1,"stats":{"Line":0}},{"line":1081,"address":[5653486],"length":1,"stats":{"Line":1}},{"line":1082,"address":[5731443,5731666,5731372],"length":1,"stats":{"Line":6}},{"line":1083,"address":[5653621,5653716],"length":1,"stats":{"Line":5}},{"line":1085,"address":[5653607],"length":1,"stats":{"Line":2}},{"line":1088,"address":[5726324],"length":1,"stats":{"Line":2}},{"line":1090,"address":[2954863],"length":1,"stats":{"Line":2}},{"line":1091,"address":[21339434],"length":1,"stats":{"Line":5}},{"line":1093,"address":[6123768,6123814],"length":1,"stats":{"Line":6}},{"line":1094,"address":[5654039],"length":1,"stats":{"Line":2}},{"line":1097,"address":[5727053,5727717,5726843,5727575,5726970,5734090,5727603],"length":1,"stats":{"Line":17}},{"line":1099,"address":[20867423,20867782],"length":1,"stats":{"Line":5}},{"line":1100,"address":[5558387,5558322,5558889,5558699,5556414],"length":1,"stats":{"Line":12}},{"line":1101,"address":[2962647,2956021,2962624],"length":1,"stats":{"Line":4}},{"line":1103,"address":[5733380,5733017],"length":1,"stats":{"Line":3}},{"line":1104,"address":[20929798,20927236],"length":1,"stats":{"Line":2}},{"line":1105,"address":[6125042,6125125],"length":1,"stats":{"Line":3}},{"line":1106,"address":[5728150,5728050],"length":1,"stats":{"Line":3}},{"line":1109,"address":[5655705],"length":1,"stats":{"Line":1}},{"line":1111,"address":[5655922,5655738],"length":1,"stats":{"Line":7}},{"line":1112,"address":[5733692,5733838],"length":1,"stats":{"Line":2}},{"line":1113,"address":[6125829],"length":1,"stats":{"Line":1}},{"line":1114,"address":[5656159],"length":1,"stats":{"Line":1}},{"line":1115,"address":[5560207],"length":1,"stats":{"Line":1}},{"line":1116,"address":[18783137],"length":1,"stats":{"Line":0}},{"line":1118,"address":[5656807,5656404],"length":1,"stats":{"Line":0}},{"line":1119,"address":[5562408,5562368,5560784],"length":1,"stats":{"Line":0}},{"line":1120,"address":[2959581],"length":1,"stats":{"Line":0}},{"line":1121,"address":[5731062],"length":1,"stats":{"Line":0}},{"line":1126,"address":[6126631,6126058],"length":1,"stats":{"Line":2}},{"line":1127,"address":[5730321,5729585],"length":1,"stats":{"Line":2}},{"line":1128,"address":[5657922],"length":1,"stats":{"Line":1}},{"line":1129,"address":[5560945,5560845,5562074,5561846],"length":1,"stats":{"Line":1}},{"line":1130,"address":[5735479,5734847],"length":1,"stats":{"Line":0}},{"line":1132,"address":[5735125,5734807,5734890],"length":1,"stats":{"Line":0}},{"line":1140,"address":[5735220],"length":1,"stats":{"Line":0}},{"line":1143,"address":[21027356,21027426],"length":1,"stats":{"Line":3}},{"line":1144,"address":[5562147,5561567],"length":1,"stats":{"Line":2}},{"line":1146,"address":[5960856],"length":1,"stats":{"Line":3}},{"line":1151,"address":[5562836,5559944],"length":1,"stats":{"Line":6}},{"line":1152,"address":[6128724,6130494],"length":1,"stats":{"Line":0}},{"line":1154,"address":[5734601,5734592],"length":1,"stats":{"Line":0}},{"line":1155,"address":[21341455,21341923],"length":1,"stats":{"Line":0}},{"line":1157,"address":[5660820,5661165],"length":1,"stats":{"Line":0}},{"line":1158,"address":[20870366,20869873,20870068],"length":1,"stats":{"Line":0}},{"line":1159,"address":[2961700],"length":1,"stats":{"Line":0}},{"line":1160,"address":[21028114],"length":1,"stats":{"Line":0}},{"line":1161,"address":[21341904,21342180,21337181,21337084,21342218,21341856,21340980,21339184,21337766,21342292,21337679],"length":1,"stats":{"Line":0}},{"line":1166,"address":[5565301],"length":1,"stats":{"Line":0}},{"line":1169,"address":[6128598,6128890],"length":1,"stats":{"Line":7}},{"line":1170,"address":[20871466,20871264],"length":1,"stats":{"Line":0}},{"line":1172,"address":[5659569,5659287],"length":1,"stats":{"Line":0}},{"line":1173,"address":[21343081,21343383,21343151],"length":1,"stats":{"Line":0}},{"line":1174,"address":[5563817,5563743,5563864],"length":1,"stats":{"Line":0}},{"line":1175,"address":[5733105,5732511],"length":1,"stats":{"Line":0}},{"line":1176,"address":[21024693,21023296,21023498,21023188,21023322],"length":1,"stats":{"Line":0}},{"line":1177,"address":[5732542,5732785],"length":1,"stats":{"Line":0}},{"line":1178,"address":[5660225],"length":1,"stats":{"Line":0}},{"line":1179,"address":[5564286,5564201],"length":1,"stats":{"Line":0}},{"line":1180,"address":[20930962],"length":1,"stats":{"Line":0}},{"line":1184,"address":[5733272],"length":1,"stats":{"Line":0}},{"line":1189,"address":[6128773],"length":1,"stats":{"Line":4}},{"line":1192,"address":[5494096,5495241,5495784],"length":1,"stats":{"Line":5}},{"line":1193,"address":[5416775],"length":1,"stats":{"Line":2}},{"line":1195,"address":[5416783],"length":1,"stats":{"Line":2}},{"line":1196,"address":[5494259],"length":1,"stats":{"Line":0}},{"line":1199,"address":[5416827],"length":1,"stats":{"Line":3}},{"line":1201,"address":[5499448,5499332],"length":1,"stats":{"Line":6}},{"line":1202,"address":[3567930,3568741],"length":1,"stats":{"Line":0}},{"line":1203,"address":[5326767,5326832],"length":1,"stats":{"Line":0}},{"line":1204,"address":[5890483],"length":1,"stats":{"Line":0}},{"line":1208,"address":[5494492],"length":1,"stats":{"Line":1}},{"line":1209,"address":[5499637],"length":1,"stats":{"Line":3}},{"line":1210,"address":[3568158],"length":1,"stats":{"Line":1}},{"line":1211,"address":[5499923,5499852],"length":1,"stats":{"Line":5}},{"line":1212,"address":[5500060,5499978],"length":1,"stats":{"Line":2}},{"line":1213,"address":[20933245],"length":1,"stats":{"Line":1}},{"line":1218,"address":[18788859],"length":1,"stats":{"Line":1}},{"line":1221,"address":[5890784,5890965,5890971],"length":1,"stats":{"Line":2}},{"line":1222,"address":[20933485],"length":1,"stats":{"Line":1}},{"line":1223,"address":[3569344,3569394],"length":1,"stats":{"Line":5}},{"line":1226,"address":[5496039,5496016],"length":1,"stats":{"Line":14}},{"line":1227,"address":[5734965,5735328,5735232,5735180,5734838,5735541],"length":1,"stats":{"Line":10}},{"line":1229,"address":[2963165,2963060,2963117,2963388,2963215],"length":1,"stats":{"Line":14}},{"line":1230,"address":[5740470,5740738,5740720],"length":1,"stats":{"Line":0}},{"line":1232,"address":[2963568],"length":1,"stats":{"Line":4}},{"line":1235,"address":[21025179,21023026,21024504,21025589,21025457,21024129,21024644,21025522,21025731,21024608],"length":1,"stats":{"Line":0}},{"line":1236,"address":[21342671],"length":1,"stats":{"Line":0}},{"line":1237,"address":[5567161,5567315],"length":1,"stats":{"Line":0}},{"line":1238,"address":[6133336,6133278],"length":1,"stats":{"Line":0}},{"line":1240,"address":[20874800],"length":1,"stats":{"Line":0}},{"line":1244,"address":[5663881,5663781,5663937],"length":1,"stats":{"Line":0}},{"line":1245,"address":[2965171,2965729,2964691,2964086,2965055],"length":1,"stats":{"Line":0}},{"line":1246,"address":[5743141,5743027,5742969,5742611,5742717],"length":1,"stats":{"Line":0}},{"line":1248,"address":[5664985,5664926,5664866,5665177,5663279],"length":1,"stats":{"Line":0}},{"line":1249,"address":[6136386,6135045,6136368],"length":1,"stats":{"Line":0}},{"line":1251,"address":[18789345],"length":1,"stats":{"Line":0}},{"line":1257,"address":[5743770,5743804,5743338],"length":1,"stats":{"Line":0}},{"line":1258,"address":[21032910,21032880,21032841],"length":1,"stats":{"Line":0}},{"line":1259,"address":[20933998],"length":1,"stats":{"Line":0}},{"line":1262,"address":[6136788,6136574,6136724,6138027,6136512],"length":1,"stats":{"Line":4}},{"line":1264,"address":[5744753,5744907],"length":1,"stats":{"Line":2}},{"line":1265,"address":[2967986,2968090,2968040],"length":1,"stats":{"Line":3}},{"line":1267,"address":[21033127],"length":1,"stats":{"Line":1}},{"line":1268,"address":[5571245],"length":1,"stats":{"Line":1}},{"line":1269,"address":[6137091],"length":1,"stats":{"Line":1}},{"line":1274,"address":[5740310,5740466,5740410],"length":1,"stats":{"Line":3}},{"line":1275,"address":[5570962,5572845,5572131,5572267,5571728],"length":1,"stats":{"Line":2}},{"line":1276,"address":[5741779,5741893,5741469,5741721,5741363],"length":1,"stats":{"Line":4}},{"line":1278,"address":[5746921,5746670,5746610,5744839,5746729],"length":1,"stats":{"Line":3}},{"line":1279,"address":[6140304,6140322,6138965],"length":1,"stats":{"Line":0}},{"line":1281,"address":[5747445],"length":1,"stats":{"Line":0}},{"line":1287,"address":[2970542,2970114,2970576],"length":1,"stats":{"Line":3}},{"line":1288,"address":[5747704,5747947],"length":1,"stats":{"Line":2}},{"line":1289,"address":[5747966],"length":1,"stats":{"Line":1}},{"line":1292,"address":[5418768],"length":1,"stats":{"Line":1}},{"line":1299,"address":[5670904,5671058],"length":1,"stats":{"Line":3}},{"line":1300,"address":[21033519,21033470],"length":1,"stats":{"Line":8}},{"line":1302,"address":[5748974],"length":1,"stats":{"Line":2}},{"line":1303,"address":[5575220],"length":1,"stats":{"Line":2}},{"line":1304,"address":[21033557,21033492],"length":1,"stats":{"Line":1}},{"line":1305,"address":[21027346,21027292],"length":1,"stats":{"Line":1}},{"line":1310,"address":[21033702],"length":1,"stats":{"Line":5}},{"line":1311,"address":[21027507],"length":1,"stats":{"Line":6}},{"line":1313,"address":[5577402,5576661,5576299,5576800,5574937],"length":1,"stats":{"Line":7}},{"line":1314,"address":[5746281,5746023,5746453,5745917,5746339,5751243],"length":1,"stats":{"Line":4}},{"line":1316,"address":[20875433,20875940],"length":1,"stats":{"Line":3}},{"line":1317,"address":[5582578,5582560,5577733],"length":1,"stats":{"Line":0}},{"line":1319,"address":[2974711],"length":1,"stats":{"Line":3}},{"line":1325,"address":[5578476,5577968,5578436],"length":1,"stats":{"Line":3}},{"line":1326,"address":[6144242,6144517],"length":1,"stats":{"Line":2}},{"line":1327,"address":[5747580,5747432,5747448,5747676,5747483],"length":1,"stats":{"Line":5}},{"line":1329,"address":[6144556,6144748,6144548],"length":1,"stats":{"Line":2}},{"line":1332,"address":[2975791,2975730],"length":1,"stats":{"Line":4}},{"line":1333,"address":[5675929,5675289,5676067],"length":1,"stats":{"Line":0}},{"line":1334,"address":[6147788,6145763],"length":1,"stats":{"Line":0}},{"line":1335,"address":[5754119,5753942],"length":1,"stats":{"Line":0}},{"line":1336,"address":[5755516,5754055],"length":1,"stats":{"Line":0}},{"line":1338,"address":[5749100,5748994],"length":1,"stats":{"Line":0}},{"line":1341,"address":[2977444,2976953,2977390],"length":1,"stats":{"Line":0}},{"line":1342,"address":[5755127],"length":1,"stats":{"Line":0}},{"line":1348,"address":[5748183],"length":1,"stats":{"Line":6}},{"line":1354,"address":[5747984],"length":1,"stats":{"Line":2}},{"line":1357,"address":[5418864,5418887],"length":1,"stats":{"Line":4}},{"line":1359,"address":[5756737,5756891],"length":1,"stats":{"Line":2}},{"line":1360,"address":[2979913,2979832,2979778],"length":1,"stats":{"Line":3}},{"line":1362,"address":[5756983],"length":1,"stats":{"Line":1}},{"line":1363,"address":[2979809],"length":1,"stats":{"Line":1}},{"line":1365,"address":[5757170],"length":1,"stats":{"Line":1}},{"line":1369,"address":[6149498,6149554,6149398],"length":1,"stats":{"Line":3}},{"line":1370,"address":[2981349,2979534,2980791,2980675,2980276],"length":1,"stats":{"Line":2}},{"line":1371,"address":[5759033,5758503,5758861,5758919,5760605,5758609],"length":1,"stats":{"Line":4}},{"line":1373,"address":[5584726,5585037,5582967,5584786,5584845],"length":1,"stats":{"Line":3}},{"line":1374,"address":[5586770,5586752,5585145],"length":1,"stats":{"Line":0}},{"line":1376,"address":[5681500],"length":1,"stats":{"Line":0}},{"line":1382,"address":[5585382,5585795],"length":1,"stats":{"Line":2}},{"line":1383,"address":[6151606,6152494,6151693],"length":1,"stats":{"Line":2}},{"line":1387,"address":[5759945,5760035],"length":1,"stats":{"Line":2}},{"line":1389,"address":[5760274],"length":1,"stats":{"Line":1}},{"line":1390,"address":[5586375],"length":1,"stats":{"Line":1}},{"line":1391,"address":[2982895],"length":1,"stats":{"Line":1}},{"line":1397,"address":[5891287,5891264],"length":1,"stats":{"Line":0}},{"line":1399,"address":[5683105,5683259],"length":1,"stats":{"Line":0}},{"line":1400,"address":[5756144,5756225,5756086],"length":1,"stats":{"Line":0}},{"line":1402,"address":[6153111],"length":1,"stats":{"Line":0}},{"line":1403,"address":[5587421],"length":1,"stats":{"Line":0}},{"line":1405,"address":[5761362],"length":1,"stats":{"Line":0}},{"line":1409,"address":[5683986,5683830,5683930],"length":1,"stats":{"Line":0}},{"line":1410,"address":[2985445,2983630,2984372,2984771,2984887],"length":1,"stats":{"Line":0}},{"line":1411,"address":[5684977,5684871,5685229,5685287,5686973,5685401],"length":1,"stats":{"Line":0}},{"line":1413,"address":[6152951,6154829,6154710,6155021,6154770],"length":1,"stats":{"Line":0}},{"line":1414,"address":[6155129,6156754,6156736],"length":1,"stats":{"Line":0}},{"line":1416,"address":[5758424],"length":1,"stats":{"Line":0}},{"line":1422,"address":[5685606,5686019],"length":1,"stats":{"Line":0}},{"line":1423,"address":[5764750,5763949,5763862],"length":1,"stats":{"Line":0}},{"line":1426,"address":[5764137,5764227],"length":1,"stats":{"Line":0}},{"line":1428,"address":[6156402],"length":1,"stats":{"Line":0}},{"line":1429,"address":[5590567],"length":1,"stats":{"Line":0}},{"line":1430,"address":[5759287],"length":1,"stats":{"Line":0}},{"line":1437,"address":[5501440],"length":1,"stats":{"Line":0}},{"line":1438,"address":[5891317],"length":1,"stats":{"Line":0}},{"line":1444,"address":[5419376],"length":1,"stats":{"Line":0}},{"line":1445,"address":[5328081],"length":1,"stats":{"Line":0}},{"line":1448,"address":[5765071,5765345,5765470,5764979,5764944,5765298,5765758],"length":1,"stats":{"Line":4}},{"line":1449,"address":[5765379,5765098,5765496],"length":1,"stats":{"Line":1}},{"line":1458,"address":[5761275,5760983,5761055],"length":1,"stats":{"Line":0}},{"line":1459,"address":[6158507,6158186,6158237,6157878,6158132],"length":1,"stats":{"Line":0}},{"line":1462,"address":[6159396,6158626,6158718,6158945,6158576,6159108,6158992],"length":1,"stats":{"Line":4}},{"line":1463,"address":[3111111],"length":1,"stats":{"Line":1}},{"line":1471,"address":[5503607],"length":1,"stats":{"Line":0}},{"line":1474,"address":[5502288],"length":1,"stats":{"Line":0}},{"line":1475,"address":[5497201],"length":1,"stats":{"Line":0}},{"line":1478,"address":[5892208],"length":1,"stats":{"Line":0}},{"line":1479,"address":[5328549],"length":1,"stats":{"Line":0}},{"line":1482,"address":[5497248],"length":1,"stats":{"Line":0}},{"line":1483,"address":[3570565],"length":1,"stats":{"Line":0}},{"line":1486,"address":[5892240],"length":1,"stats":{"Line":0}},{"line":1487,"address":[5419905],"length":1,"stats":{"Line":0}},{"line":1490,"address":[5893247,5894139,5892288],"length":1,"stats":{"Line":1}},{"line":1494,"address":[3570720],"length":1,"stats":{"Line":1}},{"line":1495,"address":[5502594],"length":1,"stats":{"Line":1}},{"line":1497,"address":[5892328,5892917,5892527],"length":1,"stats":{"Line":3}},{"line":1498,"address":[5498895,5498304,5498994],"length":1,"stats":{"Line":3}},{"line":1499,"address":[5421338,5420978],"length":1,"stats":{"Line":2}},{"line":1500,"address":[5330034],"length":1,"stats":{"Line":1}},{"line":1501,"address":[5498765,5498830],"length":1,"stats":{"Line":2}},{"line":1502,"address":[5503942],"length":1,"stats":{"Line":1}},{"line":1505,"address":[5893497,5893572,5893345],"length":1,"stats":{"Line":3}},{"line":1506,"address":[5503502],"length":1,"stats":{"Line":1}},{"line":1507,"address":[3571690],"length":1,"stats":{"Line":1}},{"line":1508,"address":[5503565],"length":1,"stats":{"Line":1}},{"line":1511,"address":[5497714,5498180,5498105],"length":1,"stats":{"Line":3}},{"line":1512,"address":[5497743,5497994],"length":1,"stats":{"Line":2}},{"line":1513,"address":[5329314],"length":1,"stats":{"Line":1}},{"line":1514,"address":[5503149],"length":1,"stats":{"Line":1}},{"line":1517,"address":[5497766,5497822],"length":1,"stats":{"Line":2}},{"line":1521,"address":[5894198],"length":1,"stats":{"Line":0}},{"line":1522,"address":[5690662,5690865,5690989],"length":1,"stats":{"Line":0}},{"line":1525,"address":[5691552,5691264,5691403,5692028,5691746,5691299,5691599],"length":1,"stats":{"Line":4}},{"line":1526,"address":[5577207],"length":1,"stats":{"Line":1}},{"line":1529,"address":[5499430],"length":1,"stats":{"Line":4}},{"line":1530,"address":[2992591,2992390,2992716],"length":1,"stats":{"Line":1}},{"line":1539,"address":[5771344,5771109,5771037],"length":1,"stats":{"Line":6}},{"line":1540,"address":[5974087],"length":1,"stats":{"Line":8}},{"line":1543,"address":[5499632],"length":1,"stats":{"Line":0}},{"line":1544,"address":[5894639],"length":1,"stats":{"Line":0}},{"line":1547,"address":[5422600,5422352,5422568],"length":1,"stats":{"Line":2}},{"line":1548,"address":[5505019,5504879,5504971],"length":1,"stats":{"Line":6}},{"line":1549,"address":[5422407],"length":1,"stats":{"Line":2}},{"line":1550,"address":[3573014],"length":1,"stats":{"Line":2}},{"line":1554,"address":[5331544,5331512,5331296],"length":1,"stats":{"Line":1}},{"line":1555,"address":[5500031,5500171,5500123],"length":1,"stats":{"Line":3}},{"line":1556,"address":[5505143],"length":1,"stats":{"Line":1}},{"line":1557,"address":[5500070],"length":1,"stats":{"Line":1}},{"line":1561,"address":[5500454,5500486,5500240],"length":1,"stats":{"Line":1}},{"line":1562,"address":[5331737,5331598,5331689],"length":1,"stats":{"Line":3}},{"line":1563,"address":[5422918],"length":1,"stats":{"Line":1}},{"line":1564,"address":[5895300],"length":1,"stats":{"Line":1}},{"line":1568,"address":[5332188,5332182,5331808],"length":1,"stats":{"Line":1}},{"line":1573,"address":[5895723,5895545,5895795],"length":1,"stats":{"Line":3}},{"line":1574,"address":[5895561],"length":1,"stats":{"Line":1}},{"line":1575,"address":[5895662,5895592],"length":1,"stats":{"Line":2}},{"line":1576,"address":[5505798],"length":1,"stats":{"Line":1}},{"line":1580,"address":[5506016],"length":1,"stats":{"Line":2}},{"line":1581,"address":[5423566],"length":1,"stats":{"Line":2}},{"line":1584,"address":[5501008],"length":1,"stats":{"Line":0}},{"line":1588,"address":[5423688],"length":1,"stats":{"Line":0}},{"line":1589,"address":[5501051],"length":1,"stats":{"Line":0}},{"line":1594,"address":[5332646,5332678,5332432],"length":1,"stats":{"Line":1}},{"line":1595,"address":[5506409,5506270,5506361],"length":1,"stats":{"Line":3}},{"line":1596,"address":[5896150],"length":1,"stats":{"Line":1}},{"line":1597,"address":[5332516],"length":1,"stats":{"Line":1}},{"line":1601,"address":[5506726,5506480,5506694],"length":1,"stats":{"Line":0}},{"line":1602,"address":[5896489,5896537,5896398],"length":1,"stats":{"Line":0}},{"line":1603,"address":[5424054],"length":1,"stats":{"Line":0}},{"line":1604,"address":[5332772],"length":1,"stats":{"Line":0}},{"line":1608,"address":[5506774],"length":1,"stats":{"Line":4}},{"line":1609,"address":[6163558,6163763,6163900],"length":1,"stats":{"Line":1}},{"line":1612,"address":[5767107,5767072,5767360,5767211,5767836,5767407,5767554],"length":1,"stats":{"Line":0}},{"line":1613,"address":[5772406,5772748,5772611],"length":1,"stats":{"Line":0}},{"line":1616,"address":[5424495],"length":1,"stats":{"Line":0}},{"line":1617,"address":[5580599],"length":1,"stats":{"Line":0}},{"line":1626,"address":[5774374,5774081,5774154],"length":1,"stats":{"Line":0}},{"line":1627,"address":[5406231],"length":1,"stats":{"Line":0}}],"covered":440,"coverable":757},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","album_tracks.rs"],"content":"use super::common::filter_by_original_album_artist;\nuse crate::{\n    AsyncDiscoveryIterator, AsyncPaginatedIterator, ExactScrobbleEdit, LastFmEditClientImpl,\n    Result, ScrobbleEdit,\n};\nuse async_trait::async_trait;\n\n/// Case 3: Album tracks discovery (album specified, track not specified)\n///\n/// This discovers all tracks in a specific album by iterating through the album's tracks\n/// and for each track, loading its scrobbles incrementally. This is now truly incremental\n/// like the artist tracks discovery.\npub struct AlbumTracksDiscovery {\n    client: LastFmEditClientImpl,\n    edit: ScrobbleEdit,\n    album_name: String,\n    tracks_iterator: crate::AlbumTracksIterator,\n    current_track_results: Vec\u003cExactScrobbleEdit\u003e,\n    current_track_index: usize,\n}\n\nimpl AlbumTracksDiscovery {\n    pub fn new(client: LastFmEditClientImpl, edit: ScrobbleEdit, album_name: String) -\u003e Self {\n        let tracks_iterator = crate::AlbumTracksIterator::new(\n            client.clone(),\n            album_name.clone(),\n            edit.artist_name_original.clone(),\n        );\n\n        Self {\n            client,\n            edit,\n            album_name,\n            tracks_iterator,\n            current_track_results: Vec::new(),\n            current_track_index: 0,\n        }\n    }\n}\n\n#[async_trait(?Send)]\nimpl AsyncDiscoveryIterator\u003cExactScrobbleEdit\u003e for AlbumTracksDiscovery {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cExactScrobbleEdit\u003e\u003e {\n        // If we have results from the current track, return the next one\n        if self.current_track_index \u003c self.current_track_results.len() {\n            let result = self.current_track_results[self.current_track_index].clone();\n            self.current_track_index += 1;\n            return Ok(Some(result));\n        }\n\n        // Get the next track from the iterator\n        while let Some(track) = self.tracks_iterator.next().await? {\n            log::debug!(\n                \"Getting scrobble data for track '{}' from album '{}' by '{}'\",\n                track.name,\n                self.album_name,\n                self.edit.artist_name_original\n            );\n\n            // Get scrobble data for this track\n            match self\n                .client\n                .load_edit_form_values_internal(\u0026track.name, \u0026self.edit.artist_name_original)\n                .await\n            {\n                Ok(track_scrobbles) =\u003e {\n                    // Apply user's changes and filtering\n                    let mut modified_edits = Vec::new();\n                    for scrobble in track_scrobbles {\n                        let mut modified_edit = scrobble.clone();\n                        if let Some(new_track_name) = \u0026self.edit.track_name {\n                            modified_edit.track_name = new_track_name.clone();\n                        }\n                        if let Some(new_album_name) = \u0026self.edit.album_name {\n                            modified_edit.album_name = new_album_name.clone();\n                        }\n                        modified_edit.artist_name = self.edit.artist_name.clone();\n                        if let Some(new_album_artist_name) = \u0026self.edit.album_artist_name {\n                            modified_edit.album_artist_name = new_album_artist_name.clone();\n                        }\n                        modified_edit.edit_all = self.edit.edit_all;\n                        modified_edits.push(modified_edit);\n                    }\n\n                    let filtered_edits =\n                        filter_by_original_album_artist(modified_edits, \u0026self.edit);\n\n                    if !filtered_edits.is_empty() {\n                        // Store results and return the first one\n                        self.current_track_results = filtered_edits;\n                        self.current_track_index = 1; // We'll return the first result below\n                        return Ok(Some(self.current_track_results[0].clone()));\n                    }\n                }\n                Err(e) =\u003e {\n                    log::debug!(\n                        \"Failed to get scrobble data for track '{}': {}\",\n                        track.name,\n                        e\n                    );\n                    // Continue with next track\n                }\n            }\n        }\n\n        // No more tracks\n        Ok(None)\n    }\n}\n","traces":[{"line":23,"address":[5929872,5930878,5930712],"length":1,"stats":{"Line":1}},{"line":25,"address":[5538040,5538093],"length":1,"stats":{"Line":2}},{"line":26,"address":[5364245,5364307],"length":1,"stats":{"Line":2}},{"line":27,"address":[5460219],"length":1,"stats":{"Line":1}},{"line":35,"address":[3489011],"length":1,"stats":{"Line":1}},{"line":43,"address":[5930927],"length":1,"stats":{"Line":4}},{"line":45,"address":[5684993],"length":1,"stats":{"Line":1}},{"line":46,"address":[5853804],"length":1,"stats":{"Line":1}},{"line":47,"address":[3361770,3361918],"length":1,"stats":{"Line":1}},{"line":48,"address":[5853947],"length":1,"stats":{"Line":1}},{"line":52,"address":[6250738,6251406,6255187,6256586,6251035,6255135],"length":1,"stats":{"Line":3}},{"line":53,"address":[5864949,5865077,5865021],"length":1,"stats":{"Line":3}},{"line":61,"address":[5781877,5786163,5781986,5786667,5786713],"length":1,"stats":{"Line":5}},{"line":63,"address":[5786186,5786610],"length":1,"stats":{"Line":2}},{"line":64,"address":[5854389,5854194,5854160,5859226,5853479,5859166],"length":1,"stats":{"Line":4}},{"line":66,"address":[5860958],"length":1,"stats":{"Line":1}},{"line":68,"address":[6251894],"length":1,"stats":{"Line":1}},{"line":69,"address":[3362777,3362538,3362650],"length":1,"stats":{"Line":3}},{"line":70,"address":[3362868,3363669],"length":1,"stats":{"Line":2}},{"line":71,"address":[5855905,5856275],"length":1,"stats":{"Line":1}},{"line":72,"address":[5862370,5862504,5862523],"length":1,"stats":{"Line":0}},{"line":74,"address":[5783525,5783808,5784031],"length":1,"stats":{"Line":3}},{"line":75,"address":[5856353,5856296,5856372],"length":1,"stats":{"Line":2}},{"line":77,"address":[6253815,6253595,6253796],"length":1,"stats":{"Line":2}},{"line":78,"address":[5688387,5687986],"length":1,"stats":{"Line":1}},{"line":79,"address":[6254197,6254216,6254035],"length":1,"stats":{"Line":0}},{"line":81,"address":[6254057],"length":1,"stats":{"Line":1}},{"line":82,"address":[5688114],"length":1,"stats":{"Line":1}},{"line":85,"address":[6252447,6252333],"length":1,"stats":{"Line":2}},{"line":88,"address":[6252526,6252455],"length":1,"stats":{"Line":2}},{"line":90,"address":[5686656,5686564],"length":1,"stats":{"Line":1}},{"line":91,"address":[5782990],"length":1,"stats":{"Line":1}},{"line":92,"address":[5855493],"length":1,"stats":{"Line":1}},{"line":95,"address":[5860878],"length":1,"stats":{"Line":0}},{"line":96,"address":[5685838,5688801,5688829],"length":1,"stats":{"Line":0}},{"line":107,"address":[5690543],"length":1,"stats":{"Line":1}}],"covered":32,"coverable":36},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","artist_tracks.rs"],"content":"use super::common::filter_by_original_album_artist;\nuse crate::{\n    AsyncDiscoveryIterator, AsyncPaginatedIterator, ExactScrobbleEdit, LastFmEditClientImpl,\n    Result, ScrobbleEdit,\n};\nuse async_trait::async_trait;\n\n/// Case 4: Artist tracks discovery (neither track nor album specified)\n///\n/// This discovers all tracks by an artist by iterating through the artist's catalog\n/// and for each track, loading its scrobbles incrementally. This is the most complex\n/// case as it involves nested iteration.\npub struct ArtistTracksDiscovery {\n    client: LastFmEditClientImpl,\n    edit: ScrobbleEdit,\n    tracks_iterator: crate::ArtistTracksIterator,\n    current_track_results: Vec\u003cExactScrobbleEdit\u003e,\n    current_track_index: usize,\n}\n\nimpl ArtistTracksDiscovery {\n    pub fn new(client: LastFmEditClientImpl, edit: ScrobbleEdit) -\u003e Self {\n        let tracks_iterator =\n            crate::ArtistTracksIterator::new(client.clone(), edit.artist_name_original.clone());\n\n        Self {\n            client,\n            edit,\n            tracks_iterator,\n            current_track_results: Vec::new(),\n            current_track_index: 0,\n        }\n    }\n}\n\n#[async_trait(?Send)]\nimpl AsyncDiscoveryIterator\u003cExactScrobbleEdit\u003e for ArtistTracksDiscovery {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cExactScrobbleEdit\u003e\u003e {\n        // If we have results from the current track, return the next one\n        if self.current_track_index \u003c self.current_track_results.len() {\n            let result = self.current_track_results[self.current_track_index].clone();\n            self.current_track_index += 1;\n            return Ok(Some(result));\n        }\n\n        // Get the next track from the iterator\n        while let Some(track) = self.tracks_iterator.next().await? {\n            // Get scrobble data for this track\n            match self\n                .client\n                .load_edit_form_values_internal(\u0026track.name, \u0026self.edit.artist_name_original)\n                .await\n            {\n                Ok(track_scrobbles) =\u003e {\n                    // Apply user's changes and filtering\n                    let mut modified_edits = Vec::new();\n                    for scrobble in track_scrobbles {\n                        let mut modified_edit = scrobble.clone();\n                        if let Some(new_track_name) = \u0026self.edit.track_name {\n                            modified_edit.track_name = new_track_name.clone();\n                        }\n                        if let Some(new_album_name) = \u0026self.edit.album_name {\n                            modified_edit.album_name = new_album_name.clone();\n                        }\n                        modified_edit.artist_name = self.edit.artist_name.clone();\n                        if let Some(new_album_artist_name) = \u0026self.edit.album_artist_name {\n                            modified_edit.album_artist_name = new_album_artist_name.clone();\n                        }\n                        modified_edit.edit_all = self.edit.edit_all;\n                        modified_edits.push(modified_edit);\n                    }\n\n                    let filtered_edits =\n                        filter_by_original_album_artist(modified_edits, \u0026self.edit);\n\n                    if !filtered_edits.is_empty() {\n                        // Store results and return the first one\n                        self.current_track_results = filtered_edits;\n                        self.current_track_index = 1; // We'll return the first result below\n                        return Ok(Some(self.current_track_results[0].clone()));\n                    }\n                }\n                Err(e) =\u003e {\n                    log::warn!(\n                        \"Failed to get scrobble data for track '{}': {}\",\n                        track.name,\n                        e\n                    );\n                    // Continue with next track\n                }\n            }\n        }\n\n        // No more tracks\n        Ok(None)\n    }\n}\n","traces":[{"line":22,"address":[5610480,5611215,5611118],"length":1,"stats":{"Line":1}},{"line":23,"address":[3360363,3360961,3360416],"length":1,"stats":{"Line":1}},{"line":30,"address":[5779586],"length":1,"stats":{"Line":1}},{"line":38,"address":[5652819,5652368,5652628,5652866,5652445,5653294],"length":1,"stats":{"Line":4}},{"line":40,"address":[5749089],"length":1,"stats":{"Line":1}},{"line":41,"address":[5828076],"length":1,"stats":{"Line":1}},{"line":42,"address":[5749438,5749290],"length":1,"stats":{"Line":1}},{"line":43,"address":[5828219],"length":1,"stats":{"Line":1}},{"line":47,"address":[3356135,3351842,3352131,3352490,3356087,3357069],"length":1,"stats":{"Line":3}},{"line":49,"address":[5826429,5826578,5822245,5826624,5822354],"length":1,"stats":{"Line":5}},{"line":51,"address":[5826452,5826521],"length":1,"stats":{"Line":2}},{"line":52,"address":[5588642],"length":1,"stats":{"Line":5}},{"line":54,"address":[5653774],"length":1,"stats":{"Line":1}},{"line":56,"address":[5750022],"length":1,"stats":{"Line":1}},{"line":57,"address":[6219966,6220101,6219850],"length":1,"stats":{"Line":3}},{"line":58,"address":[6220192,6221033],"length":1,"stats":{"Line":2}},{"line":59,"address":[5830177,5830544],"length":1,"stats":{"Line":1}},{"line":60,"address":[5830258,5830389,5830408],"length":1,"stats":{"Line":0}},{"line":62,"address":[3354566,3354789,3354289],"length":1,"stats":{"Line":1}},{"line":63,"address":[5830562,5830638,5830619],"length":1,"stats":{"Line":0}},{"line":65,"address":[5824398,5824197,5824417],"length":1,"stats":{"Line":2}},{"line":66,"address":[5824556,5824945],"length":1,"stats":{"Line":2}},{"line":67,"address":[5831190,5831015,5831171],"length":1,"stats":{"Line":2}},{"line":69,"address":[5824653],"length":1,"stats":{"Line":1}},{"line":70,"address":[6221958],"length":1,"stats":{"Line":1}},{"line":73,"address":[3353373,3353483],"length":1,"stats":{"Line":2}},{"line":76,"address":[5823134,5823063],"length":1,"stats":{"Line":2}},{"line":78,"address":[5829524,5829616],"length":1,"stats":{"Line":1}},{"line":79,"address":[5829742],"length":1,"stats":{"Line":1}},{"line":80,"address":[5823381],"length":1,"stats":{"Line":1}},{"line":83,"address":[5828766],"length":1,"stats":{"Line":0}},{"line":84,"address":[5653726,5656699,5656671],"length":1,"stats":{"Line":0}},{"line":95,"address":[5657974],"length":1,"stats":{"Line":1}}],"covered":29,"coverable":33},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","common.rs"],"content":"use crate::{ExactScrobbleEdit, ScrobbleEdit};\n\n/// Filter discovered edits based on original album artist if specified\n///\n/// When album_artist_name_original is specified in the ScrobbleEdit, we only want\n/// to return ExactScrobbleEdits that match that original album artist value.\n/// This prevents implicit fan-out over different album artists.\npub fn filter_by_original_album_artist(\n    discovered_edits: Vec\u003cExactScrobbleEdit\u003e,\n    edit: \u0026ScrobbleEdit,\n) -\u003e Vec\u003cExactScrobbleEdit\u003e {\n    if let Some(target_album_artist) = \u0026edit.album_artist_name_original {\n        log::debug!(\n            \"Filtering {} discovered edits to only include album artist '{}'\",\n            discovered_edits.len(),\n            target_album_artist\n        );\n\n        let filtered: Vec\u003cExactScrobbleEdit\u003e = discovered_edits\n            .into_iter()\n            .filter(|scrobble| scrobble.album_artist_name_original == *target_album_artist)\n            .collect();\n\n        log::debug!(\n            \"After filtering by album artist '{}': {} edits remain\",\n            target_album_artist,\n            filtered.len()\n        );\n\n        filtered\n    } else {\n        discovered_edits\n    }\n}\n","traces":[{"line":8,"address":[5826192,5827396],"length":1,"stats":{"Line":1}},{"line":12,"address":[5747511,5747358,5748171],"length":1,"stats":{"Line":5}},{"line":13,"address":[6217321,6217189,6217393,6217496],"length":1,"stats":{"Line":3}},{"line":19,"address":[5826436,5826845],"length":1,"stats":{"Line":2}},{"line":21,"address":[5982208,5982233],"length":1,"stats":{"Line":3}},{"line":24,"address":[5652058],"length":1,"stats":{"Line":3}},{"line":30,"address":[5651928],"length":1,"stats":{"Line":1}},{"line":32,"address":[5651273],"length":1,"stats":{"Line":2}}],"covered":8,"coverable":8},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","discovery_iterator.rs"],"content":"use crate::Result;\nuse async_trait::async_trait;\n\n/// Async iterator trait for discovering scrobble edits incrementally\n///\n/// This trait is designed for iterators that yield individual results one at a time,\n/// unlike AsyncPaginatedIterator which is designed for page-based iteration.\n/// This is particularly useful for discovery operations that might make many API\n/// requests and need to avoid rate limiting by yielding results incrementally.\n#[async_trait(?Send)]\npub trait AsyncDiscoveryIterator\u003cT\u003e {\n    /// Get the next item from the iterator\n    ///\n    /// Returns `Ok(Some(item))` if there's a next item available,\n    /// `Ok(None)` if the iterator is exhausted, or `Err(e)` if an error occurred.\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cT\u003e\u003e;\n\n    /// Collect all remaining items from the iterator into a Vec\n    ///\n    /// This is a convenience method that calls `next()` repeatedly until\n    /// the iterator is exhausted and collects all results.\n    async fn collect_all(\u0026mut self) -\u003e Result\u003cVec\u003cT\u003e\u003e {\n        let mut items = Vec::new();\n        while let Some(item) = self.next().await? {\n            items.push(item);\n        }\n        Ok(items)\n    }\n\n    /// Take the first `n` items from the iterator\n    ///\n    /// This stops after collecting `n` items or when the iterator is exhausted,\n    /// whichever comes first.\n    async fn take(\u0026mut self, n: usize) -\u003e Result\u003cVec\u003cT\u003e\u003e {\n        let mut items = Vec::with_capacity(n);\n        for _ in 0..n {\n            if let Some(item) = self.next().await? {\n                items.push(item);\n            } else {\n                break;\n            }\n        }\n        Ok(items)\n    }\n}\n","traces":[{"line":22,"address":[5356505],"length":1,"stats":{"Line":8}},{"line":23,"address":[5864732,5862012,5866092,5863372],"length":1,"stats":{"Line":2}},{"line":24,"address":[5864754,5864838,5863721,5864044,5863095,5864455,5862093,5862684,5863478,5861735,5866114,5866764,5865404,5866173,5866441,5863453,5862361,5865081,5862034,5865815,5866198,5862118,5864813,5863394],"length":1,"stats":{"Line":8}},{"line":25,"address":[5866749,5866703,5865343,5864029,5862623,5862669,5863983,5865389],"length":1,"stats":{"Line":4}},{"line":27,"address":[3206009,3207305,3204713,3203417],"length":1,"stats":{"Line":2}},{"line":34,"address":[5658126],"length":1,"stats":{"Line":0}},{"line":35,"address":[5873879,5876887,5875383,5878391],"length":1,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[5415156,5412516,5416628,5411924],"length":1,"stats":{"Line":0}},{"line":38,"address":[5879101,5877551,5879055,5874589,5874543,5876047,5876093,5877597],"length":1,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}}],"covered":5,"coverable":12},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","exact_match.rs"],"content":"use super::common::filter_by_original_album_artist;\nuse crate::{\n    AsyncDiscoveryIterator, ExactScrobbleEdit, LastFmEditClientImpl, LastFmError, Result,\n    ScrobbleEdit,\n};\nuse async_trait::async_trait;\n\n/// Case 1: Exact match discovery (track + album specified)\n///\n/// This discovers the specific scrobble that matches both the track and album,\n/// yielding at most one result.\npub struct ExactMatchDiscovery {\n    client: LastFmEditClientImpl,\n    edit: ScrobbleEdit,\n    track_name: String,\n    album_name: String,\n    result: Option\u003cExactScrobbleEdit\u003e,\n    completed: bool,\n}\n\nimpl ExactMatchDiscovery {\n    pub fn new(\n        client: LastFmEditClientImpl,\n        edit: ScrobbleEdit,\n        track_name: String,\n        album_name: String,\n    ) -\u003e Self {\n        Self {\n            client,\n            edit,\n            track_name,\n            album_name,\n            result: None,\n            completed: false,\n        }\n    }\n}\n\n#[async_trait(?Send)]\nimpl AsyncDiscoveryIterator\u003cExactScrobbleEdit\u003e for ExactMatchDiscovery {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cExactScrobbleEdit\u003e\u003e {\n        if self.completed {\n            return Ok(None);\n        }\n\n        if self.result.is_none() {\n            // Perform the lookup inline (previously discover_track_album_exact_match)\n            log::debug!(\n                \"Looking up missing metadata for track '{}' on album '{}' by '{}'\",\n                self.track_name,\n                self.album_name,\n                self.edit.artist_name_original\n            );\n\n            match self\n                .client\n                .load_edit_form_values_internal(\u0026self.track_name, \u0026self.edit.artist_name_original)\n                .await\n            {\n                Ok(all_variations) =\u003e {\n                    // Filter by album artist first if specified, then find the variation that matches the specific album\n                    let filtered_variations =\n                        filter_by_original_album_artist(all_variations, \u0026self.edit);\n\n                    if let Some(exact_edit) = filtered_variations\n                        .iter()\n                        .find(|variation| variation.album_name_original == self.album_name)\n                    {\n                        // Apply the user's desired changes to this exact variation\n                        let mut modified_edit = exact_edit.clone();\n                        if let Some(new_track_name) = \u0026self.edit.track_name {\n                            modified_edit.track_name = new_track_name.clone();\n                        }\n                        if let Some(new_album_name) = \u0026self.edit.album_name {\n                            modified_edit.album_name = new_album_name.clone();\n                        }\n                        modified_edit.artist_name = self.edit.artist_name.clone();\n                        if let Some(new_album_artist_name) = \u0026self.edit.album_artist_name {\n                            modified_edit.album_artist_name = new_album_artist_name.clone();\n                        }\n                        modified_edit.edit_all = self.edit.edit_all;\n\n                        self.result = Some(modified_edit);\n                    } else {\n                        let album_artist_filter = if self.edit.album_artist_name_original.is_some()\n                        {\n                            format!(\n                                \" with album artist '{}'\",\n                                self.edit.album_artist_name_original.as_ref().unwrap()\n                            )\n                        } else {\n                            String::new()\n                        };\n                        self.completed = true;\n                        return Err(LastFmError::Parse(format!(\n                            \"Track '{}' not found on album '{}' by '{}'{} in recent scrobbles\",\n                            self.track_name,\n                            self.album_name,\n                            self.edit.artist_name_original,\n                            album_artist_filter\n                        )));\n                    }\n                }\n                Err(e) =\u003e {\n                    self.completed = true;\n                    return Err(e);\n                }\n            }\n        }\n\n        self.completed = true;\n        Ok(self.result.take())\n    }\n}\n","traces":[{"line":22,"address":[3173328],"length":1,"stats":{"Line":1}},{"line":41,"address":[5540207],"length":1,"stats":{"Line":4}},{"line":42,"address":[5855302],"length":1,"stats":{"Line":1}},{"line":43,"address":[5855360],"length":1,"stats":{"Line":1}},{"line":46,"address":[5776459,5776552],"length":1,"stats":{"Line":2}},{"line":48,"address":[3305830,3305710],"length":1,"stats":{"Line":2}},{"line":55,"address":[5849732,5850022,5849778,5849156,5850077],"length":1,"stats":{"Line":5}},{"line":57,"address":[5855569,5856037],"length":1,"stats":{"Line":2}},{"line":58,"address":[5680014,5681366,5681063,5681120,5681174],"length":1,"stats":{"Line":3}},{"line":60,"address":[3306867],"length":1,"stats":{"Line":1}},{"line":62,"address":[3306899],"length":1,"stats":{"Line":1}},{"line":65,"address":[3306942,3307009,3307079],"length":1,"stats":{"Line":3}},{"line":67,"address":[5850480,5853137,5853120],"length":1,"stats":{"Line":3}},{"line":70,"address":[5850699,5850591],"length":1,"stats":{"Line":2}},{"line":71,"address":[5857484,5857123],"length":1,"stats":{"Line":1}},{"line":72,"address":[6248225,6248094,6248244],"length":1,"stats":{"Line":0}},{"line":74,"address":[6248113,6248390,6248613],"length":1,"stats":{"Line":1}},{"line":75,"address":[5857559,5857502,5857578],"length":1,"stats":{"Line":0}},{"line":77,"address":[5857521,5857741,5857722],"length":1,"stats":{"Line":2}},{"line":78,"address":[5683231,5682808],"length":1,"stats":{"Line":1}},{"line":79,"address":[5858164,5858145,5857955],"length":1,"stats":{"Line":0}},{"line":81,"address":[5851593],"length":1,"stats":{"Line":1}},{"line":83,"address":[5851924,5851618],"length":1,"stats":{"Line":1}},{"line":85,"address":[5856982,5858784],"length":1,"stats":{"Line":0}},{"line":87,"address":[5852556],"length":1,"stats":{"Line":0}},{"line":89,"address":[6249701,6249800],"length":1,"stats":{"Line":0}},{"line":92,"address":[3309013,3308974],"length":1,"stats":{"Line":0}},{"line":94,"address":[5852455],"length":1,"stats":{"Line":0}},{"line":95,"address":[5859116,5858858],"length":1,"stats":{"Line":0}},{"line":104,"address":[5856493],"length":1,"stats":{"Line":0}},{"line":105,"address":[5850173],"length":1,"stats":{"Line":0}},{"line":106,"address":[5856576],"length":1,"stats":{"Line":0}},{"line":111,"address":[5680350],"length":1,"stats":{"Line":1}},{"line":112,"address":[5680369,5683403],"length":1,"stats":{"Line":2}}],"covered":22,"coverable":34},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","mod.rs"],"content":"pub mod album_tracks;\npub mod artist_tracks;\npub mod common;\npub mod discovery_iterator;\npub mod exact_match;\npub mod track_variations;\n\npub use album_tracks::AlbumTracksDiscovery;\npub use artist_tracks::ArtistTracksDiscovery;\npub use common::filter_by_original_album_artist;\npub use discovery_iterator::AsyncDiscoveryIterator;\npub use exact_match::ExactMatchDiscovery;\npub use track_variations::TrackVariationsDiscovery;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","track_variations.rs"],"content":"use super::common::filter_by_original_album_artist;\nuse crate::{\n    AsyncDiscoveryIterator, ExactScrobbleEdit, LastFmEditClientImpl, Result, ScrobbleEdit,\n};\nuse async_trait::async_trait;\n\n/// Case 2: Track variations discovery (track specified, album not specified)\n///\n/// This discovers all album variations of a specific track by loading the track's\n/// scrobble data incrementally and yielding each variation as it processes them.\n/// This is now truly incremental like the artist and album tracks discovery.\npub struct TrackVariationsDiscovery {\n    client: LastFmEditClientImpl,\n    edit: ScrobbleEdit,\n    track_name: String,\n    scrobbles_loaded: bool,\n    current_results: Vec\u003cExactScrobbleEdit\u003e,\n    current_index: usize,\n}\n\nimpl TrackVariationsDiscovery {\n    pub fn new(client: LastFmEditClientImpl, edit: ScrobbleEdit, track_name: String) -\u003e Self {\n        Self {\n            client,\n            edit,\n            track_name,\n            scrobbles_loaded: false,\n            current_results: Vec::new(),\n            current_index: 0,\n        }\n    }\n}\n\n#[async_trait(?Send)]\nimpl AsyncDiscoveryIterator\u003cExactScrobbleEdit\u003e for TrackVariationsDiscovery {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cExactScrobbleEdit\u003e\u003e {\n        // If we have results from current batch, return the next one\n        if self.current_index \u003c self.current_results.len() {\n            let result = self.current_results[self.current_index].clone();\n            self.current_index += 1;\n            return Ok(Some(result));\n        }\n\n        // If we haven't loaded scrobbles yet, load them\n        if !self.scrobbles_loaded {\n            log::debug!(\n                \"Getting scrobble data for track '{}' by '{}'\",\n                self.track_name,\n                self.edit.artist_name_original\n            );\n\n            match self\n                .client\n                .load_edit_form_values_internal(\u0026self.track_name, \u0026self.edit.artist_name_original)\n                .await\n            {\n                Ok(track_scrobbles) =\u003e {\n                    // Apply user's changes and filtering\n                    let mut modified_edits = Vec::new();\n                    for scrobble in track_scrobbles {\n                        let mut modified_edit = scrobble.clone();\n                        if let Some(new_track_name) = \u0026self.edit.track_name {\n                            modified_edit.track_name = new_track_name.clone();\n                        }\n                        if let Some(new_album_name) = \u0026self.edit.album_name {\n                            modified_edit.album_name = new_album_name.clone();\n                        }\n                        modified_edit.artist_name = self.edit.artist_name.clone();\n                        if let Some(new_album_artist_name) = \u0026self.edit.album_artist_name {\n                            modified_edit.album_artist_name = new_album_artist_name.clone();\n                        }\n                        modified_edit.edit_all = self.edit.edit_all;\n                        modified_edits.push(modified_edit);\n                    }\n\n                    let filtered_edits =\n                        filter_by_original_album_artist(modified_edits, \u0026self.edit);\n\n                    if !filtered_edits.is_empty() {\n                        // Store results and return the first one\n                        self.current_results = filtered_edits;\n                        self.current_index = 1; // We'll return the first result below\n                        self.scrobbles_loaded = true;\n                        return Ok(Some(self.current_results[0].clone()));\n                    }\n                }\n                Err(e) =\u003e {\n                    log::debug!(\n                        \"Failed to get scrobble data for track '{}': {}\",\n                        self.track_name,\n                        e\n                    );\n                    self.scrobbles_loaded = true;\n                    return Err(e);\n                }\n            }\n            self.scrobbles_loaded = true;\n        }\n\n        // No more results\n        Ok(None)\n    }\n}\n","traces":[{"line":22,"address":[6181762,6181721,6181312],"length":1,"stats":{"Line":1}},{"line":28,"address":[5790762],"length":1,"stats":{"Line":1}},{"line":36,"address":[2868673,2867149,2867072,2867335,2867554,2867504],"length":1,"stats":{"Line":4}},{"line":38,"address":[5452789],"length":1,"stats":{"Line":1}},{"line":39,"address":[2868464,2867662],"length":1,"stats":{"Line":2}},{"line":40,"address":[2868613,2868471],"length":1,"stats":{"Line":1}},{"line":41,"address":[5453770],"length":1,"stats":{"Line":1}},{"line":45,"address":[2870089,2867639],"length":1,"stats":{"Line":1}},{"line":46,"address":[5531251,5531183,5531056],"length":1,"stats":{"Line":3}},{"line":52,"address":[5358484,5357947,5357901,5358429,5357397],"length":1,"stats":{"Line":6}},{"line":54,"address":[5922930,5923338],"length":1,"stats":{"Line":2}},{"line":55,"address":[5923424,5923481,5922405,5923965,5923773],"length":1,"stats":{"Line":5}},{"line":57,"address":[5454269],"length":1,"stats":{"Line":1}},{"line":59,"address":[5527317],"length":1,"stats":{"Line":1}},{"line":60,"address":[5454628,5454493,5454377],"length":1,"stats":{"Line":3}},{"line":61,"address":[5455496,5454713],"length":1,"stats":{"Line":2}},{"line":62,"address":[5455536,5455897],"length":1,"stats":{"Line":2}},{"line":63,"address":[5925585,5925435,5925566],"length":1,"stats":{"Line":2}},{"line":65,"address":[2870326,2870826,2870603],"length":1,"stats":{"Line":1}},{"line":66,"address":[5360292,5360311,5360235],"length":1,"stats":{"Line":0}},{"line":68,"address":[5529143,5529162,5528942],"length":1,"stats":{"Line":2}},{"line":69,"address":[5534405,5534794],"length":1,"stats":{"Line":2}},{"line":70,"address":[5456543,5456368,5456524],"length":1,"stats":{"Line":2}},{"line":72,"address":[5529398],"length":1,"stats":{"Line":1}},{"line":73,"address":[5926239],"length":1,"stats":{"Line":1}},{"line":76,"address":[5359176,5359062],"length":1,"stats":{"Line":3}},{"line":79,"address":[5924688,5924753],"length":1,"stats":{"Line":2}},{"line":81,"address":[5924759,5924851],"length":1,"stats":{"Line":1}},{"line":82,"address":[2869861],"length":1,"stats":{"Line":2}},{"line":83,"address":[5925000],"length":1,"stats":{"Line":2}},{"line":84,"address":[5925019],"length":1,"stats":{"Line":2}},{"line":87,"address":[5358512],"length":1,"stats":{"Line":0}},{"line":88,"address":[5454224,5457093,5457273],"length":1,"stats":{"Line":0}},{"line":93,"address":[5530111],"length":1,"stats":{"Line":0}},{"line":94,"address":[5535234],"length":1,"stats":{"Line":0}},{"line":97,"address":[5359686],"length":1,"stats":{"Line":0}},{"line":101,"address":[5357309],"length":1,"stats":{"Line":1}}],"covered":31,"coverable":37},{"path":["/","home","imalison","Projects","lastfm-edit","src","edit_analysis.rs"],"content":"use http_types::StatusCode;\nuse scraper::{Html, Selector};\n\n/// Result of analyzing an edit response from Last.fm\n#[derive(Debug, Clone)]\npub struct EditAnalysisResult {\n    /// Whether the edit was successful based on all indicators\n    pub success: bool,\n    /// Optional detailed message about the result\n    pub message: Option\u003cString\u003e,\n    /// Track name found in the response (if any)\n    pub actual_track_name: Option\u003cString\u003e,\n    /// Album name found in the response (if any)\n    pub actual_album_name: Option\u003cString\u003e,\n}\n\n/// Analyze the HTML response from a Last.fm edit request to determine success/failure\n///\n/// This function parses the response HTML to look for success/error indicators\n/// and extract the actual track/album names that were processed.\n///\n/// # Arguments\n/// * `response_text` - The HTML response body from the edit request\n/// * `status_code` - The HTTP status code of the response\n///\n/// # Returns\n/// An `EditAnalysisResult` containing the analysis results\npub fn analyze_edit_response(response_text: \u0026str, status_code: StatusCode) -\u003e EditAnalysisResult {\n    // Parse the HTML response to check for actual success/failure\n    let document = Html::parse_document(response_text);\n\n    // Check for success indicator\n    let success_selector = Selector::parse(\".alert-success\").unwrap();\n    let error_selector = Selector::parse(\".alert-danger, .alert-error, .error\").unwrap();\n\n    let has_success_alert = document.select(\u0026success_selector).next().is_some();\n    let has_error_alert = document.select(\u0026error_selector).next().is_some();\n\n    // Extract track and album names from the response\n    let (actual_track_name, actual_album_name) =\n        extract_track_album_names(\u0026document, response_text);\n\n    log::debug!(\n        \"Response analysis: success_alert={}, error_alert={}, track='{}', album='{}'\",\n        has_success_alert,\n        has_error_alert,\n        actual_track_name.as_deref().unwrap_or(\"not found\"),\n        actual_album_name.as_deref().unwrap_or(\"not found\")\n    );\n\n    // Determine if edit was truly successful\n    let final_success = status_code.is_success() \u0026\u0026 has_success_alert \u0026\u0026 !has_error_alert;\n\n    // Create detailed message\n    let message = if has_error_alert {\n        // Extract error message\n        if let Some(error_element) = document.select(\u0026error_selector).next() {\n            Some(format!(\n                \"Edit failed: {}\",\n                error_element.text().collect::\u003cString\u003e().trim()\n            ))\n        } else {\n            Some(\"Edit failed with unknown error\".to_string())\n        }\n    } else if final_success {\n        Some(format!(\n            \"Edit successful - Track: '{}', Album: '{}'\",\n            actual_track_name.as_deref().unwrap_or(\"unknown\"),\n            actual_album_name.as_deref().unwrap_or(\"unknown\")\n        ))\n    } else {\n        Some(format!(\"Edit failed with status: {status_code}\"))\n    };\n\n    EditAnalysisResult {\n        success: final_success,\n        message,\n        actual_track_name,\n        actual_album_name,\n    }\n}\n\n/// Extract track and album names from the edit response\n///\n/// This function tries multiple strategies to find the actual track and album names\n/// in the response, including direct CSS selectors and regex patterns.\nfn extract_track_album_names(\n    document: \u0026Html,\n    response_text: \u0026str,\n) -\u003e (Option\u003cString\u003e, Option\u003cString\u003e) {\n    let mut actual_track_name = None;\n    let mut actual_album_name = None;\n\n    // Try direct selectors first\n    let track_name_selector = Selector::parse(\"td.chartlist-name a\").unwrap();\n    let album_name_selector = Selector::parse(\"td.chartlist-album a\").unwrap();\n\n    if let Some(track_element) = document.select(\u0026track_name_selector).next() {\n        actual_track_name = Some(track_element.text().collect::\u003cString\u003e().trim().to_string());\n    }\n\n    if let Some(album_element) = document.select(\u0026album_name_selector).next() {\n        actual_album_name = Some(album_element.text().collect::\u003cString\u003e().trim().to_string());\n    }\n\n    // If not found, try extracting from the raw response text using generic patterns\n    if actual_track_name.is_none() || actual_album_name.is_none() {\n        if actual_track_name.is_none() {\n            actual_track_name = extract_track_name_from_text(response_text);\n        }\n\n        if actual_album_name.is_none() {\n            actual_album_name = extract_album_name_from_text(response_text);\n        }\n    }\n\n    (actual_track_name, actual_album_name)\n}\n\n/// Extract track name from response text using regex patterns\nfn extract_track_name_from_text(response_text: \u0026str) -\u003e Option\u003cString\u003e {\n    // Look for track name in href=\"/music/{artist}/_/{track}\"\n    // Use regex to find track URLs\n    let track_pattern = regex::Regex::new(r#\"href=\"/music/[^\"]+/_/([^\"]+)\"\"#).unwrap();\n    if let Some(captures) = track_pattern.captures(response_text) {\n        if let Some(track_match) = captures.get(1) {\n            let raw_track = track_match.as_str();\n            // URL decode the track name\n            let decoded_track = urlencoding::decode(raw_track)\n                .unwrap_or_else(|_| raw_track.into())\n                .replace('+', \" \");\n            return Some(decoded_track);\n        }\n    }\n    None\n}\n\n/// Extract album name from response text using regex patterns\nfn extract_album_name_from_text(response_text: \u0026str) -\u003e Option\u003cString\u003e {\n    // Look for album name in href=\"/music/{artist}/{album}\"\n    // Find album links that are not track links (don't contain /_/)\n    let album_pattern =\n        regex::Regex::new(r#\"href=\"/music/[^\"]+/([^\"/_]+)\"[^\u003e]*\u003e[^\u003c]*\u003c/a\u003e\"#).unwrap();\n    if let Some(captures) = album_pattern.captures(response_text) {\n        if let Some(album_match) = captures.get(1) {\n            let raw_album = album_match.as_str();\n            // URL decode the album name\n            let decoded_album = urlencoding::decode(raw_album)\n                .unwrap_or_else(|_| raw_album.into())\n                .replace('+', \" \");\n            return Some(decoded_album);\n        }\n    }\n    None\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_analyze_success_response() {\n        let html = r#\"\n            \u003cdiv class=\"alert-success\"\u003eEdit successful\u003c/div\u003e\n            \u003ctable\u003e\n                \u003ctr\u003e\n                    \u003ctd class=\"chartlist-name\"\u003e\u003ca href=\"/music/artist/_/track\"\u003eTest Track\u003c/a\u003e\u003c/td\u003e\n                    \u003ctd class=\"chartlist-album\"\u003e\u003ca href=\"/music/artist/album\"\u003eTest Album\u003c/a\u003e\u003c/td\u003e\n                \u003c/tr\u003e\n            \u003c/table\u003e\n        \"#;\n\n        let result = analyze_edit_response(html, StatusCode::Ok);\n        assert!(result.success);\n        // The CSS selectors should extract the text content of the links\n        assert_eq!(result.actual_track_name, Some(\"Test Track\".to_string()));\n        assert_eq!(result.actual_album_name, Some(\"Test Album\".to_string()));\n    }\n\n    #[test]\n    fn test_analyze_error_response() {\n        let html = r#\"\n            \u003cdiv class=\"alert-danger\"\u003eEdit failed: Invalid data\u003c/div\u003e\n        \"#;\n\n        let result = analyze_edit_response(html, StatusCode::Ok);\n        assert!(!result.success);\n        assert!(result\n            .message\n            .unwrap()\n            .contains(\"Edit failed: Invalid data\"));\n    }\n\n    #[test]\n    fn test_extract_from_regex_patterns() {\n        let html = r#\"\n            Some content with \u003ca href=\"/music/Artist/AlbumName\"\u003ealbum link\u003c/a\u003e\n            and later \u003ca href=\"/music/Artist/_/TrackName\"\u003etrack link\u003c/a\u003e\n        \"#;\n\n        let result = analyze_edit_response(html, StatusCode::Ok);\n        // Should extract from regex patterns when direct selectors fail\n        // The track pattern captures from /_/ URLs, album pattern from non-/_/ URLs\n        assert_eq!(result.actual_track_name, Some(\"TrackName\".to_string()));\n        assert_eq!(result.actual_album_name, Some(\"AlbumName\".to_string()));\n    }\n}\n","traces":[{"line":28,"address":[5877572,5877445,5874400],"length":1,"stats":{"Line":4}},{"line":30,"address":[5802242],"length":1,"stats":{"Line":4}},{"line":33,"address":[6272099,6272174],"length":1,"stats":{"Line":8}},{"line":34,"address":[5881024,5881099],"length":1,"stats":{"Line":8}},{"line":36,"address":[5706077,5706156],"length":1,"stats":{"Line":8}},{"line":37,"address":[5881357],"length":1,"stats":{"Line":4}},{"line":40,"address":[5881563],"length":1,"stats":{"Line":2}},{"line":43,"address":[5881890],"length":1,"stats":{"Line":0}},{"line":52,"address":[5875313,5875982],"length":1,"stats":{"Line":4}},{"line":55,"address":[5707370],"length":1,"stats":{"Line":2}},{"line":57,"address":[5805275,5803824,5804666,5804737],"length":1,"stats":{"Line":6}},{"line":58,"address":[6274750,6274845],"length":1,"stats":{"Line":2}},{"line":60,"address":[5708532,5708365,5708426],"length":1,"stats":{"Line":6}},{"line":63,"address":[5708795,5708392],"length":1,"stats":{"Line":0}},{"line":65,"address":[5803812,5805199,5804661,5804693],"length":1,"stats":{"Line":6}},{"line":66,"address":[5882985,5883110],"length":1,"stats":{"Line":4}},{"line":68,"address":[5876510,5876113],"length":1,"stats":{"Line":4}},{"line":69,"address":[6274212],"length":1,"stats":{"Line":2}},{"line":72,"address":[5876145,5876086],"length":1,"stats":{"Line":2}},{"line":87,"address":[5709894,5708944,5711210],"length":1,"stats":{"Line":4}},{"line":91,"address":[3494328],"length":1,"stats":{"Line":4}},{"line":92,"address":[5877698],"length":1,"stats":{"Line":4}},{"line":95,"address":[5709058,5709130],"length":1,"stats":{"Line":8}},{"line":96,"address":[5877905,5877830],"length":1,"stats":{"Line":8}},{"line":98,"address":[5805869,5805801,5805730],"length":1,"stats":{"Line":12}},{"line":99,"address":[6275818,6275769,6276021],"length":1,"stats":{"Line":2}},{"line":102,"address":[6276275,6276177],"length":1,"stats":{"Line":6}},{"line":103,"address":[3495627,3495379,3495444],"length":1,"stats":{"Line":2}},{"line":107,"address":[5710546,5710460],"length":1,"stats":{"Line":4}},{"line":108,"address":[5879172,5879366,5879581],"length":1,"stats":{"Line":8}},{"line":109,"address":[5710760,5710786],"length":1,"stats":{"Line":3}},{"line":112,"address":[6277398,6277206,6276988],"length":1,"stats":{"Line":6}},{"line":113,"address":[5886033,5886059],"length":1,"stats":{"Line":2}},{"line":117,"address":[5710557],"length":1,"stats":{"Line":2}},{"line":121,"address":[5807680,5808683,5808609],"length":1,"stats":{"Line":3}},{"line":124,"address":[5879947],"length":1,"stats":{"Line":3}},{"line":125,"address":[5880043,5880091],"length":1,"stats":{"Line":5}},{"line":126,"address":[5886740,5886652],"length":1,"stats":{"Line":4}},{"line":127,"address":[5880444,5880395],"length":1,"stats":{"Line":4}},{"line":129,"address":[3497270,3497128],"length":1,"stats":{"Line":4}},{"line":130,"address":[5648672,5648699],"length":1,"stats":{"Line":0}},{"line":132,"address":[6278343],"length":1,"stats":{"Line":2}},{"line":135,"address":[5808638],"length":1,"stats":{"Line":2}},{"line":139,"address":[5881857,5881931,5880928],"length":1,"stats":{"Line":2}},{"line":142,"address":[5887387],"length":1,"stats":{"Line":2}},{"line":144,"address":[3497751,3497703],"length":1,"stats":{"Line":4}},{"line":145,"address":[5712604,5712692],"length":1,"stats":{"Line":4}},{"line":146,"address":[3498055,3498104],"length":1,"stats":{"Line":4}},{"line":148,"address":[3498278,3498136],"length":1,"stats":{"Line":4}},{"line":149,"address":[5648800,5648827],"length":1,"stats":{"Line":0}},{"line":151,"address":[5713095],"length":1,"stats":{"Line":2}},{"line":154,"address":[5713230],"length":1,"stats":{"Line":2}}],"covered":48,"coverable":52},{"path":["/","home","imalison","Projects","lastfm-edit","src","headers.rs"],"content":"use http_client::Request;\n\n/// Common Chrome user agent string for all requests\nconst USER_AGENT: \u0026str = \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36\";\n\n/// Common Chrome headers for security info\nconst SEC_CH_UA: \u0026str =\n    \"\\\"Not)A;Brand\\\";v=\\\"8\\\", \\\"Chromium\\\";v=\\\"138\\\", \\\"Google Chrome\\\";v=\\\"138\\\"\";\nconst SEC_CH_UA_MOBILE: \u0026str = \"?0\";\nconst SEC_CH_UA_PLATFORM: \u0026str = \"\\\"Linux\\\"\";\n\n/// Add common browser headers to a request\npub fn add_common_headers(request: \u0026mut Request) {\n    let _ = request.insert_header(\"User-Agent\", USER_AGENT);\n    let _ = request.insert_header(\"Accept-Language\", \"en-US,en;q=0.9\");\n    let _ = request.insert_header(\"Accept-Encoding\", \"gzip, deflate, br\");\n    let _ = request.insert_header(\"DNT\", \"1\");\n    let _ = request.insert_header(\"Connection\", \"keep-alive\");\n    let _ = request.insert_header(\"sec-ch-ua\", SEC_CH_UA);\n    let _ = request.insert_header(\"sec-ch-ua-mobile\", SEC_CH_UA_MOBILE);\n    let _ = request.insert_header(\"sec-ch-ua-platform\", SEC_CH_UA_PLATFORM);\n}\n\n/// Add headers for HTML form login requests\npub fn add_login_headers(request: \u0026mut Request, login_url: \u0026str, base_url: \u0026str) {\n    add_common_headers(request);\n    let _ = request.insert_header(\"Referer\", login_url);\n    let _ = request.insert_header(\"Origin\", base_url);\n    let _ = request.insert_header(\"Content-Type\", \"application/x-www-form-urlencoded\");\n    let _ = request.insert_header(\n        \"Accept\",\n        \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\"\n    );\n    let _ = request.insert_header(\"Upgrade-Insecure-Requests\", \"1\");\n    let _ = request.insert_header(\"Sec-Fetch-Dest\", \"document\");\n    let _ = request.insert_header(\"Sec-Fetch-Mode\", \"navigate\");\n    let _ = request.insert_header(\"Sec-Fetch-Site\", \"same-origin\");\n    let _ = request.insert_header(\"Sec-Fetch-User\", \"?1\");\n}\n\n/// Add headers for AJAX form edit requests\npub fn add_edit_headers(request: \u0026mut Request, referer_url: \u0026str) {\n    add_common_headers(request);\n    let _ = request.insert_header(\"Accept\", \"*/*\");\n    let _ = request.insert_header(\n        \"Content-Type\",\n        \"application/x-www-form-urlencoded;charset=UTF-8\",\n    );\n    let _ = request.insert_header(\"Priority\", \"u=1, i\");\n    let _ = request.insert_header(\"X-Requested-With\", \"XMLHttpRequest\");\n    let _ = request.insert_header(\"Sec-Fetch-Dest\", \"empty\");\n    let _ = request.insert_header(\"Sec-Fetch-Mode\", \"cors\");\n    let _ = request.insert_header(\"Sec-Fetch-Site\", \"same-origin\");\n    let _ = request.insert_header(\"Referer\", referer_url);\n}\n\n/// Add headers for GET requests (regular pages or AJAX)\npub fn add_get_headers(request: \u0026mut Request, is_ajax: bool, referer_url: Option\u003c\u0026str\u003e) {\n    add_common_headers(request);\n\n    if is_ajax {\n        let _ = request.insert_header(\"Accept\", \"*/*\");\n        let _ = request.insert_header(\"X-Requested-With\", \"XMLHttpRequest\");\n    } else {\n        let _ = request.insert_header(\n            \"Accept\",\n            \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\"\n        );\n        let _ = request.insert_header(\"Upgrade-Insecure-Requests\", \"1\");\n    }\n\n    if let Some(referer) = referer_url {\n        let _ = request.insert_header(\"Referer\", referer);\n    }\n}\n\n/// Add cookies to a request if they exist\npub fn add_cookies(request: \u0026mut Request, cookies: \u0026[String]) {\n    if !cookies.is_empty() {\n        let cookie_header = cookies.join(\"; \");\n        let _ = request.insert_header(\"Cookie\", \u0026cookie_header);\n    }\n}\n","traces":[{"line":13,"address":[6401184],"length":1,"stats":{"Line":2}},{"line":14,"address":[18818576,18818537,18818585,18818528],"length":1,"stats":{"Line":3}},{"line":15,"address":[6013355],"length":1,"stats":{"Line":2}},{"line":16,"address":[5861791],"length":1,"stats":{"Line":2}},{"line":17,"address":[6401363],"length":1,"stats":{"Line":3}},{"line":18,"address":[20901936],"length":1,"stats":{"Line":2}},{"line":19,"address":[21314409],"length":1,"stats":{"Line":2}},{"line":20,"address":[6020009],"length":1,"stats":{"Line":3}},{"line":21,"address":[5862067],"length":1,"stats":{"Line":2}},{"line":25,"address":[6013744],"length":1,"stats":{"Line":0}},{"line":26,"address":[21314480],"length":1,"stats":{"Line":0}},{"line":27,"address":[6020221],"length":1,"stats":{"Line":0}},{"line":28,"address":[21314488],"length":1,"stats":{"Line":0}},{"line":29,"address":[6013925],"length":1,"stats":{"Line":0}},{"line":30,"address":[3429602],"length":1,"stats":{"Line":0}},{"line":34,"address":[3429658],"length":1,"stats":{"Line":0}},{"line":35,"address":[5862477],"length":1,"stats":{"Line":0}},{"line":36,"address":[5862535],"length":1,"stats":{"Line":0}},{"line":37,"address":[6014209],"length":1,"stats":{"Line":0}},{"line":38,"address":[18930816],"length":1,"stats":{"Line":0}},{"line":42,"address":[5862720],"length":1,"stats":{"Line":1}},{"line":43,"address":[6020766],"length":1,"stats":{"Line":1}},{"line":44,"address":[5926969],"length":1,"stats":{"Line":1}},{"line":45,"address":[6402349],"length":1,"stats":{"Line":1}},{"line":49,"address":[6014497],"length":1,"stats":{"Line":1}},{"line":50,"address":[6014549],"length":1,"stats":{"Line":1}},{"line":51,"address":[6402511],"length":1,"stats":{"Line":1}},{"line":52,"address":[5863049],"length":1,"stats":{"Line":1}},{"line":53,"address":[6021107],"length":1,"stats":{"Line":1}},{"line":54,"address":[5927367],"length":1,"stats":{"Line":1}},{"line":58,"address":[6402752],"length":1,"stats":{"Line":3}},{"line":59,"address":[6014894],"length":1,"stats":{"Line":2}},{"line":61,"address":[6021288],"length":1,"stats":{"Line":3}},{"line":62,"address":[6021409],"length":1,"stats":{"Line":2}},{"line":63,"address":[6402981],"length":1,"stats":{"Line":3}},{"line":65,"address":[5927489],"length":1,"stats":{"Line":1}},{"line":69,"address":[5863349],"length":1,"stats":{"Line":2}},{"line":72,"address":[3430715],"length":1,"stats":{"Line":2}},{"line":73,"address":[3430774],"length":1,"stats":{"Line":2}},{"line":78,"address":[3431054,3430832,3431060],"length":1,"stats":{"Line":1}},{"line":79,"address":[6021682],"length":1,"stats":{"Line":4}},{"line":80,"address":[5863702],"length":1,"stats":{"Line":1}},{"line":81,"address":[5863818,5863744],"length":1,"stats":{"Line":4}}],"covered":32,"coverable":43},{"path":["/","home","imalison","Projects","lastfm-edit","src","iterator.rs"],"content":"use crate::r#trait::LastFmEditClient;\nuse crate::{Album, AlbumPage, Result, Track, TrackPage};\n\nuse async_trait::async_trait;\n\n/// Async iterator trait for paginated Last.fm data.\n///\n/// This trait provides a common interface for iterating over paginated data from Last.fm,\n/// such as tracks, albums, and recent scrobbles. All iterators implement efficient streaming\n/// with automatic pagination and built-in rate limiting.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n///\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut tracks = client.artist_tracks(\"Radiohead\");\n///\n/// // Iterate one by one\n/// while let Some(track) = tracks.next().await? {\n///     println!(\"{}\", track.name);\n/// }\n///\n/// // Or collect a limited number\n/// let first_10 = tracks.take(10).await?;\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\n#[cfg_attr(feature = \"mock\", mockall::automock)]\n#[async_trait(?Send)]\npub trait AsyncPaginatedIterator\u003cT\u003e {\n    /// Fetch the next item from the iterator.\n    ///\n    /// This method automatically handles pagination, fetching new pages as needed.\n    /// Returns `None` when there are no more items available.\n    ///\n    /// # Returns\n    ///\n    /// - `Ok(Some(item))` - Next item in the sequence\n    /// - `Ok(None)` - No more items available\n    /// - `Err(...)` - Network or parsing error occurred\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cT\u003e\u003e;\n\n    /// Collect all remaining items into a Vec.\n    ///\n    /// **Warning**: This method will fetch ALL remaining pages, which could be\n    /// many thousands of items for large libraries. Use [`take`](Self::take) for\n    /// safer bounded collection.\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n    /// # tokio_test::block_on(async {\n    /// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n    /// let mut tracks = client.artist_tracks(\"Small Artist\");\n    /// let all_tracks = tracks.collect_all().await?;\n    /// println!(\"Found {} tracks total\", all_tracks.len());\n    /// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n    /// # });\n    /// ```\n    async fn collect_all(\u0026mut self) -\u003e Result\u003cVec\u003cT\u003e\u003e {\n        let mut items = Vec::new();\n        while let Some(item) = self.next().await? {\n            items.push(item);\n        }\n        Ok(items)\n    }\n\n    /// Take up to n items from the iterator.\n    ///\n    /// This is the recommended way to collect a bounded number of items\n    /// from potentially large datasets.\n    ///\n    /// # Arguments\n    ///\n    /// * `n` - Maximum number of items to collect\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n    /// # tokio_test::block_on(async {\n    /// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n    /// let mut tracks = client.artist_tracks(\"Radiohead\");\n    /// let top_20 = tracks.take(20).await?;\n    /// println!(\"Top 20 tracks: {:?}\", top_20);\n    /// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n    /// # });\n    /// ```\n    async fn take(\u0026mut self, n: usize) -\u003e Result\u003cVec\u003cT\u003e\u003e {\n        let mut items = Vec::new();\n        for _ in 0..n {\n            match self.next().await? {\n                Some(item) =\u003e items.push(item),\n                None =\u003e break,\n            }\n        }\n        Ok(items)\n    }\n\n    /// Get the current page number (0-indexed).\n    ///\n    /// Returns the page number of the most recently fetched page.\n    fn current_page(\u0026self) -\u003e u32;\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `Some(n)` if the total page count is known, `None` otherwise.\n    /// This information may not be available until at least one page has been fetched.\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        None // Default implementation returns None\n    }\n}\n\n/// Iterator for browsing an artist's tracks from a user's library.\n///\n/// This iterator provides access to all tracks by a specific artist\n/// in the authenticated user's Last.fm library. Unlike the basic track listing,\n/// this iterator fetches tracks by iterating through the artist's albums first,\n/// which provides complete album information for each track.\n///\n/// The iterator loads albums and their tracks as needed and handles rate limiting\n/// automatically to be respectful to Last.fm's servers.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut tracks = client.artist_tracks(\"The Beatles\");\n///\n/// // Get the top 5 tracks with album information\n/// let top_tracks = tracks.take(5).await?;\n/// for track in top_tracks {\n///     let album = track.album.as_deref().unwrap_or(\"Unknown Album\");\n///     println!(\"{} [{}] (played {} times)\", track.name, album, track.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct ArtistTracksIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    artist: String,\n    album_iterator: Option\u003cArtistAlbumsIterator\u003cC\u003e\u003e,\n    current_album_tracks: Option\u003cAlbumTracksIterator\u003cC\u003e\u003e,\n    track_buffer: Vec\u003cTrack\u003e,\n    finished: bool,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient + Clone\u003e AsyncPaginatedIterator\u003cTrack\u003e for ArtistTracksIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        // If we're finished, return None\n        if self.finished {\n            return Ok(None);\n        }\n\n        // If track buffer is empty, try to get more tracks\n        while self.track_buffer.is_empty() {\n            // If we don't have a current album tracks iterator, get the next album\n            if self.current_album_tracks.is_none() {\n                // Initialize album iterator if needed\n                if self.album_iterator.is_none() {\n                    self.album_iterator = Some(ArtistAlbumsIterator::new(\n                        self.client.clone(),\n                        self.artist.clone(),\n                    ));\n                }\n\n                // Get next album\n                if let Some(ref mut album_iter) = self.album_iterator {\n                    if let Some(album) = album_iter.next().await? {\n                        log::debug!(\n                            \"Processing album '{}' for artist '{}'\",\n                            album.name,\n                            self.artist\n                        );\n                        // Create album tracks iterator for this album\n                        self.current_album_tracks = Some(AlbumTracksIterator::new(\n                            self.client.clone(),\n                            album.name.clone(),\n                            self.artist.clone(),\n                        ));\n                    } else {\n                        // No more albums, we're done\n                        log::debug!(\"No more albums for artist '{}'\", self.artist);\n                        self.finished = true;\n                        return Ok(None);\n                    }\n                }\n            }\n\n            // Get tracks from current album\n            if let Some(ref mut album_tracks) = self.current_album_tracks {\n                if let Some(track) = album_tracks.next().await? {\n                    self.track_buffer.push(track);\n                } else {\n                    // This album is exhausted, move to next album\n                    log::debug!(\n                        \"Finished processing current album for artist '{}'\",\n                        self.artist\n                    );\n                    self.current_album_tracks = None;\n                    // Continue the loop to try getting the next album\n                }\n            }\n        }\n\n        // Return the next track from our buffer\n        Ok(self.track_buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        // Since we're iterating through albums, return the album iterator's current page\n        if let Some(ref album_iter) = self.album_iterator {\n            album_iter.current_page()\n        } else {\n            0\n        }\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        // Since we're iterating through albums, return the album iterator's total pages\n        if let Some(ref album_iter) = self.album_iterator {\n            album_iter.total_pages()\n        } else {\n            None\n        }\n    }\n}\n\nimpl\u003cC: LastFmEditClient + Clone\u003e ArtistTracksIterator\u003cC\u003e {\n    /// Create a new artist tracks iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::artist_tracks`](crate::LastFmEditClient::artist_tracks).\n    pub fn new(client: C, artist: String) -\u003e Self {\n        Self {\n            client,\n            artist,\n            album_iterator: None,\n            current_album_tracks: None,\n            track_buffer: Vec::new(),\n            finished: false,\n        }\n    }\n}\n\n/// Iterator for browsing an artist's tracks directly using the paginated artist tracks endpoint.\n///\n/// This iterator provides access to all tracks by a specific artist\n/// in the authenticated user's Last.fm library by directly using the\n/// `/user/{username}/library/music/{artist}/+tracks` endpoint with pagination.\n/// This is more efficient than the album-based approach as it doesn't need to\n/// iterate through albums first.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut tracks = client.artist_tracks_direct(\"The Beatles\");\n///\n/// // Get the first 10 tracks directly from the paginated endpoint\n/// let first_10_tracks = tracks.take(10).await?;\n/// for track in first_10_tracks {\n///     println!(\"{} (played {} times)\", track.name, track.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct ArtistTracksDirectIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    artist: String,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003cTrack\u003e,\n    total_pages: Option\u003cu32\u003e,\n    tracks_yielded: u32,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cTrack\u003e for ArtistTracksDirectIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if let Some(page) = self.next_page().await? {\n                self.buffer = page.tracks;\n                self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            }\n        }\n\n        if let Some(track) = self.buffer.pop() {\n            self.tracks_yielded += 1;\n            Ok(Some(track))\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e ArtistTracksDirectIterator\u003cC\u003e {\n    /// Create a new direct artist tracks iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::artist_tracks_direct`](crate::LastFmEditClient::artist_tracks_direct).\n    pub fn new(client: C, artist: String) -\u003e Self {\n        Self {\n            client,\n            artist,\n            current_page: 1,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n            tracks_yielded: 0,\n        }\n    }\n\n    /// Fetch the next page of tracks.\n    ///\n    /// This method handles pagination automatically and includes rate limiting.\n    pub async fn next_page(\u0026mut self) -\u003e Result\u003cOption\u003cTrackPage\u003e\u003e {\n        if !self.has_more {\n            return Ok(None);\n        }\n\n        log::debug!(\n            \"Fetching page {} of {} tracks (yielded {} tracks so far)\",\n            self.current_page,\n            self.artist,\n            self.tracks_yielded\n        );\n\n        let page = self\n            .client\n            .get_artist_tracks_page(\u0026self.artist, self.current_page)\n            .await?;\n\n        self.has_more = page.has_next_page;\n        self.current_page += 1;\n        self.total_pages = page.total_pages;\n\n        Ok(Some(page))\n    }\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `None` until at least one page has been fetched.\n    pub fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\n/// Iterator for browsing an artist's albums from a user's library.\n///\n/// This iterator provides paginated access to all albums by a specific artist\n/// in the authenticated user's Last.fm library, ordered by play count.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut albums = client.artist_albums(\"Pink Floyd\");\n///\n/// // Get all albums (be careful with large discographies!)\n/// while let Some(album) = albums.next().await? {\n///     println!(\"{} (played {} times)\", album.name, album.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct ArtistAlbumsIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    artist: String,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003cAlbum\u003e,\n    total_pages: Option\u003cu32\u003e,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cAlbum\u003e for ArtistAlbumsIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cAlbum\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if let Some(page) = self.next_page().await? {\n                self.buffer = page.albums;\n                self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            }\n        }\n\n        Ok(self.buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e ArtistAlbumsIterator\u003cC\u003e {\n    /// Create a new artist albums iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::artist_albums`](crate::LastFmEditClient::artist_albums).\n    pub fn new(client: C, artist: String) -\u003e Self {\n        Self {\n            client,\n            artist,\n            current_page: 1,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Fetch the next page of albums.\n    ///\n    /// This method handles pagination automatically and includes rate limiting.\n    pub async fn next_page(\u0026mut self) -\u003e Result\u003cOption\u003cAlbumPage\u003e\u003e {\n        if !self.has_more {\n            return Ok(None);\n        }\n\n        let page = self\n            .client\n            .get_artist_albums_page(\u0026self.artist, self.current_page)\n            .await?;\n\n        self.has_more = page.has_next_page;\n        self.current_page += 1;\n        self.total_pages = page.total_pages;\n\n        Ok(Some(page))\n    }\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `None` until at least one page has been fetched.\n    pub fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\n/// Iterator for browsing a user's recent tracks/scrobbles.\n///\n/// This iterator provides access to the user's recent listening history with timestamps,\n/// which is essential for finding tracks that can be edited. It supports optional\n/// timestamp-based filtering to avoid reprocessing old data.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// // Get recent tracks with timestamps\n/// let mut recent = client.recent_tracks();\n/// while let Some(track) = recent.next().await? {\n///     if let Some(timestamp) = track.timestamp {\n///         println!(\"{} - {} ({})\", track.artist, track.name, timestamp);\n///     }\n/// }\n///\n/// // Or stop at a specific timestamp to avoid reprocessing\n/// let last_processed = 1640995200;\n/// let mut recent = lastfm_edit::RecentTracksIterator::new(client).with_stop_timestamp(last_processed);\n/// let new_tracks = recent.collect_all().await?;\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct RecentTracksIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003cTrack\u003e,\n    stop_at_timestamp: Option\u003cu64\u003e,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cTrack\u003e for RecentTracksIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if !self.has_more {\n                return Ok(None);\n            }\n\n            let tracks = self.client.get_recent_scrobbles(self.current_page).await?;\n\n            if tracks.is_empty() {\n                self.has_more = false;\n                return Ok(None);\n            }\n\n            // Check if we should stop based on timestamp\n            if let Some(stop_timestamp) = self.stop_at_timestamp {\n                let mut filtered_tracks = Vec::new();\n                for track in tracks {\n                    if let Some(track_timestamp) = track.timestamp {\n                        if track_timestamp \u003c= stop_timestamp {\n                            self.has_more = false;\n                            break;\n                        }\n                    }\n                    filtered_tracks.push(track);\n                }\n                self.buffer = filtered_tracks;\n            } else {\n                self.buffer = tracks;\n            }\n\n            self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            self.current_page += 1;\n        }\n\n        Ok(self.buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e RecentTracksIterator\u003cC\u003e {\n    /// Create a new recent tracks iterator starting from page 1.\n    ///\n    /// This is typically called via [`LastFmEditClient::recent_tracks`](crate::LastFmEditClient::recent_tracks).\n    pub fn new(client: C) -\u003e Self {\n        Self::with_starting_page(client, 1)\n    }\n\n    /// Create a new recent tracks iterator starting from a specific page.\n    ///\n    /// This allows resuming pagination from an arbitrary page, useful for\n    /// continuing from where a previous iteration left off.\n    ///\n    /// # Arguments\n    ///\n    /// * `client` - The LastFmEditClient to use for API calls\n    /// * `starting_page` - The page number to start from (1-indexed)\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n    /// # tokio_test::block_on(async {\n    /// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n    ///\n    /// // Start from page 5\n    /// let mut recent = client.recent_tracks_from_page(5);\n    /// let tracks = recent.take(10).await?;\n    /// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n    /// # });\n    /// ```\n    pub fn with_starting_page(client: C, starting_page: u32) -\u003e Self {\n        let page = std::cmp::max(1, starting_page);\n        Self {\n            client,\n            current_page: page,\n            has_more: true,\n            buffer: Vec::new(),\n            stop_at_timestamp: None,\n        }\n    }\n\n    /// Set a timestamp to stop iteration at.\n    ///\n    /// When this is set, the iterator will stop returning tracks once it encounters\n    /// a track with a timestamp less than or equal to the specified value. This is\n    /// useful for incremental processing to avoid reprocessing old data.\n    ///\n    /// # Arguments\n    ///\n    /// * `timestamp` - Unix timestamp to stop at\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n    /// # tokio_test::block_on(async {\n    /// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n    /// let last_processed = 1640995200; // Some previous timestamp\n    ///\n    /// let mut recent = lastfm_edit::RecentTracksIterator::new(client).with_stop_timestamp(last_processed);\n    /// let new_tracks = recent.collect_all().await?; // Only gets new tracks\n    /// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n    /// # });\n    /// ```\n    pub fn with_stop_timestamp(mut self, timestamp: u64) -\u003e Self {\n        self.stop_at_timestamp = Some(timestamp);\n        self\n    }\n}\n\n/// Iterator for browsing tracks in a specific album from a user's library.\n///\n/// This iterator provides access to all tracks in a specific album by an artist\n/// in the authenticated user's Last.fm library. Unlike paginated iterators,\n/// this loads tracks once and iterates through them.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut tracks = client.album_tracks(\"The Dark Side of the Moon\", \"Pink Floyd\");\n///\n/// // Get all tracks in the album\n/// while let Some(track) = tracks.next().await? {\n///     println!(\"{} - {}\", track.name, track.artist);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct AlbumTracksIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    album_name: String,\n    artist_name: String,\n    tracks: Option\u003cVec\u003cTrack\u003e\u003e,\n    index: usize,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cTrack\u003e for AlbumTracksIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        // Load tracks if not already loaded\n        if self.tracks.is_none() {\n            // Use get_album_tracks_page instead of get_album_tracks to avoid infinite recursion\n            let tracks_page = self\n                .client\n                .get_album_tracks_page(\u0026self.album_name, \u0026self.artist_name, 1)\n                .await?;\n            log::debug!(\n                \"Album '{}' by '{}' has {} tracks: {:?}\",\n                self.album_name,\n                self.artist_name,\n                tracks_page.tracks.len(),\n                tracks_page\n                    .tracks\n                    .iter()\n                    .map(|t| \u0026t.name)\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n            );\n\n            if tracks_page.tracks.is_empty() {\n                log::warn!(\n                    \"ğŸš¨ ZERO TRACKS FOUND for album '{}' by '{}' - investigating...\",\n                    self.album_name,\n                    self.artist_name\n                );\n                log::debug!(\"Full TrackPage for empty album: has_next_page={}, page_number={}, total_pages={:?}\", \n                           tracks_page.has_next_page, tracks_page.page_number, tracks_page.total_pages);\n            }\n            self.tracks = Some(tracks_page.tracks);\n        }\n\n        // Return next track\n        if let Some(tracks) = \u0026self.tracks {\n            if self.index \u003c tracks.len() {\n                let track = tracks[self.index].clone();\n                self.index += 1;\n                Ok(Some(track))\n            } else {\n                Ok(None)\n            }\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        // Album tracks don't have pages, so return 0\n        0\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e AlbumTracksIterator\u003cC\u003e {\n    /// Create a new album tracks iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::album_tracks`](crate::LastFmEditClient::album_tracks).\n    pub fn new(client: C, album_name: String, artist_name: String) -\u003e Self {\n        Self {\n            client,\n            album_name,\n            artist_name,\n            tracks: None,\n            index: 0,\n        }\n    }\n}\n\n/// Iterator for searching tracks in the user's library.\n///\n/// This iterator provides paginated access to tracks that match a search query\n/// in the authenticated user's Last.fm library, using Last.fm's built-in search functionality.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut search_results = client.search_tracks(\"remaster\");\n///\n/// // Get first 20 search results\n/// while let Some(track) = search_results.next().await? {\n///     println!(\"{} - {} (played {} times)\", track.artist, track.name, track.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct SearchTracksIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    query: String,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003cTrack\u003e,\n    total_pages: Option\u003cu32\u003e,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cTrack\u003e for SearchTracksIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if let Some(page) = self.next_page().await? {\n                self.buffer = page.tracks;\n                self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            }\n        }\n\n        Ok(self.buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e SearchTracksIterator\u003cC\u003e {\n    /// Create a new search tracks iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::search_tracks`](crate::LastFmEditClient::search_tracks).\n    pub fn new(client: C, query: String) -\u003e Self {\n        Self {\n            client,\n            query,\n            current_page: 1,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Create a new search tracks iterator starting from a specific page.\n    ///\n    /// This is useful for implementing offset functionality efficiently by starting\n    /// at the appropriate page rather than iterating through all previous pages.\n    pub fn with_starting_page(client: C, query: String, starting_page: u32) -\u003e Self {\n        let page = std::cmp::max(1, starting_page);\n        Self {\n            client,\n            query,\n            current_page: page,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Fetch the next page of search results.\n    ///\n    /// This method handles pagination automatically and includes rate limiting\n    /// to be respectful to Last.fm's servers.\n    pub async fn next_page(\u0026mut self) -\u003e Result\u003cOption\u003cTrackPage\u003e\u003e {\n        if !self.has_more {\n            return Ok(None);\n        }\n\n        let page = self\n            .client\n            .search_tracks_page(\u0026self.query, self.current_page)\n            .await?;\n\n        self.has_more = page.has_next_page;\n        self.current_page += 1;\n        self.total_pages = page.total_pages;\n\n        Ok(Some(page))\n    }\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `None` until at least one page has been fetched.\n    pub fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\n/// Iterator for searching albums in the user's library.\n///\n/// This iterator provides paginated access to albums that match a search query\n/// in the authenticated user's Last.fm library, using Last.fm's built-in search functionality.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut search_results = client.search_albums(\"deluxe\");\n///\n/// // Get first 10 search results\n/// let top_10 = search_results.take(10).await?;\n/// for album in top_10 {\n///     println!(\"{} - {} (played {} times)\", album.artist, album.name, album.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct SearchAlbumsIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    query: String,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003cAlbum\u003e,\n    total_pages: Option\u003cu32\u003e,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cAlbum\u003e for SearchAlbumsIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cAlbum\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if let Some(page) = self.next_page().await? {\n                self.buffer = page.albums;\n                self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            }\n        }\n\n        Ok(self.buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e SearchAlbumsIterator\u003cC\u003e {\n    /// Create a new search albums iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::search_albums`](crate::LastFmEditClient::search_albums).\n    pub fn new(client: C, query: String) -\u003e Self {\n        Self {\n            client,\n            query,\n            current_page: 1,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Create a new search albums iterator starting from a specific page.\n    ///\n    /// This is useful for implementing offset functionality efficiently by starting\n    /// at the appropriate page rather than iterating through all previous pages.\n    pub fn with_starting_page(client: C, query: String, starting_page: u32) -\u003e Self {\n        let page = std::cmp::max(1, starting_page);\n        Self {\n            client,\n            query,\n            current_page: page,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Fetch the next page of search results.\n    ///\n    /// This method handles pagination automatically and includes rate limiting\n    /// to be respectful to Last.fm's servers.\n    pub async fn next_page(\u0026mut self) -\u003e Result\u003cOption\u003cAlbumPage\u003e\u003e {\n        if !self.has_more {\n            return Ok(None);\n        }\n\n        let page = self\n            .client\n            .search_albums_page(\u0026self.query, self.current_page)\n            .await?;\n\n        self.has_more = page.has_next_page;\n        self.current_page += 1;\n        self.total_pages = page.total_pages;\n\n        Ok(Some(page))\n    }\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `None` until at least one page has been fetched.\n    pub fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\n// =============================================================================\n// ARTISTS ITERATOR\n// =============================================================================\n\n/// Iterator for browsing all artists in the user's library.\n///\n/// This iterator provides access to all artists in the authenticated user's Last.fm library,\n/// sorted by play count (highest first). The iterator loads artists as needed and handles\n/// rate limiting automatically to be respectful to Last.fm's servers.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut artists = client.artists();\n///\n/// // Get the top 10 artists\n/// let top_artists = artists.take(10).await?;\n/// for artist in top_artists {\n///     println!(\"{} ({} plays)\", artist.name, artist.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct ArtistsIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003ccrate::Artist\u003e,\n    total_pages: Option\u003cu32\u003e,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003ccrate::Artist\u003e for ArtistsIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003ccrate::Artist\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if let Some(page) = self.next_page().await? {\n                self.buffer = page.artists;\n                self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            }\n        }\n\n        Ok(self.buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e ArtistsIterator\u003cC\u003e {\n    /// Create a new artists iterator.\n    ///\n    /// This iterator will start from page 1 and load all artists in the user's library.\n    pub fn new(client: C) -\u003e Self {\n        Self {\n            client,\n            current_page: 1,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Create a new artists iterator starting from a specific page.\n    ///\n    /// This is useful for implementing offset functionality efficiently by starting\n    /// at the appropriate page rather than iterating through all previous pages.\n    pub fn with_starting_page(client: C, starting_page: u32) -\u003e Self {\n        let page = std::cmp::max(1, starting_page);\n        Self {\n            client,\n            current_page: page,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Fetch the next page of artists.\n    ///\n    /// This method handles pagination automatically and includes rate limiting\n    /// to be respectful to Last.fm's servers.\n    pub async fn next_page(\u0026mut self) -\u003e Result\u003cOption\u003ccrate::ArtistPage\u003e\u003e {\n        if !self.has_more {\n            return Ok(None);\n        }\n\n        let page = self.client.get_artists_page(self.current_page).await?;\n\n        self.has_more = page.has_next_page;\n        self.current_page += 1;\n        self.total_pages = page.total_pages;\n\n        Ok(Some(page))\n    }\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `None` until at least one page has been fetched.\n    pub fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n","traces":[{"line":67,"address":[6040736,6039436,6036255,6041213,6039678,6038202,6042666,6040719,6031849,6033319,6037792,6042380,6042256,6037779,6036307,6031657,6039299,6033805,6032388,6033328,6036749,6041102,6035214,6035258,6034883,6036682,6031897,6033738,6039722,6035325,6032019,6036396,6033694,6032344,6031945,6033363,6032455,6039347,6036272,6042733,6038158,6036638,6042243,6039789,6033452,6040771,6032108,6041146,6039312,6042622,6031705,6034972,6040860,6034848,6042291,6043763,6031609,6037827,6038269,6031984,6031753,6037916,6031801,6034835],"length":1,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[5945948,5945655,5947788,5942205,5946032,5945249,5938327,5938673,5943729,5949713,5941568,5947372,5940380,5941543,5948976,5942615,5941484,5942992,5947456,5948951,5944135,5948193,5938614,5940023,5941191,5946316,5943324,5948599,5944844,5948892,5939671,5940048,5940785,5938698,5941852,5939964,5942967,5938950,5942908,5944512,5939271,5944487,5946007,5947079,5944428,5949308,5946669,5947431],"length":1,"stats":{"Line":0}},{"line":70,"address":[3384306,3385778,3384260,3385732,3389906,3381328,3391332,3387150,3391378,3389860,3382834,3388440,3381374,3387104,3382788,3388394],"length":1,"stats":{"Line":0}},{"line":72,"address":[5949762,5939318,5945298,5940834,5948242,5946718,5943778,5942254],"length":1,"stats":{"Line":0}},{"line":97,"address":[5953520,5956624,5958252,5955722,5961750,5952502,5961706,5961328,5955155,5955244,5952115,5958163,5957046,5961318,5950302,5950480,5962918,5952070,5959718,5961930,5950515,5959852,5955542,5949982,5958730,5953898,5950858,5953942,5950110,5952204,5958506,5960150,5959728,5951082,5953506,5953644,5958128,5950430,5950238,5955498,5950046,5961452,5960330,5956748,5958114,5950604,5950174,5950366,5950902,5952080,5957002,5959763,5952682,5958550,5953555,5956610,5954122,5955110,5961363,5956659,5955120,5957226,5952458,5960106],"length":1,"stats":{"Line":0}},{"line":98,"address":[5960184,5958584,5950936,5952536,5955576,5961784,5953976,5957080],"length":1,"stats":{"Line":0}},{"line":99,"address":[3398546,3398457,3403968,3392505,3396981,3393961,3403202,3394752,3395353,3396905,3401650,3403189,3399412,3394037,3392581,3401561,3396308,3394050,3401637,3400098,3393360,3395442,3396994,3398533,3402516,3403113,3400964,3392594,3400085,3400009,3395429,3397860],"length":1,"stats":{"Line":0}},{"line":100,"address":[3121060,3118804,3119108,3118516,3119412,3116628,3118132,3117780],"length":1,"stats":{"Line":0}},{"line":101,"address":[6049998,6048450,6046926,6051790,6056258,6048786,6050286,6056594,6045746,6051502,6053058,6053394,6045410,6054994,6054658,6047182],"length":1,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[5843620,5846724,5845224,5842184,5853032,5851432,5849832,5848228],"length":1,"stats":{"Line":0}},{"line":117,"address":[3404128,3404096],"length":1,"stats":{"Line":0}},{"line":118,"address":[6056741,6056773],"length":1,"stats":{"Line":0}},{"line":162,"address":[5853850,5853515,5854024,5853897,5853456,5857909,5853659,5853417],"length":1,"stats":{"Line":4}},{"line":164,"address":[6057312],"length":1,"stats":{"Line":1}},{"line":165,"address":[3404725],"length":1,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":171,"address":[],"length":0,"stats":{"Line":2}},{"line":173,"address":[5855709,5856165],"length":1,"stats":{"Line":2}},{"line":174,"address":[],"length":0,"stats":{"Line":2}},{"line":175,"address":[3406499,3406561],"length":1,"stats":{"Line":2}},{"line":176,"address":[3406569],"length":1,"stats":{"Line":1}},{"line":181,"address":[5901562,5903274,5901145],"length":1,"stats":{"Line":3}},{"line":182,"address":[5587249],"length":1,"stats":{"Line":3}},{"line":183,"address":[5966457,5966628,5966592],"length":1,"stats":{"Line":3}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[3408207,3408334,3408306],"length":1,"stats":{"Line":2}},{"line":190,"address":[5902788,5902406],"length":1,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":2}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":196,"address":[6060307,6061333,6061524],"length":1,"stats":{"Line":3}},{"line":197,"address":[6061343],"length":1,"stats":{"Line":1}},{"line":198,"address":[5903362],"length":1,"stats":{"Line":1}},{"line":204,"address":[3406181,3406345,3409085],"length":1,"stats":{"Line":3}},{"line":205,"address":[5509317],"length":1,"stats":{"Line":5}},{"line":206,"address":[],"length":0,"stats":{"Line":2}},{"line":209,"address":[5854852,5855000,5855057],"length":1,"stats":{"Line":3}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[5900744,5900408],"length":1,"stats":{"Line":1}},{"line":220,"address":[],"length":0,"stats":{"Line":2}},{"line":223,"address":[5904032],"length":1,"stats":{"Line":0}},{"line":225,"address":[5858654],"length":1,"stats":{"Line":0}},{"line":226,"address":[3409315],"length":1,"stats":{"Line":0}},{"line":228,"address":[3409326],"length":1,"stats":{"Line":0}},{"line":232,"address":[6055744],"length":1,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[3409411],"length":1,"stats":{"Line":0}},{"line":237,"address":[5968403],"length":1,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":2}},{"line":252,"address":[5818788],"length":1,"stats":{"Line":2}},{"line":296,"address":[3409789,3409641,3410046,3409504,3411240,3409465,3409539,3409833],"length":1,"stats":{"Line":4}},{"line":298,"address":[5968825,5969880],"length":1,"stats":{"Line":2}},{"line":299,"address":[5981956],"length":1,"stats":{"Line":2}},{"line":300,"address":[5860095,5859990],"length":1,"stats":{"Line":1}},{"line":301,"address":[5860215],"length":1,"stats":{"Line":1}},{"line":305,"address":[6062674,6063890,6063747,6063992],"length":1,"stats":{"Line":4}},{"line":306,"address":[],"length":0,"stats":{"Line":2}},{"line":307,"address":[5970106],"length":1,"stats":{"Line":1}},{"line":309,"address":[3411008],"length":1,"stats":{"Line":1}},{"line":313,"address":[5906240],"length":1,"stats":{"Line":0}},{"line":314,"address":[5906245],"length":1,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[5970469],"length":1,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":1}},{"line":332,"address":[],"length":0,"stats":{"Line":1}},{"line":341,"address":[6022936,6022928,6023269,6022944,6022985,6023888,6023090,6024604],"length":1,"stats":{"Line":4}},{"line":342,"address":[3371579],"length":1,"stats":{"Line":1}},{"line":343,"address":[],"length":0,"stats":{"Line":1}},{"line":346,"address":[6023320,6023367,6023176],"length":1,"stats":{"Line":3}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[5930340,5929518,5930802,5930036,5929974,5930269,5930436],"length":1,"stats":{"Line":5}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[5819951,5820372],"length":1,"stats":{"Line":2}},{"line":356,"address":[3372617,3372414,3372696,3372321,3372364,3371629],"length":1,"stats":{"Line":3}},{"line":358,"address":[6024333],"length":1,"stats":{"Line":1}},{"line":359,"address":[5820969,5821148],"length":1,"stats":{"Line":1}},{"line":360,"address":[6024419],"length":1,"stats":{"Line":1}},{"line":362,"address":[6018073],"length":1,"stats":{"Line":1}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[5970579,5970505,5970869,5970825,5971102,5970673,5970544,5972030],"length":1,"stats":{"Line":4}},{"line":408,"address":[],"length":0,"stats":{"Line":2}},{"line":409,"address":[5508964],"length":1,"stats":{"Line":2}},{"line":410,"address":[6059159,6059054],"length":1,"stats":{"Line":1}},{"line":411,"address":[6065663],"length":1,"stats":{"Line":1}},{"line":415,"address":[6059384,6058346],"length":1,"stats":{"Line":2}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[6065861],"length":1,"stats":{"Line":0}},{"line":422,"address":[6065888],"length":1,"stats":{"Line":0}},{"line":423,"address":[5862501],"length":1,"stats":{"Line":0}},{"line":431,"address":[6024991,6025013,6024624],"length":1,"stats":{"Line":2}},{"line":437,"address":[5866746],"length":1,"stats":{"Line":2}},{"line":445,"address":[6025512,6025338,6025048,6025056,6025178,6026204,6025040,6025091],"length":1,"stats":{"Line":4}},{"line":446,"address":[5821766],"length":1,"stats":{"Line":1}},{"line":447,"address":[5867218],"length":1,"stats":{"Line":1}},{"line":450,"address":[6025856,6025412,6025258,6025474,6025692,6025760,6026210],"length":1,"stats":{"Line":5}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[6025397,6025272],"length":1,"stats":{"Line":2}},{"line":453,"address":[5970436],"length":1,"stats":{"Line":3}},{"line":455,"address":[3374377],"length":1,"stats":{"Line":1}},{"line":456,"address":[5932162,5932332],"length":1,"stats":{"Line":1}},{"line":457,"address":[],"length":0,"stats":{"Line":1}},{"line":459,"address":[6019673],"length":1,"stats":{"Line":1}},{"line":465,"address":[3374656],"length":1,"stats":{"Line":0}},{"line":466,"address":[3374661],"length":1,"stats":{"Line":0}},{"line":509,"address":[5972195,5972814,5972160,5974484,5972505,5972121,5972461,5972303],"length":1,"stats":{"Line":4}},{"line":511,"address":[5910537,5908325],"length":1,"stats":{"Line":2}},{"line":512,"address":[3413464],"length":1,"stats":{"Line":1}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[6066138,6066648,6068654,6066465,6066553],"length":1,"stats":{"Line":2}},{"line":518,"address":[6067035,6067103],"length":1,"stats":{"Line":2}},{"line":519,"address":[6067136],"length":1,"stats":{"Line":0}},{"line":520,"address":[5909152],"length":1,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":2}},{"line":525,"address":[6060956],"length":1,"stats":{"Line":0}},{"line":526,"address":[3414476,3414585,3414712],"length":1,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[3414821],"length":1,"stats":{"Line":0}},{"line":529,"address":[6067999],"length":1,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[5909834,5910287],"length":1,"stats":{"Line":0}},{"line":535,"address":[5974229,5974296],"length":1,"stats":{"Line":0}},{"line":537,"address":[6060975,6061936],"length":1,"stats":{"Line":1}},{"line":540,"address":[6068470,6068247],"length":1,"stats":{"Line":2}},{"line":541,"address":[6068481,6068542],"length":1,"stats":{"Line":1}},{"line":544,"address":[6062178,6059982],"length":1,"stats":{"Line":2}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[3374688],"length":1,"stats":{"Line":2}},{"line":557,"address":[3374696],"length":1,"stats":{"Line":2}},{"line":584,"address":[],"length":0,"stats":{"Line":2}},{"line":585,"address":[6026328,6026414],"length":1,"stats":{"Line":4}},{"line":590,"address":[],"length":0,"stats":{"Line":2}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[5975257,5974889,5975778,5978586,5975087,5974928,5974975,5975304],"length":1,"stats":{"Line":4}},{"line":660,"address":[5975319,5978125],"length":1,"stats":{"Line":2}},{"line":662,"address":[],"length":0,"stats":{"Line":7}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[6062887,6062981],"length":1,"stats":{"Line":2}},{"line":665,"address":[3416460,3416515,3416568,3415901,3416850,3416771],"length":1,"stats":{"Line":5}},{"line":666,"address":[5976554],"length":1,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[6064496,6063798],"length":1,"stats":{"Line":4}},{"line":679,"address":[6071088,6070991],"length":1,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[6065036,6064659],"length":1,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":1}},{"line":691,"address":[],"length":0,"stats":{"Line":2}},{"line":692,"address":[3418850,3418936,3418979,3419213],"length":1,"stats":{"Line":4}},{"line":693,"address":[5868705,5868791],"length":1,"stats":{"Line":2}},{"line":694,"address":[6072330,6072190],"length":1,"stats":{"Line":1}},{"line":695,"address":[6072247],"length":1,"stats":{"Line":1}},{"line":697,"address":[3418941],"length":1,"stats":{"Line":1}},{"line":700,"address":[5913994],"length":1,"stats":{"Line":0}},{"line":704,"address":[6066064],"length":1,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[6020368],"length":1,"stats":{"Line":1}},{"line":758,"address":[5914825,5914869,5914505,5914579,5915102,5916030,5914673,5914544],"length":1,"stats":{"Line":4}},{"line":760,"address":[5980128,5979073],"length":1,"stats":{"Line":2}},{"line":761,"address":[3119284],"length":1,"stats":{"Line":2}},{"line":762,"address":[3420567,3420466],"length":1,"stats":{"Line":1}},{"line":763,"address":[6073855],"length":1,"stats":{"Line":1}},{"line":767,"address":[6072922,6073960],"length":1,"stats":{"Line":2}},{"line":770,"address":[5870656],"length":1,"stats":{"Line":0}},{"line":771,"address":[5980245],"length":1,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[5870693],"length":1,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":1}},{"line":789,"address":[],"length":0,"stats":{"Line":1}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":799,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[3376220,3375898,3376888,3375760,3376058,3375776,3375811,3375768],"length":1,"stats":{"Line":4}},{"line":815,"address":[5869478],"length":1,"stats":{"Line":1}},{"line":816,"address":[3375938],"length":1,"stats":{"Line":1}},{"line":819,"address":[5934272,5934722,5933986,5933770,5934204,5933924,5934368],"length":1,"stats":{"Line":5}},{"line":820,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[5824200,5824325],"length":1,"stats":{"Line":2}},{"line":822,"address":[3109988],"length":1,"stats":{"Line":3}},{"line":824,"address":[5824873],"length":1,"stats":{"Line":1}},{"line":825,"address":[6028290,6028460],"length":1,"stats":{"Line":1}},{"line":826,"address":[],"length":0,"stats":{"Line":1}},{"line":828,"address":[5870377],"length":1,"stats":{"Line":1}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[6067811,6069262,6067737,6068101,6068334,6068057,6067905,6067776],"length":1,"stats":{"Line":0}},{"line":875,"address":[5980689,5981744],"length":1,"stats":{"Line":0}},{"line":876,"address":[5582788],"length":1,"stats":{"Line":0}},{"line":877,"address":[6068967,6068862],"length":1,"stats":{"Line":0}},{"line":878,"address":[6069087],"length":1,"stats":{"Line":0}},{"line":882,"address":[5981768,5980730],"length":1,"stats":{"Line":0}},{"line":885,"address":[3422416],"length":1,"stats":{"Line":0}},{"line":886,"address":[3422421],"length":1,"stats":{"Line":0}},{"line":889,"address":[6069312],"length":1,"stats":{"Line":0}},{"line":890,"address":[5917701],"length":1,"stats":{"Line":0}},{"line":898,"address":[5935125,5935103,5934736],"length":1,"stats":{"Line":0}},{"line":904,"address":[3377042],"length":1,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":920,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[5935203,5935450,5935160,5935290,5935152,5935168,5935624,5936316],"length":1,"stats":{"Line":0}},{"line":930,"address":[5825686],"length":1,"stats":{"Line":0}},{"line":931,"address":[5825746],"length":1,"stats":{"Line":0}},{"line":934,"address":[5935968,5935586,5935872,5936322,5935524,5935804,5935370],"length":1,"stats":{"Line":0}},{"line":935,"address":[],"length":0,"stats":{"Line":0}},{"line":936,"address":[3377544,3377669],"length":1,"stats":{"Line":0}},{"line":937,"address":[5935555,5935852,5935317,5935936,5935599,5935650],"length":1,"stats":{"Line":0}},{"line":939,"address":[5936057],"length":1,"stats":{"Line":0}},{"line":940,"address":[5936082,5936252],"length":1,"stats":{"Line":0}},{"line":941,"address":[5826550],"length":1,"stats":{"Line":0}},{"line":943,"address":[5936169],"length":1,"stats":{"Line":0}},{"line":949,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":0}},{"line":992,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[3422855,3423844],"length":1,"stats":{"Line":0}},{"line":995,"address":[3423076,3422684,3422995,3422920],"length":1,"stats":{"Line":0}},{"line":996,"address":[5873458,5873560],"length":1,"stats":{"Line":0}},{"line":997,"address":[5983264],"length":1,"stats":{"Line":0}},{"line":1001,"address":[5918145,5919172],"length":1,"stats":{"Line":0}},{"line":1004,"address":[5873856],"length":1,"stats":{"Line":0}},{"line":1005,"address":[6077253],"length":1,"stats":{"Line":0}},{"line":1008,"address":[3423984],"length":1,"stats":{"Line":0}},{"line":1009,"address":[5919285],"length":1,"stats":{"Line":0}},{"line":1017,"address":[],"length":0,"stats":{"Line":0}},{"line":1022,"address":[5826851],"length":1,"stats":{"Line":0}},{"line":1031,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":0}},{"line":1046,"address":[6025194,6024096,6024379,6024131,6024218,6024502,6024088,6024080],"length":1,"stats":{"Line":0}},{"line":1047,"address":[6030582],"length":1,"stats":{"Line":0}},{"line":1048,"address":[3378962],"length":1,"stats":{"Line":0}},{"line":1051,"address":[6030629,6031584,6030912,6030817,6030682],"length":1,"stats":{"Line":0}},{"line":1053,"address":[5937511],"length":1,"stats":{"Line":0}},{"line":1054,"address":[6031514,6031344],"length":1,"stats":{"Line":0}},{"line":1055,"address":[5873396],"length":1,"stats":{"Line":0}},{"line":1057,"address":[],"length":0,"stats":{"Line":0}},{"line":1063,"address":[],"length":0,"stats":{"Line":0}},{"line":1064,"address":[],"length":0,"stats":{"Line":0}}],"covered":113,"coverable":258},{"path":["/","home","imalison","Projects","lastfm-edit","src","lib.rs"],"content":"//! # lastfm-edit\n//!\n//! A Rust crate for programmatic access to Last.fm's scrobble editing functionality via web scraping.\n//!\n//! This crate provides a high-level interface for authenticating with Last.fm, browsing user libraries,\n//! and performing bulk edits on scrobbled tracks. It uses web scraping to access functionality not\n//! available through Last.fm's public API.\n//!\n//! ## Features\n//!\n//! - **Authentication**: Login to Last.fm with username/password\n//! - **Library browsing**: Paginated access to tracks, albums, and recent scrobbles\n//! - **Bulk editing**: Edit track names, artist names, and album information\n//! - **Async iterators**: Stream large datasets efficiently\n//! - **HTTP client abstraction**: Works with any HTTP client implementation\n//!\n//! ## Quick Start\n//!\n//! ```rust,no_run\n//! use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, AsyncPaginatedIterator, Result};\n//!\n//! #[tokio::main]\n//! async fn main() -\u003e Result\u003c()\u003e {\n//!     // Create HTTP client and login\n//!     let http_client = http_client::native::NativeClient::new();\n//!     let client = LastFmEditClientImpl::login_with_credentials(\n//!         Box::new(http_client),\n//!         \"username\",\n//!         \"password\"\n//!     ).await?;\n//!\n//!     // Browse recent tracks\n//!     let mut recent_tracks = client.recent_tracks();\n//!     while let Some(track) = recent_tracks.next().await? {\n//!         println!(\"{} - {}\", track.artist, track.name);\n//!     }\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ## Core Components\n//!\n//! - [`LastFmEditClient`] - Main client trait for interacting with Last.fm\n//! - [`Track`], [`Album`] - Data structures for music metadata\n//! - [`AsyncPaginatedIterator`] - Trait for streaming paginated data\n//! - [`ScrobbleEdit`] - Represents track edit operations\n//! - [`LastFmError`] - Error types for the crate\n//!\n//! ## Installation\n//!\n//! Add this to your `Cargo.toml`:\n//! ```toml\n//! [dependencies]\n//! lastfm-edit = \"3.1.0\"\n//! http-client = { version = \"^6.6.3\", package = \"http-client-2\", features = [\"curl_client\"] }\n//! tokio = { version = \"1.0\", features = [\"full\"] }\n//! ```\n//!\n//! ## Usage Patterns\n//!\n//! ### Basic Library Browsing\n//!\n//! ```rust,no_run\n//! use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, AsyncPaginatedIterator, Result};\n//!\n//! #[tokio::main]\n//! async fn main() -\u003e Result\u003c()\u003e {\n//!     let http_client = http_client::native::NativeClient::new();\n//!     let client = LastFmEditClientImpl::login_with_credentials(\n//!         Box::new(http_client),\n//!         \"username\",\n//!         \"password\"\n//!     ).await?;\n//!\n//!     // Get all tracks by an artist\n//!     let mut tracks = client.artist_tracks(\"Radiohead\");\n//!     while let Some(track) = tracks.next().await? {\n//!         println!(\"{} - {}\", track.artist, track.name);\n//!     }\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ### Bulk Track Editing\n//!\n//! ```rust,no_run\n//! use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, ScrobbleEdit, AsyncPaginatedIterator, Result};\n//!\n//! #[tokio::main]\n//! async fn main() -\u003e Result\u003c()\u003e {\n//!     let http_client = http_client::native::NativeClient::new();\n//!     let client = LastFmEditClientImpl::login_with_credentials(\n//!         Box::new(http_client),\n//!         \"username\",\n//!         \"password\"\n//!     ).await?;\n//!\n//!     // Find and edit tracks\n//!     let tracks = client.artist_tracks(\"Artist Name\").collect_all().await?;\n//!     for track in tracks {\n//!         if track.name.contains(\"(Remaster)\") {\n//!             let new_name = track.name.replace(\" (Remaster)\", \"\");\n//!\n//!             // Create edit for this track\n//!             let edit = ScrobbleEdit::from_track_info(\n//!                 \u0026track.name,\n//!                 \u0026track.name, // Use track name as album fallback\n//!                 \u0026track.artist,\n//!                 0 // No timestamp needed for bulk edit\n//!             )\n//!             .with_track_name(\u0026new_name)\n//!             .with_edit_all(true);\n//!\n//!             let response = client.edit_scrobble(\u0026edit).await?;\n//!             if response.success() {\n//!                 println!(\"Successfully edited: {} -\u003e {}\", track.name, new_name);\n//!             }\n//!         }\n//!     }\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ### Recent Tracks Monitoring\n//!\n//! ```rust,no_run\n//! use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, AsyncPaginatedIterator, Result};\n//!\n//! #[tokio::main]\n//! async fn main() -\u003e Result\u003c()\u003e {\n//!     let http_client = http_client::native::NativeClient::new();\n//!     let client = LastFmEditClientImpl::login_with_credentials(\n//!         Box::new(http_client),\n//!         \"username\",\n//!         \"password\"\n//!     ).await?;\n//!\n//!     // Get recent tracks (first 100)\n//!     let recent_tracks = client.recent_tracks().take(100).await?;\n//!     println!(\"Found {} recent tracks\", recent_tracks.len());\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ### Mocking for Testing\n//!\n//! Enable the `mock` feature to use `MockLastFmEditClient` for testing:\n//!\n//! ```toml\n//! [dev-dependencies]\n//! lastfm-edit = { version = \"3.1.0\", features = [\"mock\"] }\n//! mockall = \"0.13\"\n//! ```\n//!\n//! ```rust,ignore\n//! #[cfg(feature = \"mock\")]\n//! mod tests {\n//!     use lastfm_edit::{LastFmEditClient, MockLastFmEditClient, Result, EditResponse, ScrobbleEdit};\n//!     use mockall::predicate::*;\n//!\n//!     #[tokio::test]\n//!     async fn test_edit_workflow() -\u003e Result\u003c()\u003e {\n//!         let mut mock_client = MockLastFmEditClient::new();\n//!\n//!         // Set up expectations\n//!         mock_client\n//!             .expect_login()\n//!             .with(eq(\"testuser\"), eq(\"testpass\"))\n//!             .times(1)\n//!             .returning(|_, _| Ok(()));\n//!\n//!         mock_client\n//!             .expect_edit_scrobble()\n//!             .times(1)\n//!             .returning(|_| Ok(EditResponse {\n//!                 success: true,\n//!                 message: Some(\"Edit successful\".to_string()),\n//!             }));\n//!\n//!         // Use as trait object\n//!         let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n//!\n//!         client.login(\"testuser\", \"testpass\").await?;\n//!\n//!         let edit = ScrobbleEdit::new(\n//!             Some(\"Old Track\".to_string()),\n//!             Some(\"Old Album\".to_string()),\n//!             Some(\"Old Artist\".to_string()),\n//!             Some(\"Old Artist\".to_string()),\n//!             \"New Track\".to_string(),\n//!             \"New Album\".to_string(),\n//!             \"New Artist\".to_string(),\n//!             \"New Artist\".to_string(),\n//!             1640995200,\n//!             false,\n//!         );\n//!\n//!         let response = client.edit_scrobble(\u0026edit).await?;\n//!         assert!(response.success);\n//!\n//!         Ok(())\n//!     }\n//! }\n//! ```\n//!\n//! ## License\n//!\n//! MIT\n\npub mod client;\npub mod discovery;\npub mod edit_analysis;\npub mod headers;\npub mod iterator;\npub mod login;\npub mod parsing;\npub mod retry;\npub mod session_persistence;\npub mod r#trait;\npub mod types;\npub mod vcr_form_data;\npub mod vcr_matcher;\npub mod vcr_test_utils;\n\npub use client::LastFmEditClientImpl;\npub use discovery::{\n    AlbumTracksDiscovery, ArtistTracksDiscovery, AsyncDiscoveryIterator, ExactMatchDiscovery,\n    TrackVariationsDiscovery,\n};\npub use login::LoginManager;\npub use r#trait::LastFmEditClient;\n\n// Re-export all types from the consolidated types module\npub use iterator::AsyncPaginatedIterator;\npub use types::{\n    Album, AlbumPage, Artist, ArtistPage, ClientConfig, ClientEvent, ClientEventReceiver,\n    ClientEventWatcher, EditResponse, ExactScrobbleEdit, LastFmEditSession, LastFmError,\n    OperationalDelayConfig, RateLimitConfig, RateLimitType, RequestInfo, RetryConfig, RetryResult,\n    ScrobbleEdit, SharedEventBroadcaster, SingleEditResponse, Track, TrackPage,\n};\n\n// Type aliases for iterators with the concrete client type\npub type ArtistsIterator = iterator::ArtistsIterator\u003cLastFmEditClientImpl\u003e;\npub type ArtistTracksIterator = iterator::ArtistTracksIterator\u003cLastFmEditClientImpl\u003e;\npub type ArtistTracksDirectIterator = iterator::ArtistTracksDirectIterator\u003cLastFmEditClientImpl\u003e;\npub type ArtistAlbumsIterator = iterator::ArtistAlbumsIterator\u003cLastFmEditClientImpl\u003e;\npub type AlbumTracksIterator = iterator::AlbumTracksIterator\u003cLastFmEditClientImpl\u003e;\npub type RecentTracksIterator = iterator::RecentTracksIterator\u003cLastFmEditClientImpl\u003e;\npub type SearchTracksIterator = iterator::SearchTracksIterator\u003cLastFmEditClientImpl\u003e;\npub type SearchAlbumsIterator = iterator::SearchAlbumsIterator\u003cLastFmEditClientImpl\u003e;\n#[cfg(feature = \"mock\")]\npub use r#trait::MockLastFmEditClient;\n\n// Re-export the mock iterator when the mock feature is enabled\n#[cfg(feature = \"mock\")]\npub use iterator::MockAsyncPaginatedIterator;\npub use session_persistence::{SessionManager, SessionPersistence};\n\n// Re-export scraper types for testing\npub use scraper::Html;\n\n/// A convenient type alias for [`Result`] with [`LastFmError`] as the error type.\npub type Result\u003cT\u003e = std::result::Result\u003cT, LastFmError\u003e;\n","traces":[{"line":247,"address":[24135998,24137134,24138149,24135351,24136064,24135285,24138071,24137200],"length":1,"stats":{"Line":3}},{"line":248,"address":[27577164],"length":1,"stats":{"Line":2}},{"line":249,"address":[22128212,22128246],"length":1,"stats":{"Line":0}},{"line":250,"address":[16945512,16945544],"length":1,"stats":{"Line":0}},{"line":251,"address":[25289440,25289461,25289489,25289456,25289445,25289472],"length":1,"stats":{"Line":4}},{"line":252,"address":[25190618,25190560,25190566],"length":1,"stats":{"Line":1}},{"line":253,"address":[24088220],"length":1,"stats":{"Line":0}},{"line":254,"address":[29280803,29282802,29282720,29280752,29281746,29281680,29279616,29278896,29279667,29278954],"length":1,"stats":{"Line":2}},{"line":267,"address":[29343349],"length":1,"stats":{"Line":1}}],"covered":6,"coverable":9},{"path":["/","home","imalison","Projects","lastfm-edit","src","login.rs"],"content":"use crate::types::{LastFmEditSession, LastFmError};\nuse crate::Result;\nuse http_client::{HttpClient, Request};\nuse http_types::{Method, Url};\nuse scraper::{Html, Selector};\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\n/// Login functionality separated from the main client\npub struct LoginManager {\n    client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n    base_url: String,\n}\n\nimpl LoginManager {\n    pub fn new(client: Arc\u003cdyn HttpClient + Send + Sync\u003e, base_url: String) -\u003e Self {\n        Self { client, base_url }\n    }\n\n    /// Authenticate with Last.fm using username and password.\n    ///\n    /// This method:\n    /// 1. Fetches the login page to extract CSRF tokens\n    /// 2. Submits the login form with credentials\n    /// 3. Validates the authentication by checking for session cookies\n    /// 4. Returns a valid session for use with the client\n    ///\n    /// # Arguments\n    ///\n    /// * `username` - Last.fm username or email\n    /// * `password` - Last.fm password\n    ///\n    /// # Returns\n    ///\n    /// Returns a [`LastFmEditSession`] on successful authentication, or [`LastFmError::Auth`] on failure.\n    pub async fn login(\u0026self, username: \u0026str, password: \u0026str) -\u003e Result\u003cLastFmEditSession\u003e {\n        log::info!(\"ğŸ” Starting Last.fm login for username: {username}\");\n\n        // Step 1: Fetch login page and extract CSRF token and cookies\n        let login_url = format!(\"{}/login\", self.base_url);\n        let (csrf_token, next_field, mut cookies) = self.fetch_login_page(\u0026login_url).await?;\n\n        // Step 2: Submit login form\n        let response = self\n            .submit_login_form(\n                \u0026login_url,\n                username,\n                password,\n                \u0026csrf_token,\n                \u0026next_field,\n                \u0026cookies,\n            )\n            .await?;\n\n        // Step 3: Extract cookies from login response\n        extract_cookies_from_response(\u0026response, \u0026mut cookies);\n        log::debug!(\"ğŸª Cookies after login response: {cookies:?}\");\n\n        // Step 4: Validate login response\n        self.validate_login_response(response, username, cookies, csrf_token)\n            .await\n    }\n\n    /// Fetch the login page and extract CSRF token, next field, and cookies\n    async fn fetch_login_page(\n        \u0026self,\n        login_url: \u0026str,\n    ) -\u003e Result\u003c(String, Option\u003cString\u003e, Vec\u003cString\u003e)\u003e {\n        log::debug!(\"ğŸ“¡ Fetching login page: {login_url}\");\n        let mut response = self.get(login_url).await?;\n\n        log::debug!(\"ğŸ“‹ Login page response status: {}\", response.status());\n        log::debug!(\n            \"ğŸ“‹ Login page response headers: {:?}\",\n            response.iter().collect::\u003cVec\u003c_\u003e\u003e()\n        );\n\n        // Extract cookies from the login page response\n        let mut cookies = Vec::new();\n        extract_cookies_from_response(\u0026response, \u0026mut cookies);\n        log::debug!(\"ğŸª Initial cookies from login page: {cookies:?}\");\n\n        // Read and parse the HTML response\n        let html = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\"ğŸ“„ Login page HTML length: {} chars\", html.len());\n        if html.len() \u003c 500 {\n            log::debug!(\"ğŸ“„ Login page HTML content (short): {html}\");\n        }\n\n        // Extract CSRF token and next field from form\n        let (csrf_token, next_field) = self.extract_login_form_data(\u0026html)?;\n        log::debug!(\"ğŸ”‘ Extracted CSRF token: {csrf_token}\",);\n        log::debug!(\"â¡ï¸  Next field: {next_field:?}\");\n\n        Ok((csrf_token, next_field, cookies))\n    }\n\n    /// Submit the login form with credentials\n    async fn submit_login_form(\n        \u0026self,\n        login_url: \u0026str,\n        username: \u0026str,\n        password: \u0026str,\n        csrf_token: \u0026str,\n        next_field: \u0026Option\u003cString\u003e,\n        cookies: \u0026[String],\n    ) -\u003e Result\u003chttp_types::Response\u003e {\n        // Prepare form data\n        let mut form_data = HashMap::new();\n        form_data.insert(\"csrfmiddlewaretoken\", csrf_token);\n        form_data.insert(\"username_or_email\", username);\n        form_data.insert(\"password\", password);\n\n        if let Some(ref next_value) = next_field {\n            form_data.insert(\"next\", next_value);\n            log::debug!(\"â¡ï¸  Including next field in form: {next_value}\");\n        }\n\n        log::debug!(\n            \"ğŸ“ Form data fields: {:?}\",\n            form_data.keys().collect::\u003cVec\u003c_\u003e\u003e()\n        );\n        log::debug!(\"ğŸ“ Form username: {username}\");\n        log::debug!(\"ğŸ“ Form password length: {} chars\", password.len());\n\n        // Create and configure the POST request\n        let mut request = self.create_login_request(login_url, cookies)?;\n\n        // Convert form data to URL-encoded string\n        let form_string: String = form_data\n            .iter()\n            .map(|(k, v)| format!(\"{}={}\", urlencoding::encode(k), urlencoding::encode(v)))\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\u0026\");\n\n        log::debug!(\"ğŸ“¤ Sending POST request to: {login_url}\");\n        log::debug!(\"ğŸ“¤ Form body length: {} chars\", form_string.len());\n        log::debug!(\"ğŸ“¤ Form body (masked): {form_string}\");\n        log::debug!(\"ğŸ“¤ Request headers: Referer={}, Origin={}, Content-Type=application/x-www-form-urlencoded\", \n            login_url, \u0026self.base_url);\n\n        request.set_body(form_string);\n\n        // Send the request\n        let response = self\n            .client\n            .send(request)\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\"ğŸ“¥ Login response status: {}\", response.status());\n        log::debug!(\n            \"ğŸ“¥ Login response headers: {:?}\",\n            response.iter().collect::\u003cVec\u003c_\u003e\u003e()\n        );\n\n        Ok(response)\n    }\n\n    /// Create and configure the login POST request with all necessary headers\n    fn create_login_request(\u0026self, login_url: \u0026str, cookies: \u0026[String]) -\u003e Result\u003cRequest\u003e {\n        let mut request = Request::new(Method::Post, login_url.parse::\u003cUrl\u003e().unwrap());\n\n        // Set all the required headers\n        let _ = request.insert_header(\"Referer\", login_url);\n        let _ = request.insert_header(\"Origin\", \u0026self.base_url);\n        let _ = request.insert_header(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        let _ = request.insert_header(\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36\"\n        );\n        let _ = request.insert_header(\n            \"Accept\",\n            \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\"\n        );\n        let _ = request.insert_header(\"Accept-Language\", \"en-US,en;q=0.9\");\n        let _ = request.insert_header(\"Accept-Encoding\", \"gzip, deflate, br\");\n        let _ = request.insert_header(\"DNT\", \"1\");\n        let _ = request.insert_header(\"Connection\", \"keep-alive\");\n        let _ = request.insert_header(\"Upgrade-Insecure-Requests\", \"1\");\n        let _ = request.insert_header(\n            \"sec-ch-ua\",\n            \"\\\"Not)A;Brand\\\";v=\\\"8\\\", \\\"Chromium\\\";v=\\\"138\\\", \\\"Google Chrome\\\";v=\\\"138\\\"\",\n        );\n        let _ = request.insert_header(\"sec-ch-ua-mobile\", \"?0\");\n        let _ = request.insert_header(\"sec-ch-ua-platform\", \"\\\"Linux\\\"\");\n        let _ = request.insert_header(\"Sec-Fetch-Dest\", \"document\");\n        let _ = request.insert_header(\"Sec-Fetch-Mode\", \"navigate\");\n        let _ = request.insert_header(\"Sec-Fetch-Site\", \"same-origin\");\n        let _ = request.insert_header(\"Sec-Fetch-User\", \"?1\");\n\n        // Add cookies if we have any\n        if !cookies.is_empty() {\n            let cookie_header = cookies.join(\"; \");\n            let _ = request.insert_header(\"Cookie\", \u0026cookie_header);\n        }\n\n        Ok(request)\n    }\n\n    /// Validate the login response and return a session if successful\n    async fn validate_login_response(\n        \u0026self,\n        mut response: http_types::Response,\n        username: \u0026str,\n        cookies: Vec\u003cString\u003e,\n        csrf_token: String,\n    ) -\u003e Result\u003cLastFmEditSession\u003e {\n        // Handle 403 Forbidden responses (likely CSRF failures)\n        if response.status() == 403 {\n            return self.handle_403_response(response).await;\n        }\n\n        // Check for successful session establishment\n        if let Some(session) =\n            self.check_session_success(\u0026response, username, \u0026cookies, \u0026csrf_token)\n        {\n            return Ok(session);\n        }\n\n        // For other cases, analyze the response body\n        let response_html = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"ğŸ“„ Login response HTML length: {} chars\",\n            response_html.len()\n        );\n        if response_html.len() \u003c 500 {\n            log::debug!(\"ğŸ“„ Login response HTML content (short): {response_html}\");\n        }\n\n        // Check if we were redirected away from login page (success indicator)\n        let has_login_form = self.check_for_login_form(\u0026response_html);\n        log::debug!(\"ğŸ” Final login validation:\");\n        log::debug!(\"   - Response contains login form: {has_login_form}\");\n        log::debug!(\"   - Response status: {}\", response.status());\n\n        if !has_login_form \u0026\u0026 response.status() == 200 {\n            log::info!(\"âœ… Login successful - no login form detected in response\");\n            Ok(LastFmEditSession::new(\n                username.to_string(),\n                cookies,\n                Some(csrf_token),\n                self.base_url.clone(),\n            ))\n        } else {\n            // Parse and return error message\n            let error_msg = self.parse_login_error(\u0026response_html);\n            log::warn!(\"âŒ Login failed: {error_msg}\");\n            Err(LastFmError::Auth(error_msg))\n        }\n    }\n\n    /// Handle 403 Forbidden responses\n    async fn handle_403_response(\n        \u0026self,\n        mut response: http_types::Response,\n    ) -\u003e Result\u003cLastFmEditSession\u003e {\n        let response_html = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\"ğŸ“„ 403 response HTML length: {} chars\", response_html.len());\n        if response_html.len() \u003c 2000 {\n            log::debug!(\"ğŸ“„ 403 response HTML content: {response_html}\");\n        } else {\n            // Log first and last 500 chars for large responses\n            log::debug!(\"ğŸ“„ 403 response HTML start: {}\", \u0026response_html[..500]);\n            log::debug!(\n                \"ğŸ“„ 403 response HTML end: {}\",\n                \u0026response_html[response_html.len() - 500..]\n            );\n        }\n\n        let login_error = self.parse_login_error(\u0026response_html);\n        Err(LastFmError::Auth(login_error))\n    }\n\n    /// Check if the response indicates successful session establishment\n    fn check_session_success(\n        \u0026self,\n        response: \u0026http_types::Response,\n        username: \u0026str,\n        cookies: \u0026[String],\n        csrf_token: \u0026str,\n    ) -\u003e Option\u003cLastFmEditSession\u003e {\n        let has_real_session = cookies\n            .iter()\n            .any(|cookie| cookie.starts_with(\"sessionid=.\") \u0026\u0026 cookie.len() \u003e 50);\n\n        log::debug!(\"ğŸ” Session validation:\");\n        log::debug!(\"   - Has real session cookie: {has_real_session}\");\n        log::debug!(\"   - Response status: {}\", response.status());\n        log::debug!(\"   - All cookies: {cookies:?}\");\n\n        if has_real_session \u0026\u0026 (response.status() == 302 || response.status() == 200) {\n            log::info!(\"âœ… Login successful - authenticated session established\");\n            Some(LastFmEditSession::new(\n                username.to_string(),\n                cookies.to_vec(),\n                Some(csrf_token.to_string()),\n                self.base_url.clone(),\n            ))\n        } else {\n            None\n        }\n    }\n\n    /// Make a simple HTTP GET request (without retry logic)\n    async fn get(\u0026self, url: \u0026str) -\u003e Result\u003chttp_types::Response\u003e {\n        let mut request = Request::new(Method::Get, url.parse::\u003cUrl\u003e().unwrap());\n        let _ = request.insert_header(\"User-Agent\", \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36\");\n\n        self.client\n            .send(request)\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))\n    }\n\n    /// Extract login form data (CSRF token and next field)\n    fn extract_login_form_data(\u0026self, html: \u0026str) -\u003e Result\u003c(String, Option\u003cString\u003e)\u003e {\n        let document = Html::parse_document(html);\n\n        let csrf_token = self.extract_csrf_token(\u0026document)?;\n\n        // Check if there's a 'next' field in the form\n        let next_selector = Selector::parse(\"input[name=\\\"next\\\"]\").unwrap();\n        let next_field = document\n            .select(\u0026next_selector)\n            .next()\n            .and_then(|input| input.value().attr(\"value\"))\n            .map(|s| s.to_string());\n\n        Ok((csrf_token, next_field))\n    }\n\n    fn extract_csrf_token(\u0026self, document: \u0026Html) -\u003e Result\u003cString\u003e {\n        let csrf_selector = Selector::parse(\"input[name=\\\"csrfmiddlewaretoken\\\"]\").unwrap();\n\n        let csrf_token = document\n            .select(\u0026csrf_selector)\n            .next()\n            .and_then(|input| input.value().attr(\"value\"))\n            .map(|token| token.to_string())\n            .ok_or(LastFmError::CsrfNotFound)?;\n\n        log::debug!(\"ğŸ”‘ CSRF token extracted from HTML: {csrf_token}\");\n        Ok(csrf_token)\n    }\n\n    /// Parse login error messages from HTML\n    fn parse_login_error(\u0026self, html: \u0026str) -\u003e String {\n        let document = Html::parse_document(html);\n\n        let error_selector = Selector::parse(\".alert-danger, .form-error, .error-message\").unwrap();\n\n        let mut error_messages = Vec::new();\n        for error in document.select(\u0026error_selector) {\n            let error_text = error.text().collect::\u003cString\u003e().trim().to_string();\n            if !error_text.is_empty() {\n                error_messages.push(error_text);\n            }\n        }\n\n        if error_messages.is_empty() {\n            \"Login failed - please check your credentials\".to_string()\n        } else {\n            format!(\"Login failed: {}\", error_messages.join(\"; \"))\n        }\n    }\n\n    /// Check if HTML contains a login form\n    fn check_for_login_form(\u0026self, html: \u0026str) -\u003e bool {\n        let document = Html::parse_document(html);\n        let login_form_selector =\n            Selector::parse(\"form[action*=\\\"login\\\"], input[name=\\\"username_or_email\\\"]\").unwrap();\n        document.select(\u0026login_form_selector).next().is_some()\n    }\n}\n\n/// Extract cookies from HTTP response - utility function\npub fn extract_cookies_from_response(response: \u0026http_types::Response, cookies: \u0026mut Vec\u003cString\u003e) {\n    if let Some(cookie_headers) = response.header(\"set-cookie\") {\n        for cookie_header in cookie_headers {\n            let cookie_str = cookie_header.as_str();\n            // Extract just the cookie name=value part (before any semicolon)\n            if let Some(cookie_value) = cookie_str.split(';').next() {\n                let cookie_name = cookie_value.split('=').next().unwrap_or(\"\");\n\n                // Remove any existing cookie with the same name\n                cookies.retain(|existing| !existing.starts_with(\u0026format!(\"{cookie_name}=\")));\n                cookies.push(cookie_value.to_string());\n            }\n        }\n    }\n}\n","traces":[{"line":16,"address":[6167280],"length":1,"stats":{"Line":1}},{"line":36,"address":[3258514,3256288,3256633,3256372,3257342,3256548],"length":1,"stats":{"Line":4}},{"line":37,"address":[5781076,5781306,5781266],"length":1,"stats":{"Line":3}},{"line":40,"address":[3257018,3256696],"length":1,"stats":{"Line":2}},{"line":41,"address":[3132130],"length":1,"stats":{"Line":2}},{"line":44,"address":[5866352,5865461,5865859,5865935,5866265,5866237],"length":1,"stats":{"Line":5}},{"line":46,"address":[5782585],"length":1,"stats":{"Line":1}},{"line":47,"address":[6346535],"length":1,"stats":{"Line":1}},{"line":48,"address":[5782727],"length":1,"stats":{"Line":1}},{"line":49,"address":[5782751],"length":1,"stats":{"Line":1}},{"line":50,"address":[6346650],"length":1,"stats":{"Line":1}},{"line":51,"address":[3258225],"length":1,"stats":{"Line":1}},{"line":53,"address":[6346852,6347264,6347183,6346980,6345015,6346912],"length":1,"stats":{"Line":3}},{"line":56,"address":[6347422],"length":1,"stats":{"Line":1}},{"line":57,"address":[3259025,3259260],"length":1,"stats":{"Line":2}},{"line":60,"address":[5784760,5783725,5784256],"length":1,"stats":{"Line":3}},{"line":61,"address":[5781196,5784229,5784289,5784581,5784952],"length":1,"stats":{"Line":3}},{"line":65,"address":[6167392],"length":1,"stats":{"Line":1}},{"line":69,"address":[3260639,3260845,3260802],"length":1,"stats":{"Line":3}},{"line":70,"address":[5391167],"length":1,"stats":{"Line":2}},{"line":72,"address":[5952918,5952764,5952864],"length":1,"stats":{"Line":3}},{"line":73,"address":[5786824,5786438,5786859,5786995],"length":1,"stats":{"Line":3}},{"line":79,"address":[5786830],"length":1,"stats":{"Line":1}},{"line":80,"address":[3262593],"length":1,"stats":{"Line":1}},{"line":81,"address":[5953820,5953912],"length":1,"stats":{"Line":2}},{"line":84,"address":[3265828,3263378,3263452,3262734,3263542,3263086],"length":1,"stats":{"Line":4}},{"line":86,"address":[3263059,3263119,3263410,3260735,3263215],"length":1,"stats":{"Line":3}},{"line":87,"address":[5963488,5963506,5961078],"length":1,"stats":{"Line":0}},{"line":89,"address":[5954795,5954923,5954891],"length":1,"stats":{"Line":3}},{"line":90,"address":[5961658,5961321],"length":1,"stats":{"Line":2}},{"line":91,"address":[5961711],"length":1,"stats":{"Line":0}},{"line":95,"address":[5789199,5788818],"length":1,"stats":{"Line":2}},{"line":96,"address":[3264817,3264868,3264727],"length":1,"stats":{"Line":3}},{"line":97,"address":[5956306,5956628,5955991],"length":1,"stats":{"Line":3}},{"line":99,"address":[6353724],"length":1,"stats":{"Line":1}},{"line":103,"address":[6167440],"length":1,"stats":{"Line":1}},{"line":113,"address":[5791224],"length":1,"stats":{"Line":1}},{"line":114,"address":[3266616],"length":1,"stats":{"Line":1}},{"line":115,"address":[5791436],"length":1,"stats":{"Line":1}},{"line":116,"address":[6355338],"length":1,"stats":{"Line":1}},{"line":118,"address":[5791541],"length":1,"stats":{"Line":1}},{"line":119,"address":[5958021,5958144],"length":1,"stats":{"Line":2}},{"line":120,"address":[5964583],"length":1,"stats":{"Line":1}},{"line":123,"address":[5964938,5964488,5964992,5965128],"length":1,"stats":{"Line":3}},{"line":127,"address":[6355936,6356394,6356448],"length":1,"stats":{"Line":3}},{"line":128,"address":[5792903,5792560,5792970],"length":1,"stats":{"Line":3}},{"line":131,"address":[5966194,5968619,5965781],"length":1,"stats":{"Line":2}},{"line":134,"address":[3268785,3269016,3268891],"length":1,"stats":{"Line":3}},{"line":136,"address":[5963854,5963808],"length":1,"stats":{"Line":2}},{"line":140,"address":[6357781,6357887],"length":1,"stats":{"Line":2}},{"line":141,"address":[3269588,3269195,3269534],"length":1,"stats":{"Line":3}},{"line":142,"address":[5967192,5967577,5967631],"length":1,"stats":{"Line":3}},{"line":143,"address":[5961167,5961725,5961513,5961601],"length":1,"stats":{"Line":0}},{"line":146,"address":[5795087],"length":1,"stats":{"Line":1}},{"line":149,"address":[6359475,6359865,6359552,6359893,6359363,6360007],"length":1,"stats":{"Line":5}},{"line":151,"address":[5968402],"length":1,"stats":{"Line":1}},{"line":152,"address":[5565399],"length":1,"stats":{"Line":3}},{"line":153,"address":[5797792,5796135,5797810],"length":1,"stats":{"Line":0}},{"line":155,"address":[5879170,5879311,5879260],"length":1,"stats":{"Line":3}},{"line":156,"address":[3272091],"length":1,"stats":{"Line":0}},{"line":161,"address":[5796775],"length":1,"stats":{"Line":1}},{"line":165,"address":[5777371,5777377,5775728],"length":1,"stats":{"Line":1}},{"line":166,"address":[3433490],"length":1,"stats":{"Line":1}},{"line":169,"address":[5602153,5602081],"length":1,"stats":{"Line":2}},{"line":170,"address":[5776033],"length":1,"stats":{"Line":1}},{"line":171,"address":[5698264],"length":1,"stats":{"Line":1}},{"line":172,"address":[5776156],"length":1,"stats":{"Line":1}},{"line":176,"address":[5698400],"length":1,"stats":{"Line":1}},{"line":180,"address":[5602436],"length":1,"stats":{"Line":1}},{"line":181,"address":[6168296],"length":1,"stats":{"Line":1}},{"line":182,"address":[3434032],"length":1,"stats":{"Line":1}},{"line":183,"address":[5602640],"length":1,"stats":{"Line":1}},{"line":184,"address":[5698738],"length":1,"stats":{"Line":1}},{"line":185,"address":[3434210],"length":1,"stats":{"Line":1}},{"line":189,"address":[5602842],"length":1,"stats":{"Line":1}},{"line":190,"address":[5776766],"length":1,"stats":{"Line":1}},{"line":191,"address":[5602978],"length":1,"stats":{"Line":1}},{"line":192,"address":[3434450],"length":1,"stats":{"Line":1}},{"line":193,"address":[6168906],"length":1,"stats":{"Line":1}},{"line":194,"address":[5603182],"length":1,"stats":{"Line":1}},{"line":197,"address":[5771948],"length":1,"stats":{"Line":1}},{"line":198,"address":[6169087],"length":1,"stats":{"Line":1}},{"line":199,"address":[5777330,5777242],"length":1,"stats":{"Line":2}},{"line":202,"address":[5777183],"length":1,"stats":{"Line":1}},{"line":206,"address":[5777392],"length":1,"stats":{"Line":1}},{"line":214,"address":[3273645,3273491],"length":1,"stats":{"Line":2}},{"line":215,"address":[5488892],"length":1,"stats":{"Line":0}},{"line":219,"address":[3274104],"length":1,"stats":{"Line":2}},{"line":222,"address":[5965426],"length":1,"stats":{"Line":1}},{"line":226,"address":[6362971,6362910,6363901,6363787,6367950,6363729],"length":1,"stats":{"Line":0}},{"line":228,"address":[3098289],"length":1,"stats":{"Line":0}},{"line":229,"address":[6363869,6368176,6368194],"length":1,"stats":{"Line":0}},{"line":231,"address":[5883303,5883058,5883154,5883186],"length":1,"stats":{"Line":0}},{"line":235,"address":[5800272,5800621],"length":1,"stats":{"Line":0}},{"line":236,"address":[6364526],"length":1,"stats":{"Line":0}},{"line":240,"address":[6364469,6364895],"length":1,"stats":{"Line":0}},{"line":241,"address":[6364929,6365035],"length":1,"stats":{"Line":0}},{"line":242,"address":[5801489,5801435,5801147],"length":1,"stats":{"Line":0}},{"line":243,"address":[5884337,5884701,5884676],"length":1,"stats":{"Line":0}},{"line":245,"address":[5968218,5968571,5968655,5969860],"length":1,"stats":{"Line":0}},{"line":246,"address":[6366111,6366207],"length":1,"stats":{"Line":0}},{"line":247,"address":[3277954,3278049],"length":1,"stats":{"Line":0}},{"line":248,"address":[5975171,5975465],"length":1,"stats":{"Line":0}},{"line":249,"address":[5885521],"length":1,"stats":{"Line":0}},{"line":250,"address":[5802686],"length":1,"stats":{"Line":0}},{"line":251,"address":[5802779],"length":1,"stats":{"Line":0}},{"line":255,"address":[5886015,5885066],"length":1,"stats":{"Line":0}},{"line":256,"address":[6367068,6366978,6367273],"length":1,"stats":{"Line":0}},{"line":257,"address":[3278330],"length":1,"stats":{"Line":0}},{"line":262,"address":[5777600],"length":1,"stats":{"Line":0}},{"line":266,"address":[5805115,5805057,5804646,5804798,5805229],"length":1,"stats":{"Line":0}},{"line":268,"address":[3280177,3279859,3279798,3279979,3279919],"length":1,"stats":{"Line":0}},{"line":269,"address":[5807394,5805197,5807376],"length":1,"stats":{"Line":0}},{"line":271,"address":[5805330,5805426,5805458],"length":1,"stats":{"Line":0}},{"line":272,"address":[6369629,6369280],"length":1,"stats":{"Line":0}},{"line":273,"address":[5806771,5805842],"length":1,"stats":{"Line":0}},{"line":276,"address":[5888693,5888847,5888793],"length":1,"stats":{"Line":0}},{"line":277,"address":[6370203,6369743,6370149,6370404],"length":1,"stats":{"Line":0}},{"line":283,"address":[5889960,5889211],"length":1,"stats":{"Line":0}},{"line":284,"address":[3282155],"length":1,"stats":{"Line":0}},{"line":288,"address":[5777680,5779754,5779726],"length":1,"stats":{"Line":1}},{"line":295,"address":[5772667],"length":1,"stats":{"Line":1}},{"line":297,"address":[5807550,5807520],"length":1,"stats":{"Line":2}},{"line":299,"address":[6169915,6169838],"length":1,"stats":{"Line":2}},{"line":300,"address":[5604323,5604077],"length":1,"stats":{"Line":2}},{"line":301,"address":[5604277,5604600],"length":1,"stats":{"Line":2}},{"line":302,"address":[5778410,5778725],"length":1,"stats":{"Line":2}},{"line":304,"address":[3436492,3436227,3437209],"length":1,"stats":{"Line":2}},{"line":305,"address":[5774019,5773901],"length":1,"stats":{"Line":2}},{"line":306,"address":[5605721,5605825],"length":1,"stats":{"Line":2}},{"line":307,"address":[6171066],"length":1,"stats":{"Line":1}},{"line":308,"address":[5605554,5605299],"length":1,"stats":{"Line":2}},{"line":309,"address":[5605624,5605562],"length":1,"stats":{"Line":2}},{"line":310,"address":[5774352],"length":1,"stats":{"Line":1}},{"line":313,"address":[5773793],"length":1,"stats":{"Line":0}},{"line":318,"address":[3282739,3282874,3282704,3283394,3283400],"length":1,"stats":{"Line":4}},{"line":319,"address":[5807778,5807877],"length":1,"stats":{"Line":2}},{"line":320,"address":[5980800,5980898],"length":1,"stats":{"Line":2}},{"line":322,"address":[5808074,5808199,5808568,5808628,5808258],"length":1,"stats":{"Line":5}},{"line":323,"address":[5891036],"length":1,"stats":{"Line":1}},{"line":324,"address":[5891123,5891466,5891173,5890725,5891291],"length":1,"stats":{"Line":3}},{"line":325,"address":[5975152,5975170],"length":1,"stats":{"Line":0}},{"line":329,"address":[6171776,6172740,6172789],"length":1,"stats":{"Line":1}},{"line":330,"address":[5606056],"length":1,"stats":{"Line":1}},{"line":332,"address":[3437461,3437525],"length":1,"stats":{"Line":2}},{"line":335,"address":[5606414,5606342],"length":1,"stats":{"Line":2}},{"line":336,"address":[5775146,5775222,5775290],"length":1,"stats":{"Line":3}},{"line":339,"address":[3283921,3283920],"length":1,"stats":{"Line":2}},{"line":340,"address":[5981760,5981782],"length":1,"stats":{"Line":3}},{"line":342,"address":[5780582],"length":1,"stats":{"Line":1}},{"line":345,"address":[5775712,5776742,5776780],"length":1,"stats":{"Line":1}},{"line":346,"address":[5780918],"length":1,"stats":{"Line":1}},{"line":348,"address":[5780980,5781113,5781045,5781183,5781310],"length":1,"stats":{"Line":4}},{"line":351,"address":[6372800,6372801],"length":1,"stats":{"Line":2}},{"line":352,"address":[5981856,5981878],"length":1,"stats":{"Line":2}},{"line":353,"address":[5703248,5704092,5703579,5703347,5703454],"length":1,"stats":{"Line":2}},{"line":355,"address":[5607610,5607774],"length":1,"stats":{"Line":2}},{"line":356,"address":[5607667],"length":1,"stats":{"Line":1}},{"line":360,"address":[5782882,5783324,5781968],"length":1,"stats":{"Line":0}},{"line":361,"address":[5782035],"length":1,"stats":{"Line":0}},{"line":363,"address":[3439585,3439513],"length":1,"stats":{"Line":0}},{"line":365,"address":[3439625],"length":1,"stats":{"Line":0}},{"line":366,"address":[5609422,5608574,5608377,5608450],"length":1,"stats":{"Line":0}},{"line":367,"address":[6174869,6174426],"length":1,"stats":{"Line":0}},{"line":368,"address":[5705337],"length":1,"stats":{"Line":0}},{"line":369,"address":[5609326,5609412],"length":1,"stats":{"Line":0}},{"line":373,"address":[5782539],"length":1,"stats":{"Line":0}},{"line":374,"address":[3440054,3440336],"length":1,"stats":{"Line":0}},{"line":376,"address":[3440090,3440020],"length":1,"stats":{"Line":0}},{"line":381,"address":[3441216,3440784,3441222],"length":1,"stats":{"Line":0}},{"line":382,"address":[3440815],"length":1,"stats":{"Line":0}},{"line":383,"address":[5778290,5778221],"length":1,"stats":{"Line":0}},{"line":385,"address":[5609769,5609640,5609707],"length":1,"stats":{"Line":0}},{"line":390,"address":[3441248],"length":1,"stats":{"Line":1}},{"line":391,"address":[3441276],"length":1,"stats":{"Line":1}},{"line":392,"address":[5783940,5783900],"length":1,"stats":{"Line":4}},{"line":393,"address":[3441445],"length":1,"stats":{"Line":2}},{"line":395,"address":[5706207],"length":1,"stats":{"Line":2}},{"line":396,"address":[6176093],"length":1,"stats":{"Line":2}},{"line":399,"address":[6176168],"length":1,"stats":{"Line":10}},{"line":400,"address":[5610400],"length":1,"stats":{"Line":1}}],"covered":127,"coverable":181},{"path":["/","home","imalison","Projects","lastfm-edit","src","parsing.rs"],"content":"//! HTML parsing utilities for Last.fm pages.\n//!\n//! This module contains all the HTML parsing logic for extracting track, album,\n//! and other data from Last.fm web pages. These functions are primarily pure\n//! functions that take HTML documents and return structured data.\n\nuse crate::{Album, AlbumPage, Artist, ArtistPage, LastFmError, Result, Track, TrackPage};\nuse scraper::{Html, Selector};\n\n/// Parser struct containing parsing methods for Last.fm HTML pages.\n///\n/// This struct holds the parsing logic that was previously embedded in the client.\n/// It's designed to be stateless and focused purely on HTML parsing.\n#[derive(Debug, Clone)]\npub struct LastFmParser;\n\nimpl LastFmParser {\n    /// Create a new parser instance.\n    pub fn new() -\u003e Self {\n        Self\n    }\n\n    /// Parse recent scrobbles from the user's library page\n    /// This extracts real scrobble data with timestamps for editing\n    pub fn parse_recent_scrobbles(\u0026self, document: \u0026Html) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        let mut tracks = Vec::new();\n\n        // Recent scrobbles are typically in chartlist tables - there can be multiple\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let row_selector = Selector::parse(\"tbody tr\").unwrap();\n\n        let tables: Vec\u003c_\u003e = document.select(\u0026table_selector).collect();\n        log::debug!(\"Found {} chartlist tables\", tables.len());\n\n        for table in tables {\n            for row in table.select(\u0026row_selector) {\n                if let Ok(track) = self.parse_recent_scrobble_row(\u0026row) {\n                    tracks.push(track);\n                }\n            }\n        }\n\n        if tracks.is_empty() {\n            log::debug!(\"No tracks found in recent scrobbles\");\n        }\n\n        log::debug!(\"Parsed {} recent scrobbles\", tracks.len());\n        Ok(tracks)\n    }\n\n    /// Parse a single row from the recent scrobbles table\n    fn parse_recent_scrobble_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cTrack\u003e {\n        // Extract track name\n        let name_selector = Selector::parse(\".chartlist-name a\").unwrap();\n        let name = row\n            .select(\u0026name_selector)\n            .next()\n            .ok_or(LastFmError::Parse(\"Missing track name\".to_string()))?\n            .text()\n            .collect::\u003cString\u003e()\n            .trim()\n            .to_string();\n\n        // Extract artist name\n        let artist_selector = Selector::parse(\".chartlist-artist a\").unwrap();\n        let artist = row\n            .select(\u0026artist_selector)\n            .next()\n            .ok_or(LastFmError::Parse(\"Missing artist name\".to_string()))?\n            .text()\n            .collect::\u003cString\u003e()\n            .trim()\n            .to_string();\n\n        // Extract timestamp from data attributes or hidden inputs\n        let timestamp = self.extract_scrobble_timestamp(row);\n\n        // Extract album from hidden inputs in edit form\n        let album = self.extract_scrobble_album(row);\n\n        // Extract album artist from hidden inputs in edit form\n        let album_artist = self.extract_scrobble_album_artist(row);\n\n        // For recent scrobbles, playcount is typically 1 since they're individual scrobbles\n        let playcount = 1;\n\n        Ok(Track {\n            name,\n            artist,\n            playcount,\n            timestamp,\n            album,\n            album_artist,\n        })\n    }\n\n    /// Extract timestamp from scrobble row elements\n    fn extract_scrobble_timestamp(\u0026self, row: \u0026scraper::ElementRef) -\u003e Option\u003cu64\u003e {\n        // Look for timestamp in various places:\n\n        // 1. Check for data-timestamp attribute\n        if let Some(timestamp_str) = row.value().attr(\"data-timestamp\") {\n            if let Ok(timestamp) = timestamp_str.parse::\u003cu64\u003e() {\n                return Some(timestamp);\n            }\n        }\n\n        // 2. Look for hidden timestamp input\n        let timestamp_input_selector = Selector::parse(\"input[name='timestamp']\").unwrap();\n        if let Some(input) = row.select(\u0026timestamp_input_selector).next() {\n            if let Some(value) = input.value().attr(\"value\") {\n                if let Ok(timestamp) = value.parse::\u003cu64\u003e() {\n                    return Some(timestamp);\n                }\n            }\n        }\n\n        // 3. Look for edit form with timestamp\n        let edit_form_selector =\n            Selector::parse(\"form[data-edit-scrobble] input[name='timestamp']\").unwrap();\n        if let Some(timestamp_input) = row.select(\u0026edit_form_selector).next() {\n            if let Some(value) = timestamp_input.value().attr(\"value\") {\n                if let Ok(timestamp) = value.parse::\u003cu64\u003e() {\n                    return Some(timestamp);\n                }\n            }\n        }\n\n        // Removed time element parsing - testing if needed\n\n        None\n    }\n\n    /// Extract album name from scrobble row elements\n    fn extract_scrobble_album(\u0026self, row: \u0026scraper::ElementRef) -\u003e Option\u003cString\u003e {\n        // Look for album_name in hidden inputs within edit forms\n        let album_input_selector =\n            Selector::parse(\"form[data-edit-scrobble] input[name='album_name']\").unwrap();\n\n        if let Some(album_input) = row.select(\u0026album_input_selector).next() {\n            if let Some(album_name) = album_input.value().attr(\"value\") {\n                if !album_name.is_empty() {\n                    return Some(album_name.to_string());\n                }\n            }\n        }\n\n        None\n    }\n\n    /// Extract album artist name from scrobble row elements\n    fn extract_scrobble_album_artist(\u0026self, row: \u0026scraper::ElementRef) -\u003e Option\u003cString\u003e {\n        // Look for album_artist_name in hidden inputs within edit forms\n        let album_artist_input_selector =\n            Selector::parse(\"form[data-edit-scrobble] input[name='album_artist_name']\").unwrap();\n\n        if let Some(album_artist_input) = row.select(\u0026album_artist_input_selector).next() {\n            if let Some(album_artist_name) = album_artist_input.value().attr(\"value\") {\n                if !album_artist_name.is_empty() {\n                    return Some(album_artist_name.to_string());\n                }\n            }\n        }\n\n        None\n    }\n\n    /// Parse a tracks page into a `TrackPage` structure\n    pub fn parse_tracks_page(\n        \u0026self,\n        document: \u0026Html,\n        page_number: u32,\n        artist: \u0026str,\n        album: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cTrackPage\u003e {\n        let tracks = self.extract_tracks_from_document(document, artist, album)?;\n\n        // Check for pagination\n        let (has_next_page, total_pages) = self.parse_pagination(document, page_number)?;\n\n        Ok(TrackPage {\n            tracks,\n            page_number,\n            has_next_page,\n            total_pages,\n        })\n    }\n\n    /// Extract tracks from HTML document\n    pub fn extract_tracks_from_document(\n        \u0026self,\n        document: \u0026Html,\n        artist: \u0026str,\n        album: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        let mut tracks = Vec::new();\n        let mut seen_tracks = std::collections::HashSet::new();\n\n        log::debug!(\"Starting track extraction for artist: {artist}, album: {album:?}\");\n\n        // JSON parsing removed - was not implemented and always failed\n\n        // Parse track data from data-track-name attributes (AJAX response)\n        let track_selector = Selector::parse(\"[data-track-name]\").unwrap();\n        let track_elements: Vec\u003c_\u003e = document.select(\u0026track_selector).collect();\n        log::debug!(\n            \"Found {} elements with data-track-name\",\n            track_elements.len()\n        );\n\n        for element in track_elements {\n            let track_name = element.value().attr(\"data-track-name\").unwrap_or(\"\");\n            if track_name.is_empty() {\n                continue;\n            }\n            if seen_tracks.contains(track_name) {\n                continue;\n            }\n            seen_tracks.insert(track_name.to_string());\n\n            match self.find_playcount_for_track(document, track_name) {\n                Ok(playcount) =\u003e {\n                    let timestamp = self.find_timestamp_for_track(document, track_name);\n                    let track = Track {\n                        name: track_name.to_string(),\n                        artist: artist.to_string(),\n                        playcount,\n                        timestamp,\n                        album: album.map(|a| a.to_string()),\n                        album_artist: None, // Not available in aggregate track listings\n                    };\n                    tracks.push(track);\n                    log::debug!(\"Added track '{track_name}' with {playcount} plays\");\n                }\n                Err(e) =\u003e {\n                    log::debug!(\"FAILED to find playcount for track '{track_name}': {e}\");\n                }\n            }\n        }\n\n        // Always try fallback parsing from chartlist tables to catch tracks without data-track-name\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let tables: Vec\u003c_\u003e = document.select(\u0026table_selector).collect();\n\n        for table in tables {\n            let row_selector = Selector::parse(\"tbody tr\").unwrap();\n            let rows: Vec\u003c_\u003e = table.select(\u0026row_selector).collect();\n\n            for row in rows.iter() {\n                // Try to parse as track row\n                if let Ok(mut track) = self.parse_track_row(row) {\n                    track.artist = artist.to_string();\n                    if let Some(album_name) = album {\n                        track.album = Some(album_name.to_string());\n                    }\n\n                    // Only add if we don't already have this track\n                    if !seen_tracks.contains(\u0026track.name) {\n                        seen_tracks.insert(track.name.clone());\n                        tracks.push(track);\n                    }\n                }\n            }\n        }\n\n        log::debug!(\"Successfully extracted {} unique tracks\", tracks.len());\n        Ok(tracks)\n    }\n\n    // Removed parse_tracks_from_rows - no longer needed\n\n    /// Parse a single track row from chartlist table\n    pub fn parse_track_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cTrack\u003e {\n        // Extract track name using shared method\n        let name = self.extract_name_from_row(row, \"track\")?;\n\n        // Parse play count using shared method\n        let playcount = self.extract_playcount_from_row(row);\n\n        let artist = \"\".to_string(); // Will be filled in by caller\n\n        Ok(Track {\n            name,\n            artist,\n            playcount,\n            timestamp: None,    // Not available in table parsing mode\n            album: None,        // Not available in table parsing mode\n            album_artist: None, // Not available in table parsing mode\n        })\n    }\n\n    /// Parse albums page into `AlbumPage` structure\n    pub fn parse_albums_page(\n        \u0026self,\n        document: \u0026Html,\n        page_number: u32,\n        artist: \u0026str,\n    ) -\u003e Result\u003cAlbumPage\u003e {\n        let mut albums = Vec::new();\n\n        // Try parsing album data from data attributes (AJAX response)\n        let album_selector = Selector::parse(\"[data-album-name]\").unwrap();\n        let album_elements: Vec\u003c_\u003e = document.select(\u0026album_selector).collect();\n\n        if !album_elements.is_empty() {\n            log::debug!(\n                \"Found {} album elements with data-album-name\",\n                album_elements.len()\n            );\n\n            // Use a set to track unique albums\n            let mut seen_albums = std::collections::HashSet::new();\n\n            for element in album_elements {\n                let album_name = element.value().attr(\"data-album-name\").unwrap_or(\"\");\n                if !album_name.is_empty() \u0026\u0026 !seen_albums.contains(album_name) {\n                    seen_albums.insert(album_name.to_string());\n\n                    if let Ok(playcount) = self.find_playcount_for_album(document, album_name) {\n                        let timestamp = self.find_timestamp_for_album(document, album_name);\n                        let album = Album {\n                            name: album_name.to_string(),\n                            artist: artist.to_string(),\n                            playcount,\n                            timestamp,\n                        };\n                        albums.push(album);\n                    }\n                }\n            }\n        } else {\n            // Fall back to parsing album rows from chartlist tables\n            albums = self.parse_albums_from_rows(document, artist)?;\n        }\n\n        let (has_next_page, total_pages) = self.parse_pagination(document, page_number)?;\n\n        Ok(AlbumPage {\n            albums,\n            page_number,\n            has_next_page,\n            total_pages,\n        })\n    }\n\n    /// Parse albums from chartlist table rows\n    fn parse_albums_from_rows(\u0026self, document: \u0026Html, artist: \u0026str) -\u003e Result\u003cVec\u003cAlbum\u003e\u003e {\n        let mut albums = Vec::new();\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let row_selector = Selector::parse(\"tbody tr\").unwrap();\n\n        for table in document.select(\u0026table_selector) {\n            for row in table.select(\u0026row_selector) {\n                if let Ok(mut album) = self.parse_album_row(\u0026row) {\n                    album.artist = artist.to_string();\n                    albums.push(album);\n                }\n            }\n        }\n        Ok(albums)\n    }\n\n    /// Parse a single album row from chartlist table\n    pub fn parse_album_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cAlbum\u003e {\n        // Extract album name using shared method\n        let name = self.extract_name_from_row(row, \"album\")?;\n\n        // Parse play count using shared method\n        let playcount = self.extract_playcount_from_row(row);\n\n        let artist = \"\".to_string(); // Will be filled in by caller\n\n        Ok(Album {\n            name,\n            artist,\n            playcount,\n            timestamp: None, // Not available in table parsing\n        })\n    }\n\n    // === SEARCH RESULTS PARSING ===\n\n    /// Parse track search results from AJAX response\n    ///\n    /// This parses the HTML returned by `/user/{username}/library/tracks/search?ajax=1\u0026query={query}`\n    /// which contains chartlist tables with track results.\n    pub fn parse_track_search_results(\u0026self, document: \u0026Html) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        let mut tracks = Vec::new();\n\n        // Search results use the same chartlist structure as library pages\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let row_selector = Selector::parse(\"tbody tr\").unwrap();\n\n        let tables: Vec\u003c_\u003e = document.select(\u0026table_selector).collect();\n        log::debug!(\"Found {} chartlist tables in search results\", tables.len());\n\n        for table in tables {\n            for row in table.select(\u0026row_selector) {\n                if let Ok(track) = self.parse_search_track_row(\u0026row) {\n                    tracks.push(track);\n                }\n            }\n        }\n\n        log::debug!(\"Parsed {} tracks from search results\", tracks.len());\n        Ok(tracks)\n    }\n\n    /// Parse album search results from AJAX response\n    ///\n    /// This parses the HTML returned by `/user/{username}/library/albums/search?ajax=1\u0026query={query}`\n    /// which contains chartlist tables with album results.\n    pub fn parse_album_search_results(\u0026self, document: \u0026Html) -\u003e Result\u003cVec\u003cAlbum\u003e\u003e {\n        let mut albums = Vec::new();\n\n        // Search results use the same chartlist structure as library pages\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let row_selector = Selector::parse(\"tbody tr\").unwrap();\n\n        let tables: Vec\u003c_\u003e = document.select(\u0026table_selector).collect();\n        log::debug!(\n            \"Found {} chartlist tables in album search results\",\n            tables.len()\n        );\n\n        for table in tables {\n            for row in table.select(\u0026row_selector) {\n                if let Ok(album) = self.parse_search_album_row(\u0026row) {\n                    albums.push(album);\n                }\n            }\n        }\n\n        log::debug!(\"Parsed {} albums from search results\", albums.len());\n        Ok(albums)\n    }\n\n    /// Parse a single track row from search results\n    fn parse_search_track_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cTrack\u003e {\n        // Extract track name using the standard chartlist structure\n        let name = self.extract_name_from_row(row, \"track\")?;\n\n        // Extract artist name from chartlist-artist column\n        let artist_selector = Selector::parse(\".chartlist-artist a\").unwrap();\n        let artist = row\n            .select(\u0026artist_selector)\n            .next()\n            .map(|el| el.text().collect::\u003cString\u003e().trim().to_string())\n            .ok_or_else(|| {\n                LastFmError::Parse(\"Missing artist name in search results\".to_string())\n            })?;\n\n        // Extract playcount from the bar value\n        let playcount = self.extract_playcount_from_row(row);\n\n        // Search results typically don't have timestamps since they're aggregated\n        let timestamp = None;\n\n        // Try to extract album information if available in the search results\n        let album = self.extract_album_from_search_row(row);\n        let album_artist = self.extract_album_artist_from_search_row(row);\n\n        Ok(Track {\n            name,\n            artist,\n            playcount,\n            timestamp,\n            album,\n            album_artist,\n        })\n    }\n\n    /// Parse a single album row from search results\n    fn parse_search_album_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cAlbum\u003e {\n        // Extract album name using the standard chartlist structure\n        let name = self.extract_name_from_row(row, \"album\")?;\n\n        // Extract artist name from chartlist-artist column\n        let artist_selector = Selector::parse(\".chartlist-artist a\").unwrap();\n        let artist = row\n            .select(\u0026artist_selector)\n            .next()\n            .map(|el| el.text().collect::\u003cString\u003e().trim().to_string())\n            .ok_or_else(|| {\n                LastFmError::Parse(\"Missing artist name in album search results\".to_string())\n            })?;\n\n        // Extract playcount from the bar value\n        let playcount = self.extract_playcount_from_row(row);\n\n        Ok(Album {\n            name,\n            artist,\n            playcount,\n            timestamp: None, // Search results don't have timestamps\n        })\n    }\n\n    /// Extract album information from search track row\n    fn extract_album_from_search_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Option\u003cString\u003e {\n        // Look for album information in hidden form inputs (similar to recent scrobbles)\n        let album_input_selector = Selector::parse(\"input[name='album']\").unwrap();\n        if let Some(input) = row.select(\u0026album_input_selector).next() {\n            if let Some(value) = input.value().attr(\"value\") {\n                let album = value.trim().to_string();\n                if !album.is_empty() {\n                    return Some(album);\n                }\n            }\n        }\n        None\n    }\n\n    /// Extract album artist information from search track row\n    fn extract_album_artist_from_search_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Option\u003cString\u003e {\n        // Look for album artist information in hidden form inputs\n        let album_artist_input_selector = Selector::parse(\"input[name='album_artist']\").unwrap();\n        if let Some(input) = row.select(\u0026album_artist_input_selector).next() {\n            if let Some(value) = input.value().attr(\"value\") {\n                let album_artist = value.trim().to_string();\n                if !album_artist.is_empty() {\n                    return Some(album_artist);\n                }\n            }\n        }\n        None\n    }\n\n    // === SHARED PARSING UTILITIES ===\n\n    /// Extract name from chartlist row (works for both tracks and albums)\n    fn extract_name_from_row(\u0026self, row: \u0026scraper::ElementRef, item_type: \u0026str) -\u003e Result\u003cString\u003e {\n        let name_selector = Selector::parse(\".chartlist-name a\").unwrap();\n        let name = row\n            .select(\u0026name_selector)\n            .next()\n            .map(|el| el.text().collect::\u003cString\u003e().trim().to_string())\n            .ok_or_else(|| LastFmError::Parse(format!(\"Missing {item_type} name\")))?;\n        Ok(name)\n    }\n\n    /// Extract playcount from chartlist row (works for both tracks and albums)\n    fn extract_playcount_from_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e u32 {\n        let playcount_selector = Selector::parse(\".chartlist-count-bar-value\").unwrap();\n        let mut playcount = 1; // default fallback\n\n        if let Some(element) = row.select(\u0026playcount_selector).next() {\n            let text = element.text().collect::\u003cString\u003e().trim().to_string();\n            // Extract just the number part (before \"scrobbles\" if present)\n            if let Some(number_part) = text.split_whitespace().next() {\n                if let Ok(count) = number_part.parse::\u003cu32\u003e() {\n                    playcount = count;\n                }\n            }\n        }\n        playcount\n    }\n\n    /// Parse pagination information from document\n    pub fn parse_pagination(\n        \u0026self,\n        document: \u0026Html,\n        _current_page: u32,\n    ) -\u003e Result\u003c(bool, Option\u003cu32\u003e)\u003e {\n        let pagination_selector = Selector::parse(\".pagination-list\").unwrap();\n\n        if let Some(pagination) = document.select(\u0026pagination_selector).next() {\n            // Try multiple possible selectors for next page link\n            let next_selectors = [\n                \"a[aria-label=\\\"Next\\\"]\",\n                \".pagination-next a\",\n                \"a:contains(\\\"Next\\\")\",\n                \".next a\",\n            ];\n\n            let mut has_next = false;\n            for selector_str in \u0026next_selectors {\n                if let Ok(selector) = Selector::parse(selector_str) {\n                    if pagination.select(\u0026selector).next().is_some() {\n                        has_next = true;\n                        break;\n                    }\n                }\n            }\n\n            // Try to extract total pages from pagination text\n            let total_pages = self.extract_total_pages_from_pagination(\u0026pagination);\n\n            Ok((has_next, total_pages))\n        } else {\n            // No pagination found - single page\n            Ok((false, Some(1)))\n        }\n    }\n\n    /// Helper functions for pagination parsing\n    fn extract_total_pages_from_pagination(\u0026self, pagination: \u0026scraper::ElementRef) -\u003e Option\u003cu32\u003e {\n        // Look for patterns like \"Page 1 of 42\"\n        let text = pagination.text().collect::\u003cString\u003e();\n        if let Some(of_pos) = text.find(\" of \") {\n            let after_of = \u0026text[of_pos + 4..];\n            if let Some(number_end) = after_of.find(|c: char| !c.is_ascii_digit()) {\n                if let Ok(total) = after_of[..number_end].parse::\u003cu32\u003e() {\n                    return Some(total);\n                }\n            } else if let Ok(total) = after_of.trim().parse::\u003cu32\u003e() {\n                return Some(total);\n            }\n        }\n        None\n    }\n\n    // === JSON PARSING METHODS ===\n    // Removed unused JSON parsing method\n\n    // === FIND HELPER METHODS ===\n\n    pub fn find_timestamp_for_track(\u0026self, _document: \u0026Html, _track_name: \u0026str) -\u003e Option\u003cu64\u003e {\n        // Implementation would search for timestamp data\n        None\n    }\n\n    pub fn find_playcount_for_track(\u0026self, document: \u0026Html, track_name: \u0026str) -\u003e Result\u003cu32\u003e {\n        // Look for chartlist-count-bar-value elements near the track\n        let count_selector = Selector::parse(\".chartlist-count-bar-value\").unwrap();\n        let link_selector = Selector::parse(\"a[href*=\\\"/music/\\\"]\").unwrap();\n\n        // Find all track links that match our track name\n        for link in document.select(\u0026link_selector) {\n            let link_text = link.text().collect::\u003cString\u003e().trim().to_string();\n            if link_text == track_name {\n                if let Some(row) = self.find_ancestor_row(link) {\n                    if let Some(count_element) = row.select(\u0026count_selector).next() {\n                        let text = count_element.text().collect::\u003cString\u003e().trim().to_string();\n                        if let Some(number_part) = text.split_whitespace().next() {\n                            if let Ok(count) = number_part.parse::\u003cu32\u003e() {\n                                return Ok(count);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        Err(LastFmError::Parse(format!(\n            \"Could not find playcount for track: {track_name}\"\n        )))\n    }\n\n    pub fn find_timestamp_for_album(\u0026self, _document: \u0026Html, _album_name: \u0026str) -\u003e Option\u003cu64\u003e {\n        // Implementation would search for timestamp data\n        None\n    }\n\n    pub fn find_playcount_for_album(\u0026self, document: \u0026Html, album_name: \u0026str) -\u003e Result\u003cu32\u003e {\n        // Look for chartlist-count-bar-value elements near the album\n        let count_selector = Selector::parse(\".chartlist-count-bar-value\").unwrap();\n        let link_selector = Selector::parse(\"a[href*=\\\"/music/\\\"]\").unwrap();\n\n        // Find all album links that match our album name\n        for link in document.select(\u0026link_selector) {\n            let link_text = link.text().collect::\u003cString\u003e().trim().to_string();\n            if link_text == album_name {\n                if let Some(row) = self.find_ancestor_row(link) {\n                    if let Some(count_element) = row.select(\u0026count_selector).next() {\n                        let text = count_element.text().collect::\u003cString\u003e().trim().to_string();\n                        if let Some(number_part) = text.split_whitespace().next() {\n                            if let Ok(count) = number_part.parse::\u003cu32\u003e() {\n                                return Ok(count);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        Err(LastFmError::Parse(format!(\n            \"Could not find playcount for album: {album_name}\"\n        )))\n    }\n\n    pub fn find_ancestor_row\u003c'a\u003e(\n        \u0026self,\n        element: scraper::ElementRef\u003c'a\u003e,\n    ) -\u003e Option\u003cscraper::ElementRef\u003c'a\u003e\u003e {\n        let mut current = element;\n        while let Some(parent) = current.parent() {\n            if let Some(parent_elem) = scraper::ElementRef::wrap(parent) {\n                if parent_elem.value().name() == \"tr\" {\n                    return Some(parent_elem);\n                }\n                current = parent_elem;\n            } else {\n                break;\n            }\n        }\n        None\n    }\n\n    /// Parse artists page from user's library\n    pub fn parse_artists_page(\u0026self, document: \u0026Html, page_number: u32) -\u003e Result\u003cArtistPage\u003e {\n        let mut artists = Vec::new();\n\n        // Parse artists from chartlist table rows\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let row_selector = Selector::parse(\"tr.js-link-block\").unwrap();\n\n        let tables: Vec\u003c_\u003e = document.select(\u0026table_selector).collect();\n        log::debug!(\"Found {} chartlist tables for artists\", tables.len());\n\n        for table in tables {\n            for row in table.select(\u0026row_selector) {\n                if let Ok(artist) = self.parse_artist_row(\u0026row) {\n                    artists.push(artist);\n                }\n            }\n        }\n\n        log::debug!(\"Parsed {} artists from page {}\", artists.len(), page_number);\n\n        let (has_next_page, total_pages) = self.parse_pagination(document, page_number)?;\n\n        Ok(ArtistPage {\n            artists,\n            page_number,\n            has_next_page,\n            total_pages,\n        })\n    }\n\n    /// Parse a single artist row from the artist library table\n    fn parse_artist_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cArtist\u003e {\n        // Extract artist name from the name column\n        let name_selector = Selector::parse(\"td.chartlist-name a\").unwrap();\n        let name = row\n            .select(\u0026name_selector)\n            .next()\n            .ok_or(LastFmError::Parse(\"Missing artist name\".to_string()))?\n            .text()\n            .collect::\u003cString\u003e()\n            .trim()\n            .to_string();\n\n        // Extract playcount from the count bar\n        let count_selector = Selector::parse(\".chartlist-count-bar\").unwrap();\n        let playcount = if let Some(count_element) = row.select(\u0026count_selector).next() {\n            let count_text = count_element.text().collect::\u003cString\u003e();\n            self.extract_number_from_count_text(\u0026count_text)\n                .unwrap_or(0)\n        } else {\n            0\n        };\n\n        // Artists in library listings typically don't have individual timestamps\n        let timestamp = None;\n\n        Ok(Artist {\n            name,\n            playcount,\n            timestamp,\n        })\n    }\n\n    /// Extract numeric value from count text like \"3,395 scrobbles\"\n    fn extract_number_from_count_text(\u0026self, text: \u0026str) -\u003e Option\u003cu32\u003e {\n        // Remove commas and extract the first numeric part\n        let cleaned = text.replace(',', \"\");\n        cleaned.split_whitespace().next()?.parse::\u003cu32\u003e().ok()\n    }\n}\n\nimpl Default for LastFmParser {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[{"line":19,"address":[21056492,21056210],"length":1,"stats":{"Line":0}},{"line":20,"address":[21056654,21056640],"length":1,"stats":{"Line":0}},{"line":25,"address":[21062933],"length":1,"stats":{"Line":1}},{"line":26,"address":[5885719],"length":1,"stats":{"Line":1}},{"line":29,"address":[5717184,5717112],"length":1,"stats":{"Line":2}},{"line":30,"address":[5892375,5892300],"length":1,"stats":{"Line":2}},{"line":32,"address":[6283419,6283490],"length":1,"stats":{"Line":2}},{"line":33,"address":[5886117,5886204,5886280],"length":1,"stats":{"Line":3}},{"line":35,"address":[5717554,5717930,5718065],"length":1,"stats":{"Line":3}},{"line":36,"address":[6285666,6285062,6285186,6284189],"length":1,"stats":{"Line":4}},{"line":37,"address":[5719308,5719206,5719235],"length":1,"stats":{"Line":3}},{"line":38,"address":[5815964,5815876],"length":1,"stats":{"Line":2}},{"line":43,"address":[5814614],"length":1,"stats":{"Line":1}},{"line":44,"address":[18820476],"length":1,"stats":{"Line":0}},{"line":47,"address":[5893606,5893721,5893287],"length":1,"stats":{"Line":3}},{"line":48,"address":[5887204],"length":1,"stats":{"Line":1}},{"line":52,"address":[18820623],"length":1,"stats":{"Line":1}},{"line":54,"address":[3215948],"length":1,"stats":{"Line":1}},{"line":55,"address":[20907242,20907236,20906416],"length":1,"stats":{"Line":4}},{"line":58,"address":[6286198,6286028],"length":1,"stats":{"Line":1}},{"line":65,"address":[5720566],"length":1,"stats":{"Line":1}},{"line":66,"address":[6286784,6287280,6287054,6286927,6286713],"length":1,"stats":{"Line":4}},{"line":67,"address":[21058353,21058218],"length":1,"stats":{"Line":0}},{"line":69,"address":[6286852,6287022],"length":1,"stats":{"Line":1}},{"line":76,"address":[5817830],"length":1,"stats":{"Line":1}},{"line":79,"address":[5890134],"length":1,"stats":{"Line":1}},{"line":82,"address":[5721506],"length":1,"stats":{"Line":1}},{"line":85,"address":[5894801],"length":1,"stats":{"Line":1}},{"line":87,"address":[6287740],"length":1,"stats":{"Line":1}},{"line":88,"address":[20906947],"length":1,"stats":{"Line":1}},{"line":89,"address":[5721612],"length":1,"stats":{"Line":1}},{"line":92,"address":[18821514],"length":1,"stats":{"Line":1}},{"line":93,"address":[21378159,21378605],"length":1,"stats":{"Line":0}},{"line":98,"address":[3219663,3218304,3219669],"length":1,"stats":{"Line":1}},{"line":102,"address":[3218345],"length":1,"stats":{"Line":1}},{"line":103,"address":[3218436,3218555],"length":1,"stats":{"Line":0}},{"line":104,"address":[6288460],"length":1,"stats":{"Line":0}},{"line":109,"address":[5722288],"length":1,"stats":{"Line":1}},{"line":110,"address":[5897612,5897428,5897544],"length":1,"stats":{"Line":3}},{"line":111,"address":[5819032,5819083],"length":1,"stats":{"Line":2}},{"line":112,"address":[5722773],"length":1,"stats":{"Line":1}},{"line":113,"address":[5897904],"length":1,"stats":{"Line":1}},{"line":119,"address":[5722884],"length":1,"stats":{"Line":0}},{"line":121,"address":[5891691,5891620,5891759],"length":1,"stats":{"Line":0}},{"line":122,"address":[5819595,5819646],"length":1,"stats":{"Line":0}},{"line":123,"address":[5819766],"length":1,"stats":{"Line":0}},{"line":124,"address":[5819825],"length":1,"stats":{"Line":0}},{"line":131,"address":[3219616],"length":1,"stats":{"Line":0}},{"line":135,"address":[5723520,5724156,5724150],"length":1,"stats":{"Line":1}},{"line":137,"address":[5892214],"length":1,"stats":{"Line":1}},{"line":140,"address":[6289749,6289684,6289817],"length":1,"stats":{"Line":3}},{"line":141,"address":[6289928,6289877],"length":1,"stats":{"Line":2}},{"line":142,"address":[5892651],"length":1,"stats":{"Line":1}},{"line":143,"address":[5820461],"length":1,"stats":{"Line":1}},{"line":148,"address":[6290188],"length":1,"stats":{"Line":0}},{"line":152,"address":[5893462,5893468,5892832],"length":1,"stats":{"Line":1}},{"line":154,"address":[5820646],"length":1,"stats":{"Line":1}},{"line":157,"address":[5892932,5893065,5892997],"length":1,"stats":{"Line":3}},{"line":158,"address":[5893125,5893176],"length":1,"stats":{"Line":2}},{"line":159,"address":[3220823],"length":1,"stats":{"Line":1}},{"line":160,"address":[5899757],"length":1,"stats":{"Line":1}},{"line":165,"address":[5893436],"length":1,"stats":{"Line":0}},{"line":169,"address":[5822043,5821264,5822037],"length":1,"stats":{"Line":1}},{"line":176,"address":[5893622],"length":1,"stats":{"Line":1}},{"line":179,"address":[3221418,3221358],"length":1,"stats":{"Line":3}},{"line":181,"address":[6291546],"length":1,"stats":{"Line":2}},{"line":182,"address":[5725443],"length":1,"stats":{"Line":2}},{"line":190,"address":[3221792,3228117,3226201],"length":1,"stats":{"Line":1}},{"line":196,"address":[3221887],"length":1,"stats":{"Line":1}},{"line":197,"address":[5894456],"length":1,"stats":{"Line":1}},{"line":199,"address":[3222101,3222141,3222012],"length":1,"stats":{"Line":3}},{"line":204,"address":[3222107,3222464],"length":1,"stats":{"Line":2}},{"line":205,"address":[5822810,5822881],"length":1,"stats":{"Line":2}},{"line":206,"address":[5901806],"length":1,"stats":{"Line":0}},{"line":211,"address":[5727118,5726983,5726583],"length":1,"stats":{"Line":3}},{"line":212,"address":[5823610,5826841],"length":1,"stats":{"Line":2}},{"line":213,"address":[5730512],"length":1,"stats":{"Line":1}},{"line":216,"address":[6296617],"length":1,"stats":{"Line":1}},{"line":219,"address":[5730606],"length":1,"stats":{"Line":1}},{"line":221,"address":[3226712],"length":1,"stats":{"Line":1}},{"line":222,"address":[3226864],"length":1,"stats":{"Line":2}},{"line":223,"address":[5905926],"length":1,"stats":{"Line":2}},{"line":225,"address":[6296997],"length":1,"stats":{"Line":2}},{"line":226,"address":[5730968],"length":1,"stats":{"Line":2}},{"line":229,"address":[5873270,5873248],"length":1,"stats":{"Line":6}},{"line":232,"address":[5827741],"length":1,"stats":{"Line":1}},{"line":233,"address":[5827775],"length":1,"stats":{"Line":1}},{"line":235,"address":[5899403],"length":1,"stats":{"Line":0}},{"line":236,"address":[3227766,3227790,3226803],"length":1,"stats":{"Line":0}},{"line":242,"address":[5895883],"length":1,"stats":{"Line":1}},{"line":243,"address":[5896043,5895972],"length":1,"stats":{"Line":2}},{"line":245,"address":[5824008,5823846],"length":1,"stats":{"Line":2}},{"line":246,"address":[6294312,6293700],"length":1,"stats":{"Line":2}},{"line":247,"address":[6294441,6294362],"length":1,"stats":{"Line":2}},{"line":249,"address":[6296441,6294560,6294468],"length":1,"stats":{"Line":3}},{"line":251,"address":[6294760,6296114,6294820,6294893],"length":1,"stats":{"Line":6}},{"line":252,"address":[5897740,5897645,5897721],"length":1,"stats":{"Line":4}},{"line":253,"address":[5897876,5898185],"length":1,"stats":{"Line":4}},{"line":254,"address":[5825771,5825822,5825715],"length":1,"stats":{"Line":4}},{"line":258,"address":[5897958,5898197],"length":1,"stats":{"Line":4}},{"line":259,"address":[3225665,3225603],"length":1,"stats":{"Line":2}},{"line":260,"address":[6295684],"length":1,"stats":{"Line":1}},{"line":266,"address":[5902761,5902920],"length":1,"stats":{"Line":4}},{"line":267,"address":[5727755],"length":1,"stats":{"Line":1}},{"line":273,"address":[5900816,5901517,5901523],"length":1,"stats":{"Line":1}},{"line":275,"address":[6298267],"length":1,"stats":{"Line":1}},{"line":278,"address":[5907484,5907540],"length":1,"stats":{"Line":2}},{"line":280,"address":[5732475],"length":1,"stats":{"Line":1}},{"line":282,"address":[5907671],"length":1,"stats":{"Line":1}},{"line":283,"address":[5828944],"length":1,"stats":{"Line":1}},{"line":286,"address":[6298615],"length":1,"stats":{"Line":1}},{"line":287,"address":[6298627],"length":1,"stats":{"Line":1}},{"line":288,"address":[5732581],"length":1,"stats":{"Line":1}},{"line":293,"address":[6301003,6301884,6298944],"length":1,"stats":{"Line":1}},{"line":299,"address":[5732981],"length":1,"stats":{"Line":1}},{"line":302,"address":[3229090,3229018],"length":1,"stats":{"Line":2}},{"line":303,"address":[5901879,5901808],"length":1,"stats":{"Line":2}},{"line":305,"address":[5733329,5735259,5733258],"length":1,"stats":{"Line":3}},{"line":306,"address":[5908615],"length":1,"stats":{"Line":0}},{"line":312,"address":[5908515],"length":1,"stats":{"Line":0}},{"line":314,"address":[5830464,5830329,5830218],"length":1,"stats":{"Line":0}},{"line":315,"address":[6300268,6300156],"length":1,"stats":{"Line":0}},{"line":316,"address":[5902973],"length":1,"stats":{"Line":0}},{"line":317,"address":[5903055],"length":1,"stats":{"Line":0}},{"line":319,"address":[3230419,3230498],"length":1,"stats":{"Line":0}},{"line":320,"address":[6300648,6300733],"length":1,"stats":{"Line":0}},{"line":322,"address":[3230625],"length":1,"stats":{"Line":0}},{"line":323,"address":[5903392],"length":1,"stats":{"Line":0}},{"line":327,"address":[5734900],"length":1,"stats":{"Line":0}},{"line":333,"address":[3229404,3231626,3230881,3231028],"length":1,"stats":{"Line":2}},{"line":336,"address":[5910784,5910336,5909249],"length":1,"stats":{"Line":2}},{"line":338,"address":[3231435],"length":1,"stats":{"Line":1}},{"line":339,"address":[5831911],"length":1,"stats":{"Line":1}},{"line":347,"address":[5906233,5906093,5904512],"length":1,"stats":{"Line":1}},{"line":348,"address":[5910997],"length":1,"stats":{"Line":1}},{"line":349,"address":[6302043,6302112],"length":1,"stats":{"Line":2}},{"line":350,"address":[6302150,6302219],"length":1,"stats":{"Line":2}},{"line":352,"address":[5832823,5832699,5832634],"length":1,"stats":{"Line":3}},{"line":353,"address":[5736758,5736451,5736634,5737553],"length":1,"stats":{"Line":4}},{"line":354,"address":[5911944,5911895,5912027,5912473],"length":1,"stats":{"Line":4}},{"line":355,"address":[5905775,5905794,5905715],"length":1,"stats":{"Line":2}},{"line":356,"address":[5905914],"length":1,"stats":{"Line":1}},{"line":360,"address":[5736513],"length":1,"stats":{"Line":1}},{"line":364,"address":[5912688,5913263,5913257],"length":1,"stats":{"Line":1}},{"line":366,"address":[3233515],"length":1,"stats":{"Line":1}},{"line":369,"address":[5737868,5737924],"length":1,"stats":{"Line":2}},{"line":371,"address":[3233785],"length":1,"stats":{"Line":1}},{"line":373,"address":[5906675],"length":1,"stats":{"Line":1}},{"line":374,"address":[5834400],"length":1,"stats":{"Line":1}},{"line":377,"address":[3233861],"length":1,"stats":{"Line":1}},{"line":387,"address":[5915499,5915588,5913280],"length":1,"stats":{"Line":1}},{"line":388,"address":[3234107],"length":1,"stats":{"Line":1}},{"line":391,"address":[5906956,5907028],"length":1,"stats":{"Line":2}},{"line":392,"address":[5738491,5738416],"length":1,"stats":{"Line":2}},{"line":394,"address":[5738611,5738540],"length":1,"stats":{"Line":2}},{"line":395,"address":[5913718,5913805,5913881],"length":1,"stats":{"Line":3}},{"line":397,"address":[5913811,5914187,5914322],"length":1,"stats":{"Line":3}},{"line":398,"address":[5836301,5836425,5836902,5835742],"length":1,"stats":{"Line":4}},{"line":399,"address":[5740176,5740074,5740103],"length":1,"stats":{"Line":3}},{"line":400,"address":[3236208,3236124],"length":1,"stats":{"Line":2}},{"line":405,"address":[5908181,5908023],"length":1,"stats":{"Line":2}},{"line":406,"address":[5914496],"length":1,"stats":{"Line":1}},{"line":413,"address":[3238552,3238471,3236352],"length":1,"stats":{"Line":0}},{"line":414,"address":[5915675],"length":1,"stats":{"Line":0}},{"line":417,"address":[6306716,6306788],"length":1,"stats":{"Line":0}},{"line":418,"address":[6306907,6306832],"length":1,"stats":{"Line":0}},{"line":420,"address":[5915964,5916035],"length":1,"stats":{"Line":0}},{"line":421,"address":[5837662],"length":1,"stats":{"Line":0}},{"line":426,"address":[5916674,5916539,5916163],"length":1,"stats":{"Line":0}},{"line":427,"address":[5741662,5742774,5742345,5742221],"length":1,"stats":{"Line":0}},{"line":428,"address":[5838887,5838858,5838960],"length":1,"stats":{"Line":0}},{"line":429,"address":[5839048,5839136],"length":1,"stats":{"Line":0}},{"line":434,"address":[5910533,5910375],"length":1,"stats":{"Line":0}},{"line":435,"address":[6307840],"length":1,"stats":{"Line":0}},{"line":439,"address":[5912952,5912887,5911520],"length":1,"stats":{"Line":1}},{"line":441,"address":[3238635],"length":1,"stats":{"Line":1}},{"line":444,"address":[6309258,6309186],"length":1,"stats":{"Line":2}},{"line":445,"address":[3239238,3239120,3239036,3238965],"length":1,"stats":{"Line":3}},{"line":448,"address":[5704640,5704657],"length":1,"stats":{"Line":2}},{"line":449,"address":[5801296],"length":1,"stats":{"Line":0}},{"line":450,"address":[5704878],"length":1,"stats":{"Line":0}},{"line":454,"address":[5840126],"length":1,"stats":{"Line":1}},{"line":457,"address":[6309790],"length":1,"stats":{"Line":1}},{"line":460,"address":[5918818],"length":1,"stats":{"Line":1}},{"line":461,"address":[5912427],"length":1,"stats":{"Line":1}},{"line":463,"address":[6309993],"length":1,"stats":{"Line":1}},{"line":464,"address":[3239537],"length":1,"stats":{"Line":1}},{"line":465,"address":[5918937],"length":1,"stats":{"Line":1}},{"line":468,"address":[6309961],"length":1,"stats":{"Line":1}},{"line":474,"address":[3241147,3240032,3241212],"length":1,"stats":{"Line":0}},{"line":476,"address":[5840811],"length":1,"stats":{"Line":0}},{"line":479,"address":[5841026,5841098],"length":1,"stats":{"Line":0}},{"line":480,"address":[5913442,5913656,5913510,5913371],"length":1,"stats":{"Line":0}},{"line":483,"address":[3174337,3174320],"length":1,"stats":{"Line":0}},{"line":484,"address":[5705184],"length":1,"stats":{"Line":0}},{"line":485,"address":[5705198],"length":1,"stats":{"Line":0}},{"line":489,"address":[5841598],"length":1,"stats":{"Line":0}},{"line":491,"address":[5745271],"length":1,"stats":{"Line":0}},{"line":492,"address":[5913849],"length":1,"stats":{"Line":0}},{"line":493,"address":[5745227],"length":1,"stats":{"Line":0}},{"line":495,"address":[5920331],"length":1,"stats":{"Line":0}},{"line":500,"address":[5746278,5746315,5745568],"length":1,"stats":{"Line":1}},{"line":502,"address":[5920678],"length":1,"stats":{"Line":1}},{"line":503,"address":[3241409,3241344,3241477],"length":1,"stats":{"Line":3}},{"line":504,"address":[5920933,5920984],"length":1,"stats":{"Line":0}},{"line":505,"address":[5746034],"length":1,"stats":{"Line":0}},{"line":506,"address":[5746088,5746147],"length":1,"stats":{"Line":0}},{"line":507,"address":[5921230],"length":1,"stats":{"Line":0}},{"line":511,"address":[5914945],"length":1,"stats":{"Line":1}},{"line":515,"address":[6313147,6313110,6312400],"length":1,"stats":{"Line":1}},{"line":517,"address":[5746374],"length":1,"stats":{"Line":1}},{"line":518,"address":[6312565,6312633,6312500],"length":1,"stats":{"Line":3}},{"line":519,"address":[3242356,3242305],"length":1,"stats":{"Line":0}},{"line":520,"address":[3242478],"length":1,"stats":{"Line":0}},{"line":521,"address":[5915512,5915571],"length":1,"stats":{"Line":0}},{"line":522,"address":[5843358],"length":1,"stats":{"Line":0}},{"line":526,"address":[5922129],"length":1,"stats":{"Line":1}},{"line":532,"address":[5916438,5916400,5915760],"length":1,"stats":{"Line":1}},{"line":533,"address":[5747151],"length":1,"stats":{"Line":1}},{"line":534,"address":[5922418,5922350,5922559,5922285],"length":1,"stats":{"Line":4}},{"line":537,"address":[3174657,3174640],"length":1,"stats":{"Line":2}},{"line":538,"address":[5801936,5801957],"length":1,"stats":{"Line":5}},{"line":539,"address":[5916294],"length":1,"stats":{"Line":1}},{"line":543,"address":[6314704,6314744,6313872],"length":1,"stats":{"Line":1}},{"line":544,"address":[5922908],"length":1,"stats":{"Line":1}},{"line":545,"address":[5747898],"length":1,"stats":{"Line":1}},{"line":547,"address":[6314038,6314106,6313973],"length":1,"stats":{"Line":3}},{"line":548,"address":[5916758,5916807],"length":1,"stats":{"Line":2}},{"line":550,"address":[6314438],"length":1,"stats":{"Line":1}},{"line":551,"address":[5845070,5844962,5845005],"length":1,"stats":{"Line":3}},{"line":552,"address":[5917287],"length":1,"stats":{"Line":1}},{"line":556,"address":[5748646],"length":1,"stats":{"Line":1}},{"line":560,"address":[5918833,5917360,5918676],"length":1,"stats":{"Line":1}},{"line":565,"address":[5748754],"length":1,"stats":{"Line":1}},{"line":567,"address":[5917545,5917914,5917480,5917613],"length":1,"stats":{"Line":5}},{"line":569,"address":[5924093],"length":1,"stats":{"Line":1}},{"line":576,"address":[5749129],"length":1,"stats":{"Line":1}},{"line":577,"address":[6315201,6316149,6315337],"length":1,"stats":{"Line":3}},{"line":578,"address":[3245001,3245058,3245131],"length":1,"stats":{"Line":3}},{"line":579,"address":[5924599,5924678],"length":1,"stats":{"Line":2}},{"line":580,"address":[5924896],"length":1,"stats":{"Line":1}},{"line":587,"address":[5845844,5846356],"length":1,"stats":{"Line":2}},{"line":589,"address":[5846370],"length":1,"stats":{"Line":1}},{"line":592,"address":[6315235],"length":1,"stats":{"Line":2}},{"line":597,"address":[5926081,5926087,5925264],"length":1,"stats":{"Line":1}},{"line":599,"address":[6316279],"length":1,"stats":{"Line":1}},{"line":600,"address":[5846796,5846713],"length":1,"stats":{"Line":2}},{"line":601,"address":[3246065,3246116],"length":1,"stats":{"Line":0}},{"line":602,"address":[3246214],"length":1,"stats":{"Line":0}},{"line":603,"address":[5750689,5750754],"length":1,"stats":{"Line":0}},{"line":604,"address":[6316901],"length":1,"stats":{"Line":0}},{"line":606,"address":[6316945,6316791],"length":1,"stats":{"Line":0}},{"line":607,"address":[6317028],"length":1,"stats":{"Line":0}},{"line":610,"address":[3246081],"length":1,"stats":{"Line":1}},{"line":618,"address":[5847472],"length":1,"stats":{"Line":2}},{"line":620,"address":[5847492],"length":1,"stats":{"Line":2}},{"line":623,"address":[5751088,5753142,5753148],"length":1,"stats":{"Line":1}},{"line":625,"address":[6317220],"length":1,"stats":{"Line":1}},{"line":626,"address":[5919968,5919900],"length":1,"stats":{"Line":2}},{"line":629,"address":[5926504,5926628,5926433],"length":1,"stats":{"Line":3}},{"line":630,"address":[3247520,3247204],"length":1,"stats":{"Line":2}},{"line":631,"address":[3247731],"length":1,"stats":{"Line":1}},{"line":632,"address":[6318262],"length":1,"stats":{"Line":1}},{"line":633,"address":[5848855,5848749],"length":1,"stats":{"Line":2}},{"line":634,"address":[5752532,5752483],"length":1,"stats":{"Line":2}},{"line":635,"address":[5927827],"length":1,"stats":{"Line":2}},{"line":636,"address":[5927983,5928024],"length":1,"stats":{"Line":4}},{"line":637,"address":[5849450],"length":1,"stats":{"Line":2}},{"line":644,"address":[5848097],"length":1,"stats":{"Line":0}},{"line":649,"address":[6319232],"length":1,"stats":{"Line":0}},{"line":651,"address":[3248756],"length":1,"stats":{"Line":0}},{"line":654,"address":[5851708,5849648,5851702],"length":1,"stats":{"Line":0}},{"line":656,"address":[5753284],"length":1,"stats":{"Line":0}},{"line":657,"address":[5928512,5928444],"length":1,"stats":{"Line":0}},{"line":660,"address":[5922340,5922216,5922145],"length":1,"stats":{"Line":0}},{"line":661,"address":[5850476,5850176],"length":1,"stats":{"Line":0}},{"line":662,"address":[3249827],"length":1,"stats":{"Line":0}},{"line":663,"address":[5754326],"length":1,"stats":{"Line":0}},{"line":664,"address":[5754445,5754551],"length":1,"stats":{"Line":0}},{"line":665,"address":[3250224,3250159],"length":1,"stats":{"Line":0}},{"line":666,"address":[5851315],"length":1,"stats":{"Line":0}},{"line":667,"address":[5930111,5930152],"length":1,"stats":{"Line":0}},{"line":668,"address":[5851578],"length":1,"stats":{"Line":0}},{"line":675,"address":[3249349],"length":1,"stats":{"Line":0}},{"line":680,"address":[5930368],"length":1,"stats":{"Line":1}},{"line":684,"address":[3250856],"length":1,"stats":{"Line":1}},{"line":685,"address":[3251188,3250882],"length":1,"stats":{"Line":2}},{"line":686,"address":[6321589,6321490],"length":1,"stats":{"Line":2}},{"line":687,"address":[5755558],"length":1,"stats":{"Line":1}},{"line":688,"address":[5930733],"length":1,"stats":{"Line":1}},{"line":690,"address":[5924275],"length":1,"stats":{"Line":1}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[5933440,5930784,5933351],"length":1,"stats":{"Line":0}},{"line":700,"address":[5930837],"length":1,"stats":{"Line":0}},{"line":703,"address":[5852246,5852318],"length":1,"stats":{"Line":0}},{"line":704,"address":[5931002,5931077],"length":1,"stats":{"Line":0}},{"line":706,"address":[6322189,6322118],"length":1,"stats":{"Line":0}},{"line":707,"address":[5924979,5924903,5924816],"length":1,"stats":{"Line":0}},{"line":709,"address":[5853196,5853061,5852685],"length":1,"stats":{"Line":0}},{"line":710,"address":[5854357,5854233,5853256,5854754],"length":1,"stats":{"Line":0}},{"line":711,"address":[6324099,6324172,6324070],"length":1,"stats":{"Line":0}},{"line":712,"address":[3253727,3253643],"length":1,"stats":{"Line":0}},{"line":717,"address":[5756881,5756972],"length":1,"stats":{"Line":0}},{"line":719,"address":[5853375,5853750],"length":1,"stats":{"Line":0}},{"line":721,"address":[5926214],"length":1,"stats":{"Line":0}},{"line":722,"address":[6323582],"length":1,"stats":{"Line":0}},{"line":730,"address":[5928429,5928718,5927056],"length":1,"stats":{"Line":0}},{"line":732,"address":[5933515],"length":1,"stats":{"Line":0}},{"line":733,"address":[5933653,5933588,5933796,5934149,5933923],"length":1,"stats":{"Line":0}},{"line":736,"address":[5758819,5758649],"length":1,"stats":{"Line":0}},{"line":743,"address":[5759251],"length":1,"stats":{"Line":0}},{"line":744,"address":[5934640,5934542,5934403,5934474],"length":1,"stats":{"Line":0}},{"line":745,"address":[5934602,5934645],"length":1,"stats":{"Line":0}},{"line":746,"address":[3255128,3255052],"length":1,"stats":{"Line":0}},{"line":749,"address":[3255005],"length":1,"stats":{"Line":0}},{"line":753,"address":[5856216],"length":1,"stats":{"Line":0}},{"line":755,"address":[5856275],"length":1,"stats":{"Line":0}},{"line":756,"address":[3255240],"length":1,"stats":{"Line":0}},{"line":757,"address":[3255280],"length":1,"stats":{"Line":0}},{"line":763,"address":[3255520,3255976,3255982],"length":1,"stats":{"Line":0}},{"line":765,"address":[5928767],"length":1,"stats":{"Line":0}},{"line":766,"address":[3255663,3255955,3255587],"length":1,"stats":{"Line":0}},{"line":771,"address":[5760576],"length":1,"stats":{"Line":0}},{"line":772,"address":[5760577],"length":1,"stats":{"Line":0}}],"covered":206,"coverable":325},{"path":["/","home","imalison","Projects","lastfm-edit","src","retry.rs"],"content":"use crate::types::{LastFmError, RetryConfig, RetryResult};\nuse crate::Result;\nuse std::future::Future;\nuse std::time::{Instant, SystemTime, UNIX_EPOCH};\n\n/// Execute an async operation with retry logic for rate limiting\n///\n/// This function handles the common pattern of retrying operations that may fail\n/// due to rate limiting, with exponential backoff and configurable limits.\n///\n/// # Arguments\n/// * `config` - Retry configuration\n/// * `operation_name` - Name of the operation for logging\n/// * `operation` - Async function that returns a Result\n/// * `on_rate_limit` - Callback for rate limit events (delay in seconds, timestamp)\n/// * `on_rate_limit_end` - Optional callback for when rate limiting ends (total duration in seconds)\n///\n/// # Returns\n/// A `RetryResult` containing the successful result and retry statistics\npub async fn retry_with_backoff\u003cT, F, Fut, OnRateLimit, OnRateLimitEnd\u003e(\n    config: RetryConfig,\n    operation_name: \u0026str,\n    mut operation: F,\n    mut on_rate_limit: OnRateLimit,\n    mut on_rate_limit_end: OnRateLimitEnd,\n) -\u003e Result\u003cRetryResult\u003cT\u003e\u003e\nwhere\n    F: FnMut() -\u003e Fut,\n    Fut: Future\u003cOutput = Result\u003cT\u003e\u003e,\n    OnRateLimit: FnMut(u64, u64, \u0026str),\n    OnRateLimitEnd: FnMut(u64, \u0026str),\n{\n    let mut retries = 0;\n    let mut total_retry_time = 0;\n    let mut rate_limit_start_time: Option\u003cInstant\u003e = None;\n\n    loop {\n        match operation().await {\n            Ok(result) =\u003e {\n                // If we had rate limiting and now succeeded, emit rate limit end event\n                if let Some(start_time) = rate_limit_start_time {\n                    let total_duration = start_time.elapsed().as_secs();\n                    on_rate_limit_end(total_duration, operation_name);\n                }\n\n                return Ok(RetryResult {\n                    result,\n                    attempts_made: retries,\n                    total_retry_time,\n                });\n            }\n            Err(LastFmError::RateLimit { retry_after }) =\u003e {\n                // Track when rate limiting first occurs\n                if rate_limit_start_time.is_none() {\n                    rate_limit_start_time = Some(Instant::now());\n                }\n\n                if !config.enabled || retries \u003e= config.max_retries {\n                    if !config.enabled {\n                        log::debug!(\"Retries disabled for {operation_name} operation\");\n                    } else {\n                        log::warn!(\n                            \"Max retries ({}) exceeded for {operation_name} operation\",\n                            config.max_retries\n                        );\n                    }\n                    return Err(LastFmError::RateLimit { retry_after });\n                }\n\n                // Calculate delay with exponential backoff\n                let base_backoff = config.base_delay * 2_u64.pow(retries);\n                let delay = std::cmp::min(\n                    std::cmp::min(retry_after + base_backoff, config.max_delay),\n                    retry_after + (retries as u64 * 30), // Legacy backoff for compatibility\n                );\n\n                log::info!(\n                    \"{} rate limited. Waiting {} seconds before retry {} of {}\",\n                    operation_name,\n                    delay,\n                    retries + 1,\n                    config.max_retries\n                );\n\n                // Notify caller about rate limit\n                let timestamp = SystemTime::now()\n                    .duration_since(UNIX_EPOCH)\n                    .unwrap_or_default()\n                    .as_secs();\n                on_rate_limit(delay, timestamp, operation_name);\n\n                tokio::time::sleep(std::time::Duration::from_secs(delay)).await;\n                retries += 1;\n                total_retry_time += delay;\n            }\n            Err(other_error) =\u003e {\n                return Err(other_error);\n            }\n        }\n    }\n}\n\n/// Simplified retry function for operations that don't need custom rate limit handling\npub async fn retry_operation\u003cT, F, Fut\u003e(\n    config: RetryConfig,\n    operation_name: \u0026str,\n    operation: F,\n) -\u003e Result\u003cRetryResult\u003cT\u003e\u003e\nwhere\n    F: FnMut() -\u003e Fut,\n    Fut: Future\u003cOutput = Result\u003cT\u003e\u003e,\n{\n    retry_with_backoff(\n        config,\n        operation_name,\n        operation,\n        |delay, timestamp, op_name| {\n            log::debug!(\n                \"Rate limited during {op_name}: waiting {delay} seconds (at timestamp {timestamp})\"\n            );\n        },\n        |duration, op_name| {\n            log::debug!(\"Rate limiting ended for {op_name} after {duration} seconds\");\n        },\n    )\n    .await\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::sync::atomic::{AtomicU32, Ordering};\n    use std::sync::Arc;\n\n    #[tokio::test]\n    async fn test_successful_operation() {\n        let config = RetryConfig {\n            max_retries: 3,\n            base_delay: 1,\n            max_delay: 60,\n            enabled: true,\n        };\n\n        let result = retry_operation(config, \"test\", || async { Ok::\u003ci32, LastFmError\u003e(42) }).await;\n\n        assert!(result.is_ok());\n        let retry_result = result.unwrap();\n        assert_eq!(retry_result.result, 42);\n        assert_eq!(retry_result.attempts_made, 0);\n        assert_eq!(retry_result.total_retry_time, 0);\n    }\n\n    #[tokio::test]\n    async fn test_retry_on_rate_limit() {\n        let config = RetryConfig {\n            max_retries: 2,\n            base_delay: 1,\n            max_delay: 60,\n            enabled: true,\n        };\n\n        let call_count = Arc::new(AtomicU32::new(0));\n        let call_count_clone = call_count.clone();\n\n        let result = retry_operation(config, \"test\", move || {\n            let count = call_count_clone.fetch_add(1, Ordering::SeqCst);\n            async move {\n                if count \u003c 2 {\n                    Err(LastFmError::RateLimit { retry_after: 1 })\n                } else {\n                    Ok::\u003ci32, LastFmError\u003e(42)\n                }\n            }\n        })\n        .await;\n\n        assert!(result.is_ok());\n        let retry_result = result.unwrap();\n        assert_eq!(retry_result.result, 42);\n        assert_eq!(retry_result.attempts_made, 2);\n        assert!(retry_result.total_retry_time \u003e= 2); // At least 2 seconds of delay\n    }\n\n    #[tokio::test]\n    async fn test_max_retries_exceeded() {\n        let config = RetryConfig {\n            max_retries: 1,\n            base_delay: 1,\n            max_delay: 60,\n            enabled: true,\n        };\n\n        let result = retry_operation(config, \"test\", || async {\n            Err::\u003ci32, LastFmError\u003e(LastFmError::RateLimit { retry_after: 1 })\n        })\n        .await;\n\n        assert!(result.is_err());\n        match result.unwrap_err() {\n            LastFmError::RateLimit { .. } =\u003e {} // Expected\n            other =\u003e panic!(\"Expected rate limit error, got: {other:?}\"),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_retries_disabled() {\n        let config = RetryConfig::disabled();\n\n        let result = retry_operation(config, \"test\", || async {\n            Err::\u003ci32, LastFmError\u003e(LastFmError::RateLimit { retry_after: 1 })\n        })\n        .await;\n\n        assert!(result.is_err());\n        match result.unwrap_err() {\n            LastFmError::RateLimit { .. } =\u003e {} // Expected - should fail immediately\n            other =\u003e panic!(\"Expected rate limit error, got: {other:?}\"),\n        }\n    }\n}\n","traces":[{"line":20,"address":[2809744,2809344,2809968,2810048,2809904,2809408,2809600],"length":1,"stats":{"Line":6}},{"line":33,"address":[5992362,6001759,5997053],"length":1,"stats":{"Line":7}},{"line":34,"address":[5909871,5905180,5914577],"length":1,"stats":{"Line":7}},{"line":35,"address":[5830658,5825967,5835364],"length":1,"stats":{"Line":7}},{"line":37,"address":[6001811,5992414,5997108,5993063,6002475,5997759],"length":1,"stats":{"Line":10}},{"line":38,"address":[3096783,3125825,3126273,3128193,3097217,3097569,3095841],"length":1,"stats":{"Line":21}},{"line":39,"address":[2834338,2820663,2838974,2825159,2829696,2816167,2811597],"length":1,"stats":{"Line":5}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[5827152,5832049,5836863,5831860,5836610,5827341],"length":1,"stats":{"Line":4}},{"line":43,"address":[6000211,6004919,6009733],"length":1,"stats":{"Line":2}},{"line":46,"address":[5827225,5831933,5836717],"length":1,"stats":{"Line":4}},{"line":47,"address":[5915879],"length":1,"stats":{"Line":2}},{"line":48,"address":[5836673,5831904,5827196],"length":1,"stats":{"Line":4}},{"line":49,"address":[6003126,5993642,5998350],"length":1,"stats":{"Line":5}},{"line":52,"address":[6394797,6385269,6389981],"length":1,"stats":{"Line":4}},{"line":54,"address":[6385476,6390009,6385587,6395032,6390309,6385297,6394828,6390192,6395143],"length":1,"stats":{"Line":12}},{"line":55,"address":[2816848,2835030,2830377,2839770,2825840,2812306,2821344],"length":1,"stats":{"Line":4}},{"line":58,"address":[6000687,6000554,6005409,6010243,6005270,6010110],"length":1,"stats":{"Line":7}},{"line":59,"address":[2830465,2821432,2825928,2835118,2816936,2839858,2812400],"length":1,"stats":{"Line":2}},{"line":60,"address":[6005412,6000486,5995849,6005206,5995655,5995746,6005297,6000395,6000589],"length":1,"stats":{"Line":3}},{"line":62,"address":[5839253,5834005,5829694,5834437,5829265,5838816],"length":1,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[5838879,5829328,5834068],"length":1,"stats":{"Line":2}},{"line":71,"address":[2812456,2821602,2840034,2835294,2821482,2812579,2817106,2825978,2839914,2826098,2830515,2835174,2830635,2816986],"length":1,"stats":{"Line":3}},{"line":73,"address":[5828003,5828050,5837559,5832775,5837606,5832728],"length":1,"stats":{"Line":6}},{"line":74,"address":[2812663,2821830,2821683,2817187,2826326,2817334,2826179,2830716,2830863,2840262,2840115,2835522,2835375,2812810],"length":1,"stats":{"Line":3}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[5828853,5828347,5838405,5833587,5837903,5833075],"length":1,"stats":{"Line":6}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":3}},{"line":92,"address":[6008346,5998983,6011459,6003639,6003673,5998842,6008239,5998949,6008380,6003536,6006648,6001908],"length":1,"stats":{"Line":9}},{"line":93,"address":[5992836,5997527,5992935,5997626,6002237,6002336],"length":1,"stats":{"Line":3}},{"line":94,"address":[5835984,5826579,5826531,5835932,5826456,5831147,5831222,5831271,5835857],"length":1,"stats":{"Line":6}},{"line":96,"address":[],"length":0,"stats":{"Line":2}},{"line":97,"address":[5906888,5916432,5911604],"length":1,"stats":{"Line":2}},{"line":104,"address":[2842288,2842352,2842416,2842224],"length":1,"stats":{"Line":4}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[2845328,2846096,2844944,2845712],"length":1,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":4}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":14}}],"covered":39,"coverable":51},{"path":["/","home","imalison","Projects","lastfm-edit","src","session_persistence.rs"],"content":"use crate::types::{LastFmEditSession, LastFmError};\nuse crate::Result;\nuse std::fs;\nuse std::path::PathBuf;\n\n/// Configurable session manager for storing session data in XDG directories.\n///\n/// This struct allows customization of the application prefix for session storage.\n/// Sessions are stored per-user in the format:\n/// `~/.local/share/{app_name}/users/{username}/session.json`\n#[derive(Clone, Debug)]\npub struct SessionManager {\n    app_name: String,\n}\n\nimpl SessionManager {\n    /// Create a new session manager with a custom application name.\n    ///\n    /// # Arguments\n    /// * `app_name` - The application name to use as the directory prefix\n    pub fn new(app_name: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            app_name: app_name.into(),\n        }\n    }\n\n    /// Get the session file path for a given username using the configured app name.\n    ///\n    /// Returns a path like: `~/.local/share/{app_name}/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns the path where the session should be stored, or an error if\n    /// the XDG data directory cannot be determined.\n    pub fn get_session_path(\u0026self, username: \u0026str) -\u003e Result\u003cPathBuf\u003e {\n        let data_dir = dirs::data_dir()\n            .ok_or_else(|| LastFmError::Http(\"Cannot determine XDG data directory\".to_string()))?;\n\n        let session_dir = data_dir.join(\u0026self.app_name).join(\"users\").join(username);\n\n        Ok(session_dir.join(\"session.json\"))\n    }\n\n    /// Save a session to the XDG data directory.\n    ///\n    /// This creates the necessary directory structure and saves the session\n    /// as JSON to `~/.local/share/{app_name}/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `session` - The session to save\n    ///\n    /// # Returns\n    /// Returns Ok(()) on success, or an error if the save fails.\n    pub fn save_session(\u0026self, session: \u0026LastFmEditSession) -\u003e Result\u003c()\u003e {\n        let session_path = self.get_session_path(\u0026session.username)?;\n\n        // Create parent directories if they don't exist\n        if let Some(parent) = session_path.parent() {\n            fs::create_dir_all(parent).map_err(|e| {\n                LastFmError::Http(format!(\"Failed to create session directory: {e}\"))\n            })?;\n        }\n\n        // Serialize session to JSON\n        let session_json = session\n            .to_json()\n            .map_err(|e| LastFmError::Http(format!(\"Failed to serialize session: {e}\")))?;\n\n        // Write to file\n        fs::write(\u0026session_path, session_json)\n            .map_err(|e| LastFmError::Http(format!(\"Failed to write session file: {e}\")))?;\n\n        log::debug!(\"Session saved to: {}\", session_path.display());\n        Ok(())\n    }\n\n    /// Load a session from the XDG data directory.\n    ///\n    /// Attempts to load a session from `~/.local/share/{app_name}/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns the loaded session on success, or an error if the file doesn't exist\n    /// or cannot be parsed.\n    pub fn load_session(\u0026self, username: \u0026str) -\u003e Result\u003cLastFmEditSession\u003e {\n        let session_path = self.get_session_path(username)?;\n\n        if !session_path.exists() {\n            return Err(LastFmError::Http(format!(\n                \"No saved session found for user: {username}\"\n            )));\n        }\n\n        // Read and parse session file\n        let session_json = fs::read_to_string(\u0026session_path)\n            .map_err(|e| LastFmError::Http(format!(\"Failed to read session file: {e}\")))?;\n\n        let session = LastFmEditSession::from_json(\u0026session_json)\n            .map_err(|e| LastFmError::Http(format!(\"Failed to parse session JSON: {e}\")))?;\n\n        log::debug!(\"Session loaded from: {}\", session_path.display());\n        Ok(session)\n    }\n\n    /// Check if a saved session exists for the given username.\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns true if a session file exists, false otherwise.\n    pub fn session_exists(\u0026self, username: \u0026str) -\u003e bool {\n        match self.get_session_path(username) {\n            Ok(path) =\u003e path.exists(),\n            Err(_) =\u003e false,\n        }\n    }\n\n    /// Remove a saved session for the given username.\n    ///\n    /// This deletes the session file from the XDG data directory.\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns Ok(()) on success, or an error if the deletion fails.\n    pub fn remove_session(\u0026self, username: \u0026str) -\u003e Result\u003c()\u003e {\n        let session_path = self.get_session_path(username)?;\n\n        if session_path.exists() {\n            fs::remove_file(\u0026session_path)\n                .map_err(|e| LastFmError::Http(format!(\"Failed to remove session file: {e}\")))?;\n            log::debug!(\"Session removed from: {}\", session_path.display());\n        }\n\n        Ok(())\n    }\n\n    /// List all usernames that have saved sessions.\n    ///\n    /// Scans the XDG data directory for session files and returns the usernames.\n    ///\n    /// # Returns\n    /// Returns a vector of usernames that have saved sessions.\n    pub fn list_saved_users(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        let data_dir = dirs::data_dir()\n            .ok_or_else(|| LastFmError::Http(\"Cannot determine XDG data directory\".to_string()))?;\n\n        let users_dir = data_dir.join(\u0026self.app_name).join(\"users\");\n\n        if !users_dir.exists() {\n            return Ok(Vec::new());\n        }\n\n        let mut users = Vec::new();\n        let entries = fs::read_dir(\u0026users_dir)\n            .map_err(|e| LastFmError::Http(format!(\"Failed to read users directory: {e}\")))?;\n\n        for entry in entries {\n            let entry = entry\n                .map_err(|e| LastFmError::Http(format!(\"Failed to read directory entry: {e}\")))?;\n\n            if entry.file_type().map(|t| t.is_dir()).unwrap_or(false) {\n                let session_file = entry.path().join(\"session.json\");\n                if session_file.exists() {\n                    if let Some(username) = entry.file_name().to_str() {\n                        users.push(username.to_string());\n                    }\n                }\n            }\n        }\n\n        Ok(users)\n    }\n\n    /// Get the application name used by this session manager.\n    pub fn app_name(\u0026self) -\u003e \u0026str {\n        \u0026self.app_name\n    }\n}\n\n/// Session persistence utilities for managing session data in XDG directories.\n///\n/// This module provides functionality to save and load Last.fm session data\n/// using the XDG Base Directory Specification. Sessions are stored per-user\n/// in the format: `~/.local/share/lastfm-edit/users/{username}/session.json`\n///\n/// # Deprecated\n/// Use [`SessionManager`] instead for more flexibility and customization.\npub struct SessionPersistence;\n\nimpl SessionPersistence {\n    /// Get the default session manager for lastfm-edit.\n    fn default_manager() -\u003e SessionManager {\n        SessionManager::new(\"lastfm-edit\")\n    }\n\n    /// Get the session file path for a given username using XDG directories.\n    ///\n    /// Returns a path like: `~/.local/share/lastfm-edit/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns the path where the session should be stored, or an error if\n    /// the XDG data directory cannot be determined.\n    pub fn get_session_path(username: \u0026str) -\u003e Result\u003cPathBuf\u003e {\n        Self::default_manager().get_session_path(username)\n    }\n\n    /// Save a session to the XDG data directory.\n    ///\n    /// This creates the necessary directory structure and saves the session\n    /// as JSON to `~/.local/share/lastfm-edit/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `session` - The session to save\n    ///\n    /// # Returns\n    /// Returns Ok(()) on success, or an error if the save fails.\n    pub fn save_session(session: \u0026LastFmEditSession) -\u003e Result\u003c()\u003e {\n        Self::default_manager().save_session(session)\n    }\n\n    /// Load a session from the XDG data directory.\n    ///\n    /// Attempts to load a session from `~/.local/share/lastfm-edit/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns the loaded session on success, or an error if the file doesn't exist\n    /// or cannot be parsed.\n    pub fn load_session(username: \u0026str) -\u003e Result\u003cLastFmEditSession\u003e {\n        Self::default_manager().load_session(username)\n    }\n\n    /// Check if a saved session exists for the given username.\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns true if a session file exists, false otherwise.\n    pub fn session_exists(username: \u0026str) -\u003e bool {\n        Self::default_manager().session_exists(username)\n    }\n\n    /// Remove a saved session for the given username.\n    ///\n    /// This deletes the session file from the XDG data directory.\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns Ok(()) on success, or an error if the deletion fails.\n    pub fn remove_session(username: \u0026str) -\u003e Result\u003c()\u003e {\n        Self::default_manager().remove_session(username)\n    }\n\n    /// List all usernames that have saved sessions.\n    ///\n    /// Scans the XDG data directory for session files and returns the usernames.\n    ///\n    /// # Returns\n    /// Returns a vector of usernames that have saved sessions.\n    pub fn list_saved_users() -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        Self::default_manager().list_saved_users()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_session_path_generation() {\n        let path = SessionPersistence::get_session_path(\"testuser\").unwrap();\n        assert!(path\n            .to_string_lossy()\n            .contains(\"lastfm-edit/users/testuser/session.json\"));\n    }\n\n    #[test]\n    fn test_session_exists_nonexistent() {\n        let fake_username = format!(\"nonexistent_user_{}\", std::process::id());\n        assert!(!SessionPersistence::session_exists(\u0026fake_username));\n    }\n}\n","traces":[{"line":21,"address":[5789872],"length":1,"stats":{"Line":2}},{"line":23,"address":[5989095],"length":1,"stats":{"Line":2}},{"line":37,"address":[5780925,5780931,5780048],"length":1,"stats":{"Line":1}},{"line":38,"address":[6119475,6119320],"length":1,"stats":{"Line":1}},{"line":39,"address":[5967795],"length":1,"stats":{"Line":0}},{"line":41,"address":[6027096,6027023],"length":1,"stats":{"Line":4}},{"line":43,"address":[5968387],"length":1,"stats":{"Line":2}},{"line":56,"address":[6128179,6126480,6128187],"length":1,"stats":{"Line":0}},{"line":57,"address":[3576076],"length":1,"stats":{"Line":0}},{"line":60,"address":[3576347,3576418],"length":1,"stats":{"Line":0}},{"line":61,"address":[6120837,6120675,6120723],"length":1,"stats":{"Line":0}},{"line":62,"address":[5995735,5995670],"length":1,"stats":{"Line":0}},{"line":67,"address":[6127016,6128185,6127326,6127204],"length":1,"stats":{"Line":0}},{"line":69,"address":[5969358],"length":1,"stats":{"Line":0}},{"line":72,"address":[6028795,6029278,6028563,6028681],"length":1,"stats":{"Line":0}},{"line":73,"address":[5823366,5823344],"length":1,"stats":{"Line":0}},{"line":75,"address":[6121368,6121462],"length":1,"stats":{"Line":0}},{"line":76,"address":[6127748],"length":1,"stats":{"Line":0}},{"line":89,"address":[6130250,6128208,6130217],"length":1,"stats":{"Line":0}},{"line":90,"address":[5782713],"length":1,"stats":{"Line":0}},{"line":92,"address":[5782960,5783031],"length":1,"stats":{"Line":0}},{"line":93,"address":[6128588,6128645],"length":1,"stats":{"Line":0}},{"line":99,"address":[3579698,3578100,3578486,3578391],"length":1,"stats":{"Line":0}},{"line":100,"address":[6122657],"length":1,"stats":{"Line":0}},{"line":102,"address":[6030317,6030246,6030464],"length":1,"stats":{"Line":0}},{"line":103,"address":[5791110,5791088],"length":1,"stats":{"Line":0}},{"line":105,"address":[3579092,3579006,3579296],"length":1,"stats":{"Line":0}},{"line":106,"address":[6129654],"length":1,"stats":{"Line":0}},{"line":116,"address":[5784736,5785014,5785008],"length":1,"stats":{"Line":1}},{"line":117,"address":[5972367],"length":1,"stats":{"Line":1}},{"line":118,"address":[6130349],"length":1,"stats":{"Line":1}},{"line":119,"address":[3579794],"length":1,"stats":{"Line":0}},{"line":132,"address":[6032716,6031744,6032722],"length":1,"stats":{"Line":0}},{"line":133,"address":[5785113],"length":1,"stats":{"Line":0}},{"line":135,"address":[3580327,3580395],"length":1,"stats":{"Line":0}},{"line":136,"address":[6130991,6131128],"length":1,"stats":{"Line":0}},{"line":137,"address":[3580537],"length":1,"stats":{"Line":0}},{"line":138,"address":[5973221],"length":1,"stats":{"Line":0}},{"line":141,"address":[6032104],"length":1,"stats":{"Line":0}},{"line":150,"address":[5788561,5786064,5788463],"length":1,"stats":{"Line":0}},{"line":151,"address":[6131805,6131639],"length":1,"stats":{"Line":0}},{"line":152,"address":[3581179],"length":1,"stats":{"Line":0}},{"line":154,"address":[6033039,6033130],"length":1,"stats":{"Line":0}},{"line":156,"address":[5974265],"length":1,"stats":{"Line":0}},{"line":157,"address":[6125975,6125929],"length":1,"stats":{"Line":0}},{"line":160,"address":[3581705],"length":1,"stats":{"Line":0}},{"line":161,"address":[6127756,6126040,6126111,6126233],"length":1,"stats":{"Line":0}},{"line":162,"address":[6132521],"length":1,"stats":{"Line":0}},{"line":164,"address":[6126315,6126409,6126494],"length":1,"stats":{"Line":0}},{"line":165,"address":[6126831,6126733,6126556],"length":1,"stats":{"Line":0}},{"line":166,"address":[6133119],"length":1,"stats":{"Line":0}},{"line":168,"address":[6126956,6127027],"length":1,"stats":{"Line":0}},{"line":169,"address":[6133431],"length":1,"stats":{"Line":0}},{"line":170,"address":[5975704],"length":1,"stats":{"Line":0}},{"line":171,"address":[5788280,5788174],"length":1,"stats":{"Line":0}},{"line":172,"address":[3583323,3583364],"length":1,"stats":{"Line":0}},{"line":178,"address":[6034069],"length":1,"stats":{"Line":0}},{"line":182,"address":[6035248],"length":1,"stats":{"Line":0}},{"line":183,"address":[6035253],"length":1,"stats":{"Line":0}},{"line":199,"address":[6134128],"length":1,"stats":{"Line":2}},{"line":200,"address":[5788600],"length":1,"stats":{"Line":2}},{"line":213,"address":[6035296,6035429,6035435],"length":1,"stats":{"Line":1}},{"line":214,"address":[5788668],"length":1,"stats":{"Line":1}},{"line":227,"address":[5788908,5788784,5788902],"length":1,"stats":{"Line":0}},{"line":228,"address":[6035490],"length":1,"stats":{"Line":0}},{"line":241,"address":[5789067,5788928,5789061],"length":1,"stats":{"Line":0}},{"line":242,"address":[5788972],"length":1,"stats":{"Line":0}},{"line":252,"address":[5976815,5976688,5976809],"length":1,"stats":{"Line":1}},{"line":253,"address":[5976721],"length":1,"stats":{"Line":1}},{"line":265,"address":[5976965,5976832,5976971],"length":1,"stats":{"Line":0}},{"line":266,"address":[6134812],"length":1,"stats":{"Line":0}},{"line":275,"address":[5977101,5977095,5976992],"length":1,"stats":{"Line":0}},{"line":276,"address":[5977016],"length":1,"stats":{"Line":0}}],"covered":15,"coverable":73},{"path":["/","home","imalison","Projects","lastfm-edit","src","trait.rs"],"content":"use crate::iterator::AsyncPaginatedIterator;\nuse crate::types::{\n    Album, Artist, ArtistPage, ClientEvent, ClientEventReceiver, EditResponse, ExactScrobbleEdit,\n    LastFmEditSession, LastFmError, ScrobbleEdit, Track,\n};\nuse crate::Result;\nuse async_trait::async_trait;\n\n/// Trait for Last.fm client operations that can be mocked for testing.\n///\n/// This trait abstracts the core functionality needed for Last.fm scrobble editing\n/// to enable easy mocking and testing. All methods that perform network operations or\n/// state changes are included to support comprehensive test coverage.\n///\n/// # Mocking Support\n///\n/// When the `mock` feature is enabled, this crate provides `MockLastFmEditClient`\n/// that implements this trait using the `mockall` library.\n///\n#[cfg_attr(feature = \"mock\", mockall::automock)]\n#[async_trait(?Send)]\npub trait LastFmEditClient {\n    // =============================================================================\n    // CORE EDITING METHODS - Most important functionality\n    // =============================================================================\n\n    /// Edit scrobbles by discovering and updating all matching instances.\n    ///\n    /// This is the main editing method that automatically discovers all scrobble instances\n    /// that match the provided criteria and applies the specified changes to each one.\n    ///\n    /// # How it works\n    ///\n    /// 1. **Discovery**: Analyzes the `ScrobbleEdit` to determine what to search for:\n    ///    - If `track_name_original` is specified: finds all album variations of that track\n    ///    - If only `album_name_original` is specified: finds all tracks in that album\n    ///    - If neither is specified: finds all tracks by that artist\n    ///\n    /// 2. **Enrichment**: For each discovered scrobble, extracts complete metadata\n    ///    including album artist information from the user's library\n    ///\n    /// 3. **Editing**: Applies the requested changes to each discovered instance\n    ///\n    /// # Arguments\n    ///\n    /// * `edit` - A `ScrobbleEdit` specifying what to find and how to change it\n    ///\n    /// # Returns\n    ///\n    /// Returns an `EditResponse` containing results for all edited scrobbles, including:\n    /// - Overall success status\n    /// - Individual results for each scrobble instance\n    /// - Detailed error messages if any edits fail\n    ///\n    /// # Errors\n    ///\n    /// Returns `LastFmError::Parse` if no matching scrobbles are found, or other errors\n    /// for network/authentication issues.\n    ///\n    /// # Example\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, ScrobbleEdit, Result};\n    /// # async fn example(client: \u0026dyn LastFmEditClient) -\u003e Result\u003c()\u003e {\n    /// // Change track name for all instances of a track\n    /// let edit = ScrobbleEdit::from_track_and_artist(\"Old Track Name\", \"Artist\")\n    ///     .with_track_name(\"New Track Name\");\n    ///\n    /// let response = client.edit_scrobble(\u0026edit).await?;\n    /// if response.success() {\n    ///     println!(\"Successfully edited {} scrobbles\", response.total_edits());\n    /// }\n    /// # Ok(())\n    /// # }\n    /// ```\n    async fn edit_scrobble(\u0026self, edit: \u0026ScrobbleEdit) -\u003e Result\u003cEditResponse\u003e;\n\n    /// Edit a single scrobble with complete information and retry logic.\n    ///\n    /// This method performs a single edit operation on a fully-specified scrobble.\n    /// Unlike [`edit_scrobble`], this method does not perform discovery, enrichment,\n    /// or multiple edits - it edits exactly one scrobble instance.\n    ///\n    /// # Key Differences from `edit_scrobble`\n    ///\n    /// - **No discovery**: Requires a fully-specified `ExactScrobbleEdit`\n    /// - **Single edit**: Only edits one scrobble instance\n    /// - **No enrichment**: All fields must be provided upfront\n    /// - **Retry logic**: Automatically retries on rate limiting\n    ///\n    /// # Arguments\n    ///\n    /// * `exact_edit` - A fully-specified edit with all required fields populated,\n    ///   including original metadata and timestamps\n    /// * `max_retries` - Maximum number of retry attempts for rate limiting.\n    ///   The method will wait with exponential backoff between retries.\n    ///\n    /// # Returns\n    ///\n    /// Returns an `EditResponse` with a single result indicating success or failure.\n    /// If max retries are exceeded due to rate limiting, returns a failed response\n    /// rather than an error.\n    ///\n    /// # Example\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, ExactScrobbleEdit, Result};\n    /// # async fn example(client: \u0026dyn LastFmEditClient) -\u003e Result\u003c()\u003e {\n    /// let exact_edit = ExactScrobbleEdit::new(\n    ///     \"Original Track\".to_string(),\n    ///     \"Original Album\".to_string(),\n    ///     \"Artist\".to_string(),\n    ///     \"Artist\".to_string(),\n    ///     \"New Track Name\".to_string(),\n    ///     \"Original Album\".to_string(),\n    ///     \"Artist\".to_string(),\n    ///     \"Artist\".to_string(),\n    ///     1640995200, // timestamp\n    ///     false\n    /// );\n    ///\n    /// let response = client.edit_scrobble_single(\u0026exact_edit, 3).await?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    async fn edit_scrobble_single(\n        \u0026self,\n        exact_edit: \u0026ExactScrobbleEdit,\n        max_retries: u32,\n    ) -\u003e Result\u003cEditResponse\u003e;\n\n    /// Delete a scrobble by its identifying information.\n    ///\n    /// This method deletes a specific scrobble from the user's library using the\n    /// artist name, track name, and timestamp to uniquely identify it.\n    ///\n    /// # Arguments\n    ///\n    /// * `artist_name` - The artist name of the scrobble to delete\n    /// * `track_name` - The track name of the scrobble to delete\n    /// * `timestamp` - The unix timestamp of the scrobble to delete\n    ///\n    /// # Returns\n    ///\n    /// Returns `true` if the deletion was successful, `false` otherwise.\n    async fn delete_scrobble(\n        \u0026self,\n        artist_name: \u0026str,\n        track_name: \u0026str,\n        timestamp: u64,\n    ) -\u003e Result\u003cbool\u003e;\n\n    /// Create an incremental discovery iterator for scrobble editing.\n    ///\n    /// This returns the appropriate discovery iterator based on what fields are specified\n    /// in the ScrobbleEdit. The iterator yields `ExactScrobbleEdit` results incrementally,\n    /// which helps avoid rate limiting issues when discovering many scrobbles.\n    ///\n    /// Returns a `Box\u003cdyn AsyncDiscoveryIterator\u003cExactScrobbleEdit\u003e\u003e` to handle the different\n    /// discovery strategies uniformly.\n    fn discover_scrobbles(\n        \u0026self,\n        edit: ScrobbleEdit,\n    ) -\u003e Box\u003cdyn crate::AsyncDiscoveryIterator\u003ccrate::ExactScrobbleEdit\u003e\u003e;\n\n    // =============================================================================\n    // ITERATOR METHODS - Core library browsing functionality\n    // =============================================================================\n\n    /// Create an iterator for browsing all artists in the user's library.\n    fn artists(\u0026self) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cArtist\u003e\u003e;\n\n    /// Create an iterator for browsing an artist's tracks from the user's library.\n    fn artist_tracks(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for browsing an artist's tracks directly using the paginated endpoint.\n    ///\n    /// This alternative approach uses\n    /// `/user/{username}/library/music/{artist}/+tracks` directly with\n    /// pagination, which is more efficient than the album-based approach since\n    /// it doesn't need to iterate through albums first. The downside of this\n    /// approach is that the tracks will not come with album information, which\n    /// will need to get looked up eventually in the process of making edits.\n    fn artist_tracks_direct(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for browsing an artist's albums from the user's library.\n    fn artist_albums(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cAlbum\u003e\u003e;\n\n    /// Create an iterator for browsing tracks from a specific album.\n    fn album_tracks(\n        \u0026self,\n        album_name: \u0026str,\n        artist_name: \u0026str,\n    ) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for browsing the user's recent tracks/scrobbles.\n    fn recent_tracks(\u0026self) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for browsing the user's recent tracks starting from a specific page.\n    fn recent_tracks_from_page(\u0026self, starting_page: u32)\n        -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for searching tracks in the user's library.\n    ///\n    /// This returns an iterator that uses Last.fm's library search functionality\n    /// to find tracks matching the provided query string. The iterator handles\n    /// pagination automatically.\n    ///\n    /// # Arguments\n    ///\n    /// * `query` - The search query (e.g., \"remaster\", \"live\", artist name, etc.)\n    ///\n    /// # Returns\n    ///\n    /// Returns a `SearchTracksIterator` for streaming search results.\n    fn search_tracks(\u0026self, query: \u0026str) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for searching albums in the user's library.\n    ///\n    /// This returns an iterator that uses Last.fm's library search functionality\n    /// to find albums matching the provided query string. The iterator handles\n    /// pagination automatically.\n    ///\n    /// # Arguments\n    ///\n    /// * `query` - The search query (e.g., \"remaster\", \"deluxe\", artist name, etc.)\n    ///\n    /// # Returns\n    ///\n    /// Returns a `SearchAlbumsIterator` for streaming search results.\n    fn search_albums(\u0026self, query: \u0026str) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cAlbum\u003e\u003e;\n\n    // =============================================================================\n    // SEARCH METHODS - Library search functionality\n    // =============================================================================\n\n    /// Get a single page of track search results from the user's library.\n    ///\n    /// This performs a search using Last.fm's library search functionality,\n    /// returning one page of tracks that match the provided query string.\n    /// For iterator-based access, use [`search_tracks`](Self::search_tracks) instead.\n    ///\n    /// # Arguments\n    ///\n    /// * `query` - The search query (e.g., \"remaster\", \"live\", artist name, etc.)\n    /// * `page` - The page number to retrieve (1-based)\n    ///\n    /// # Returns\n    ///\n    /// Returns a `TrackPage` containing the search results with pagination information.\n    async fn search_tracks_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003ccrate::TrackPage\u003e;\n\n    /// Get a single page of album search results from the user's library.\n    ///\n    /// This performs a search using Last.fm's library search functionality,\n    /// returning one page of albums that match the provided query string.\n    /// For iterator-based access, use [`search_albums`](Self::search_albums) instead.\n    ///\n    /// # Arguments\n    ///\n    /// * `query` - The search query (e.g., \"remaster\", \"deluxe\", artist name, etc.)\n    /// * `page` - The page number to retrieve (1-based)\n    ///\n    /// # Returns\n    ///\n    /// Returns an `AlbumPage` containing the search results with pagination information.\n    async fn search_albums_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003ccrate::AlbumPage\u003e;\n\n    // =============================================================================\n    // CORE DATA METHODS - Essential data access\n    // =============================================================================\n\n    /// Get the currently authenticated username.\n    fn username(\u0026self) -\u003e String;\n\n    /// Fetch recent scrobbles from the user's listening history.\n    async fn get_recent_scrobbles(\u0026self, page: u32) -\u003e Result\u003cVec\u003cTrack\u003e\u003e;\n\n    /// Find the most recent scrobble for a specific track.\n    async fn find_recent_scrobble_for_track(\n        \u0026self,\n        track_name: \u0026str,\n        artist_name: \u0026str,\n        max_pages: u32,\n    ) -\u003e Result\u003cOption\u003cTrack\u003e\u003e;\n\n    /// Get a page of artists from the user's library.\n    async fn get_artists_page(\u0026self, page: u32) -\u003e Result\u003cArtistPage\u003e;\n\n    /// Get a page of tracks from the user's library for the specified artist.\n    async fn get_artist_tracks_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003ccrate::TrackPage\u003e;\n\n    /// Get a page of albums from the user's library for the specified artist.\n    async fn get_artist_albums_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003ccrate::AlbumPage\u003e;\n\n    /// Get a page of tracks from a specific album in the user's library.\n    async fn get_album_tracks_page(\n        \u0026self,\n        album_name: \u0026str,\n        artist_name: \u0026str,\n        page: u32,\n    ) -\u003e Result\u003ccrate::TrackPage\u003e;\n\n    /// Get a page of tracks from the user's recent listening history.\n    async fn get_recent_tracks_page(\u0026self, page: u32) -\u003e Result\u003ccrate::TrackPage\u003e {\n        let tracks = self.get_recent_scrobbles(page).await?;\n        let has_next_page = !tracks.is_empty();\n        Ok(crate::TrackPage {\n            tracks,\n            page_number: page,\n            has_next_page,\n            total_pages: None,\n        })\n    }\n\n    // =============================================================================\n    // CONVENIENCE METHODS - Higher-level helpers and shortcuts\n    // =============================================================================\n\n    /// Discover all scrobble edit variations based on the provided ScrobbleEdit template.\n    ///\n    /// This method analyzes what fields are specified in the input ScrobbleEdit and discovers\n    /// all relevant scrobble instances that match the criteria:\n    /// - If track_name_original is specified: discovers all album variations of that track\n    /// - If only album_name_original is specified: discovers all tracks in that album\n    /// - If neither is specified: discovers all tracks by that artist\n    ///\n    /// Returns fully-specified ExactScrobbleEdit instances with all metadata populated\n    /// from the user's library, ready for editing operations.\n    async fn discover_scrobble_edit_variations(\n        \u0026self,\n        edit: \u0026ScrobbleEdit,\n    ) -\u003e Result\u003cVec\u003cExactScrobbleEdit\u003e\u003e {\n        // Use the incremental iterator and collect all results\n        let mut discovery_iterator = self.discover_scrobbles(edit.clone());\n        discovery_iterator.collect_all().await\n    }\n\n    /// Get tracks from a specific album page.\n    async fn get_album_tracks(\u0026self, album_name: \u0026str, artist_name: \u0026str) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        let mut tracks_iterator = self.album_tracks(album_name, artist_name);\n        tracks_iterator.collect_all().await\n    }\n\n    /// Find a scrobble by its timestamp in recent scrobbles.\n    async fn find_scrobble_by_timestamp(\u0026self, timestamp: u64) -\u003e Result\u003cTrack\u003e {\n        log::debug!(\"Searching for scrobble with timestamp {timestamp}\");\n\n        // Search through recent scrobbles to find the one with matching timestamp\n        for page in 1..=10 {\n            // Search up to 10 pages of recent scrobbles\n            let scrobbles = self.get_recent_scrobbles(page).await?;\n\n            for scrobble in scrobbles {\n                if let Some(scrobble_timestamp) = scrobble.timestamp {\n                    if scrobble_timestamp == timestamp {\n                        log::debug!(\n                            \"Found scrobble: '{}' by '{}' with album: '{:?}', album_artist: '{:?}'\",\n                            scrobble.name,\n                            scrobble.artist,\n                            scrobble.album,\n                            scrobble.album_artist\n                        );\n                        return Ok(scrobble);\n                    }\n                }\n            }\n        }\n\n        Err(LastFmError::Parse(format!(\n            \"Could not find scrobble with timestamp {timestamp}\"\n        )))\n    }\n\n    /// Edit album metadata by updating scrobbles with new album name.\n    async fn edit_album(\n        \u0026self,\n        old_album_name: \u0026str,\n        new_album_name: \u0026str,\n        artist_name: \u0026str,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        log::debug!(\"Editing album '{old_album_name}' -\u003e '{new_album_name}' by '{artist_name}'\");\n\n        let edit = ScrobbleEdit::for_album(old_album_name, artist_name, artist_name)\n            .with_album_name(new_album_name);\n\n        self.edit_scrobble(\u0026edit).await\n    }\n\n    /// Edit artist metadata by updating scrobbles with new artist name.\n    ///\n    /// This edits ALL tracks from the artist that are found in recent scrobbles.\n    async fn edit_artist(\n        \u0026self,\n        old_artist_name: \u0026str,\n        new_artist_name: \u0026str,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        log::debug!(\"Editing artist '{old_artist_name}' -\u003e '{new_artist_name}'\");\n\n        let edit = ScrobbleEdit::for_artist(old_artist_name, new_artist_name);\n\n        self.edit_scrobble(\u0026edit).await\n    }\n\n    /// Edit artist metadata for a specific track only.\n    ///\n    /// This edits only the specified track if found in recent scrobbles.\n    async fn edit_artist_for_track(\n        \u0026self,\n        track_name: \u0026str,\n        old_artist_name: \u0026str,\n        new_artist_name: \u0026str,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        log::debug!(\"Editing artist for track '{track_name}' from '{old_artist_name}' -\u003e '{new_artist_name}'\");\n\n        let edit = ScrobbleEdit::from_track_and_artist(track_name, old_artist_name)\n            .with_artist_name(new_artist_name);\n\n        self.edit_scrobble(\u0026edit).await\n    }\n\n    /// Edit artist metadata for all tracks in a specific album.\n    ///\n    /// This edits ALL tracks from the specified album that are found in recent scrobbles.\n    async fn edit_artist_for_album(\n        \u0026self,\n        album_name: \u0026str,\n        old_artist_name: \u0026str,\n        new_artist_name: \u0026str,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        log::debug!(\"Editing artist for album '{album_name}' from '{old_artist_name}' -\u003e '{new_artist_name}'\");\n\n        let edit = ScrobbleEdit::for_album(album_name, old_artist_name, old_artist_name)\n            .with_artist_name(new_artist_name);\n\n        self.edit_scrobble(\u0026edit).await\n    }\n\n    // =============================================================================\n    // SESSION \u0026 EVENT MANAGEMENT - Authentication and monitoring\n    // =============================================================================\n\n    /// Extract the current session state for persistence.\n    ///\n    /// This allows you to save the authentication state and restore it later\n    /// without requiring the user to log in again.\n    ///\n    /// # Returns\n    ///\n    /// Returns a [`LastFmEditSession`] that can be serialized and saved.\n    fn get_session(\u0026self) -\u003e LastFmEditSession;\n\n    /// Restore session state from a previously saved session.\n    ///\n    /// This allows you to restore authentication state without logging in again.\n    ///\n    /// # Arguments\n    ///\n    /// * `session` - Previously saved session state\n    fn restore_session(\u0026self, session: LastFmEditSession);\n\n    /// Subscribe to internal client events.\n    ///\n    /// Returns a broadcast receiver that can be used to listen to events like rate limiting.\n    /// Multiple subscribers can listen simultaneously.\n    ///\n    /// # Example\n    /// ```rust,no_run\n    /// use lastfm_edit::{LastFmEditClientImpl, LastFmEditSession, ClientEvent};\n    ///\n    /// let http_client = http_client::native::NativeClient::new();\n    /// let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let client = LastFmEditClientImpl::from_session(Box::new(http_client), test_session);\n    /// let mut events = client.subscribe();\n    ///\n    /// // Listen for events in a background task\n    /// tokio::spawn(async move {\n    ///     while let Ok(event) = events.recv().await {\n    ///         match event {\n    ///             ClientEvent::RequestStarted { request } =\u003e {\n    ///                 println!(\"Request started: {}\", request.short_description());\n    ///             }\n    ///             ClientEvent::RequestCompleted { request, status_code, duration_ms } =\u003e {\n    ///                 println!(\"Request completed: {} - {} ({} ms)\", request.short_description(), status_code, duration_ms);\n    ///             }\n    ///             ClientEvent::RateLimited { delay_seconds, .. } =\u003e {\n    ///                 println!(\"Rate limited! Waiting {} seconds\", delay_seconds);\n    ///             }\n    ///             ClientEvent::RateLimitEnded { total_rate_limit_duration_seconds, .. } =\u003e {\n    ///                 println!(\"Rate limiting ended after {} seconds\", total_rate_limit_duration_seconds);\n    ///             }\n    ///             ClientEvent::EditAttempted { edit, success, .. } =\u003e {\n    ///                 println!(\"Edit attempt: '{}' -\u003e '{}' - {}\",\n    ///                          edit.track_name_original, edit.track_name,\n    ///                          if success { \"Success\" } else { \"Failed\" });\n    ///             }\n    ///         }\n    ///     }\n    /// });\n    /// ```\n    fn subscribe(\u0026self) -\u003e ClientEventReceiver;\n\n    /// Get the latest client event without subscribing to future events.\n    ///\n    /// This returns the most recent event that occurred, or `None` if no events have occurred yet.\n    /// Unlike `subscribe()`, this provides instant access to the current state without waiting.\n    ///\n    /// # Example\n    /// ```rust,no_run\n    /// use lastfm_edit::{LastFmEditClientImpl, LastFmEditSession, ClientEvent};\n    ///\n    /// let http_client = http_client::native::NativeClient::new();\n    /// let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let client = LastFmEditClientImpl::from_session(Box::new(http_client), test_session);\n    ///\n    /// if let Some(ClientEvent::RateLimited { delay_seconds, .. }) = client.latest_event() {\n    ///     println!(\"Currently rate limited for {} seconds\", delay_seconds);\n    /// }\n    /// ```\n    fn latest_event(\u0026self) -\u003e Option\u003cClientEvent\u003e;\n\n    /// Validate if the current session is still working.\n    ///\n    /// This method makes a test request to a protected Last.fm settings page to verify\n    /// that the current session is still valid. If the session has expired or become\n    /// invalid, Last.fm will redirect to the login page.\n    ///\n    /// This is useful for checking session validity before attempting operations that\n    /// require authentication, especially after loading a previously saved session.\n    ///\n    /// # Returns\n    ///\n    /// Returns `true` if the session is valid and can be used for authenticated operations,\n    /// `false` if the session is invalid or expired.\n    async fn validate_session(\u0026self) -\u003e bool;\n}\n","traces":[{"line":305,"address":[5984576,5984620,5984755,5984424,5984323,5984288,5985467],"length":1,"stats":{"Line":0}},{"line":306,"address":[6079281,6078589,6078259,6078455],"length":1,"stats":{"Line":0}},{"line":307,"address":[5921045,5920974],"length":1,"stats":{"Line":0}},{"line":308,"address":[2796986],"length":1,"stats":{"Line":0}},{"line":309,"address":[2796919],"length":1,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[2796975],"length":1,"stats":{"Line":0}},{"line":335,"address":[6405790],"length":1,"stats":{"Line":1}},{"line":336,"address":[5583252],"length":1,"stats":{"Line":2}},{"line":340,"address":[6406400,6406822,6407066,6406435,6406524,6406778],"length":1,"stats":{"Line":0}},{"line":341,"address":[2798610],"length":1,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[5696926],"length":1,"stats":{"Line":0}},{"line":347,"address":[5923768,5923852],"length":1,"stats":{"Line":0}},{"line":350,"address":[6075436,6076664,6075738],"length":1,"stats":{"Line":0}},{"line":352,"address":[5504836],"length":1,"stats":{"Line":0}},{"line":354,"address":[5924701,5924944,5924809],"length":1,"stats":{"Line":0}},{"line":355,"address":[6077116,6076614],"length":1,"stats":{"Line":0}},{"line":356,"address":[2801248],"length":1,"stats":{"Line":0}},{"line":357,"address":[6077546,6077258,6077168],"length":1,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[6409700],"length":1,"stats":{"Line":0}},{"line":370,"address":[2800876],"length":1,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[5926851,5926955],"length":1,"stats":{"Line":0}},{"line":384,"address":[2802595,2803011],"length":1,"stats":{"Line":0}},{"line":385,"address":[6078926],"length":1,"stats":{"Line":0}},{"line":387,"address":[5579127],"length":1,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[5928407],"length":1,"stats":{"Line":0}},{"line":402,"address":[6412810,6412096,6413005,6412895],"length":1,"stats":{"Line":0}},{"line":414,"address":[6413811,6413906],"length":1,"stats":{"Line":0}},{"line":416,"address":[6414274,6413863],"length":1,"stats":{"Line":0}},{"line":417,"address":[6414261],"length":1,"stats":{"Line":0}},{"line":419,"address":[6088254,6088449,6087456,6088339],"length":1,"stats":{"Line":0}},{"line":431,"address":[2806899,2806799],"length":1,"stats":{"Line":0}},{"line":433,"address":[6415771,6415351],"length":1,"stats":{"Line":0}},{"line":434,"address":[6089710],"length":1,"stats":{"Line":0}},{"line":436,"address":[5581799],"length":1,"stats":{"Line":0}}],"covered":2,"coverable":44},{"path":["/","home","imalison","Projects","lastfm-edit","src","types.rs"],"content":"//! Data types for Last.fm music metadata and operations.\n//!\n//! This module contains all the core data structures used throughout the crate,\n//! including track and album metadata, edit operations, error types, session state,\n//! configuration, and event handling.\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fmt;\nuse thiserror::Error;\nuse tokio::sync::{broadcast, watch};\n\n// ================================================================================================\n// TRACK AND ALBUM METADATA\n// ================================================================================================\n\n/// Represents a music track with associated metadata.\n///\n/// This structure contains track information as parsed from Last.fm pages,\n/// including play count and optional timestamp data for scrobbles.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]\npub struct Track {\n    /// The track name/title\n    pub name: String,\n    /// The artist name\n    pub artist: String,\n    /// Number of times this track has been played/scrobbled\n    pub playcount: u32,\n    /// Unix timestamp of when this track was scrobbled (if available)\n    ///\n    /// This field is populated when tracks are retrieved from recent scrobbles\n    /// or individual scrobble data, but may be `None` for aggregate track listings.\n    pub timestamp: Option\u003cu64\u003e,\n    /// The album name (if available)\n    ///\n    /// This field is populated when tracks are retrieved from recent scrobbles\n    /// where album information is available in the edit forms. May be `None`\n    /// for aggregate track listings or when album information is not available.\n    pub album: Option\u003cString\u003e,\n    /// The album artist name (if available and different from track artist)\n    ///\n    /// This field is populated when tracks are retrieved from recent scrobbles\n    /// where album artist information is available. May be `None` for tracks\n    /// where the album artist is the same as the track artist, or when this\n    /// information is not available.\n    pub album_artist: Option\u003cString\u003e,\n}\n\nimpl fmt::Display for Track {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let album_part = if let Some(ref album) = self.album {\n            format!(\" [{album}]\")\n        } else {\n            String::new()\n        };\n        write!(f, \"{} - {}{}\", self.artist, self.name, album_part)\n    }\n}\n\n/// Represents a paginated collection of tracks.\n///\n/// This structure is returned by track listing methods and provides\n/// information about the current page and pagination state.\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]\npub struct TrackPage {\n    /// The tracks on this page\n    pub tracks: Vec\u003cTrack\u003e,\n    /// Current page number (1-indexed)\n    pub page_number: u32,\n    /// Whether there are more pages available\n    pub has_next_page: bool,\n    /// Total number of pages, if known\n    ///\n    /// This may be `None` if the total page count cannot be determined\n    /// from the Last.fm response.\n    pub total_pages: Option\u003cu32\u003e,\n}\n\n/// Represents a music album with associated metadata.\n///\n/// This structure contains album information as parsed from Last.fm pages,\n/// including play count and optional timestamp data for scrobbles.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]\npub struct Album {\n    /// The album name/title\n    pub name: String,\n    /// The artist name\n    pub artist: String,\n    /// Number of times this album has been played/scrobbled\n    pub playcount: u32,\n    /// Unix timestamp of when this album was last scrobbled (if available)\n    ///\n    /// This field is populated when albums are retrieved from recent scrobbles\n    /// or individual scrobble data, but may be `None` for aggregate album listings.\n    pub timestamp: Option\u003cu64\u003e,\n}\n\nimpl fmt::Display for Album {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{} - {}\", self.artist, self.name)\n    }\n}\n\n/// Represents a paginated collection of albums.\n///\n/// This structure is returned by album listing methods and provides\n/// information about the current page and pagination state.\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]\npub struct AlbumPage {\n    /// The albums on this page\n    pub albums: Vec\u003cAlbum\u003e,\n    /// Current page number (1-indexed)\n    pub page_number: u32,\n    /// Whether there are more pages available\n    pub has_next_page: bool,\n    /// Total number of pages, if known\n    ///\n    /// This may be `None` if the total page count cannot be determined\n    /// from the Last.fm response.\n    pub total_pages: Option\u003cu32\u003e,\n}\n\nimpl Album {\n    /// Convert the Unix timestamp to a human-readable datetime.\n    ///\n    /// Returns `None` if no timestamp is available or if the timestamp is invalid.\n    #[must_use]\n    pub fn scrobbled_at(\u0026self) -\u003e Option\u003cDateTime\u003cUtc\u003e\u003e {\n        self.timestamp\n            .and_then(|ts| DateTime::from_timestamp(i64::try_from(ts).ok()?, 0))\n    }\n}\n\n/// Represents a music artist with associated metadata.\n///\n/// This structure contains artist information as parsed from Last.fm pages,\n/// including the total number of scrobbles for this artist.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]\npub struct Artist {\n    /// The artist name\n    pub name: String,\n    /// Number of times this artist has been played/scrobbled\n    pub playcount: u32,\n    /// Unix timestamp of when this artist was last scrobbled (if available)\n    ///\n    /// This field is populated when artists are retrieved from recent scrobbles\n    /// or individual scrobble data, but may be `None` for aggregate artist listings.\n    pub timestamp: Option\u003cu64\u003e,\n}\n\nimpl fmt::Display for Artist {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.name)\n    }\n}\n\n/// Represents a paginated collection of artists.\n///\n/// This structure is returned by artist listing methods and provides\n/// information about the current page and pagination state.\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]\npub struct ArtistPage {\n    /// The artists on this page\n    pub artists: Vec\u003cArtist\u003e,\n    /// Current page number (1-indexed)\n    pub page_number: u32,\n    /// Whether there are more pages available\n    pub has_next_page: bool,\n    /// Total number of pages, if known\n    ///\n    /// This may be `None` if the total page count cannot be determined\n    /// from the Last.fm response.\n    pub total_pages: Option\u003cu32\u003e,\n}\n\nimpl Artist {\n    /// Convert the Unix timestamp to a human-readable datetime.\n    ///\n    /// Returns `None` if no timestamp is available or if the timestamp is invalid.\n    #[must_use]\n    pub fn scrobbled_at(\u0026self) -\u003e Option\u003cDateTime\u003cUtc\u003e\u003e {\n        self.timestamp\n            .and_then(|ts| DateTime::from_timestamp(i64::try_from(ts).ok()?, 0))\n    }\n}\n\n// ================================================================================================\n// EDIT OPERATIONS\n// ================================================================================================\n\n/// Represents a scrobble edit operation.\n///\n/// This structure contains all the information needed to edit a specific scrobble\n/// on Last.fm, including both the original and new metadata values.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]\npub struct ScrobbleEdit {\n    /// Original track name as it appears in the scrobble (optional - if None, edits all tracks)\n    pub track_name_original: Option\u003cString\u003e,\n    /// Original album name as it appears in the scrobble (optional)\n    pub album_name_original: Option\u003cString\u003e,\n    /// Original artist name as it appears in the scrobble (required)\n    pub artist_name_original: String,\n    /// Original album artist name as it appears in the scrobble (optional)\n    pub album_artist_name_original: Option\u003cString\u003e,\n\n    /// New track name to set (optional - if None, keeps original track names)\n    pub track_name: Option\u003cString\u003e,\n    /// New album name to set (optional - if None, keeps original album names)\n    pub album_name: Option\u003cString\u003e,\n    /// New artist name to set\n    pub artist_name: String,\n    /// New album artist name to set (optional - if None, keeps original album artist names)\n    pub album_artist_name: Option\u003cString\u003e,\n\n    /// Unix timestamp of the scrobble to edit (optional)\n    ///\n    /// This identifies the specific scrobble instance to modify.\n    /// If None, the client will attempt to find a representative timestamp.\n    pub timestamp: Option\u003cu64\u003e,\n    /// Whether to edit all instances or just this specific scrobble\n    ///\n    /// When `true`, Last.fm will update all scrobbles with matching metadata.\n    /// When `false`, only this specific scrobble (identified by timestamp) is updated.\n    pub edit_all: bool,\n}\n\nimpl fmt::Display for ScrobbleEdit {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let mut changes = Vec::new();\n\n        // Check if artist is being changed\n        if self.artist_name != self.artist_name_original {\n            changes.push(format!(\n                \"Artist: {} â†’ {}\",\n                self.artist_name_original, self.artist_name\n            ));\n        }\n\n        // Check if track name is being changed\n        if let Some(ref new_track) = self.track_name {\n            if let Some(ref original_track) = self.track_name_original {\n                if new_track != original_track {\n                    changes.push(format!(\"Track: {original_track} â†’ {new_track}\"));\n                }\n            } else {\n                changes.push(format!(\"Track: â†’ {new_track}\"));\n            }\n        }\n\n        // Check if album name is being changed\n        if let Some(ref new_album) = self.album_name {\n            match \u0026self.album_name_original {\n                Some(ref original_album) if new_album != original_album =\u003e {\n                    changes.push(format!(\"Album: {original_album} â†’ {new_album}\"));\n                }\n                None =\u003e {\n                    changes.push(format!(\"Album: â†’ {new_album}\"));\n                }\n                _ =\u003e {} // No change\n            }\n        }\n\n        // Check if album artist is being changed\n        if let Some(ref new_album_artist) = self.album_artist_name {\n            match \u0026self.album_artist_name_original {\n                Some(ref original_album_artist) if new_album_artist != original_album_artist =\u003e {\n                    changes.push(format!(\n                        \"Album Artist: {original_album_artist} â†’ {new_album_artist}\"\n                    ));\n                }\n                None =\u003e {\n                    changes.push(format!(\"Album Artist: â†’ {new_album_artist}\"));\n                }\n                _ =\u003e {} // No change\n            }\n        }\n\n        if changes.is_empty() {\n            write!(f, \"No changes\")\n        } else {\n            let scope = if self.edit_all {\n                \" (all instances)\"\n            } else {\n                \"\"\n            };\n            write!(f, \"{}{}\", changes.join(\", \"), scope)\n        }\n    }\n}\n\n/// Response from a single scrobble edit operation.\n///\n/// This structure contains the result of attempting to edit a specific scrobble instance,\n/// including success status and any error messages.\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]\npub struct SingleEditResponse {\n    /// Whether this individual edit operation was successful\n    pub success: bool,\n    /// Optional message describing the result or any errors\n    pub message: Option\u003cString\u003e,\n    /// Information about which album variation was edited\n    pub album_info: Option\u003cString\u003e,\n    /// The exact scrobble edit that was performed\n    pub exact_scrobble_edit: ExactScrobbleEdit,\n}\n\n/// Response from a scrobble edit operation that may affect multiple album variations.\n///\n/// When editing a track that appears on multiple albums, this response contains\n/// the results of all individual edit operations performed.\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]\npub struct EditResponse {\n    /// Results of individual edit operations\n    pub individual_results: Vec\u003cSingleEditResponse\u003e,\n}\n\n/// Internal representation of a scrobble edit with all fields fully specified.\n///\n/// This type is used internally by the client after enriching metadata from\n/// Last.fm. Unlike `ScrobbleEdit`, all fields are required and non-optional,\n/// ensuring we have complete information before performing edit operations.\n///\n/// This type represents a fully-specified scrobble edit where all fields are known.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]\npub struct ExactScrobbleEdit {\n    /// Original track name as it appears in the scrobble\n    pub track_name_original: String,\n    /// Original album name as it appears in the scrobble\n    pub album_name_original: String,\n    /// Original artist name as it appears in the scrobble\n    pub artist_name_original: String,\n    /// Original album artist name as it appears in the scrobble\n    pub album_artist_name_original: String,\n\n    /// New track name to set\n    pub track_name: String,\n    /// New album name to set\n    pub album_name: String,\n    /// New artist name to set\n    pub artist_name: String,\n    /// New album artist name to set\n    pub album_artist_name: String,\n\n    /// Unix timestamp of the scrobble to edit\n    pub timestamp: u64,\n    /// Whether to edit all instances or just this specific scrobble\n    pub edit_all: bool,\n}\n\nimpl fmt::Display for ExactScrobbleEdit {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let mut changes = Vec::new();\n\n        // Check if artist is being changed\n        if self.artist_name != self.artist_name_original {\n            changes.push(format!(\n                \"Artist: {} â†’ {}\",\n                self.artist_name_original, self.artist_name\n            ));\n        }\n\n        // Check if track name is being changed\n        if self.track_name != self.track_name_original {\n            changes.push(format!(\n                \"Track: {} â†’ {}\",\n                self.track_name_original, self.track_name\n            ));\n        }\n\n        // Check if album name is being changed\n        if self.album_name != self.album_name_original {\n            changes.push(format!(\n                \"Album: {} â†’ {}\",\n                self.album_name_original, self.album_name\n            ));\n        }\n\n        // Check if album artist is being changed\n        if self.album_artist_name != self.album_artist_name_original {\n            changes.push(format!(\n                \"Album Artist: {} â†’ {}\",\n                self.album_artist_name_original, self.album_artist_name\n            ));\n        }\n\n        if changes.is_empty() {\n            write!(f, \"No changes\")\n        } else {\n            let scope = if self.edit_all {\n                \" (all instances)\"\n            } else {\n                \"\"\n            };\n            write!(f, \"{}{}\", changes.join(\", \"), scope)\n        }\n    }\n}\n\nimpl ScrobbleEdit {\n    /// Create a new [`ScrobbleEdit`] with all required fields.\n    ///\n    /// This is the most general constructor that allows setting all fields.\n    /// For convenience, consider using [`from_track_info`](Self::from_track_info) instead.\n    ///\n    /// # Arguments\n    ///\n    /// * `track_name_original` - The current track name in the scrobble\n    /// * `album_name_original` - The current album name in the scrobble\n    /// * `artist_name_original` - The current artist name in the scrobble\n    /// * `album_artist_name_original` - The current album artist name in the scrobble\n    /// * `track_name` - The new track name to set\n    /// * `album_name` - The new album name to set\n    /// * `artist_name` - The new artist name to set\n    /// * `album_artist_name` - The new album artist name to set\n    /// * `timestamp` - Unix timestamp identifying the scrobble\n    /// * `edit_all` - Whether to edit all matching scrobbles or just this one\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        track_name_original: Option\u003cString\u003e,\n        album_name_original: Option\u003cString\u003e,\n        artist_name_original: String,\n        album_artist_name_original: Option\u003cString\u003e,\n        track_name: Option\u003cString\u003e,\n        album_name: Option\u003cString\u003e,\n        artist_name: String,\n        album_artist_name: Option\u003cString\u003e,\n        timestamp: Option\u003cu64\u003e,\n        edit_all: bool,\n    ) -\u003e Self {\n        Self {\n            track_name_original,\n            album_name_original,\n            artist_name_original,\n            album_artist_name_original,\n            track_name,\n            album_name,\n            artist_name,\n            album_artist_name,\n            timestamp,\n            edit_all,\n        }\n    }\n\n    /// Create an edit request from track information (convenience constructor).\n    ///\n    /// This constructor creates a [`ScrobbleEdit`] with the new values initially\n    /// set to the same as the original values. Use the builder methods like\n    /// [`with_track_name`](Self::with_track_name) to specify what should be changed.\n    ///\n    /// # Arguments\n    ///\n    /// * `original_track` - The current track name\n    /// * `original_album` - The current album name\n    /// * `original_artist` - The current artist name\n    /// * `timestamp` - Unix timestamp identifying the scrobble\n    pub fn from_track_info(\n        original_track: \u0026str,\n        original_album: \u0026str,\n        original_artist: \u0026str,\n        timestamp: u64,\n    ) -\u003e Self {\n        Self::new(\n            Some(original_track.to_string()),\n            Some(original_album.to_string()),\n            original_artist.to_string(),\n            Some(original_artist.to_string()), // album_artist defaults to artist\n            Some(original_track.to_string()),\n            Some(original_album.to_string()),\n            original_artist.to_string(),\n            Some(original_artist.to_string()), // album_artist defaults to artist\n            Some(timestamp),\n            true, // edit_all defaults to true\n        )\n    }\n\n    /// Set the new track name.\n    pub fn with_track_name(mut self, track_name: \u0026str) -\u003e Self {\n        self.track_name = Some(track_name.to_string());\n        self\n    }\n\n    /// Set the new album name.\n    pub fn with_album_name(mut self, album_name: \u0026str) -\u003e Self {\n        self.album_name = Some(album_name.to_string());\n        self\n    }\n\n    /// Set the new artist name.\n    ///\n    /// This also sets the album artist name to the same value.\n    pub fn with_artist_name(mut self, artist_name: \u0026str) -\u003e Self {\n        self.artist_name = artist_name.to_string();\n        self.album_artist_name = Some(artist_name.to_string());\n        self\n    }\n\n    /// Set whether to edit all instances of this track.\n    ///\n    /// When `true`, Last.fm will update all scrobbles with the same metadata.\n    /// When `false` (default), only the specific scrobble is updated.\n    pub fn with_edit_all(mut self, edit_all: bool) -\u003e Self {\n        self.edit_all = edit_all;\n        self\n    }\n\n    /// Create an edit request with minimal information, letting the client look up missing metadata.\n    ///\n    /// This constructor is useful when you only know some of the original metadata and want\n    /// the client to automatically fill in missing information by looking up the scrobble.\n    ///\n    /// # Arguments\n    ///\n    /// * `track_name` - The new track name to set\n    /// * `artist_name` - The new artist name to set\n    /// * `album_name` - The new album name to set\n    /// * `timestamp` - Unix timestamp identifying the scrobble\n    pub fn with_minimal_info(\n        track_name: \u0026str,\n        artist_name: \u0026str,\n        album_name: \u0026str,\n        timestamp: u64,\n    ) -\u003e Self {\n        Self::new(\n            Some(track_name.to_string()),\n            Some(album_name.to_string()),\n            artist_name.to_string(),\n            Some(artist_name.to_string()),\n            Some(track_name.to_string()),\n            Some(album_name.to_string()),\n            artist_name.to_string(),\n            Some(artist_name.to_string()),\n            Some(timestamp),\n            true,\n        )\n    }\n    /// Create an edit request with just track and artist information.\n    ///\n    /// This constructor is useful when you only know the track and artist names.\n    /// The client will use these as both original and new values, and will\n    /// attempt to find a representative timestamp and album information.\n    ///\n    /// # Arguments\n    ///\n    /// * `track_name` - The track name (used as both original and new)\n    /// * `artist_name` - The artist name (used as both original and new)\n    pub fn from_track_and_artist(track_name: \u0026str, artist_name: \u0026str) -\u003e Self {\n        Self::new(\n            Some(track_name.to_string()),\n            None, // Client will look up original album name\n            artist_name.to_string(),\n            None, // Client will look up original album artist name\n            Some(track_name.to_string()),\n            None, // Will be filled by client or kept as original\n            artist_name.to_string(),\n            Some(artist_name.to_string()), // album_artist defaults to artist\n            None,                          // Client will find representative timestamp\n            true,\n        )\n    }\n\n    /// Create an edit request for all tracks by an artist.\n    ///\n    /// This constructor creates a [`ScrobbleEdit`] that will edit all tracks\n    /// by the specified artist, changing the artist name to the new value.\n    ///\n    /// # Arguments\n    ///\n    /// * `old_artist_name` - The current artist name to change from\n    /// * `new_artist_name` - The new artist name to change to\n    pub fn for_artist(old_artist_name: \u0026str, new_artist_name: \u0026str) -\u003e Self {\n        Self::new(\n            None, // No specific track - edit all tracks\n            None, // No specific album - edit all albums\n            old_artist_name.to_string(),\n            None, // Client will look up original album artist name\n            None, // No track name change - keep original track names\n            None, // Keep original album names (they can vary)\n            new_artist_name.to_string(),\n            Some(new_artist_name.to_string()), // album_artist also changes for global renames\n            None,                              // Client will find representative timestamp\n            true,                              // Edit all instances by default for artist changes\n        )\n    }\n\n    /// Create an edit request for all tracks in a specific album.\n    ///\n    /// This constructor creates a [`ScrobbleEdit`] that will edit all tracks\n    /// in the specified album by the specified artist.\n    ///\n    /// # Arguments\n    ///\n    /// * `album_name` - The album name containing tracks to edit\n    /// * `artist_name` - The artist name for the album\n    /// * `new_artist_name` - The new artist name to change to\n    pub fn for_album(album_name: \u0026str, old_artist_name: \u0026str, new_artist_name: \u0026str) -\u003e Self {\n        Self::new(\n            None, // No specific track - edit all tracks in album\n            Some(album_name.to_string()),\n            old_artist_name.to_string(),\n            Some(old_artist_name.to_string()),\n            None,                         // No track name change - keep original track names\n            Some(album_name.to_string()), // Keep same album name\n            new_artist_name.to_string(),\n            None, // Keep original album_artist names (they can vary)\n            None, // Client will find representative timestamp\n            true, // Edit all instances by default for album changes\n        )\n    }\n}\n\nimpl ExactScrobbleEdit {\n    /// Create a new [`ExactScrobbleEdit`] with all fields specified.\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        track_name_original: String,\n        album_name_original: String,\n        artist_name_original: String,\n        album_artist_name_original: String,\n        track_name: String,\n        album_name: String,\n        artist_name: String,\n        album_artist_name: String,\n        timestamp: u64,\n        edit_all: bool,\n    ) -\u003e Self {\n        Self {\n            track_name_original,\n            album_name_original,\n            artist_name_original,\n            album_artist_name_original,\n            track_name,\n            album_name,\n            artist_name,\n            album_artist_name,\n            timestamp,\n            edit_all,\n        }\n    }\n\n    /// Build the form data for submitting this scrobble edit.\n    ///\n    /// This creates a HashMap containing all the form fields needed to submit\n    /// the edit request to Last.fm, including the CSRF token and all metadata fields.\n    pub fn build_form_data(\u0026self, csrf_token: \u0026str) -\u003e HashMap\u003c\u0026str, String\u003e {\n        let mut form_data = HashMap::new();\n\n        // Add fresh CSRF token (required)\n        form_data.insert(\"csrfmiddlewaretoken\", csrf_token.to_string());\n\n        // Include ALL form fields (using ExactScrobbleEdit which has all required fields)\n        form_data.insert(\"track_name_original\", self.track_name_original.clone());\n        form_data.insert(\"track_name\", self.track_name.clone());\n        form_data.insert(\"artist_name_original\", self.artist_name_original.clone());\n        form_data.insert(\"artist_name\", self.artist_name.clone());\n        form_data.insert(\"album_name_original\", self.album_name_original.clone());\n        form_data.insert(\"album_name\", self.album_name.clone());\n        form_data.insert(\n            \"album_artist_name_original\",\n            self.album_artist_name_original.clone(),\n        );\n        form_data.insert(\"album_artist_name\", self.album_artist_name.clone());\n\n        // Include timestamp (ExactScrobbleEdit always has a timestamp)\n        form_data.insert(\"timestamp\", self.timestamp.to_string());\n\n        // Edit flags\n        if self.edit_all {\n            form_data.insert(\"edit_all\", \"1\".to_string());\n        }\n        form_data.insert(\"submit\", \"edit-scrobble\".to_string());\n        form_data.insert(\"ajax\", \"1\".to_string());\n\n        form_data\n    }\n\n    /// Convert this exact edit back to a public ScrobbleEdit.\n    ///\n    /// This is useful when you need to expose the edit data through the public API.\n    pub fn to_scrobble_edit(\u0026self) -\u003e ScrobbleEdit {\n        ScrobbleEdit::new(\n            Some(self.track_name_original.clone()),\n            Some(self.album_name_original.clone()),\n            self.artist_name_original.clone(),\n            Some(self.album_artist_name_original.clone()),\n            Some(self.track_name.clone()),\n            Some(self.album_name.clone()),\n            self.artist_name.clone(),\n            Some(self.album_artist_name.clone()),\n            Some(self.timestamp),\n            self.edit_all,\n        )\n    }\n}\n\nimpl EditResponse {\n    /// Create a new EditResponse from a single result.\n    pub fn single(\n        success: bool,\n        message: Option\u003cString\u003e,\n        album_info: Option\u003cString\u003e,\n        exact_scrobble_edit: ExactScrobbleEdit,\n    ) -\u003e Self {\n        Self {\n            individual_results: vec![SingleEditResponse {\n                success,\n                message,\n                album_info,\n                exact_scrobble_edit,\n            }],\n        }\n    }\n\n    /// Create a new EditResponse from multiple results.\n    pub fn from_results(results: Vec\u003cSingleEditResponse\u003e) -\u003e Self {\n        Self {\n            individual_results: results,\n        }\n    }\n\n    /// Check if all individual edit operations were successful.\n    pub fn all_successful(\u0026self) -\u003e bool {\n        !self.individual_results.is_empty() \u0026\u0026 self.individual_results.iter().all(|r| r.success)\n    }\n\n    /// Check if any individual edit operations were successful.\n    pub fn any_successful(\u0026self) -\u003e bool {\n        self.individual_results.iter().any(|r| r.success)\n    }\n\n    /// Get the total number of edit operations performed.\n    pub fn total_edits(\u0026self) -\u003e usize {\n        self.individual_results.len()\n    }\n\n    /// Get the number of successful edit operations.\n    pub fn successful_edits(\u0026self) -\u003e usize {\n        self.individual_results.iter().filter(|r| r.success).count()\n    }\n\n    /// Get the number of failed edit operations.\n    pub fn failed_edits(\u0026self) -\u003e usize {\n        self.individual_results\n            .iter()\n            .filter(|r| !r.success)\n            .count()\n    }\n\n    /// Generate a summary message describing the overall result.\n    pub fn summary_message(\u0026self) -\u003e String {\n        let total = self.total_edits();\n        let successful = self.successful_edits();\n        let failed = self.failed_edits();\n\n        if total == 0 {\n            return \"No edit operations performed\".to_string();\n        }\n\n        if successful == total {\n            if total == 1 {\n                \"Edit completed successfully\".to_string()\n            } else {\n                format!(\"All {total} edits completed successfully\")\n            }\n        } else if successful == 0 {\n            if total == 1 {\n                \"Edit failed\".to_string()\n            } else {\n                format!(\"All {total} edits failed\")\n            }\n        } else {\n            format!(\"{successful} of {total} edits succeeded, {failed} failed\")\n        }\n    }\n\n    /// Get detailed messages from all edit operations.\n    pub fn detailed_messages(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.individual_results\n            .iter()\n            .enumerate()\n            .map(|(i, result)| {\n                let album_info = result\n                    .album_info\n                    .as_deref()\n                    .map(|info| format!(\" ({info})\"))\n                    .unwrap_or_default();\n\n                match \u0026result.message {\n                    Some(msg) =\u003e format!(\"{}: {}{}\", i + 1, msg, album_info),\n                    None =\u003e {\n                        if result.success {\n                            format!(\"{}: Success{}\", i + 1, album_info)\n                        } else {\n                            format!(\"{}: Failed{}\", i + 1, album_info)\n                        }\n                    }\n                }\n            })\n            .collect()\n    }\n\n    /// Check if this response represents a single edit (for backward compatibility).\n    pub fn is_single_edit(\u0026self) -\u003e bool {\n        self.individual_results.len() == 1\n    }\n\n    /// Check if all edits succeeded (for backward compatibility).\n    pub fn success(\u0026self) -\u003e bool {\n        self.all_successful()\n    }\n\n    /// Get a single message for backward compatibility.\n    /// Returns the summary message.\n    pub fn message(\u0026self) -\u003e Option\u003cString\u003e {\n        Some(self.summary_message())\n    }\n}\n\n// ================================================================================================\n// ERROR TYPES\n// ================================================================================================\n\n/// Error types for Last.fm operations.\n///\n/// This enum covers all possible errors that can occur when interacting with Last.fm,\n/// including network issues, authentication failures, parsing errors, and rate limiting.\n#[derive(Error, Debug)]\npub enum LastFmError {\n    /// HTTP/network related errors.\n    ///\n    /// This includes connection failures, timeouts, DNS errors, and other\n    /// low-level networking issues.\n    #[error(\"HTTP error: {0}\")]\n    Http(String),\n\n    /// Authentication failures.\n    ///\n    /// This occurs when login credentials are invalid, sessions expire,\n    /// or authentication is required but not provided.\n    ///\n    /// # Common Causes\n    /// - Invalid username/password\n    /// - Expired session cookies\n    /// - Account locked or suspended\n    /// - Two-factor authentication required\n    #[error(\"Authentication failed: {0}\")]\n    Auth(String),\n\n    /// CSRF token not found in response.\n    ///\n    /// This typically indicates that Last.fm's page structure has changed\n    /// or that the request was blocked.\n    #[error(\"CSRF token not found\")]\n    CsrfNotFound,\n\n    /// Failed to parse Last.fm's response.\n    ///\n    /// This can happen when Last.fm changes their HTML structure or\n    /// returns unexpected data formats.\n    #[error(\"Failed to parse response: {0}\")]\n    Parse(String),\n\n    /// Rate limiting from Last.fm.\n    ///\n    /// Last.fm has rate limits to prevent abuse. When hit, the client\n    /// should wait before making more requests.\n    ///\n    /// The `retry_after` field indicates how many seconds to wait before\n    /// the next request attempt.\n    #[error(\"Rate limited, retry after {retry_after} seconds\")]\n    RateLimit {\n        /// Number of seconds to wait before retrying\n        retry_after: u64,\n    },\n\n    /// Scrobble edit operation failed.\n    ///\n    /// This is returned when an edit request is properly formatted and sent,\n    /// but Last.fm rejects it for business logic reasons.\n    #[error(\"Edit failed: {0}\")]\n    EditFailed(String),\n\n    /// File system I/O errors.\n    ///\n    /// This can occur when saving debug responses or other file operations.\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n}\n\n// ================================================================================================\n// SESSION MANAGEMENT\n// ================================================================================================\n\n/// Serializable client session state that can be persisted and restored.\n///\n/// This contains all the authentication state needed to resume a Last.fm session\n/// without requiring the user to log in again.\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct LastFmEditSession {\n    /// The authenticated username\n    pub username: String,\n    /// Session cookies required for authenticated requests\n    pub cookies: Vec\u003cString\u003e,\n    /// CSRF token for form submissions\n    pub csrf_token: Option\u003cString\u003e,\n    /// Base URL for the Last.fm instance\n    pub base_url: String,\n}\n\nimpl LastFmEditSession {\n    /// Create a new client session with the provided state\n    pub fn new(\n        username: String,\n        session_cookies: Vec\u003cString\u003e,\n        csrf_token: Option\u003cString\u003e,\n        base_url: String,\n    ) -\u003e Self {\n        Self {\n            username,\n            cookies: session_cookies,\n            csrf_token,\n            base_url,\n        }\n    }\n\n    /// Check if this session appears to be valid\n    ///\n    /// This performs basic validation but doesn't guarantee the session\n    /// is still active on the server.\n    pub fn is_valid(\u0026self) -\u003e bool {\n        !self.username.is_empty()\n            \u0026\u0026 !self.cookies.is_empty()\n            \u0026\u0026 self.csrf_token.is_some()\n            \u0026\u0026 self\n                .cookies\n                .iter()\n                .any(|cookie| cookie.starts_with(\"sessionid=\") \u0026\u0026 cookie.len() \u003e 50)\n    }\n\n    /// Serialize session to JSON string\n    pub fn to_json(\u0026self) -\u003e Result\u003cString, serde_json::Error\u003e {\n        serde_json::to_string(self)\n    }\n\n    /// Deserialize session from JSON string\n    pub fn from_json(json: \u0026str) -\u003e Result\u003cSelf, serde_json::Error\u003e {\n        serde_json::from_str(json)\n    }\n}\n\n// ================================================================================================\n// CLIENT CONFIGURATION\n// ================================================================================================\n\n/// Configuration for rate limit detection behavior\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct RateLimitConfig {\n    /// Whether to detect rate limits by HTTP status codes (429, 403)\n    pub detect_by_status: bool,\n    /// Whether to detect rate limits by response body patterns\n    pub detect_by_patterns: bool,\n    /// Patterns to look for in response bodies (used when detect_by_patterns is true)\n    pub patterns: Vec\u003cString\u003e,\n    /// Additional custom patterns to look for in response bodies\n    pub custom_patterns: Vec\u003cString\u003e,\n}\n\nimpl Default for RateLimitConfig {\n    fn default() -\u003e Self {\n        Self {\n            detect_by_status: true,\n            detect_by_patterns: true,\n            patterns: vec![\n                \"you've tried to log in too many times\".to_string(),\n                \"you're requesting too many pages\".to_string(),\n                \"slow down\".to_string(),\n                \"too fast\".to_string(),\n                \"rate limit\".to_string(),\n                \"throttled\".to_string(),\n                \"temporarily blocked\".to_string(),\n                \"temporarily restricted\".to_string(),\n                \"captcha\".to_string(),\n                \"verify you're human\".to_string(),\n                \"prove you're not a robot\".to_string(),\n                \"security check\".to_string(),\n                \"service temporarily unavailable\".to_string(),\n                \"quota exceeded\".to_string(),\n                \"limit exceeded\".to_string(),\n                \"daily limit\".to_string(),\n            ],\n            custom_patterns: vec![],\n        }\n    }\n}\n\nimpl RateLimitConfig {\n    /// Create config with all detection disabled\n    pub fn disabled() -\u003e Self {\n        Self {\n            detect_by_status: false,\n            detect_by_patterns: false,\n            patterns: vec![],\n            custom_patterns: vec![],\n        }\n    }\n\n    /// Create config with only status code detection\n    pub fn status_only() -\u003e Self {\n        Self {\n            detect_by_status: true,\n            detect_by_patterns: false,\n            patterns: vec![],\n            custom_patterns: vec![],\n        }\n    }\n\n    /// Create config with only default pattern detection\n    pub fn patterns_only() -\u003e Self {\n        Self {\n            detect_by_status: false,\n            detect_by_patterns: true,\n            ..Default::default()\n        }\n    }\n\n    /// Create config with custom patterns only (no default patterns)\n    pub fn custom_patterns_only(patterns: Vec\u003cString\u003e) -\u003e Self {\n        Self {\n            detect_by_status: false,\n            detect_by_patterns: false,\n            patterns: vec![],\n            custom_patterns: patterns,\n        }\n    }\n\n    /// Create config with both default and custom patterns\n    pub fn with_custom_patterns(mut self, patterns: Vec\u003cString\u003e) -\u003e Self {\n        self.custom_patterns = patterns;\n        self\n    }\n\n    /// Create config with custom patterns (replaces built-in patterns)\n    pub fn with_patterns(mut self, patterns: Vec\u003cString\u003e) -\u003e Self {\n        self.patterns = patterns;\n        self\n    }\n}\n\n/// Configuration for operational delays between requests\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct OperationalDelayConfig {\n    /// Delay between multiple edit operations (in milliseconds)\n    pub edit_delay_ms: u64,\n    /// Delay between delete operations (in milliseconds)\n    pub delete_delay_ms: u64,\n}\n\nimpl Default for OperationalDelayConfig {\n    fn default() -\u003e Self {\n        Self {\n            edit_delay_ms: 1000,   // 1 second\n            delete_delay_ms: 1000, // 1 second\n        }\n    }\n}\n\nimpl OperationalDelayConfig {\n    /// Create config with no delays (useful for testing)\n    pub fn no_delays() -\u003e Self {\n        Self {\n            edit_delay_ms: 0,\n            delete_delay_ms: 0,\n        }\n    }\n\n    /// Create config with custom delays\n    pub fn with_delays(edit_delay_ms: u64, delete_delay_ms: u64) -\u003e Self {\n        Self {\n            edit_delay_ms,\n            delete_delay_ms,\n        }\n    }\n}\n\n/// Unified configuration for retry behavior and rate limiting\n#[derive(Debug, Clone, PartialEq, Eq, Default)]\npub struct ClientConfig {\n    /// Retry configuration\n    pub retry: RetryConfig,\n    /// Rate limit detection configuration\n    pub rate_limit: RateLimitConfig,\n    /// Operational delay configuration\n    pub operational_delays: OperationalDelayConfig,\n}\n\nimpl ClientConfig {\n    /// Create a new config with default settings\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Create config with retries disabled\n    pub fn with_retries_disabled() -\u003e Self {\n        Self {\n            retry: RetryConfig::disabled(),\n            rate_limit: RateLimitConfig::default(),\n            operational_delays: OperationalDelayConfig::default(),\n        }\n    }\n\n    /// Create config with rate limit detection disabled\n    pub fn with_rate_limiting_disabled() -\u003e Self {\n        Self {\n            retry: RetryConfig::default(),\n            rate_limit: RateLimitConfig::disabled(),\n            operational_delays: OperationalDelayConfig::default(),\n        }\n    }\n\n    /// Create config with both retries and rate limiting disabled\n    pub fn minimal() -\u003e Self {\n        Self {\n            retry: RetryConfig::disabled(),\n            rate_limit: RateLimitConfig::disabled(),\n            operational_delays: OperationalDelayConfig::default(),\n        }\n    }\n\n    /// Create config optimized for testing (rate limit detection enabled, retries enabled but no delays)\n    pub fn for_testing() -\u003e Self {\n        Self {\n            retry: RetryConfig {\n                max_retries: 3,\n                base_delay: 0, // No delay for fast tests\n                max_delay: 0,  // No delay for fast tests\n                enabled: true,\n            },\n            rate_limit: RateLimitConfig::default(), // Keep detection enabled\n            operational_delays: OperationalDelayConfig::no_delays(),\n        }\n    }\n\n    /// Set custom retry configuration\n    pub fn with_retry_config(mut self, retry_config: RetryConfig) -\u003e Self {\n        self.retry = retry_config;\n        self\n    }\n\n    /// Set custom rate limit configuration\n    pub fn with_rate_limit_config(mut self, rate_limit_config: RateLimitConfig) -\u003e Self {\n        self.rate_limit = rate_limit_config;\n        self\n    }\n\n    /// Set custom operational delay configuration\n    pub fn with_operational_delays(mut self, operational_delays: OperationalDelayConfig) -\u003e Self {\n        self.operational_delays = operational_delays;\n        self\n    }\n\n    /// Set custom retry count\n    pub fn with_max_retries(mut self, max_retries: u32) -\u003e Self {\n        self.retry.max_retries = max_retries;\n        self.retry.enabled = max_retries \u003e 0;\n        self\n    }\n\n    /// Set custom retry delays\n    pub fn with_retry_delays(mut self, base_delay: u64, max_delay: u64) -\u003e Self {\n        self.retry.base_delay = base_delay;\n        self.retry.max_delay = max_delay;\n        self\n    }\n\n    /// Add custom rate limit patterns\n    pub fn with_custom_rate_limit_patterns(mut self, patterns: Vec\u003cString\u003e) -\u003e Self {\n        self.rate_limit.custom_patterns = patterns;\n        self\n    }\n\n    /// Enable/disable HTTP status code rate limit detection\n    pub fn with_status_detection(mut self, enabled: bool) -\u003e Self {\n        self.rate_limit.detect_by_status = enabled;\n        self\n    }\n\n    /// Enable/disable response pattern rate limit detection\n    pub fn with_pattern_detection(mut self, enabled: bool) -\u003e Self {\n        self.rate_limit.detect_by_patterns = enabled;\n        self\n    }\n}\n\n/// Configuration for retry behavior\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct RetryConfig {\n    /// Maximum number of retry attempts (set to 0 to disable retries)\n    pub max_retries: u32,\n    /// Base delay for exponential backoff (in seconds)\n    pub base_delay: u64,\n    /// Maximum delay cap (in seconds)\n    pub max_delay: u64,\n    /// Whether retries are enabled at all\n    pub enabled: bool,\n}\n\nimpl Default for RetryConfig {\n    fn default() -\u003e Self {\n        Self {\n            max_retries: 3,\n            base_delay: 5,\n            max_delay: 300, // 5 minutes\n            enabled: true,\n        }\n    }\n}\n\nimpl RetryConfig {\n    /// Create a config with retries disabled\n    pub fn disabled() -\u003e Self {\n        Self {\n            max_retries: 0,\n            base_delay: 5,\n            max_delay: 300,\n            enabled: false,\n        }\n    }\n\n    /// Create a config with custom retry count\n    pub fn with_retries(max_retries: u32) -\u003e Self {\n        Self {\n            max_retries,\n            enabled: max_retries \u003e 0,\n            ..Default::default()\n        }\n    }\n\n    /// Create a config with custom delays\n    pub fn with_delays(base_delay: u64, max_delay: u64) -\u003e Self {\n        Self {\n            base_delay,\n            max_delay,\n            ..Default::default()\n        }\n    }\n}\n\n/// Result of a retry operation with context\n#[derive(Debug)]\npub struct RetryResult\u003cT\u003e {\n    /// The successful result\n    pub result: T,\n    /// Number of retry attempts made\n    pub attempts_made: u32,\n    /// Total time spent retrying (in seconds)\n    pub total_retry_time: u64,\n}\n\n// ================================================================================================\n// EVENT SYSTEM\n// ================================================================================================\n\n/// Request information for client events\n#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct RequestInfo {\n    /// The HTTP method (GET, POST, etc.)\n    pub method: String,\n    /// The full URI being requested\n    pub uri: String,\n    /// Query parameters as key-value pairs\n    pub query_params: Vec\u003c(String, String)\u003e,\n    /// Path without query parameters\n    pub path: String,\n}\n\nimpl RequestInfo {\n    /// Create RequestInfo from a URL string and method\n    pub fn from_url_and_method(url: \u0026str, method: \u0026str) -\u003e Self {\n        // Parse URL manually to avoid adding dependencies\n        let (path, query_params) = if let Some(query_start) = url.find('?') {\n            let path = url[..query_start].to_string();\n            let query_string = \u0026url[query_start + 1..];\n\n            let query_params: Vec\u003c(String, String)\u003e = query_string\n                .split('\u0026')\n                .filter_map(|pair| {\n                    if let Some(eq_pos) = pair.find('=') {\n                        let key = \u0026pair[..eq_pos];\n                        let value = \u0026pair[eq_pos + 1..];\n                        Some((key.to_string(), value.to_string()))\n                    } else if !pair.is_empty() {\n                        Some((pair.to_string(), String::new()))\n                    } else {\n                        None\n                    }\n                })\n                .collect();\n\n            (path, query_params)\n        } else {\n            (url.to_string(), Vec::new())\n        };\n\n        // Extract just the path part if it's a full URL\n        let path = if path.starts_with(\"http://\") || path.starts_with(\"https://\") {\n            if let Some(third_slash) = path[8..].find('/') {\n                path[8 + third_slash..].to_string()\n            } else {\n                \"/\".to_string()\n            }\n        } else {\n            path\n        };\n\n        Self {\n            method: method.to_string(),\n            uri: url.to_string(),\n            query_params,\n            path,\n        }\n    }\n\n    /// Get a short description of the request for logging\n    pub fn short_description(\u0026self) -\u003e String {\n        let mut desc = format!(\"{} {}\", self.method, self.path);\n        if !self.query_params.is_empty() {\n            let params: Vec\u003cString\u003e = self\n                .query_params\n                .iter()\n                .map(|(k, v)| format!(\"{k}={v}\"))\n                .collect();\n            if params.len() \u003c= 2 {\n                desc.push_str(\u0026format!(\"?{}\", params.join(\"\u0026\")));\n            } else {\n                desc.push_str(\u0026format!(\"?{}...\", params[0]));\n            }\n        }\n        desc\n    }\n}\n\n/// Type of rate limiting detected\n#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum RateLimitType {\n    /// HTTP 429 Too Many Requests\n    Http429,\n    /// HTTP 403 Forbidden (likely rate limiting)\n    Http403,\n    /// Rate limit patterns detected in response body\n    ResponsePattern,\n}\n\n/// Event type to describe internal HTTP client activity\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub enum ClientEvent {\n    /// Request started\n    RequestStarted {\n        /// Request details\n        request: RequestInfo,\n    },\n    /// Request completed successfully\n    RequestCompleted {\n        /// Request details\n        request: RequestInfo,\n        /// HTTP status code\n        status_code: u16,\n        /// Duration of the request in milliseconds\n        duration_ms: u64,\n    },\n    /// Rate limiting detected with backoff duration in seconds\n    RateLimited {\n        /// Duration to wait in seconds\n        delay_seconds: u64,\n        /// Request that triggered the rate limit (if available)\n        request: Option\u003cRequestInfo\u003e,\n        /// Type of rate limiting detected\n        rate_limit_type: RateLimitType,\n        /// Timestamp when the rate limit was detected (seconds since Unix epoch)\n        rate_limit_timestamp: u64,\n    },\n    /// Rate limiting period has ended and normal operation resumed\n    RateLimitEnded {\n        /// Request that successfully completed after rate limiting\n        request: RequestInfo,\n        /// Type of rate limiting that ended\n        rate_limit_type: RateLimitType,\n        /// Total duration the rate limiting was active in seconds\n        total_rate_limit_duration_seconds: u64,\n    },\n    /// Scrobble edit attempt completed\n    EditAttempted {\n        /// The exact scrobble edit that was attempted\n        edit: ExactScrobbleEdit,\n        /// Whether the edit was successful\n        success: bool,\n        /// Optional error message if the edit failed\n        error_message: Option\u003cString\u003e,\n        /// Duration of the edit operation in milliseconds\n        duration_ms: u64,\n    },\n}\n\n/// Type alias for the broadcast receiver\npub type ClientEventReceiver = broadcast::Receiver\u003cClientEvent\u003e;\n\n/// Type alias for the watch receiver\npub type ClientEventWatcher = watch::Receiver\u003cOption\u003cClientEvent\u003e\u003e;\n\n/// Shared event broadcasting state that persists across client clones\n#[derive(Clone)]\npub struct SharedEventBroadcaster {\n    event_tx: broadcast::Sender\u003cClientEvent\u003e,\n    last_event_tx: watch::Sender\u003cOption\u003cClientEvent\u003e\u003e,\n}\n\nimpl SharedEventBroadcaster {\n    /// Create a new shared event broadcaster\n    pub fn new() -\u003e Self {\n        let (event_tx, _) = broadcast::channel(100);\n        let (last_event_tx, _) = watch::channel(None);\n\n        Self {\n            event_tx,\n            last_event_tx,\n        }\n    }\n\n    /// Broadcast an event to all subscribers\n    pub fn broadcast_event(\u0026self, event: ClientEvent) {\n        let _ = self.event_tx.send(event.clone());\n        let _ = self.last_event_tx.send(Some(event));\n    }\n\n    /// Subscribe to events\n    pub fn subscribe(\u0026self) -\u003e ClientEventReceiver {\n        self.event_tx.subscribe()\n    }\n\n    /// Get the latest event\n    pub fn latest_event(\u0026self) -\u003e Option\u003cClientEvent\u003e {\n        self.last_event_tx.borrow().clone()\n    }\n}\n\nimpl Default for SharedEventBroadcaster {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl std::fmt::Debug for SharedEventBroadcaster {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"SharedEventBroadcaster\")\n            .field(\"subscribers\", \u0026self.event_tx.receiver_count())\n            .finish()\n    }\n}\n\n// ================================================================================================\n// TESTS\n// ================================================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_session_validity() {\n        let valid_session = LastFmEditSession::new(\n            \"testuser\".to_string(),\n            vec![\"sessionid=.eJy1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\".to_string()],\n            Some(\"csrf_token_123\".to_string()),\n            \"https://www.last.fm\".to_string(),\n        );\n        assert!(valid_session.is_valid());\n\n        let invalid_session = LastFmEditSession::new(\n            \"\".to_string(),\n            vec![],\n            None,\n            \"https://www.last.fm\".to_string(),\n        );\n        assert!(!invalid_session.is_valid());\n    }\n\n    #[test]\n    fn test_session_serialization() {\n        let session = LastFmEditSession::new(\n            \"testuser\".to_string(),\n            vec![\n                \"sessionid=.test123\".to_string(),\n                \"csrftoken=abc\".to_string(),\n            ],\n            Some(\"csrf_token_123\".to_string()),\n            \"https://www.last.fm\".to_string(),\n        );\n\n        let json = session.to_json().unwrap();\n        let restored_session = LastFmEditSession::from_json(\u0026json).unwrap();\n\n        assert_eq!(session.username, restored_session.username);\n        assert_eq!(session.cookies, restored_session.cookies);\n        assert_eq!(session.csrf_token, restored_session.csrf_token);\n        assert_eq!(session.base_url, restored_session.base_url);\n    }\n}\n","traces":[{"line":51,"address":[5255594,5255588,5255136],"length":1,"stats":{"Line":0}},{"line":52,"address":[5327777],"length":1,"stats":{"Line":0}},{"line":53,"address":[5327824],"length":1,"stats":{"Line":0}},{"line":55,"address":[5327934],"length":1,"stats":{"Line":0}},{"line":57,"address":[5409213,5409282],"length":1,"stats":{"Line":0}},{"line":99,"address":[3562277],"length":1,"stats":{"Line":0}},{"line":100,"address":[5409488],"length":1,"stats":{"Line":0}},{"line":101,"address":[3442279],"length":1,"stats":{"Line":0}},{"line":129,"address":[5409664],"length":1,"stats":{"Line":0}},{"line":130,"address":[5255812],"length":1,"stats":{"Line":0}},{"line":131,"address":[3029150,3029120],"length":1,"stats":{"Line":0}},{"line":153,"address":[3442464],"length":1,"stats":{"Line":0}},{"line":154,"address":[5409736],"length":1,"stats":{"Line":0}},{"line":182,"address":[5412160],"length":1,"stats":{"Line":0}},{"line":183,"address":[5412180],"length":1,"stats":{"Line":0}},{"line":184,"address":[6205648,6205678],"length":1,"stats":{"Line":0}},{"line":229,"address":[5256000,5258467,5258425],"length":1,"stats":{"Line":0}},{"line":230,"address":[5409905],"length":1,"stats":{"Line":0}},{"line":233,"address":[5412331,5412260],"length":1,"stats":{"Line":0}},{"line":234,"address":[5412392],"length":1,"stats":{"Line":0}},{"line":241,"address":[5256386,5256134],"length":1,"stats":{"Line":0}},{"line":242,"address":[3443027,3443117],"length":1,"stats":{"Line":0}},{"line":243,"address":[5410377,5410442],"length":1,"stats":{"Line":0}},{"line":244,"address":[5256579],"length":1,"stats":{"Line":0}},{"line":247,"address":[5256785,5256536],"length":1,"stats":{"Line":0}},{"line":252,"address":[5329051,5329534],"length":1,"stats":{"Line":0}},{"line":253,"address":[5413151],"length":1,"stats":{"Line":0}},{"line":254,"address":[5731045,5731262],"length":1,"stats":{"Line":0}},{"line":255,"address":[3443895],"length":1,"stats":{"Line":0}},{"line":258,"address":[5257095],"length":1,"stats":{"Line":0}},{"line":265,"address":[5410867,5411354],"length":1,"stats":{"Line":0}},{"line":266,"address":[5257499],"length":1,"stats":{"Line":0}},{"line":267,"address":[5413782,5413999],"length":1,"stats":{"Line":0}},{"line":268,"address":[5731800],"length":1,"stats":{"Line":0}},{"line":273,"address":[5330232],"length":1,"stats":{"Line":0}},{"line":279,"address":[5330154,5330618],"length":1,"stats":{"Line":0}},{"line":280,"address":[5258444,5258032],"length":1,"stats":{"Line":0}},{"line":282,"address":[5414229,5414294],"length":1,"stats":{"Line":0}},{"line":283,"address":[3444712],"length":1,"stats":{"Line":0}},{"line":285,"address":[5732061],"length":1,"stats":{"Line":0}},{"line":287,"address":[5258115,5258254],"length":1,"stats":{"Line":0}},{"line":352,"address":[5734049,5732480,5734007],"length":1,"stats":{"Line":0}},{"line":353,"address":[5331121],"length":1,"stats":{"Line":0}},{"line":356,"address":[5331140,5331214],"length":1,"stats":{"Line":0}},{"line":357,"address":[3445271],"length":1,"stats":{"Line":0}},{"line":364,"address":[5258617,5258845],"length":1,"stats":{"Line":0}},{"line":365,"address":[5732890],"length":1,"stats":{"Line":0}},{"line":372,"address":[3445480,3445717],"length":1,"stats":{"Line":0}},{"line":373,"address":[5331749],"length":1,"stats":{"Line":0}},{"line":380,"address":[5733104,5733348],"length":1,"stats":{"Line":0}},{"line":381,"address":[5331990],"length":1,"stats":{"Line":0}},{"line":387,"address":[5331962,5332200],"length":1,"stats":{"Line":0}},{"line":388,"address":[5415822,5416234],"length":1,"stats":{"Line":0}},{"line":390,"address":[3446292,3446227],"length":1,"stats":{"Line":0}},{"line":391,"address":[5413542],"length":1,"stats":{"Line":0}},{"line":393,"address":[5259643],"length":1,"stats":{"Line":0}},{"line":395,"address":[5332444,5332305],"length":1,"stats":{"Line":0}},{"line":419,"address":[3446688],"length":1,"stats":{"Line":1}},{"line":457,"address":[5414272,5415597,5415481],"length":1,"stats":{"Line":0}},{"line":464,"address":[5260516],"length":1,"stats":{"Line":0}},{"line":465,"address":[5734657,5734712],"length":1,"stats":{"Line":0}},{"line":466,"address":[5260819,5260752],"length":1,"stats":{"Line":0}},{"line":467,"address":[5333435,5333502],"length":1,"stats":{"Line":0}},{"line":468,"address":[3447558,3447625],"length":1,"stats":{"Line":0}},{"line":469,"address":[5261041,5261108],"length":1,"stats":{"Line":0}},{"line":470,"address":[5735215,5735148],"length":1,"stats":{"Line":0}},{"line":471,"address":[5415162,5415095],"length":1,"stats":{"Line":0}},{"line":472,"address":[3447946],"length":1,"stats":{"Line":0}},{"line":478,"address":[5417968,5418254],"length":1,"stats":{"Line":1}},{"line":479,"address":[5334426,5334485],"length":1,"stats":{"Line":2}},{"line":480,"address":[5262023],"length":1,"stats":{"Line":1}},{"line":484,"address":[3448970,3448688],"length":1,"stats":{"Line":1}},{"line":485,"address":[5418389,5418330],"length":1,"stats":{"Line":2}},{"line":486,"address":[5416199],"length":1,"stats":{"Line":1}},{"line":492,"address":[3448992,3449408],"length":1,"stats":{"Line":0}},{"line":493,"address":[5416299,5416361],"length":1,"stats":{"Line":0}},{"line":494,"address":[5335200],"length":1,"stats":{"Line":0}},{"line":495,"address":[5418973],"length":1,"stats":{"Line":0}},{"line":502,"address":[5419024],"length":1,"stats":{"Line":1}},{"line":503,"address":[5736839],"length":1,"stats":{"Line":1}},{"line":504,"address":[5262847],"length":1,"stats":{"Line":1}},{"line":518,"address":[3450709,3450825,3449504],"length":1,"stats":{"Line":0}},{"line":525,"address":[5416868],"length":1,"stats":{"Line":0}},{"line":526,"address":[5263137,5263192],"length":1,"stats":{"Line":0}},{"line":527,"address":[5417171,5417104],"length":1,"stats":{"Line":0}},{"line":528,"address":[3449998,3449931],"length":1,"stats":{"Line":0}},{"line":529,"address":[5336089,5336022],"length":1,"stats":{"Line":0}},{"line":530,"address":[5419796,5419729],"length":1,"stats":{"Line":0}},{"line":531,"address":[5737628,5737695],"length":1,"stats":{"Line":0}},{"line":532,"address":[5737703,5737770],"length":1,"stats":{"Line":0}},{"line":533,"address":[5737802],"length":1,"stats":{"Line":0}},{"line":547,"address":[5264240,5265146,5265295],"length":1,"stats":{"Line":1}},{"line":549,"address":[5420517],"length":1,"stats":{"Line":1}},{"line":550,"address":[5738439],"length":1,"stats":{"Line":1}},{"line":551,"address":[5738473,5738528],"length":1,"stats":{"Line":2}},{"line":552,"address":[5738536],"length":1,"stats":{"Line":1}},{"line":553,"address":[5264632,5264562],"length":1,"stats":{"Line":2}},{"line":554,"address":[5418544],"length":1,"stats":{"Line":1}},{"line":555,"address":[5418640,5418570],"length":1,"stats":{"Line":2}},{"line":556,"address":[5420984,5421046],"length":1,"stats":{"Line":2}},{"line":557,"address":[5421078],"length":1,"stats":{"Line":1}},{"line":571,"address":[3452832,3451952,3452680],"length":1,"stats":{"Line":1}},{"line":573,"address":[5421595],"length":1,"stats":{"Line":1}},{"line":574,"address":[5265466],"length":1,"stats":{"Line":1}},{"line":575,"address":[3452103,3452173],"length":1,"stats":{"Line":2}},{"line":576,"address":[5419429],"length":1,"stats":{"Line":1}},{"line":577,"address":[5419455],"length":1,"stats":{"Line":1}},{"line":578,"address":[5265599],"length":1,"stats":{"Line":1}},{"line":579,"address":[5419557,5419487],"length":1,"stats":{"Line":2}},{"line":580,"address":[5265693,5265755],"length":1,"stats":{"Line":2}},{"line":581,"address":[3452411],"length":1,"stats":{"Line":1}},{"line":596,"address":[5741304,5741198,5740256],"length":1,"stats":{"Line":1}},{"line":598,"address":[5740359],"length":1,"stats":{"Line":1}},{"line":599,"address":[5420372,5420302],"length":1,"stats":{"Line":2}},{"line":600,"address":[5420412,5420479],"length":1,"stats":{"Line":2}},{"line":601,"address":[3453223,3453290],"length":1,"stats":{"Line":2}},{"line":602,"address":[5420594],"length":1,"stats":{"Line":1}},{"line":603,"address":[5266818,5266748],"length":1,"stats":{"Line":2}},{"line":604,"address":[5423066],"length":1,"stats":{"Line":1}},{"line":605,"address":[3453538],"length":1,"stats":{"Line":1}},{"line":606,"address":[5420810],"length":1,"stats":{"Line":1}},{"line":615,"address":[5421216],"length":1,"stats":{"Line":1}},{"line":645,"address":[5742992,5741648,5742998],"length":1,"stats":{"Line":1}},{"line":646,"address":[5423912],"length":1,"stats":{"Line":1}},{"line":649,"address":[5267785,5267728],"length":1,"stats":{"Line":2}},{"line":652,"address":[5741844],"length":1,"stats":{"Line":1}},{"line":653,"address":[5421803],"length":1,"stats":{"Line":1}},{"line":654,"address":[3454610],"length":1,"stats":{"Line":1}},{"line":655,"address":[5340721],"length":1,"stats":{"Line":1}},{"line":656,"address":[5742207],"length":1,"stats":{"Line":1}},{"line":657,"address":[5424506],"length":1,"stats":{"Line":1}},{"line":658,"address":[5341020],"length":1,"stats":{"Line":1}},{"line":660,"address":[5268389],"length":1,"stats":{"Line":1}},{"line":662,"address":[3455048],"length":1,"stats":{"Line":1}},{"line":665,"address":[3455138],"length":1,"stats":{"Line":1}},{"line":668,"address":[5422540],"length":1,"stats":{"Line":1}},{"line":669,"address":[5268708],"length":1,"stats":{"Line":1}},{"line":671,"address":[5268677,5268802],"length":1,"stats":{"Line":2}},{"line":672,"address":[5422737],"length":1,"stats":{"Line":1}},{"line":674,"address":[3455512],"length":1,"stats":{"Line":1}},{"line":680,"address":[5425232,5426462,5426346],"length":1,"stats":{"Line":0}},{"line":682,"address":[5341662],"length":1,"stats":{"Line":0}},{"line":683,"address":[3455711,3455773],"length":1,"stats":{"Line":0}},{"line":684,"address":[5743269,5743335],"length":1,"stats":{"Line":0}},{"line":685,"address":[5342017,5341951],"length":1,"stats":{"Line":0}},{"line":686,"address":[5342123,5342057],"length":1,"stats":{"Line":0}},{"line":687,"address":[5269555,5269621],"length":1,"stats":{"Line":0}},{"line":688,"address":[5425938,5425869],"length":1,"stats":{"Line":0}},{"line":689,"address":[5342420,5342346],"length":1,"stats":{"Line":0}},{"line":690,"address":[5743844],"length":1,"stats":{"Line":0}},{"line":691,"address":[5269871],"length":1,"stats":{"Line":0}},{"line":698,"address":[5424773,5424807,5424160],"length":1,"stats":{"Line":1}},{"line":705,"address":[5426786,5426544],"length":1,"stats":{"Line":2}},{"line":715,"address":[5270976],"length":1,"stats":{"Line":1}},{"line":722,"address":[5424880],"length":1,"stats":{"Line":1}},{"line":723,"address":[3457549],"length":1,"stats":{"Line":3}},{"line":727,"address":[5343712],"length":1,"stats":{"Line":0}},{"line":728,"address":[5814922,5814912],"length":1,"stats":{"Line":0}},{"line":732,"address":[5745168],"length":1,"stats":{"Line":1}},{"line":733,"address":[5425045],"length":1,"stats":{"Line":1}},{"line":737,"address":[3457712],"length":1,"stats":{"Line":1}},{"line":738,"address":[5745189],"length":1,"stats":{"Line":3}},{"line":742,"address":[5745248],"length":1,"stats":{"Line":1}},{"line":743,"address":[5425125],"length":1,"stats":{"Line":1}},{"line":745,"address":[5736122,5736112],"length":1,"stats":{"Line":2}},{"line":750,"address":[5427520],"length":1,"stats":{"Line":1}},{"line":751,"address":[5343958],"length":1,"stats":{"Line":1}},{"line":752,"address":[5745366],"length":1,"stats":{"Line":1}},{"line":753,"address":[5425254],"length":1,"stats":{"Line":1}},{"line":755,"address":[5271393],"length":1,"stats":{"Line":1}},{"line":756,"address":[5425278],"length":1,"stats":{"Line":0}},{"line":759,"address":[5344034],"length":1,"stats":{"Line":1}},{"line":760,"address":[5427671],"length":1,"stats":{"Line":1}},{"line":761,"address":[3458375],"length":1,"stats":{"Line":1}},{"line":763,"address":[5425777],"length":1,"stats":{"Line":0}},{"line":765,"address":[5745453],"length":1,"stats":{"Line":1}},{"line":766,"address":[5745480],"length":1,"stats":{"Line":1}},{"line":767,"address":[3458222],"length":1,"stats":{"Line":1}},{"line":769,"address":[5344360],"length":1,"stats":{"Line":0}},{"line":772,"address":[5271497],"length":1,"stats":{"Line":0}},{"line":777,"address":[5272032],"length":1,"stats":{"Line":0}},{"line":778,"address":[5344672],"length":1,"stats":{"Line":0}},{"line":781,"address":[5815008,5815067,5815985,5815991],"length":1,"stats":{"Line":0}},{"line":782,"address":[5808699],"length":1,"stats":{"Line":0}},{"line":785,"address":[5816016,5816043],"length":1,"stats":{"Line":0}},{"line":788,"address":[5736267],"length":1,"stats":{"Line":0}},{"line":789,"address":[5736889,5736328],"length":1,"stats":{"Line":0}},{"line":791,"address":[5640153],"length":1,"stats":{"Line":0}},{"line":792,"address":[5815550,5815260],"length":1,"stats":{"Line":0}},{"line":794,"address":[5736519,5736423,5736375],"length":1,"stats":{"Line":0}},{"line":803,"address":[5428352],"length":1,"stats":{"Line":0}},{"line":804,"address":[5746149],"length":1,"stats":{"Line":0}},{"line":808,"address":[5344784],"length":1,"stats":{"Line":1}},{"line":809,"address":[5746181],"length":1,"stats":{"Line":1}},{"line":814,"address":[5746192],"length":1,"stats":{"Line":1}},{"line":815,"address":[3458691],"length":1,"stats":{"Line":1}},{"line":912,"address":[5344880],"length":1,"stats":{"Line":13}},{"line":930,"address":[5746368],"length":1,"stats":{"Line":1}},{"line":931,"address":[5272381,5272410],"length":1,"stats":{"Line":2}},{"line":932,"address":[3458874],"length":1,"stats":{"Line":1}},{"line":933,"address":[5746421],"length":1,"stats":{"Line":1}},{"line":934,"address":[5345049],"length":1,"stats":{"Line":1}},{"line":937,"address":[5737326,5737296],"length":1,"stats":{"Line":2}},{"line":941,"address":[5426384],"length":1,"stats":{"Line":1}},{"line":942,"address":[5345137],"length":1,"stats":{"Line":1}},{"line":946,"address":[3459024],"length":1,"stats":{"Line":1}},{"line":947,"address":[5746581],"length":1,"stats":{"Line":1}},{"line":969,"address":[5347073,5345216,5347079],"length":1,"stats":{"Line":15}},{"line":973,"address":[5747594,5746946,5747738,5748326,5747666,5746877,5746808,5747779,5747090,5747234,5746742,5747018,5747306,5747162,5747450,5747522,5747378,5746673,5746635,5748484],"length":1,"stats":{"Line":27}},{"line":991,"address":[5346915],"length":1,"stats":{"Line":14}},{"line":998,"address":[3461113,3461119,3460960],"length":1,"stats":{"Line":0}},{"line":1002,"address":[5347117],"length":1,"stats":{"Line":0}},{"line":1003,"address":[5274538],"length":1,"stats":{"Line":0}},{"line":1008,"address":[5347433,5347439,5347280],"length":1,"stats":{"Line":0}},{"line":1012,"address":[5428557],"length":1,"stats":{"Line":0}},{"line":1013,"address":[5347322],"length":1,"stats":{"Line":0}},{"line":1018,"address":[3461312],"length":1,"stats":{"Line":0}},{"line":1027,"address":[5748960,5749134],"length":1,"stats":{"Line":0}},{"line":1031,"address":[5274978],"length":1,"stats":{"Line":0}},{"line":1037,"address":[5749152,5749309],"length":1,"stats":{"Line":0}},{"line":1038,"address":[5431392,5431474],"length":1,"stats":{"Line":0}},{"line":1039,"address":[3461749],"length":1,"stats":{"Line":0}},{"line":1043,"address":[5749328,5749479],"length":1,"stats":{"Line":0}},{"line":1044,"address":[5429232,5429309],"length":1,"stats":{"Line":0}},{"line":1045,"address":[3461919],"length":1,"stats":{"Line":0}},{"line":1059,"address":[3461968],"length":1,"stats":{"Line":9}},{"line":1069,"address":[5275520],"length":1,"stats":{"Line":3}},{"line":1077,"address":[5348144],"length":1,"stats":{"Line":0}},{"line":1098,"address":[5275568],"length":1,"stats":{"Line":0}},{"line":1099,"address":[5431784],"length":1,"stats":{"Line":0}},{"line":1103,"address":[3462064,3462238,3462232],"length":1,"stats":{"Line":0}},{"line":1105,"address":[5749617],"length":1,"stats":{"Line":0}},{"line":1106,"address":[5275631],"length":1,"stats":{"Line":0}},{"line":1107,"address":[5275645],"length":1,"stats":{"Line":0}},{"line":1112,"address":[5432200,5432206,5432016],"length":1,"stats":{"Line":0}},{"line":1114,"address":[5432033],"length":1,"stats":{"Line":0}},{"line":1115,"address":[3462288],"length":1,"stats":{"Line":0}},{"line":1116,"address":[5348461],"length":1,"stats":{"Line":0}},{"line":1121,"address":[3462622,3462448,3462616],"length":1,"stats":{"Line":0}},{"line":1123,"address":[3462470],"length":1,"stats":{"Line":0}},{"line":1124,"address":[5276047],"length":1,"stats":{"Line":0}},{"line":1125,"address":[5348669],"length":1,"stats":{"Line":0}},{"line":1130,"address":[5276431,5276224,5276425],"length":1,"stats":{"Line":2}},{"line":1132,"address":[5432449],"length":1,"stats":{"Line":6}},{"line":1138,"address":[5432480],"length":1,"stats":{"Line":3}},{"line":1139,"address":[5276286],"length":1,"stats":{"Line":4}},{"line":1144,"address":[5432656],"length":1,"stats":{"Line":0}},{"line":1145,"address":[5750456],"length":1,"stats":{"Line":0}},{"line":1146,"address":[5276479],"length":1,"stats":{"Line":0}},{"line":1150,"address":[5432704,5432864],"length":1,"stats":{"Line":0}},{"line":1151,"address":[5349224,5349136],"length":1,"stats":{"Line":0}},{"line":1152,"address":[5432844],"length":1,"stats":{"Line":0}},{"line":1156,"address":[5432880],"length":1,"stats":{"Line":0}},{"line":1157,"address":[5432901],"length":1,"stats":{"Line":0}},{"line":1158,"address":[5349309],"length":1,"stats":{"Line":0}},{"line":1162,"address":[5432928],"length":1,"stats":{"Line":0}},{"line":1163,"address":[5432944],"length":1,"stats":{"Line":0}},{"line":1164,"address":[5349347],"length":1,"stats":{"Line":0}},{"line":1165,"address":[5750750],"length":1,"stats":{"Line":0}},{"line":1169,"address":[5349392],"length":1,"stats":{"Line":0}},{"line":1170,"address":[5430677],"length":1,"stats":{"Line":0}},{"line":1171,"address":[5750809],"length":1,"stats":{"Line":0}},{"line":1172,"address":[5349421],"length":1,"stats":{"Line":0}},{"line":1176,"address":[5750989,5750832],"length":1,"stats":{"Line":0}},{"line":1177,"address":[5750864,5750946],"length":1,"stats":{"Line":0}},{"line":1178,"address":[5430841],"length":1,"stats":{"Line":0}},{"line":1182,"address":[5277008],"length":1,"stats":{"Line":0}},{"line":1183,"address":[5277031],"length":1,"stats":{"Line":0}},{"line":1184,"address":[3463436],"length":1,"stats":{"Line":0}},{"line":1188,"address":[5349664],"length":1,"stats":{"Line":0}},{"line":1189,"address":[5277079],"length":1,"stats":{"Line":0}},{"line":1190,"address":[5430956],"length":1,"stats":{"Line":0}},{"line":1208,"address":[5277104],"length":1,"stats":{"Line":9}},{"line":1220,"address":[3463536],"length":1,"stats":{"Line":1}},{"line":1230,"address":[3463568],"length":1,"stats":{"Line":0}},{"line":1233,"address":[3463589],"length":1,"stats":{"Line":0}},{"line":1239,"address":[5349872],"length":1,"stats":{"Line":0}},{"line":1278,"address":[5432012,5432006,5431232],"length":1,"stats":{"Line":2}},{"line":1280,"address":[5433677,5434242,5434498],"length":1,"stats":{"Line":7}},{"line":1281,"address":[5433766],"length":1,"stats":{"Line":2}},{"line":1282,"address":[5433902,5434004,5433804],"length":1,"stats":{"Line":7}},{"line":1284,"address":[5277812],"length":1,"stats":{"Line":3}},{"line":1286,"address":[6207693,6207168,6207687],"length":1,"stats":{"Line":2}},{"line":1287,"address":[5641267],"length":1,"stats":{"Line":3}},{"line":1288,"address":[6207295],"length":1,"stats":{"Line":2}},{"line":1289,"address":[5641374,5641542,5641437],"length":1,"stats":{"Line":5}},{"line":1290,"address":[5810243,5810182],"length":1,"stats":{"Line":3}},{"line":1291,"address":[5810648,5810486,5810092],"length":1,"stats":{"Line":0}},{"line":1292,"address":[5810436,5810488],"length":1,"stats":{"Line":0}},{"line":1294,"address":[5641785],"length":1,"stats":{"Line":0}},{"line":1299,"address":[3464282],"length":1,"stats":{"Line":1}},{"line":1301,"address":[5350761,5350239],"length":1,"stats":{"Line":1}},{"line":1305,"address":[5350722,5351073,5350957],"length":1,"stats":{"Line":6}},{"line":1306,"address":[5434619,5434814],"length":1,"stats":{"Line":5}},{"line":1307,"address":[3465080,3465132],"length":1,"stats":{"Line":5}},{"line":1309,"address":[5278704,5278831],"length":1,"stats":{"Line":0}},{"line":1312,"address":[5434710],"length":1,"stats":{"Line":0}},{"line":1316,"address":[5434782],"length":1,"stats":{"Line":3}},{"line":1317,"address":[5435104],"length":1,"stats":{"Line":2}},{"line":1324,"address":[5436393,5435504,5436747],"length":1,"stats":{"Line":0}},{"line":1325,"address":[5435540],"length":1,"stats":{"Line":0}},{"line":1326,"address":[5433466,5433393],"length":1,"stats":{"Line":0}},{"line":1327,"address":[5352307,5352216],"length":1,"stats":{"Line":0}},{"line":1330,"address":[5738208,5738176],"length":1,"stats":{"Line":0}},{"line":1332,"address":[3466164,3466237],"length":1,"stats":{"Line":0}},{"line":1333,"address":[5436409,5436102],"length":1,"stats":{"Line":0}},{"line":1335,"address":[5433803,5433731],"length":1,"stats":{"Line":0}},{"line":1338,"address":[3466042],"length":1,"stats":{"Line":0}},{"line":1418,"address":[5353388,5353382,5353168],"length":1,"stats":{"Line":13}},{"line":1419,"address":[5754567],"length":1,"stats":{"Line":13}},{"line":1420,"address":[5436875],"length":1,"stats":{"Line":14}},{"line":1429,"address":[5437329,5437008,5437300],"length":1,"stats":{"Line":1}},{"line":1430,"address":[3467193,3467283],"length":1,"stats":{"Line":6}},{"line":1431,"address":[5353560],"length":1,"stats":{"Line":6}},{"line":1435,"address":[5281136],"length":1,"stats":{"Line":2}},{"line":1436,"address":[5755141],"length":1,"stats":{"Line":2}},{"line":1440,"address":[5353760,5353916,5353910],"length":1,"stats":{"Line":1}},{"line":1441,"address":[5437390,5437478],"length":1,"stats":{"Line":3}},{"line":1446,"address":[3467664],"length":1,"stats":{"Line":0}},{"line":1447,"address":[5353937],"length":1,"stats":{"Line":0}},{"line":1452,"address":[3467680],"length":1,"stats":{"Line":0}},{"line":1453,"address":[5281363,5281402],"length":1,"stats":{"Line":0}},{"line":1454,"address":[5281391],"length":1,"stats":{"Line":0}}],"covered":135,"coverable":323},{"path":["/","home","imalison","Projects","lastfm-edit","src","vcr_form_data.rs"],"content":"use std::collections::HashMap;\n\n/// Parse URL-encoded form data into key-value pairs\npub fn parse_form_data(data: \u0026str) -\u003e HashMap\u003cString, String\u003e {\n    let mut params = HashMap::new();\n\n    for pair in data.split('\u0026') {\n        if let Some((key, value)) = pair.split_once('=') {\n            // URL decode the key and value\n            let decoded_key = urlencoding::decode(key).unwrap_or_else(|_| key.into());\n            let decoded_value = urlencoding::decode(value).unwrap_or_else(|_| value.into());\n            params.insert(decoded_key.to_string(), decoded_value.to_string());\n        }\n    }\n\n    params\n}\n\n/// Encode form data back to URL-encoded string\npub fn encode_form_data(params: \u0026HashMap\u003cString, String\u003e) -\u003e String {\n    params\n        .iter()\n        .map(|(key, value)| {\n            format!(\n                \"{}={}\",\n                urlencoding::encode(key),\n                urlencoding::encode(value)\n            )\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\"\u0026\")\n}\n","traces":[{"line":4,"address":[5790329,5790323,5789376],"length":1,"stats":{"Line":0}},{"line":5,"address":[3183483],"length":1,"stats":{"Line":0}},{"line":7,"address":[3183580,3183515],"length":1,"stats":{"Line":0}},{"line":8,"address":[3183808,3183751],"length":1,"stats":{"Line":0}},{"line":10,"address":[2807819,2807792],"length":1,"stats":{"Line":0}},{"line":11,"address":[5365536,5365563],"length":1,"stats":{"Line":0}},{"line":12,"address":[5790147,5790041,5790301,5790112],"length":1,"stats":{"Line":0}},{"line":16,"address":[5789716],"length":1,"stats":{"Line":0}},{"line":20,"address":[5790575,5790352,5790569],"length":1,"stats":{"Line":0}},{"line":21,"address":[3184424,3184561],"length":1,"stats":{"Line":0}},{"line":23,"address":[5366091,5365723,5365664,5366097],"length":1,"stats":{"Line":0}},{"line":24,"address":[5365770,5365878],"length":1,"stats":{"Line":0}},{"line":26,"address":[5365739],"length":1,"stats":{"Line":0}},{"line":27,"address":[5365838],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","home","imalison","Projects","lastfm-edit","src","vcr_matcher.rs"],"content":"use http_client::Request;\nuse http_client_vcr::{RequestMatcher, SerializableRequest};\nuse std::fmt::Debug;\n\n/// Last.fm Edit VCR matcher that handles authentication flows properly\n/// Ignores cookies and session-related headers that change between test runs\n#[derive(Debug)]\npub struct LastFmEditVcrMatcher {\n    match_method: bool,\n    match_url: bool,\n    match_body: bool,\n}\n\nimpl LastFmEditVcrMatcher {\n    pub fn new() -\u003e Self {\n        Self {\n            match_method: true,\n            match_url: true,\n            match_body: false,\n        }\n    }\n\n    pub fn with_body(mut self, match_body: bool) -\u003e Self {\n        self.match_body = match_body;\n        self\n    }\n}\n\nimpl RequestMatcher for LastFmEditVcrMatcher {\n    fn matches(\u0026self, request: \u0026Request, recorded_request: \u0026SerializableRequest) -\u003e bool {\n        log::debug!(\n            \"Matching request: {} {} against recorded: {} {}\",\n            request.method(),\n            request.url(),\n            recorded_request.method,\n            recorded_request.url\n        );\n\n        if self.match_method \u0026\u0026 request.method().to_string() != recorded_request.method {\n            log::debug!(\n                \"Method mismatch: {} != {}\",\n                request.method(),\n                recorded_request.method\n            );\n            return false;\n        }\n\n        if self.match_url \u0026\u0026 request.url().to_string() != recorded_request.url {\n            log::debug!(\n                \"URL mismatch: {} != {}\",\n                request.url(),\n                recorded_request.url\n            );\n            return false;\n        }\n\n        // For Last.fm, we explicitly ignore unstable headers that change between sessions\n        // This includes cookies, session tokens, CSRF tokens, and other ephemeral data\n        let unstable_headers = [\n            \"cookie\",\n            \"set-cookie\",\n            \"authorization\",\n            \"x-csrf-token\",\n            \"csrf-token\",\n            \"sessionid\",\n            \"session\",\n            \"x-session-id\",\n            \"x-auth-token\",\n            \"auth-token\",\n        ];\n\n        // Match on all headers EXCEPT the unstable ones\n        log::debug!(\"Checking headers (ignoring unstable ones)\");\n        for (header_name, recorded_values) in \u0026recorded_request.headers {\n            let header_lower = header_name.to_lowercase();\n\n            // Skip unstable headers\n            if unstable_headers\n                .iter()\n                .any(|unstable| header_lower.contains(unstable))\n            {\n                log::debug!(\"Skipping unstable header: {header_name}\");\n                continue;\n            }\n\n            let request_header = request.header(header_name.as_str());\n            log::debug!(\n                \"Comparing stable header '{header_name}': request={:?}, recorded={recorded_values:?}\",\n                request_header.map(|v| v.iter().map(|h| h.as_str()).collect::\u003cVec\u003c_\u003e\u003e())\n            );\n\n            match request_header {\n                Some(req_val) =\u003e {\n                    let req_values: Vec\u003cString\u003e =\n                        req_val.iter().map(|v| v.as_str().to_string()).collect();\n                    if \u0026req_values != recorded_values {\n                        log::debug!(\n                            \"Header '{header_name}' values mismatch: {req_values:?} != {recorded_values:?}\"\n                        );\n                        return false;\n                    }\n                }\n                None =\u003e {\n                    // If the recorded request has a header but the current request doesn't,\n                    // that's a mismatch (unless it's an unstable header we're ignoring)\n                    log::debug!(\"Header '{header_name}' missing from request\");\n                    return false;\n                }\n            }\n        }\n\n        log::debug!(\"Request matched successfully\");\n\n        true\n    }\n\n    fn matches_serializable(\n        \u0026self,\n        request: \u0026SerializableRequest,\n        recorded_request: \u0026SerializableRequest,\n    ) -\u003e bool {\n        log::debug!(\n            \"Matching serializable request: {} {} vs {} {}\",\n            request.method,\n            request.url,\n            recorded_request.method,\n            recorded_request.url\n        );\n        if self.match_method \u0026\u0026 request.method != recorded_request.method {\n            return false;\n        }\n\n        if self.match_url \u0026\u0026 request.url != recorded_request.url {\n            return false;\n        }\n\n        // Same logic as above - ignore unstable headers\n        let unstable_headers = [\n            \"cookie\",\n            \"set-cookie\",\n            \"authorization\",\n            \"x-csrf-token\",\n            \"csrf-token\",\n            \"sessionid\",\n            \"session\",\n            \"x-session-id\",\n            \"x-auth-token\",\n            \"auth-token\",\n        ];\n\n        // Match on all headers EXCEPT the unstable ones\n        log::debug!(\n            \"Checking {} recorded headers\",\n            recorded_request.headers.len()\n        );\n        for (header_name, recorded_values) in \u0026recorded_request.headers {\n            let header_lower = header_name.to_lowercase();\n\n            // Skip unstable headers\n            if unstable_headers\n                .iter()\n                .any(|unstable| header_lower.contains(unstable))\n            {\n                log::debug!(\"Skipping unstable header: {header_name}\");\n                continue;\n            }\n\n            log::debug!(\"Checking stable header: {header_name} = {recorded_values:?}\");\n\n            let request_header = request.headers.get(header_name);\n\n            match request_header {\n                Some(req_values) =\u003e {\n                    log::debug!(\n                        \"Comparing header '{header_name}': request={req_values:?} vs recorded={recorded_values:?}\"\n                    );\n                    if req_values != recorded_values {\n                        log::debug!(\n                            \"Header '{header_name}' MISMATCH! request={req_values:?} != {recorded_values:?}\"\n                        );\n                        return false;\n                    }\n                }\n                None =\u003e {\n                    // Some headers like content-type are automatically added by HTTP clients\n                    // but may not be present during replay. For GET requests, content-type is often optional.\n                    if header_name.to_lowercase() == \"content-type\" \u0026\u0026 request.method == \"GET\" {\n                        log::debug!(\"Ignoring missing content-type header for GET request\");\n                        continue;\n                    }\n\n                    // If the recorded request has a header but the current request doesn't,\n                    // that's a mismatch (unless it's an unstable header we're ignoring)\n                    log::debug!(\n                        \"Header '{header_name}' missing from current request (recorded has: {recorded_values:?})\"\n                    );\n                    return false;\n                }\n            }\n        }\n\n        true\n    }\n}\n\nimpl Default for LastFmEditVcrMatcher {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[{"line":23,"address":[3594224],"length":1,"stats":{"Line":0}},{"line":24,"address":[5399773],"length":1,"stats":{"Line":0}},{"line":25,"address":[3594273],"length":1,"stats":{"Line":0}},{"line":30,"address":[3594320,3598435,3598133],"length":1,"stats":{"Line":0}},{"line":31,"address":[3594540,3594496,3594375,3594434],"length":1,"stats":{"Line":0}},{"line":39,"address":[3594908,3594420],"length":1,"stats":{"Line":0}},{"line":40,"address":[5404308,5400585,5404370],"length":1,"stats":{"Line":0}},{"line":45,"address":[3598775],"length":1,"stats":{"Line":0}},{"line":48,"address":[5400389,5400955],"length":1,"stats":{"Line":0}},{"line":49,"address":[3598524,3595616,3598461],"length":1,"stats":{"Line":0}},{"line":54,"address":[5403968],"length":1,"stats":{"Line":0}},{"line":59,"address":[3595127],"length":1,"stats":{"Line":0}},{"line":73,"address":[5401223,5400901],"length":1,"stats":{"Line":0}},{"line":74,"address":[5401174,5401395],"length":1,"stats":{"Line":0}},{"line":75,"address":[3595984],"length":1,"stats":{"Line":0}},{"line":78,"address":[3596017,3596359],"length":1,"stats":{"Line":0}},{"line":80,"address":[6399458,6399440],"length":1,"stats":{"Line":0}},{"line":82,"address":[3598146,3598171,3596449],"length":1,"stats":{"Line":0}},{"line":86,"address":[5402029,5401926],"length":1,"stats":{"Line":0}},{"line":87,"address":[3053728,3053833,3053753,3053808],"length":1,"stats":{"Line":0}},{"line":92,"address":[3596602],"length":1,"stats":{"Line":0}},{"line":93,"address":[3597126],"length":1,"stats":{"Line":0}},{"line":94,"address":[5403026,5402654],"length":1,"stats":{"Line":0}},{"line":96,"address":[3597568,3597655],"length":1,"stats":{"Line":0}},{"line":97,"address":[3597680,3597745,3597781],"length":1,"stats":{"Line":0}},{"line":100,"address":[5403271],"length":1,"stats":{"Line":0}},{"line":106,"address":[3597229,3597164],"length":1,"stats":{"Line":0}},{"line":107,"address":[3597216],"length":1,"stats":{"Line":0}},{"line":112,"address":[5401614,5401564],"length":1,"stats":{"Line":0}},{"line":114,"address":[3596097],"length":1,"stats":{"Line":0}},{"line":117,"address":[3603322,3599104,3602188],"length":1,"stats":{"Line":1}},{"line":122,"address":[5404738,5404679],"length":1,"stats":{"Line":2}},{"line":129,"address":[3599204,3599658],"length":1,"stats":{"Line":2}},{"line":130,"address":[3599670],"length":1,"stats":{"Line":0}},{"line":133,"address":[3599630,3600008],"length":1,"stats":{"Line":2}},{"line":134,"address":[5405551],"length":1,"stats":{"Line":4}},{"line":138,"address":[5405203],"length":1,"stats":{"Line":1}},{"line":152,"address":[3600150],"length":1,"stats":{"Line":2}},{"line":156,"address":[3600360,3600052],"length":1,"stats":{"Line":2}},{"line":157,"address":[3600453],"length":1,"stats":{"Line":1}},{"line":160,"address":[3600611,3600486],"length":1,"stats":{"Line":2}},{"line":162,"address":[6014656,6014674],"length":1,"stats":{"Line":2}},{"line":164,"address":[3603046,3600715],"length":1,"stats":{"Line":2}},{"line":168,"address":[3600818,3600670,3600770],"length":1,"stats":{"Line":3}},{"line":170,"address":[5406309,5406678],"length":1,"stats":{"Line":2}},{"line":172,"address":[3601161],"length":1,"stats":{"Line":2}},{"line":173,"address":[3601192],"length":1,"stats":{"Line":1}},{"line":174,"address":[3602241,3601208,3602201],"length":1,"stats":{"Line":5}},{"line":177,"address":[5408122,5407732],"length":1,"stats":{"Line":4}},{"line":178,"address":[5408212,5408147],"length":1,"stats":{"Line":0}},{"line":181,"address":[3602674],"length":1,"stats":{"Line":0}},{"line":187,"address":[3601499,3601256],"length":1,"stats":{"Line":2}},{"line":188,"address":[3601973,3601533,3601948],"length":1,"stats":{"Line":3}},{"line":194,"address":[3601446,3601588,3601607],"length":1,"stats":{"Line":0}},{"line":197,"address":[3601594],"length":1,"stats":{"Line":0}},{"line":202,"address":[3600526],"length":1,"stats":{"Line":3}},{"line":207,"address":[3603344],"length":1,"stats":{"Line":0}},{"line":208,"address":[3603345],"length":1,"stats":{"Line":0}}],"covered":21,"coverable":58},{"path":["/","home","imalison","Projects","lastfm-edit","src","vcr_test_utils.rs"],"content":"use crate::vcr_form_data::{encode_form_data, parse_form_data};\nuse http_client_vcr::{Filter, FilterChain, SerializableRequest, SerializableResponse};\n\n/// Last.fm-specific utilities for test cassette management.\n/// These helpers understand the Last.fm authentication flow and handle credential replacement appropriately.\n/// A custom filter that only filters passwords while preserving usernames and CSRF tokens\n#[derive(Debug)]\npub struct LastFmPasswordOnlyFilter;\n\nimpl Filter for LastFmPasswordOnlyFilter {\n    fn filter_request(\u0026self, request: \u0026mut SerializableRequest) {\n        // Filter passwords in form data\n        if let Some(body) = \u0026mut request.body {\n            if body.contains('=') \u0026\u0026 (body.contains('\u0026') || !body.contains(' ')) {\n                let mut params = parse_form_data(body);\n\n                // Only filter password field - keep username and CSRF token for request matching\n                if params.contains_key(\"password\") {\n                    params.insert(\"password\".to_string(), \"test_password\".to_string());\n                    *body = encode_form_data(\u0026params);\n                }\n            }\n        }\n\n        // Filter session cookies in request headers\n        if let Some(cookie_values) = request.headers.get_mut(\"cookie\") {\n            for cookie_header in cookie_values.iter_mut() {\n                *cookie_header = self.filter_session_cookies(cookie_header);\n            }\n        }\n    }\n\n    fn filter_response(\u0026self, response: \u0026mut SerializableResponse) {\n        // Filter session cookies in response set-cookie headers\n        if let Some(set_cookie_values) = response.headers.get_mut(\"set-cookie\") {\n            for set_cookie_header in set_cookie_values.iter_mut() {\n                if set_cookie_header.contains(\"sessionid=\") {\n                    *set_cookie_header = self.filter_set_cookie_session(set_cookie_header);\n                }\n            }\n        }\n    }\n}\n\nimpl LastFmPasswordOnlyFilter {\n    /// Filter session cookies from a cookie header string\n    fn filter_session_cookies(\u0026self, cookie_header: \u0026str) -\u003e String {\n        let mut filtered_cookies = Vec::new();\n\n        for cookie in cookie_header.split(';') {\n            let cookie = cookie.trim();\n            if cookie.starts_with(\"sessionid=\") {\n                // Replace session ID with test value\n                filtered_cookies.push(\"sessionid=test_session_id\");\n            } else {\n                filtered_cookies.push(cookie);\n            }\n        }\n\n        filtered_cookies.join(\"; \")\n    }\n\n    /// Filter session cookies from a set-cookie header string\n    fn filter_set_cookie_session(\u0026self, set_cookie_header: \u0026str) -\u003e String {\n        if set_cookie_header.starts_with(\"sessionid=\") {\n            // Extract everything after the session value up to the first semicolon or end\n            if let Some(semicolon_pos) = set_cookie_header.find(';') {\n                let attributes = \u0026set_cookie_header[semicolon_pos..];\n                format!(\"sessionid=test_session_id{attributes}\")\n            } else {\n                \"sessionid=test_session_id\".to_string()\n            }\n        } else {\n            set_cookie_header.to_string()\n        }\n    }\n}\n\n/// Create a Last.fm test filter chain that:\n/// - Keeps usernames and CSRF tokens intact (needed for proper request matching)\n/// - Filters passwords from request bodies with predictable test values\n/// - Filters session tokens with predictable test values\npub fn create_lastfm_test_filter_chain() -\u003e Result\u003cFilterChain, regex::Error\u003e {\n    let filter_chain = FilterChain::new().add_filter(Box::new(LastFmPasswordOnlyFilter));\n    Ok(filter_chain)\n}\n","traces":[{"line":11,"address":[5474293,5473536,5474287],"length":1,"stats":{"Line":0}},{"line":13,"address":[3426209],"length":1,"stats":{"Line":0}},{"line":14,"address":[3426275,3426380],"length":1,"stats":{"Line":0}},{"line":15,"address":[3426446],"length":1,"stats":{"Line":0}},{"line":18,"address":[5473839,5473911,5474260],"length":1,"stats":{"Line":0}},{"line":19,"address":[3426892,3426564,3426634],"length":1,"stats":{"Line":0}},{"line":20,"address":[3426757,3426785],"length":1,"stats":{"Line":0}},{"line":26,"address":[3426306,3426933],"length":1,"stats":{"Line":0}},{"line":27,"address":[3427003,3427235,3426949],"length":1,"stats":{"Line":0}},{"line":28,"address":[3427076,3427133],"length":1,"stats":{"Line":0}},{"line":33,"address":[3427571,3427248],"length":1,"stats":{"Line":0}},{"line":35,"address":[3427283],"length":1,"stats":{"Line":0}},{"line":36,"address":[3427395,3427347],"length":1,"stats":{"Line":0}},{"line":37,"address":[3427631,3427453],"length":1,"stats":{"Line":0}},{"line":38,"address":[3427493,3427545,3427605],"length":1,"stats":{"Line":0}},{"line":47,"address":[3428218,3427648,3428224],"length":1,"stats":{"Line":0}},{"line":48,"address":[3427699],"length":1,"stats":{"Line":0}},{"line":50,"address":[3427788,3427723],"length":1,"stats":{"Line":0}},{"line":51,"address":[5475451,5475335],"length":1,"stats":{"Line":0}},{"line":52,"address":[3428103],"length":1,"stats":{"Line":0}},{"line":54,"address":[5475593,5475553],"length":1,"stats":{"Line":0}},{"line":56,"address":[3428208,3428150],"length":1,"stats":{"Line":0}},{"line":60,"address":[5475352],"length":1,"stats":{"Line":0}},{"line":64,"address":[3428240],"length":1,"stats":{"Line":0}},{"line":65,"address":[3428305],"length":1,"stats":{"Line":0}},{"line":67,"address":[3428358,3428417],"length":1,"stats":{"Line":0}},{"line":68,"address":[3428430],"length":1,"stats":{"Line":0}},{"line":69,"address":[3428453],"length":1,"stats":{"Line":0}},{"line":71,"address":[3428571],"length":1,"stats":{"Line":0}},{"line":74,"address":[3428341],"length":1,"stats":{"Line":0}},{"line":83,"address":[3428801,3428775,3428608],"length":1,"stats":{"Line":0}},{"line":84,"address":[3428785,3428658,3428622],"length":1,"stats":{"Line":0}},{"line":85,"address":[3428736],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":33},{"path":["/","home","imalison","Projects","lastfm-edit","tests","event_broadcasting.rs"],"content":"use http_client_vcr::NoOpClient;\nuse lastfm_edit::{LastFmEditClientImpl, LastFmEditSession};\nuse std::time::Duration;\nuse tokio::time::timeout;\n\nfn create_test_session() -\u003e LastFmEditSession {\n    LastFmEditSession::new(\n        \"test_user\".to_string(),\n        vec![\"sessionid=.test_session_id_12345\".to_string()],\n        Some(\"test_csrf_token\".to_string()),\n        \"https://www.last.fm\".to_string(),\n    )\n}\n\n#[test_log::test(tokio::test)]\nasync fn test_shared_broadcaster_across_clients() {\n    // Create the first client\n    let http_client1 = NoOpClient::new();\n    let client1 = LastFmEditClientImpl::from_session(Box::new(http_client1), create_test_session());\n\n    // Create second client that shares the broadcaster with client1\n    let http_client2 = NoOpClient::new();\n    let client2 = client1.with_shared_broadcaster(Box::new(http_client2));\n\n    // Create third client with independent broadcaster\n    let http_client3 = NoOpClient::new();\n    let session = client1.get_session();\n    let client3 = LastFmEditClientImpl::from_session(Box::new(http_client3), session);\n\n    // Subscribe to events from all clients\n    let mut events1 = client1.subscribe();\n    let mut events2 = client2.subscribe();\n    let mut events3 = client3.subscribe();\n\n    // Test that clients start with no events\n    assert!(client1.latest_event().is_none());\n    assert!(client2.latest_event().is_none());\n    assert!(client3.latest_event().is_none());\n\n    // In a real scenario, rate limit events would be broadcast automatically\n    // when HTTP requests encounter rate limiting. Since we can't easily simulate\n    // that in a unit test, we verify the structure is correct by checking that:\n\n    // 1. Clients with shared broadcasters have the same latest event state\n    // 2. Clients with independent broadcasters maintain separate state\n\n    // For now, we can only test that the event subscriptions are properly set up\n    // and that no events are present initially (which is correct)\n\n    // Test that subscriptions don't immediately have events\n    let no_event_1 = timeout(Duration::from_millis(10), events1.recv()).await;\n    let no_event_2 = timeout(Duration::from_millis(10), events2.recv()).await;\n    let no_event_3 = timeout(Duration::from_millis(10), events3.recv()).await;\n\n    // All should timeout (no events received)\n    assert!(no_event_1.is_err());\n    assert!(no_event_2.is_err());\n    assert!(no_event_3.is_err());\n}\n\n#[test_log::test(tokio::test)]\nasync fn test_session_sharing_vs_broadcaster_sharing() {\n    // Create first client\n    let http_client1 = NoOpClient::new();\n    let client1 = LastFmEditClientImpl::from_session(Box::new(http_client1), create_test_session());\n\n    // Client2: shares session but NOT broadcaster\n    let http_client2 = NoOpClient::new();\n    let session = client1.get_session();\n    let client2 = LastFmEditClientImpl::from_session(Box::new(http_client2), session);\n\n    // Client3: shares BOTH session and broadcaster\n    let http_client3 = NoOpClient::new();\n    let client3 = client1.with_shared_broadcaster(Box::new(http_client3));\n\n    // Verify session sharing\n    assert_eq!(\n        client1.get_session().base_url,\n        client2.get_session().base_url\n    );\n    assert_eq!(\n        client1.get_session().base_url,\n        client3.get_session().base_url\n    );\n\n    // All clients should start with no events\n    assert!(client1.latest_event().is_none());\n    assert!(client2.latest_event().is_none());\n    assert!(client3.latest_event().is_none());\n\n    // Subscribe to verify broadcast setup\n    let _events1 = client1.subscribe();\n    let _events2 = client2.subscribe();\n    let _events3 = client3.subscribe();\n\n    // Test passes if no panics occur - the broadcaster sharing is working correctly\n    // In real usage, when client1 or client3 encounter rate limits, both would see the events\n    // while client2 would not (since it has an independent broadcaster)\n}\n\n#[test_log::test]\nfn test_client_creation_patterns() {\n    // Pattern 1: Independent clients\n    let http_client1 = NoOpClient::new();\n    let client1 = LastFmEditClientImpl::from_session(Box::new(http_client1), create_test_session());\n\n    let http_client2 = NoOpClient::new();\n    let session = client1.get_session();\n    let client2 = LastFmEditClientImpl::from_session(Box::new(http_client2), session);\n\n    // These should be independent - same session but different broadcasters\n    assert_eq!(\n        client1.get_session().base_url,\n        client2.get_session().base_url\n    );\n\n    // Pattern 2: Shared broadcaster\n    let http_client3 = NoOpClient::new();\n    let client3 = client1.with_shared_broadcaster(Box::new(http_client3));\n\n    // These should share both session and broadcaster\n    assert_eq!(\n        client1.get_session().base_url,\n        client3.get_session().base_url\n    );\n\n    // Test that we can create subscriptions without issues\n    let _sub1 = client1.subscribe();\n    let _sub2 = client2.subscribe();\n    let _sub3 = client3.subscribe();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","tests","mock_client.rs"],"content":"#[cfg(feature = \"mock\")]\nmod mock_tests {\n    use lastfm_edit::{\n        Album, AlbumPage, EditResponse, ExactScrobbleEdit, LastFmEditClient, MockLastFmEditClient,\n        Result, ScrobbleEdit, Track, TrackPage,\n    };\n    use mockall::predicate::*; // for eq(), any(), etc.\n\n    #[test_log::test(tokio::test)]\n    async fn test_mock_basic_functionality() -\u003e Result\u003c()\u003e {\n        let mut mock_client = MockLastFmEditClient::new();\n\n        mock_client\n            .expect_username()\n            .times(1)\n            .returning(|| \"testuser\".to_string());\n\n        // Use the mock as a trait object\n        let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n\n        // Test username retrieval\n        assert_eq!(client.username(), \"testuser\");\n\n        Ok(())\n    }\n\n    #[test_log::test(tokio::test)]\n    async fn test_mock_edit_scrobble() -\u003e Result\u003c()\u003e {\n        let mut mock_client = MockLastFmEditClient::new();\n\n        let edit = ScrobbleEdit::new(\n            Some(\"Old Track\".to_string()),\n            Some(\"Old Album\".to_string()),\n            \"Old Artist\".to_string(),\n            Some(\"Old Artist\".to_string()),\n            Some(\"New Track\".to_string()),\n            Some(\"New Album\".to_string()),\n            \"New Artist\".to_string(),\n            Some(\"New Artist\".to_string()),\n            Some(1640995200),\n            false,\n        );\n\n        let expected_exact_edit = ExactScrobbleEdit::new(\n            \"Old Track\".to_string(),\n            \"Old Album\".to_string(),\n            \"Old Artist\".to_string(),\n            \"Old Artist\".to_string(),\n            \"New Track\".to_string(),\n            \"New Album\".to_string(),\n            \"New Artist\".to_string(),\n            \"New Artist\".to_string(),\n            1640995200,\n            false,\n        );\n\n        let expected_response = EditResponse::single(\n            true,\n            Some(\"Edit completed successfully\".to_string()),\n            None,\n            expected_exact_edit,\n        );\n\n        // Set up expectation for edit_scrobble\n        mock_client\n            .expect_edit_scrobble()\n            .with(eq(edit.clone()))\n            .times(1)\n            .returning(move |_| Ok(expected_response.clone()));\n\n        // Use the mock\n        let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n        let response = client.edit_scrobble(\u0026edit).await?;\n\n        assert!(response.success());\n        assert_eq!(\n            response.message(),\n            Some(\"Edit completed successfully\".to_string())\n        );\n\n        Ok(())\n    }\n\n    #[test_log::test(tokio::test)]\n    async fn test_mock_get_recent_scrobbles() -\u003e Result\u003c()\u003e {\n        let mut mock_client = MockLastFmEditClient::new();\n\n        let expected_tracks = vec![\n            Track {\n                name: \"Test Track 1\".to_string(),\n                artist: \"Test Artist 1\".to_string(),\n                album: Some(\"Test Album 1\".to_string()),\n                album_artist: Some(\"Test Artist 1\".to_string()),\n                playcount: 5,\n                timestamp: Some(1640995200),\n            },\n            Track {\n                name: \"Test Track 2\".to_string(),\n                artist: \"Test Artist 2\".to_string(),\n                album: Some(\"Test Album 2\".to_string()),\n                album_artist: Some(\"Test Artist 2\".to_string()),\n                playcount: 3,\n                timestamp: Some(1640995100),\n            },\n        ];\n\n        // Set up expectation\n        mock_client\n            .expect_get_recent_scrobbles()\n            .with(eq(1))\n            .times(1)\n            .returning(move |_| Ok(expected_tracks.clone()));\n\n        // Use the mock\n        let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n        let tracks = client.get_recent_scrobbles(1).await?;\n\n        assert_eq!(tracks.len(), 2);\n        assert_eq!(tracks[0].name, \"Test Track 1\");\n        assert_eq!(tracks[1].name, \"Test Track 2\");\n\n        Ok(())\n    }\n\n    #[test_log::test(tokio::test)]\n    async fn test_mock_iterator_concept() -\u003e Result\u003c()\u003e {\n        // Note: Due to Rust's lifetime system, mocking iterators that borrow from\n        // the client is complex. In practice, you would typically mock the underlying\n        // pagination methods (like get_artist_tracks_page) rather than the iterators themselves.\n\n        let mut mock_client = MockLastFmEditClient::new();\n\n        // Mock the underlying pagination method that iterators use\n        mock_client\n            .expect_get_artist_tracks_page()\n            .with(eq(\"test_artist\"), eq(1))\n            .returning(|_, _| {\n                Ok(TrackPage {\n                    tracks: vec![Track {\n                        name: \"Mocked Track\".to_string(),\n                        artist: \"Mocked Artist\".to_string(),\n                        album: Some(\"Mocked Album\".to_string()),\n                        album_artist: Some(\"Mocked Artist\".to_string()),\n                        playcount: 10,\n                        timestamp: Some(1640995200),\n                    }],\n                    page_number: 1,\n                    has_next_page: false,\n                    total_pages: Some(1),\n                })\n            });\n\n        let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n\n        // Test that the underlying method works correctly\n        let page = client.get_artist_tracks_page(\"test_artist\", 1).await?;\n        assert_eq!(page.tracks.len(), 1);\n        assert_eq!(page.tracks[0].name, \"Mocked Track\");\n\n        Ok(())\n    }\n\n    #[test_log::test(tokio::test)]\n    async fn test_mock_iterator_trait_objects() -\u003e Result\u003c()\u003e {\n        // This test demonstrates that iterator methods return trait objects\n        // that can be used polymorphically, even though mocking the iterators\n        // themselves is complex due to lifetime constraints.\n\n        let mut mock_client = MockLastFmEditClient::new();\n\n        // Mock the underlying methods that the iterators use\n        mock_client\n            .expect_get_artist_tracks_page()\n            .with(eq(\"test_artist\"), eq(1))\n            .returning(|_, _| {\n                Ok(TrackPage {\n                    tracks: vec![Track {\n                        name: \"Iterator Track 1\".to_string(),\n                        artist: \"test_artist\".to_string(),\n                        album: Some(\"Test Album\".to_string()),\n                        album_artist: Some(\"test_artist\".to_string()),\n                        playcount: 5,\n                        timestamp: Some(1640995200),\n                    }],\n                    page_number: 1,\n                    has_next_page: false,\n                    total_pages: Some(1),\n                })\n            });\n\n        mock_client\n            .expect_get_recent_scrobbles()\n            .with(eq(1))\n            .returning(|_| {\n                Ok(vec![Track {\n                    name: \"Recent Track 1\".to_string(),\n                    artist: \"Recent Artist\".to_string(),\n                    album: Some(\"Recent Album\".to_string()),\n                    album_artist: Some(\"Recent Artist\".to_string()),\n                    playcount: 1,\n                    timestamp: Some(1640995300),\n                }])\n            });\n\n        mock_client\n            .expect_get_artist_albums_page()\n            .with(eq(\"test_artist\"), eq(1))\n            .returning(|_, _| {\n                Ok(AlbumPage {\n                    albums: vec![Album {\n                        name: \"Test Album\".to_string(),\n                        artist: \"test_artist\".to_string(),\n                        playcount: 10,\n                        timestamp: Some(1640995200),\n                    }],\n                    page_number: 1,\n                    has_next_page: false,\n                    total_pages: Some(1),\n                })\n            });\n\n        let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n\n        // Note: Iterator methods are now implemented on the concrete client type,\n        // not the trait. For testing purposes, we can cast back to the concrete type.\n        // In real code, you would typically create iterators using the concrete client.\n\n        // This demonstrates that the underlying pagination methods work\n        let tracks_page = client.get_artist_tracks_page(\"test_artist\", 1).await?;\n        assert_eq!(tracks_page.tracks.len(), 1);\n        assert_eq!(tracks_page.tracks[0].name, \"Iterator Track 1\");\n\n        let recent_page = client.get_recent_scrobbles(1).await?;\n        assert_eq!(recent_page.len(), 1);\n        assert_eq!(recent_page[0].name, \"Recent Track 1\");\n\n        let albums_page = client.get_artist_albums_page(\"test_artist\", 1).await?;\n        assert_eq!(albums_page.albums.len(), 1);\n        assert_eq!(albums_page.albums[0].name, \"Test Album\");\n\n        Ok(())\n    }\n}\n\n#[cfg(not(feature = \"mock\"))]\nmod no_mock_tests {\n    #[test]\n    fn test_mock_feature_disabled() {\n        // This test ensures the code compiles even when the mock feature is disabled\n        log::debug!(\"Mock feature is disabled - MockLastFmEditClient is not available\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","tests","parsing_send_sync.rs"],"content":"use http_client_vcr::NoOpClient;\nuse lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession};\n\nfn create_test_session() -\u003e LastFmEditSession {\n    LastFmEditSession::new(\n        \"test_user\".to_string(),\n        vec![\"sessionid=.test_session_id_12345\".to_string()],\n        Some(\"test_csrf_token\".to_string()),\n        \"https://www.last.fm\".to_string(),\n    )\n}\n\n/// Test to check if the parsing methods (non-async) are Send + Sync\n#[test_log::test]\nfn test_parsing_methods_are_send_sync() {\n    fn assert_send_sync\u003cT: Send + Sync\u003e(_: T) {}\n\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // Test that the client itself is Send + Sync (should be now that parsing is separate)\n    assert_send_sync(lastfm_client);\n}\n\n/// Test just the iterator creation without calling next() to isolate HTTP client issues\n#[test_log::test]\nfn test_iterator_creation_is_send_sync() {\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // Create iterators one at a time to avoid borrowing issues\n    let recent_tracks = lastfm_client.recent_tracks();\n    drop(recent_tracks);\n\n    let artist_tracks = lastfm_client.artist_tracks(\"test\");\n    drop(artist_tracks);\n\n    let artist_albums = lastfm_client.artist_albums(\"test\");\n    drop(artist_albums);\n}\n\n/// Test that the client itself is Send + Sync (structure-wise)\n#[test_log::test]\nfn test_client_is_send_sync() {\n    fn assert_send_sync\u003cT: Send + Sync + 'static\u003e(_: T) {}\n\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // The client should be Send + Sync at the structural level\n    assert_send_sync(lastfm_client);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","tests","thread_safety.rs"],"content":"use http_client_vcr::NoOpClient;\nuse lastfm_edit::{LastFmEditClientImpl, LastFmEditSession};\n\nfn create_test_session() -\u003e LastFmEditSession {\n    LastFmEditSession::new(\n        \"test_user\".to_string(),\n        vec![\"sessionid=.test_session_id_12345\".to_string()],\n        Some(\"test_csrf_token\".to_string()),\n        \"https://www.last.fm\".to_string(),\n    )\n}\n\n/// Test that futures from client operations are Send.\n/// This ensures they can be used across await boundaries in async contexts.\n#[test_log::test(tokio::test)]\nasync fn test_client_futures_are_send() {\n    fn assert_send\u003cT: Send\u003e(_: T) {}\n\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // Test that client get_recent_scrobbles future is Send\n    let get_scrobbles_future = lastfm_client.get_recent_scrobbles(1);\n    assert_send(get_scrobbles_future);\n\n    // Test that client get_artist_tracks_page future is Send\n    let get_tracks_future = lastfm_client.get_artist_tracks_page(\"test\", 1);\n    assert_send(get_tracks_future);\n}\n\n/// Test that iterator futures are Send.\n/// This ensures they can be used across await boundaries.\n/// Note: Current iterator implementation holds references to the client,\n/// so they are not Send. This is intentional for lifetime safety.\n#[test_log::test(tokio::test)]\nasync fn test_iterator_futures_are_send() {\n    // This test is commented out because iterators now hold references\n    // to the client, making them not Send. This is expected behavior.\n\n    // To use iterators across threads, create the iterator on the same\n    // thread where it will be used, or use the underlying pagination\n    // methods directly which are Send.\n}\n\n/// Test that we can spawn tasks with these futures.\n/// This is the most important practical test - futures must be Send to use with tokio::spawn.\n#[test_log::test(tokio::test)]\nasync fn test_futures_can_be_spawned() {\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // This should compile if futures are Send\n    let handle = tokio::spawn(async move {\n        let _ = lastfm_client.get_recent_scrobbles(1).await;\n        let _ = lastfm_client.get_artist_tracks_page(\"test\", 1).await;\n    });\n\n    // Don't actually await the handle since it will fail without proper credentials\n    handle.abort();\n}\n\n/// Test that pagination methods work across await boundaries.\n/// Note: Iterators are not Send due to holding client references.\n/// Use pagination methods directly for Send behavior.\n#[test_log::test(tokio::test)]\nasync fn test_pagination_methods_across_await_boundaries() {\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // This demonstrates using the underlying pagination methods which are Send\n    let handle = tokio::spawn(async move {\n        // Simulate some async work\n        tokio::time::sleep(std::time::Duration::from_millis(1)).await;\n\n        // Use pagination methods directly - these are Send\n        let _ = lastfm_client.get_recent_scrobbles(1).await;\n        let _ = lastfm_client.get_artist_tracks_page(\"test\", 1).await;\n    });\n\n    // Don't actually await since it will fail without credentials\n    handle.abort();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","tests","vcr_tests.rs"],"content":"mod vcr;\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>