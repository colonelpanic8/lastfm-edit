<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","imalison","Projects","lastfm-edit","examples","artist_tracks_direct.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    let artist = \"The Beatles\";\n\n    println!(\"=== Artist Tracks Direct Example ===\\n\");\n    println!(\"🎵 Comparing album-based vs direct approach for: {artist}\");\n\n    // Test the direct approach\n    println!(\"\\n📄 Using direct paginated endpoint:\");\n    let mut direct_tracks = client.artist_tracks_direct(artist);\n    let direct_tracks_list = direct_tracks.take(10).await?;\n\n    println!(\n        \"✅ Found {} tracks using direct approach:\",\n        direct_tracks_list.len()\n    );\n    for (i, track) in direct_tracks_list.iter().enumerate() {\n        println!(\n            \"  {}. {} (played {} times)\",\n            i + 1,\n            track.name,\n            track.playcount\n        );\n        if let Some(album) = \u0026track.album {\n            println!(\"     Album: {album}\");\n        }\n    }\n\n    // Compare with album-based approach\n    println!(\"\\n📀 Using album-based approach:\");\n    let mut album_tracks = client.artist_tracks(artist);\n    let album_tracks_list = album_tracks.take(10).await?;\n\n    println!(\n        \"✅ Found {} tracks using album-based approach:\",\n        album_tracks_list.len()\n    );\n    for (i, track) in album_tracks_list.iter().enumerate() {\n        println!(\n            \"  {}. {} (played {} times)\",\n            i + 1,\n            track.name,\n            track.playcount\n        );\n        if let Some(album) = \u0026track.album {\n            println!(\"     Album: {album}\");\n        }\n    }\n\n    println!(\"\\n💡 The direct approach is more efficient as it uses:\");\n    println!(\n        \"   /user/{{username}}/library/music/{}/+tracks?page=N\u0026ajax=true\",\n        artist.replace(\" \", \"+\")\n    );\n    println!(\"   Instead of iterating through albums first.\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","clean_artist_tracks.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\nuse regex::Regex;\nuse std::collections::HashSet;\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let args: Vec\u003cString\u003e = env::args().collect();\n\n    if args.len() != 3 {\n        eprintln!(\n            \"Usage: cargo run --example clean_artist_tracks -- \\\"Artist Name\\\" \\\"Regex Pattern\\\"\"\n        );\n        eprintln!(\"Examples:\");\n        eprintln!(\"  # Remove remastered suffixes:\");\n        eprintln!(\"  cargo run --example clean_artist_tracks -- \\\"The Beatles\\\" \\\" - Remastered( \\\\d{{4}})?$\\\"\");\n        eprintln!(\"  # Remove live suffixes:\");\n        eprintln!(\"  cargo run --example clean_artist_tracks -- \\\"Pink Floyd\\\" \\\" \\\\(Live\\\\)$\\\"\");\n        eprintln!(\"  # Remove explicit tags:\");\n        eprintln!(\"  cargo run --example clean_artist_tracks -- \\\"Eminem\\\" \\\" \\\\(Explicit\\\\)$\\\"\");\n        std::process::exit(1);\n    }\n\n    let artist = \u0026args[1];\n    let pattern = \u0026args[2];\n\n    let regex = match Regex::new(pattern) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            eprintln!(\"❌ Invalid regex pattern '{pattern}': {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let client = common::setup_client().await?;\n\n    println!(\"=== Artist Catalog Cleanup Tool ===\\n\");\n    println!(\"🎨 ARTIST: {artist}\");\n    println!(\"🔍 PATTERN: {pattern}\");\n    println!(\"📝 This will clean track names by removing text matching the regex pattern\");\n    println!(\"\\n🚀 Starting catalog scan...\\n\");\n\n    // Track statistics\n    let mut total_tracks_scanned = 0;\n    let mut matching_tracks_found = 0;\n    let mut tracks_successfully_cleaned = 0;\n    let mut tracks_failed_to_clean = 0;\n    let mut already_cleaned_tracks = HashSet::new();\n\n    // Step 1: Collect all matching tracks first\n    println!(\"🔍 Step 1: Scanning entire {artist} catalog for matching tracks...\");\n    let mut all_matching_tracks = Vec::new();\n    let mut page = 1;\n\n    loop {\n        match client.get_artist_tracks_page(artist, page).await {\n            Ok(track_page) =\u003e {\n                if track_page.tracks.is_empty() {\n                    println!(\n                        \"📚 Reached end of {artist} catalog - scanned {total_tracks_scanned} tracks total\"\n                    );\n                    break;\n                }\n\n                for track in track_page.tracks {\n                    total_tracks_scanned += 1;\n\n                    // Print progress every 50 tracks\n                    if total_tracks_scanned % 50 == 0 {\n                        println!(\"📖 Scanned {total_tracks_scanned} tracks so far...\");\n                    }\n\n                    // Check if this track matches our pattern\n                    if regex.is_match(\u0026track.name) {\n                        let base_name = regex.replace(\u0026track.name, \"\").to_string();\n                        if !already_cleaned_tracks.contains(\u0026base_name) {\n                            all_matching_tracks.push(track);\n                            already_cleaned_tracks.insert(base_name);\n                            matching_tracks_found += 1;\n                        }\n                    }\n                }\n\n                if !track_page.has_next_page {\n                    println!(\n                        \"📚 Reached end of {artist} catalog - scanned {total_tracks_scanned} tracks total\"\n                    );\n                    break;\n                }\n\n                page += 1;\n            }\n            Err(e) =\u003e {\n                println!(\"❌ Error fetching tracks page {page}: {e}\");\n                break;\n            }\n        }\n    }\n\n    // Step 2: Process all found matching tracks\n    if all_matching_tracks.is_empty() {\n        println!(\"\\n🎉 No matching tracks found! Your {artist} catalog is already clean.\");\n        return Ok(());\n    }\n\n    println!(\n        \"\\n🎯 Step 2: Processing {} matching tracks...\",\n        all_matching_tracks.len()\n    );\n    already_cleaned_tracks.clear(); // Reset for actual processing\n\n    for (index, track) in all_matching_tracks.iter().enumerate() {\n        let clean_name = regex.replace(\u0026track.name, \"\").to_string();\n\n        println!(\n            \"\\n🎵 [{}/{}] Cleaning: '{}' → '{}'\",\n            index + 1,\n            all_matching_tracks.len(),\n            track.name,\n            clean_name\n        );\n\n        // Skip if we've already processed this track name in this session\n        if already_cleaned_tracks.contains(\u0026clean_name) {\n            println!(\"   ⏭️  Skipping - already processed in this session\");\n            continue;\n        }\n\n        // Load real edit form values from the track page\n        let edit_template = lastfm_edit::ScrobbleEdit::from_track_and_artist(\u0026track.name, artist);\n        match client\n            .discover_scrobble_edit_variations(\u0026edit_template)\n            .await\n        {\n            Ok(exact_edit_vec) =\u003e {\n                if let Some(exact_edit) = exact_edit_vec.into_iter().next() {\n                    let mut edit_data = exact_edit.to_scrobble_edit();\n                    println!(\n                        \"   📋 Loaded edit form data - Album: '{}'\",\n                        edit_data\n                            .album_name_original\n                            .as_deref()\n                            .unwrap_or(\"unknown\")\n                    );\n\n                    // Update the track name to the cleaned version\n                    edit_data.track_name = Some(clean_name.clone());\n\n                    println!(\"   🔧 Submitting edit...\");\n\n                    // Perform the edit\n                    match client.edit_scrobble(\u0026edit_data).await {\n                        Ok(_response) =\u003e {\n                            println!(\"   ✅ Successfully cleaned: '{clean_name}'\");\n                            tracks_successfully_cleaned += 1;\n                            already_cleaned_tracks.insert(clean_name);\n                        }\n                        Err(e) =\u003e {\n                            println!(\"   ❌ Error editing '{}': {}\", track.name, e);\n                            tracks_failed_to_clean += 1;\n                        }\n                    }\n                } else {\n                    println!(\"   ⚠️  No edit data found for track\");\n                    tracks_failed_to_clean += 1;\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"   ⚠️  Couldn't load edit form for '{}': {}\", track.name, e);\n                println!(\"      This track might not be in your recent scrobbles\");\n                tracks_failed_to_clean += 1;\n            }\n        }\n\n        // Add a small delay to be respectful to Last.fm servers\n        println!(\"   ⏳ Waiting 1.2s before next track...\");\n        tokio::time::sleep(tokio::time::Duration::from_millis(1200)).await;\n    }\n\n    // Print final statistics\n    println!(\"\\n{}\", \"=\".repeat(60));\n    println!(\"🎼 {} CATALOG CLEANUP COMPLETE\", artist.to_uppercase());\n    println!(\"{}\", \"=\".repeat(60));\n    println!(\"📊 STATISTICS:\");\n    println!(\"   • Total tracks scanned: {total_tracks_scanned}\");\n    println!(\"   • Matching tracks found: {matching_tracks_found}\");\n    println!(\"   • Tracks successfully cleaned: {tracks_successfully_cleaned}\");\n    println!(\"   • Tracks failed to clean: {tracks_failed_to_clean}\");\n\n    if tracks_successfully_cleaned \u003e 0 {\n        println!(\n            \"\\n✨ Your {artist} catalog is now cleaner! Pattern '{pattern}' has been removed from track names.\"\n        );\n    }\n\n    if tracks_failed_to_clean \u003e 0 {\n        println!(\"\\n⚠️  Some tracks couldn't be cleaned. This usually happens when:\");\n        println!(\"   • The track hasn't been scrobbled recently\");\n        println!(\"   • The track data isn't in your listening history\");\n        println!(\"   • There were temporary server issues\");\n        println!(\"\\n💡 You can re-run this script later to try cleaning the remaining tracks.\");\n    }\n\n    println!(\"\\n🎵 {artist} catalog cleanup completed!\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","custom_session_manager.rs"],"content":"/// Example demonstrating how to use SessionManager with custom app names.\n///\n/// This example shows how other libraries can use SessionManager to store\n/// Last.fm sessions with their own application prefix in XDG directories.\n///\n/// Usage:\n///   direnv exec . cargo run --example custom_session_manager\nuse lastfm_edit::{LastFmEditClientImpl, SessionManager};\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    env_logger::init();\n\n    println!(\"🎵 Custom SessionManager Example\");\n    println!(\"=================================\\n\");\n\n    // Create a custom session manager for your application\n    let session_manager = SessionManager::new(\"my-music-app\");\n    println!(\"📁 Using app name: '{}'\", session_manager.app_name());\n    println!(\"📂 Sessions will be stored in: ~/.local/share/my-music-app/users/{{username}}/session.json\\n\");\n\n    let username = env::var(\"LASTFM_EDIT_USERNAME\")\n        .expect(\"LASTFM_EDIT_USERNAME environment variable not set\");\n    let password = env::var(\"LASTFM_EDIT_PASSWORD\")\n        .expect(\"LASTFM_EDIT_PASSWORD environment variable not set\");\n\n    // Check if we have a saved session with our custom manager\n    if session_manager.session_exists(\u0026username) {\n        println!(\"📁 Found existing session for user '{username}', attempting to restore...\");\n\n        match session_manager.load_session(\u0026username) {\n            Ok(session) =\u003e {\n                println!(\"📥 Session loaded successfully\");\n\n                // Create client with loaded session\n                let http_client = http_client::native::NativeClient::new();\n                let client = LastFmEditClientImpl::from_session(Box::new(http_client), session);\n\n                // Validate the session\n                println!(\"🔍 Validating session...\");\n                if client.validate_session().await {\n                    println!(\"✅ Session is valid, using saved session\");\n\n                    // Test the session by fetching recent tracks\n                    println!(\"🎧 Testing session by fetching recent tracks...\");\n                    let tracks = client.get_recent_scrobbles(1).await?;\n                    let recent_tracks: Vec\u003c_\u003e = tracks.into_iter().take(3).collect();\n                    println!(\"📊 Found {} recent tracks:\", recent_tracks.len());\n\n                    for track in recent_tracks {\n                        println!(\"   🎵 {} - {}\", track.artist, track.name);\n                    }\n\n                    return Ok(());\n                } else {\n                    println!(\"❌ Session is invalid or expired\");\n                    // Remove invalid session file\n                    let _ = session_manager.remove_session(\u0026username);\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"❌ Failed to load session: {e}\");\n                // Remove corrupted session file\n                let _ = session_manager.remove_session(\u0026username);\n            }\n        }\n    }\n\n    // No valid session found, perform fresh login\n    println!(\"🔐 No valid session found, performing fresh login...\");\n    let http_client = http_client::native::NativeClient::new();\n    let client =\n        LastFmEditClientImpl::login_with_credentials(Box::new(http_client), \u0026username, \u0026password)\n            .await?;\n\n    // Save the new session with our custom manager\n    println!(\"💾 Saving session with custom session manager...\");\n    let session = client.get_session();\n    if let Err(e) = session_manager.save_session(\u0026session) {\n        println!(\"⚠️  Warning: Failed to save session: {e}\");\n        println!(\"   (You'll need to login again next time)\");\n    } else {\n        println!(\"✅ Session saved to custom location\");\n\n        // Show the session path\n        let session_path = session_manager.get_session_path(\u0026username)?;\n        println!(\"📂 Session saved to: {}\", session_path.display());\n    }\n\n    // Test the new session\n    println!(\"🎧 Testing session by fetching recent tracks...\");\n    let tracks = client.get_recent_scrobbles(1).await?;\n    let recent_tracks: Vec\u003c_\u003e = tracks.into_iter().take(3).collect();\n    println!(\"📊 Found {} recent tracks:\", recent_tracks.len());\n\n    for track in recent_tracks {\n        println!(\"   🎵 {} - {}\", track.artist, track.name);\n    }\n\n    // Demonstrate listing saved users\n    println!(\"\\n👥 Listing all saved users for this app:\");\n    let saved_users = session_manager.list_saved_users()?;\n    if saved_users.is_empty() {\n        println!(\"   No saved users found\");\n    } else {\n        for user in saved_users {\n            println!(\"   - {user}\");\n        }\n    }\n\n    println!(\"\\n🎉 Example completed!\");\n    println!(\"💡 Your custom session is saved separately from the default lastfm-edit sessions.\");\n    println!(\n        \"💡 Other apps using SessionManager with different names won't interfere with each other.\"\n    );\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","debug_album_url.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::Result;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    let artist = \"Radiohead\";\n    let album = \"In Rainbows\";\n\n    println!(\"=== Debug Album URL Test ===\\n\");\n    println!(\"🔍 Testing URL construction for album tracks...\");\n    println!(\"Artist: {artist}\");\n    println!(\"Album: {album}\\n\");\n\n    // First, let's see if the artist has albums at all\n    println!(\"1. Testing artist albums page...\");\n    match client.get_artist_albums_page(artist, 1).await {\n        Ok(albums_page) =\u003e {\n            println!(\"✅ Found {} albums for {artist}\", albums_page.albums.len());\n            for (i, album_item) in albums_page.albums.iter().enumerate().take(5) {\n                println!(\n                    \"   [{i}] '{}' ({} plays)\",\n                    album_item.name, album_item.playcount\n                );\n            }\n        }\n        Err(e) =\u003e {\n            println!(\"❌ Error getting albums: {e}\");\n            return Ok(());\n        }\n    }\n\n    println!(\"\\n2. Testing album tracks page...\");\n    match client.get_album_tracks_page(album, artist, 1).await {\n        Ok(tracks_page) =\u003e {\n            println!(\n                \"✅ Album tracks page returned {} tracks\",\n                tracks_page.tracks.len()\n            );\n            println!(\"   Has next page: {}\", tracks_page.has_next_page);\n            println!(\"   Total pages: {:?}\", tracks_page.total_pages);\n            for (i, track) in tracks_page.tracks.iter().enumerate().take(10) {\n                println!(\n                    \"   [{i}] '{}' - Album: '{}'\",\n                    track.name,\n                    track.album.as_deref().unwrap_or(\"(none)\")\n                );\n            }\n        }\n        Err(e) =\u003e {\n            println!(\"❌ Error getting album tracks: {e}\");\n        }\n    }\n\n    // Let's also test with an album we know exists from the albums list\n    println!(\"\\n3. Testing with first album from albums list...\");\n    match client.get_artist_albums_page(artist, 1).await {\n        Ok(albums_page) =\u003e {\n            if let Some(first_album) = albums_page.albums.first() {\n                println!(\"Testing with album: '{}'\", first_album.name);\n                match client\n                    .get_album_tracks_page(\u0026first_album.name, artist, 1)\n                    .await\n                {\n                    Ok(tracks_page) =\u003e {\n                        println!(\n                            \"✅ Found {} tracks for '{}'\",\n                            tracks_page.tracks.len(),\n                            first_album.name\n                        );\n                        for (i, track) in tracks_page.tracks.iter().enumerate().take(5) {\n                            println!(\"   [{i}] '{}'\", track.name);\n                        }\n                    }\n                    Err(e) =\u003e {\n                        println!(\"❌ Error: {e}\");\n                    }\n                }\n            } else {\n                println!(\"No albums found in list\");\n            }\n        }\n        Err(e) =\u003e {\n            println!(\"❌ Error getting albums: {e}\");\n        }\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","list_artist_tracks.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    let artist = std::env::args()\n        .nth(1)\n        .unwrap_or_else(|| \"Queen\".to_string());\n\n    println!(\"=== Artist Tracks Listing (using Iterator) ===\\n\");\n    println!(\"🎵 Listing all tracks for artist: {artist}\\n\");\n\n    // Use the iterator the same way as Case 4: Artist-specific discovery\n    let mut tracks_iterator = client.artist_tracks(\u0026artist);\n    let mut track_count = 0;\n\n    println!(\"🔍 Fetching tracks using iterator...\\n\");\n\n    while let Some(track) = tracks_iterator.next().await? {\n        track_count += 1;\n        println!(\n            \"[{:4}] '{}' | Album: '{}' | Plays: {} | Timestamp: {:?}\",\n            track_count,\n            track.name,\n            track.album.as_deref().unwrap_or(\"(no album)\"),\n            track.playcount,\n            track.timestamp\n        );\n\n        // Limit output for testing to avoid overwhelming output\n        if track_count \u003e= 50 {\n            println!(\"\\n⚠️  Limiting output to first 50 tracks for testing...\");\n            break;\n        }\n    }\n\n    println!(\"\\n=== Summary ===\");\n    println!(\"📊 Total tracks displayed: {track_count}\");\n\n    if let Some(total_pages) = tracks_iterator.total_pages() {\n        println!(\"📄 Total pages available: {total_pages}\");\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","list_recent_tracks.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    // Parse command line arguments\n    let args: Vec\u003cString\u003e = env::args().collect();\n    let num_tracks: usize = args.get(1).and_then(|s| s.parse().ok()).unwrap_or(20);\n    let starting_page: u32 = args.get(2).and_then(|s| s.parse().ok()).unwrap_or(1);\n\n    println!(\"Fetching {num_tracks} recent tracks starting from page {starting_page}...\");\n    println!();\n\n    // Create iterator starting from the specified page\n    let mut recent_tracks = client.recent_tracks_from_page(starting_page);\n    let mut count = 0;\n\n    // Use the iterator to fetch tracks\n    while count \u003c num_tracks {\n        match recent_tracks.next().await? {\n            Some(track) =\u003e {\n                let timestamp_str = if let Some(ts) = track.timestamp {\n                    format!(\n                        \" ({})\",\n                        chrono::DateTime::from_timestamp(ts as i64, 0)\n                            .map(|dt| dt.format(\"%Y-%m-%d %H:%M:%S\").to_string())\n                            .unwrap_or_else(|| format!(\"timestamp: {ts}\"))\n                    )\n                } else {\n                    \" (no timestamp)\".to_string()\n                };\n\n                let album_str = if let Some(album) = \u0026track.album {\n                    format!(\" [{album}]\")\n                } else {\n                    \"\".to_string()\n                };\n\n                println!(\n                    \"{}. {} - {}{}{}\",\n                    count + 1,\n                    track.artist,\n                    track.name,\n                    album_str,\n                    timestamp_str\n                );\n\n                count += 1;\n            }\n            None =\u003e {\n                println!(\"No more tracks available.\");\n                break;\n            }\n        }\n    }\n\n    println!();\n    println!(\"Fetched {count} tracks total.\");\n\n    println!();\n    println!(\"Usage: cargo run --example list_recent_tracks [num_tracks] [starting_page]\");\n    println!(\"  num_tracks    - Number of tracks to fetch (default: 20)\");\n    println!(\"  starting_page - Page number to start from (default: 1)\");\n    println!();\n    println!(\"Examples:\");\n    println!(\"  cargo run --example list_recent_tracks 50     # Fetch 50 tracks from page 1\");\n    println!(\n        \"  cargo run --example list_recent_tracks 20 5   # Fetch 20 tracks starting from page 5\"\n    );\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","rate_limit_monitoring.rs"],"content":"use lastfm_edit::{ClientEvent, LastFmEditClientImpl};\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    env_logger::init();\n\n    let username =\n        env::var(\"LASTFM_EDIT_USERNAME\").expect(\"Set LASTFM_EDIT_USERNAME environment variable\");\n    let password =\n        env::var(\"LASTFM_EDIT_PASSWORD\").expect(\"Set LASTFM_EDIT_PASSWORD environment variable\");\n\n    // Login and create client\n    let http_client = http_client::native::NativeClient::new();\n    println!(\"Logging in as {username}...\");\n    let client =\n        LastFmEditClientImpl::login_with_credentials(Box::new(http_client), \u0026username, \u0026password)\n            .await?;\n\n    // Subscribe to client events before any operations\n    let mut events = client.subscribe();\n\n    // Spawn a background task to monitor events\n    let event_monitor = tokio::spawn(async move {\n        println!(\"🔍 Monitoring client events...\");\n        while let Ok(event) = events.recv().await {\n            match event {\n                ClientEvent::RequestStarted { request } =\u003e {\n                    println!(\"🚀 Starting request: {}\", request.short_description());\n                }\n                ClientEvent::RequestCompleted {\n                    request,\n                    status_code,\n                    duration_ms,\n                } =\u003e {\n                    println!(\n                        \"✅ Completed request: {} - {} ({} ms)\",\n                        request.short_description(),\n                        status_code,\n                        duration_ms\n                    );\n                }\n                ClientEvent::RateLimited {\n                    delay_seconds,\n                    request,\n                    rate_limit_type,\n                    rate_limit_timestamp,\n                } =\u003e {\n                    let req_desc = request\n                        .as_ref()\n                        .map(|r| r.short_description())\n                        .unwrap_or_else(|| \"unknown request\".to_string());\n                    println!(\n                        \"⏳ Rate limited ({rate_limit_type:?})! {req_desc} - Waiting {delay_seconds} seconds (at timestamp {rate_limit_timestamp})\"\n                    );\n                }\n                ClientEvent::RateLimitEnded {\n                    request,\n                    rate_limit_type,\n                    total_rate_limit_duration_seconds,\n                } =\u003e {\n                    println!(\n                        \"🎉 Rate limiting ended ({rate_limit_type:?}) after {total_rate_limit_duration_seconds} seconds - {}\",\n                        request.short_description()\n                    );\n                }\n                ClientEvent::EditAttempted {\n                    edit,\n                    success,\n                    error_message,\n                    duration_ms,\n                } =\u003e {\n                    if success {\n                        println!(\n                            \"✅ Edit succeeded: '{}' -\u003e '{}' ({duration_ms} ms)\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    } else {\n                        let error_msg = error_message\n                            .as_ref()\n                            .map(|s| format!(\" - {s}\"))\n                            .unwrap_or_default();\n                        println!(\n                            \"❌ Edit failed: '{}' -\u003e '{}' ({duration_ms} ms){error_msg}\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    }\n                }\n            }\n        }\n    });\n\n    println!(\"✅ Successfully logged in as: {}\", client.username());\n\n    // Check latest event after login\n    if let Some(event) = client.latest_event() {\n        match event {\n            ClientEvent::RequestStarted { request } =\u003e {\n                println!(\n                    \"📊 Latest event: Started request {}\",\n                    request.short_description()\n                );\n            }\n            ClientEvent::RequestCompleted {\n                request,\n                status_code,\n                duration_ms,\n            } =\u003e {\n                println!(\n                    \"📊 Latest event: Completed request {} - {} ({} ms)\",\n                    request.short_description(),\n                    status_code,\n                    duration_ms\n                );\n            }\n            ClientEvent::RateLimited {\n                delay_seconds,\n                request,\n                rate_limit_type,\n                rate_limit_timestamp,\n            } =\u003e {\n                let req_desc = request\n                    .as_ref()\n                    .map(|r| r.short_description())\n                    .unwrap_or_else(|| \"unknown request\".to_string());\n                println!(\n                    \"📊 Latest event: Rate limited ({rate_limit_type:?}) for {delay_seconds} seconds - {req_desc} (at timestamp {rate_limit_timestamp})\"\n                );\n            }\n            ClientEvent::RateLimitEnded {\n                request,\n                rate_limit_type,\n                total_rate_limit_duration_seconds,\n            } =\u003e {\n                println!(\n                    \"📊 Latest event: Rate limiting ended ({rate_limit_type:?}) after {total_rate_limit_duration_seconds} seconds - {}\",\n                    request.short_description()\n                );\n            }\n            ClientEvent::EditAttempted {\n                edit,\n                success,\n                error_message,\n                duration_ms,\n            } =\u003e {\n                if success {\n                    println!(\n                        \"📊 Latest event: Edit succeeded '{}' -\u003e '{}' ({duration_ms} ms)\",\n                        edit.track_name_original, edit.track_name\n                    );\n                } else {\n                    let error_msg = error_message\n                        .as_ref()\n                        .map(|s| format!(\" - {s}\"))\n                        .unwrap_or_default();\n                    println!(\n                        \"📊 Latest event: Edit failed '{}' -\u003e '{}' ({duration_ms} ms){error_msg}\",\n                        edit.track_name_original, edit.track_name\n                    );\n                }\n            }\n        }\n    } else {\n        println!(\"📊 No events have occurred yet\");\n    }\n\n    // Make some requests that might trigger rate limiting\n    println!(\"🎵 Fetching recent tracks to potentially trigger rate limiting...\");\n\n    for page in 1..=3 {\n        println!(\"📄 Fetching page {page}...\");\n        match client.get_recent_scrobbles(page).await {\n            Ok(tracks) =\u003e {\n                println!(\"✅ Got {} tracks from page {page}\", tracks.len());\n            }\n            Err(e) =\u003e {\n                println!(\"❌ Error on page {page}: {e}\");\n            }\n        }\n\n        // Check if we're currently rate limited\n        if let Some(ClientEvent::RateLimited { delay_seconds, .. }) = client.latest_event() {\n            println!(\n                \"🛑 Currently rate limited for {delay_seconds} seconds according to latest event\"\n            );\n        }\n\n        // Small delay between requests\n        tokio::time::sleep(std::time::Duration::from_millis(500)).await;\n    }\n\n    println!(\"🏁 Done! Event monitor will continue running...\");\n\n    // Let the event monitor run for a bit longer to catch any final events\n    tokio::time::sleep(std::time::Duration::from_secs(2)).await;\n\n    // Cancel the event monitor\n    event_monitor.abort();\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","remove_remaster.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\nuse regex::Regex;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    println!(\"=== Remaster \u0026 Year Removal Tool ===\\n\");\n    println!(\"🎯 This will remove 'remastered' text and year suffixes from track names\");\n    println!(\"📝 Patterns include: '- 2009', '(2009)', '[2009]', '- Remaster', etc.\\n\");\n\n    let artist = std::env::args()\n        .nth(1)\n        .unwrap_or_else(|| \"The Beatles\".to_string());\n\n    println!(\"🎵 Processing tracks for artist: {artist}\\n\");\n\n    // Regex patterns to clean up remaster text and year suffixes\n    // Note: Order matters! More specific patterns should come first\n    let remaster_patterns = vec![\n        // Patterns with \"remaster\" word (most specific)\n        // \"Track Name - 2009 Remaster\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*-\\s*\\d{4}\\s*remaster(ed)?.*$\").unwrap(),\n        // \"Track Name - Remaster\" or \"Track Name - Remastered\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*-\\s*remaster(ed)?.*$\").unwrap(),\n        // \"Track Name (2009 Remaster)\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*\\(\\d{4}\\s*remaster(ed)?.*\\)\\s*$\").unwrap(),\n        // \"Track Name (Remaster)\" or \"Track Name (Remastered)\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*\\(remaster(ed)?.*\\)\\s*$\").unwrap(),\n        // \"Track Name [2009 Remaster]\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*\\[\\d{4}\\s*remaster(ed)?.*\\]\\s*$\").unwrap(),\n        // \"Track Name [Remaster]\" or \"Track Name [Remastered]\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*\\[remaster(ed)?.*\\]\\s*$\").unwrap(),\n        // \"Track Name Remastered\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*remaster(ed)?\\s*(\\d{4})?\\s*$\").unwrap(),\n        // Years that are likely remaster years (1980-2030) - be more conservative\n        // \"Track Name - 2009\" -\u003e \"Track Name\" (only for likely remaster years)\n        Regex::new(r\"(?i)\\s*-\\s*(19[8-9]\\d|20[0-3]\\d)\\s*$\").unwrap(),\n        // \"Track Name (2009)\" -\u003e \"Track Name\" (only for likely remaster years)\n        Regex::new(r\"(?i)\\s*\\((19[8-9]\\d|20[0-3]\\d)\\)\\s*$\").unwrap(),\n        // \"Track Name [2009]\" -\u003e \"Track Name\" (only for likely remaster years)\n        Regex::new(r\"(?i)\\s*\\[(19[8-9]\\d|20[0-3]\\d)\\]\\s*$\").unwrap(),\n        // Other common suffixes that should be removed\n        // \"Track Name - 2019 Mix\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*-\\s*\\d{4}\\s*mix.*$\").unwrap(),\n        // \"Track Name - Mix\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*-\\s*mix.*$\").unwrap(),\n    ];\n\n    // First, collect some tracks to process\n    let mut tracks_to_process = Vec::new();\n    let mut fetched_count = 0;\n    let mut page = 1;\n\n    loop {\n        match client.get_artist_tracks_page(\u0026artist, page).await {\n            Ok(track_page) =\u003e {\n                if track_page.tracks.is_empty() {\n                    println!(\"\\n📚 Fetched all {fetched_count} tracks for {artist}\");\n                    break;\n                }\n\n                for track in track_page.tracks {\n                    fetched_count += 1;\n                    println!(\"🔍 [{:3}] Found track: '{}'\", fetched_count, track.name);\n\n                    // Check if track name contains remaster text\n                    let mut cleaned_name = track.name.clone();\n                    let mut needs_cleaning = false;\n\n                    for pattern in \u0026remaster_patterns {\n                        if pattern.is_match(\u0026cleaned_name) {\n                            cleaned_name = pattern.replace(\u0026cleaned_name, \"\").trim().to_string();\n                            needs_cleaning = true;\n                        }\n                    }\n\n                    if needs_cleaning \u0026\u0026 !cleaned_name.is_empty() {\n                        tracks_to_process.push((track, cleaned_name));\n                    }\n                }\n\n                if !track_page.has_next_page {\n                    println!(\"\\n📚 Fetched all {fetched_count} tracks for {artist}\");\n                    break;\n                }\n\n                page += 1;\n            }\n            Err(e) =\u003e {\n                println!(\"❌ Error fetching tracks page {page}: {e}\");\n                break;\n            }\n        }\n    }\n\n    println!(\n        \"\\n🧹 Starting remaster removal on {} tracks...\\n\",\n        tracks_to_process.len()\n    );\n\n    let mut processed_count = 0;\n    let mut edits_made = 0;\n    let mut rate_limit_hits = 0;\n\n    // Now process the collected tracks\n    for (track, cleaned_name) in tracks_to_process {\n        processed_count += 1;\n        println!(\n            \"🔧 [{:3}] Processing: '{}' -\u003e '{}'\",\n            processed_count, track.name, cleaned_name\n        );\n        println!(\"   🔄 Applying change...\");\n\n        // Load edit form - this makes an HTTP request\n        let edit_template =\n            lastfm_edit::ScrobbleEdit::from_track_and_artist(\u0026track.name, \u0026track.artist);\n        match client\n            .discover_scrobble_edit_variations(\u0026edit_template)\n            .await\n        {\n            Ok(exact_edit_vec) =\u003e {\n                if let Some(exact_edit) = exact_edit_vec.into_iter().next() {\n                    let mut edit_data = exact_edit.to_scrobble_edit();\n                    // Update track name\n                    edit_data.track_name = Some(cleaned_name.clone());\n\n                    // Submit edit - another HTTP request\n                    match client.edit_scrobble(\u0026edit_data).await {\n                        Ok(_) =\u003e {\n                            edits_made += 1;\n                            println!(\"   ✅ Successfully cleaned track\");\n                        }\n                        Err(e) =\u003e {\n                            println!(\"   ❌ Error editing track: {e}\");\n                            if e.to_string().contains(\"RateLimit\") {\n                                rate_limit_hits += 1;\n                                log::info!(\"Rate limit encountered during edit operation for track '{}' by '{}'\", track.name, track.artist);\n                                println!(\"   🚨 RATE LIMIT DETECTED during edit operation!\");\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    println!(\"   ⚠️  No edit data found for track\");\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"   ⚠️  Couldn't load edit form: {e}\");\n                if e.to_string().contains(\"RateLimit\") {\n                    rate_limit_hits += 1;\n                    log::info!(\n                        \"Rate limit encountered during form load for track '{}' by '{}'\",\n                        track.name,\n                        track.artist\n                    );\n                    println!(\"   🚨 RATE LIMIT DETECTED during form load!\");\n                    break;\n                }\n            }\n        }\n    }\n\n    println!(\"\\n=== Summary ===\");\n    println!(\"📊 Tracks processed: {processed_count}\");\n    println!(\"✏️  Edits made: {edits_made}\");\n    println!(\"🚨 Rate limit hits: {rate_limit_hits}\");\n\n    if rate_limit_hits \u003e 0 {\n        println!(\"\\n🎯 Rate limiting was triggered.\");\n    } else {\n        println!(\"\\n✨ All changes completed successfully!\");\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","rename_album.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let args: Vec\u003cString\u003e = env::args().collect();\n\n    if args.len() != 4 {\n        eprintln!(\"Usage: cargo run --example rename_album -- \\\"Old Album Name\\\" \\\"New Album Name\\\" \\\"Artist Name\\\"\");\n        eprintln!(\"Example: cargo run --example rename_album -- \\\"Abbey Road - Remastered 2019\\\" \\\"Abbey Road\\\" \\\"The Beatles\\\"\");\n        std::process::exit(1);\n    }\n\n    let old_album_name = \u0026args[1];\n    let new_album_name = \u0026args[2];\n    let artist_name = \u0026args[3];\n\n    let client = common::setup_client().await?;\n\n    println!(\"=== Album Rename Tool ===\\n\");\n    println!(\"🎨 Artist: {artist_name}\");\n    println!(\"💿 Renaming: '{old_album_name}' → '{new_album_name}'\");\n    println!();\n\n    println!(\"🔍 Loading album edit form data...\");\n    match client\n        .edit_album(old_album_name, new_album_name, artist_name)\n        .await\n    {\n        Ok(_response) =\u003e {\n            println!(\"✅ Successfully renamed album!\");\n            println!(\"   From: '{old_album_name}'\");\n            println!(\"   To:   '{new_album_name}'\");\n            println!(\"   Artist: {artist_name}\");\n            println!(\n                \"\\n💡 All scrobbles from this album have been updated with the new album name.\"\n            );\n        }\n        Err(e) =\u003e {\n            println!(\"❌ Failed to rename album: {e}\");\n            println!(\"\\nThis might happen if:\");\n            println!(\"   • The album hasn't been scrobbled recently\");\n            println!(\"   • The album name doesn't match exactly\");\n            println!(\"   • There are temporary server issues\");\n        }\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","rename_artist.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::Result;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let mut client = common::setup_client().await?;\n\n    let args: Vec\u003cString\u003e = std::env::args().collect();\n    if args.len() \u003c 4 {\n        eprintln!(\"Usage:\");\n        eprintln!(\"  {} all \u003cold_artist\u003e \u003cnew_artist\u003e\", args[0]);\n        eprintln!(\"  {} track \u003ctrack_name\u003e \u003cold_artist\u003e \u003cnew_artist\u003e\", args[0]);\n        eprintln!(\"  {} album \u003calbum_name\u003e \u003cold_artist\u003e \u003cnew_artist\u003e\", args[0]);\n        eprintln!();\n        eprintln!(\"Examples:\");\n        eprintln!(\"  {} all \\\"The Beatles\\\" \\\"Beatles\\\"\", args[0]);\n        eprintln!(\n            \"  {} track \\\"Hey Jude\\\" \\\"The Beatles\\\" \\\"Beatles\\\"\",\n            args[0]\n        );\n        eprintln!(\n            \"  {} album \\\"Abbey Road\\\" \\\"The Beatles\\\" \\\"Beatles\\\"\",\n            args[0]\n        );\n        std::process::exit(1);\n    }\n\n    let mode = \u0026args[1];\n\n    match mode.as_str() {\n        \"all\" =\u003e {\n            if args.len() != 4 {\n                eprintln!(\"Usage: {} all \u003cold_artist\u003e \u003cnew_artist\u003e\", args[0]);\n                std::process::exit(1);\n            }\n            let old_artist = \u0026args[2];\n            let new_artist = \u0026args[3];\n            rename_all_tracks(\u0026mut client, old_artist, new_artist).await\n        }\n        \"track\" =\u003e {\n            if args.len() != 5 {\n                eprintln!(\n                    \"Usage: {} track \u003ctrack_name\u003e \u003cold_artist\u003e \u003cnew_artist\u003e\",\n                    args[0]\n                );\n                std::process::exit(1);\n            }\n            let track_name = \u0026args[2];\n            let old_artist = \u0026args[3];\n            let new_artist = \u0026args[4];\n            rename_single_track(\u0026mut client, track_name, old_artist, new_artist).await\n        }\n        \"album\" =\u003e {\n            if args.len() != 5 {\n                eprintln!(\n                    \"Usage: {} album \u003calbum_name\u003e \u003cold_artist\u003e \u003cnew_artist\u003e\",\n                    args[0]\n                );\n                std::process::exit(1);\n            }\n            let album_name = \u0026args[2];\n            let old_artist = \u0026args[3];\n            let new_artist = \u0026args[4];\n            rename_album_tracks(\u0026mut client, album_name, old_artist, new_artist).await\n        }\n        _ =\u003e {\n            eprintln!(\"Invalid mode '{mode}'. Use 'all', 'track', or 'album'\");\n            std::process::exit(1);\n        }\n    }\n}\n\nasync fn rename_all_tracks(\n    client: \u0026mut dyn lastfm_edit::LastFmEditClient,\n    old_artist: \u0026str,\n    new_artist: \u0026str,\n) -\u003e Result\u003c()\u003e {\n    println!(\"=== Artist Rename Tool - All Tracks ===\\n\");\n    println!(\"🎯 This will rename ALL tracks from one artist to another\");\n    println!(\"📝 Old artist: '{old_artist}'\");\n    println!(\"📝 New artist: '{new_artist}'\");\n    println!(\"⚠️  This will edit ALL tracks that are found in your recent scrobbles!\\n\");\n\n    if !confirm_operation()? {\n        return Ok(());\n    }\n\n    println!(\"\\n🔍 Starting artist rename operation...\\n\");\n\n    match client.edit_artist(old_artist, new_artist).await {\n        Ok(response) =\u003e print_result(response),\n        Err(e) =\u003e println!(\"❌ Error during artist rename: {e}\"),\n    }\n\n    Ok(())\n}\n\nasync fn rename_single_track(\n    client: \u0026mut dyn lastfm_edit::LastFmEditClient,\n    track_name: \u0026str,\n    old_artist: \u0026str,\n    new_artist: \u0026str,\n) -\u003e Result\u003c()\u003e {\n    println!(\"=== Artist Rename Tool - Single Track ===\\n\");\n    println!(\"🎯 This will rename the artist for a specific track\");\n    println!(\"🎵 Track: '{track_name}'\");\n    println!(\"📝 Old artist: '{old_artist}'\");\n    println!(\"📝 New artist: '{new_artist}'\");\n    println!(\"⚠️  This will only edit this specific track if found in recent scrobbles!\\n\");\n\n    if !confirm_operation()? {\n        return Ok(());\n    }\n\n    println!(\"\\n🔍 Starting track artist rename...\\n\");\n\n    match client\n        .edit_artist_for_track(track_name, old_artist, new_artist)\n        .await\n    {\n        Ok(response) =\u003e print_result(response),\n        Err(e) =\u003e println!(\"❌ Error during track artist rename: {e}\"),\n    }\n\n    Ok(())\n}\n\nasync fn rename_album_tracks(\n    client: \u0026mut dyn lastfm_edit::LastFmEditClient,\n    album_name: \u0026str,\n    old_artist: \u0026str,\n    new_artist: \u0026str,\n) -\u003e Result\u003c()\u003e {\n    println!(\"=== Artist Rename Tool - Album Tracks ===\\n\");\n    println!(\"🎯 This will rename the artist for all tracks in a specific album\");\n    println!(\"💿 Album: '{album_name}'\");\n    println!(\"📝 Old artist: '{old_artist}'\");\n    println!(\"📝 New artist: '{new_artist}'\");\n    println!(\"⚠️  This will edit all tracks in this album that are found in recent scrobbles!\\n\");\n\n    if !confirm_operation()? {\n        return Ok(());\n    }\n\n    println!(\"\\n🔍 Starting album artist rename...\\n\");\n\n    match client\n        .edit_artist_for_album(album_name, old_artist, new_artist)\n        .await\n    {\n        Ok(response) =\u003e print_result(response),\n        Err(e) =\u003e println!(\"❌ Error during album artist rename: {e}\"),\n    }\n\n    Ok(())\n}\n\nfn confirm_operation() -\u003e Result\u003cbool\u003e {\n    print!(\"Are you sure you want to continue? [y/N]: \");\n    std::io::Write::flush(\u0026mut std::io::stdout()).unwrap();\n\n    let mut input = String::new();\n    std::io::stdin().read_line(\u0026mut input).unwrap();\n    let response = input.trim().to_lowercase();\n\n    if response != \"y\" \u0026\u0026 response != \"yes\" {\n        println!(\"Operation cancelled.\");\n        return Ok(false);\n    }\n\n    Ok(true)\n}\n\nfn print_result(response: lastfm_edit::EditResponse) {\n    if response.success() {\n        println!(\"✅ Success!\");\n        if let Some(message) = response.message() {\n            println!(\"📋 {message}\");\n        }\n    } else {\n        println!(\"❌ Operation failed\");\n        if let Some(message) = response.message() {\n            println!(\"📋 {message}\");\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","save_album_response.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::Result;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    // Test the URL construction manually to see what's wrong\n    let artist = \"Radiohead\";\n    let album = \"In Rainbows\";\n\n    // Get the session details to construct URLs manually\n    let session = client.get_session();\n    println!(\"Username: {}\", session.username);\n    println!(\"Base URL: {}\", session.base_url);\n\n    // Construct the URL we're using\n    let url = format!(\n        \"{}/user/{}/library/music/{}/{}/+tracks?page=1\u0026ajax=true\",\n        session.base_url,\n        session.username,\n        artist.replace(\" \", \"+\"),\n        album.replace(\" \", \"+\")\n    );\n\n    println!(\"Constructed URL: {url}\");\n\n    // Let's also try some variations (manually encoded):\n    let artist_encoded = artist.replace(\" \", \"%20\");\n    let album_encoded = album.replace(\" \", \"%20\");\n    let url_encoded = format!(\n        \"{}/user/{}/library/music/{}/{}/+tracks?page=1\u0026ajax=true\",\n        session.base_url, session.username, artist_encoded, album_encoded\n    );\n\n    println!(\"URL encoded version: {url_encoded}\");\n\n    // Test with a manually constructed HTTP client to see what we get\n    println!(\"\\nMaking direct HTTP request to see response...\");\n\n    // Make the request using the client's internal HTTP client\n    // We'll access this by making the client call directly and examining response\n    match client.get_album_tracks_page(album, artist, 1).await {\n        Ok(tracks_page) =\u003e {\n            println!(\"Success: {} tracks\", tracks_page.tracks.len());\n        }\n        Err(e) =\u003e {\n            println!(\"Error: {e}\");\n        }\n    }\n\n    // Let's also check what a working artist tracks URL looks like for comparison\n    let artist_tracks_url = format!(\n        \"{}/user/{}/library/music/{}/+tracks?page=1\u0026ajax=true\",\n        session.base_url,\n        session.username,\n        artist.replace(\" \", \"+\")\n    );\n    println!(\"Artist tracks URL (working): {artist_tracks_url}\");\n\n    // And albums URL\n    let artist_albums_url = format!(\n        \"{}/user/{}/library/music/{}/+albums?page=1\u0026ajax=true\",\n        session.base_url,\n        session.username,\n        artist.replace(\" \", \"+\")\n    );\n    println!(\"Artist albums URL (working): {artist_albums_url}\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","session_event_sharing.rs"],"content":"use lastfm_edit::{ClientEvent, LastFmEditClientImpl};\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    env_logger::init();\n\n    let username =\n        env::var(\"LASTFM_EDIT_USERNAME\").expect(\"Set LASTFM_EDIT_USERNAME environment variable\");\n    let password =\n        env::var(\"LASTFM_EDIT_PASSWORD\").expect(\"Set LASTFM_EDIT_PASSWORD environment variable\");\n\n    println!(\"🔧 Demonstrating shared event broadcasting between clients...\");\n\n    // Create HTTP client and login to create first client\n    let http_client = http_client::native::NativeClient::new();\n    println!(\"🔐 Logging in with client1...\");\n    let client1 =\n        LastFmEditClientImpl::login_with_credentials(Box::new(http_client), \u0026username, \u0026password)\n            .await?;\n    println!(\"✅ Successfully logged in as: {}\", client1.username());\n\n    // Create a second client that shares the broadcaster with client1\n    let http_client2 = http_client::native::NativeClient::new();\n    let client2 = client1.with_shared_broadcaster(Box::new(http_client2));\n    println!(\"🔄 Created client2 with shared broadcaster from client1\");\n\n    // Subscribe to events from both clients\n    let mut events1 = client1.subscribe();\n    let mut events2 = client2.subscribe();\n    println!(\"📡 Subscribed to events from both clients\");\n\n    // Spawn background tasks to monitor events from each client\n    let monitor1 = tokio::spawn(async move {\n        println!(\"🔍 Client1 monitor started\");\n        while let Ok(event) = events1.recv().await {\n            match event {\n                ClientEvent::RequestStarted { request } =\u003e {\n                    println!(\n                        \"🚀 Client1 monitor: Started request {}\",\n                        request.short_description()\n                    );\n                }\n                ClientEvent::RequestCompleted {\n                    request,\n                    status_code,\n                    duration_ms,\n                } =\u003e {\n                    println!(\n                        \"✅ Client1 monitor: Completed {} - {} ({} ms)\",\n                        request.short_description(),\n                        status_code,\n                        duration_ms\n                    );\n                }\n                ClientEvent::RateLimited {\n                    delay_seconds,\n                    request,\n                    rate_limit_type,\n                    rate_limit_timestamp,\n                } =\u003e {\n                    let req_desc = request\n                        .as_ref()\n                        .map(|r| r.short_description())\n                        .unwrap_or_else(|| \"unknown request\".to_string());\n                    println!(\n                        \"⏳ Client1 monitor: Rate limited ({rate_limit_type:?}) for {delay_seconds} seconds - {req_desc} (at timestamp {rate_limit_timestamp})\"\n                    );\n                }\n                ClientEvent::RateLimitEnded {\n                    request,\n                    rate_limit_type,\n                    total_rate_limit_duration_seconds,\n                } =\u003e {\n                    println!(\n                        \"🎉 Client1 monitor: Rate limiting ended ({rate_limit_type:?}) after {total_rate_limit_duration_seconds} seconds - {}\",\n                        request.short_description()\n                    );\n                }\n                ClientEvent::EditAttempted {\n                    edit,\n                    success,\n                    error_message,\n                    duration_ms,\n                } =\u003e {\n                    if success {\n                        println!(\n                            \"✅ Client1 monitor: Edit succeeded '{}' -\u003e '{}' ({duration_ms} ms)\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    } else {\n                        let error_msg = error_message\n                            .as_ref()\n                            .map(|s| format!(\" - {s}\"))\n                            .unwrap_or_default();\n                        println!(\n                            \"❌ Client1 monitor: Edit failed '{}' -\u003e '{}' ({duration_ms} ms){error_msg}\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    }\n                }\n            }\n        }\n    });\n\n    let monitor2 = tokio::spawn(async move {\n        println!(\"🔍 Client2 monitor started\");\n        while let Ok(event) = events2.recv().await {\n            match event {\n                ClientEvent::RequestStarted { request } =\u003e {\n                    println!(\n                        \"🚀 Client2 monitor: Started request {}\",\n                        request.short_description()\n                    );\n                }\n                ClientEvent::RequestCompleted {\n                    request,\n                    status_code,\n                    duration_ms,\n                } =\u003e {\n                    println!(\n                        \"✅ Client2 monitor: Completed {} - {} ({} ms)\",\n                        request.short_description(),\n                        status_code,\n                        duration_ms\n                    );\n                }\n                ClientEvent::RateLimited {\n                    delay_seconds,\n                    request,\n                    rate_limit_type,\n                    rate_limit_timestamp,\n                } =\u003e {\n                    let req_desc = request\n                        .as_ref()\n                        .map(|r| r.short_description())\n                        .unwrap_or_else(|| \"unknown request\".to_string());\n                    println!(\n                        \"⏳ Client2 monitor: Rate limited ({rate_limit_type:?}) for {delay_seconds} seconds - {req_desc} (at timestamp {rate_limit_timestamp})\"\n                    );\n                }\n                ClientEvent::RateLimitEnded {\n                    request,\n                    rate_limit_type,\n                    total_rate_limit_duration_seconds,\n                } =\u003e {\n                    println!(\n                        \"🎉 Client2 monitor: Rate limiting ended ({rate_limit_type:?}) after {total_rate_limit_duration_seconds} seconds - {}\",\n                        request.short_description()\n                    );\n                }\n                ClientEvent::EditAttempted {\n                    edit,\n                    success,\n                    error_message,\n                    duration_ms,\n                } =\u003e {\n                    if success {\n                        println!(\n                            \"✅ Client2 monitor: Edit succeeded '{}' -\u003e '{}' ({duration_ms} ms)\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    } else {\n                        let error_msg = error_message\n                            .as_ref()\n                            .map(|s| format!(\" - {s}\"))\n                            .unwrap_or_default();\n                        println!(\n                            \"❌ Client2 monitor: Edit failed '{}' -\u003e '{}' ({duration_ms} ms){error_msg}\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    }\n                }\n            }\n        }\n    });\n\n    // Make a request with client1 that might trigger rate limiting\n    println!(\"📡 Making request with client1...\");\n    match client1.get_recent_scrobbles(1).await {\n        Ok(tracks) =\u003e {\n            println!(\"✅ Client1 got {} tracks\", tracks.len());\n        }\n        Err(e) =\u003e {\n            println!(\"⚠️ Client1 error: {e}\");\n        }\n    }\n\n    // Check latest event from both clients (should be the same due to shared broadcaster)\n    let event1 = client1.latest_event();\n    let event2 = client2.latest_event();\n\n    match (event1, event2) {\n        (\n            Some(ClientEvent::RateLimited {\n                delay_seconds: delay1,\n                ..\n            }),\n            Some(ClientEvent::RateLimited {\n                delay_seconds: delay2,\n                ..\n            }),\n        ) =\u003e {\n            println!(\"🎯 Both clients show rate limiting: {delay1}s and {delay2}s\");\n            if delay1 == delay2 {\n                println!(\n                    \"✅ SUCCESS: Both clients report the same delay (shared broadcaster working!)\"\n                );\n            } else {\n                println!(\"❌ UNEXPECTED: Different delays reported\");\n            }\n        }\n        (\n            Some(ClientEvent::RequestCompleted { .. }),\n            Some(ClientEvent::RequestCompleted { .. }),\n        ) =\u003e {\n            println!(\"✅ Both clients show completed requests (shared broadcaster working!)\");\n        }\n        (\n            Some(ClientEvent::EditAttempted {\n                success: success1, ..\n            }),\n            Some(ClientEvent::EditAttempted {\n                success: success2, ..\n            }),\n        ) =\u003e {\n            if success1 == success2 {\n                println!(\"✅ Both clients show same edit result (shared broadcaster working!)\");\n            } else {\n                println!(\"❌ UNEXPECTED: Different edit results reported\");\n            }\n        }\n        (None, None) =\u003e {\n            println!(\"📊 No events occurred yet - this is normal\");\n            println!(\"    In real usage, both clients would see the same events when they occur\");\n        }\n        _ =\u003e {\n            println!(\"📊 Different event states between clients (could be due to timing)\");\n        }\n    }\n\n    // Let monitors run for a bit\n    tokio::time::sleep(std::time::Duration::from_secs(1)).await;\n\n    // Clean up\n    monitor1.abort();\n    monitor2.abort();\n\n    println!(\"🏁 Demo completed!\");\n\n    println!(\"\\n📄 Key Points:\");\n    println!(\"  • client1.with_shared_broadcaster() creates clients that share event broadcasting\");\n    println!(\"  • When any shared client encounters rate limiting, all see the same events\");\n    println!(\"  • Use this pattern when you need multiple HTTP clients but want unified rate limit handling\");\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","session_management.rs"],"content":"/// Example demonstrating both login and session restore initialization methods.\n///\n/// This example shows how to:\n/// 1. Initialize a client with username/password login\n/// 2. Save the session state to a file\n/// 3. Restore the session from the saved file\n/// 4. Use both initialization patterns\n///\n/// Usage:\n///   # First run - will prompt for credentials and save session\n///   direnv exec . cargo run --example session_management\n///\n///   # Subsequent runs - will use saved session\n///   direnv exec . cargo run --example session_management\nuse lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, Result};\nuse std::env;\nuse std::fs;\nuse std::io::{self, Write};\nuse std::path::Path;\n\nconst SESSION_FILE: \u0026str = \"session.json\";\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    env_logger::init();\n\n    println!(\"🎵 Last.fm Session Management Example\");\n    println!(\"=====================================\\n\");\n\n    // Try to load existing session first\n    if Path::new(SESSION_FILE).exists() {\n        println!(\"📁 Found existing session file, attempting to restore...\");\n        match restore_from_session().await {\n            Ok(client) =\u003e {\n                println!(\"✅ Session restored successfully!\");\n                println!(\"👤 Logged in as: {}\", client.username());\n\n                // Test the restored session by fetching recent tracks\n                println!(\"🎧 Testing session by fetching recent tracks...\");\n                let tracks = client.get_recent_scrobbles(1).await?;\n                let recent_tracks: Vec\u003c_\u003e = tracks.into_iter().take(3).collect();\n                println!(\"📊 Found {} recent tracks:\", recent_tracks.len());\n\n                for track in recent_tracks {\n                    println!(\"   🎵 {} - {}\", track.artist, track.name);\n                }\n\n                return Ok(());\n            }\n            Err(e) =\u003e {\n                println!(\"❌ Failed to restore session: {e}\");\n                println!(\"🔄 Falling back to fresh login...\\n\");\n                // Remove invalid session file\n                let _ = fs::remove_file(SESSION_FILE);\n            }\n        }\n    }\n\n    // No valid session found, perform fresh login\n    println!(\"🔑 No valid session found, performing fresh login...\");\n    let client = login_with_credentials().await?;\n    println!(\"✅ Login successful!\");\n    println!(\"👤 Logged in as: {}\", client.username());\n\n    // Save session for future use\n    println!(\"💾 Saving session to {SESSION_FILE}...\");\n    save_session(\u0026client)?;\n    println!(\"✅ Session saved!\");\n\n    // Test the new session\n    println!(\"🎧 Testing session by fetching recent tracks...\");\n    let tracks = client.get_recent_scrobbles(1).await?;\n    let recent_tracks: Vec\u003c_\u003e = tracks.into_iter().take(3).collect();\n    println!(\"📊 Found {} recent tracks:\", recent_tracks.len());\n\n    for track in recent_tracks {\n        println!(\"   🎵 {} - {}\", track.artist, track.name);\n    }\n\n    println!(\"\\n🎉 Example completed!\");\n    println!(\"💡 Next time you run this example, it will use the saved session automatically.\");\n\n    Ok(())\n}\n\n/// Restore client from saved session file\nasync fn restore_from_session() -\u003e Result\u003cLastFmEditClientImpl\u003e {\n    let session_json = fs::read_to_string(SESSION_FILE)\n        .map_err(|e| lastfm_edit::LastFmError::Http(format!(\"Failed to read session file: {e}\")))?;\n\n    let session = LastFmEditSession::from_json(\u0026session_json)\n        .map_err(|e| lastfm_edit::LastFmError::Http(format!(\"Failed to parse session: {e}\")))?;\n\n    if !session.is_valid() {\n        return Err(lastfm_edit::LastFmError::Auth(\n            \"Invalid session data\".to_string(),\n        ));\n    }\n\n    let http_client = http_client::native::NativeClient::new();\n    Ok(LastFmEditClientImpl::from_session(\n        Box::new(http_client),\n        session,\n    ))\n}\n\n/// Perform fresh login with credentials\nasync fn login_with_credentials() -\u003e Result\u003cLastFmEditClientImpl\u003e {\n    println!(\"🔧 Using login with credentials pattern...\");\n    let username = get_username();\n    let password = get_password();\n\n    let http_client = http_client::native::NativeClient::new();\n    LastFmEditClientImpl::login_with_credentials(Box::new(http_client), \u0026username, \u0026password).await\n}\n\n/// Save current session to file\nfn save_session(client: \u0026dyn LastFmEditClient) -\u003e Result\u003c()\u003e {\n    let session = client.get_session();\n    let session_json = session\n        .to_json()\n        .map_err(|e| lastfm_edit::LastFmError::Http(format!(\"Failed to serialize session: {e}\")))?;\n\n    fs::write(SESSION_FILE, session_json).map_err(|e| {\n        lastfm_edit::LastFmError::Http(format!(\"Failed to write session file: {e}\"))\n    })?;\n\n    Ok(())\n}\n\n/// Get username from environment variable or prompt\nfn get_username() -\u003e String {\n    env::var(\"LASTFM_EDIT_USERNAME\").unwrap_or_else(|_| {\n        print!(\"Last.fm username: \");\n        io::stdout().flush().unwrap();\n        let mut input = String::new();\n        io::stdin().read_line(\u0026mut input).unwrap();\n        input.trim().to_string()\n    })\n}\n\n/// Get password from environment variable or prompt\nfn get_password() -\u003e String {\n    env::var(\"LASTFM_EDIT_PASSWORD\").unwrap_or_else(|_| {\n        print!(\"Last.fm password: \");\n        io::stdout().flush().unwrap();\n        let mut input = String::new();\n        io::stdin().read_line(\u0026mut input).unwrap();\n        input.trim().to_string()\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","shared","common.rs"],"content":"use lastfm_edit::{LastFmEditClientImpl, Result};\nuse std::env;\n\npub async fn setup_client() -\u003e Result\u003cLastFmEditClientImpl\u003e {\n    // Initialize logger to handle log::debug! calls\n    env_logger::init();\n\n    let username = env::var(\"LASTFM_EDIT_USERNAME\")\n        .expect(\"LASTFM_EDIT_USERNAME environment variable not set\");\n    let password = env::var(\"LASTFM_EDIT_PASSWORD\")\n        .expect(\"LASTFM_EDIT_PASSWORD environment variable not set\");\n\n    // Login and create client\n    let http_client = http_client::native::NativeClient::new();\n    println!(\"Logging in as {username}...\");\n    let client =\n        LastFmEditClientImpl::login_with_credentials(Box::new(http_client), \u0026username, \u0026password)\n            .await?;\n    println!(\"✓ Logged in successfully\");\n\n    Ok(client)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","smart_scrobble_display.rs"],"content":"use lastfm_edit::{ExactScrobbleEdit, ScrobbleEdit};\n\nfn main() {\n    println!(\"=== Smart ScrobbleEdit Display Examples ===\\n\");\n\n    // Example 1: Only changing the artist name\n    let edit1 = ScrobbleEdit {\n        artist_name_original: \"The Beatles\".to_string(),\n        track_name_original: Some(\"Yesterday\".to_string()),\n        album_name_original: Some(\"Help!\".to_string()),\n        album_artist_name_original: None,\n\n        artist_name: \"Beatles, The\".to_string(),   // Changed\n        track_name: Some(\"Yesterday\".to_string()), // Same\n        album_name: Some(\"Help!\".to_string()),     // Same\n        album_artist_name: None,                   // Same\n\n        timestamp: None,\n        edit_all: false,\n    };\n    println!(\"📝 Artist name change:\");\n    println!(\"   {edit1}\");\n\n    // Example 2: Changing track and album names\n    let edit2 = ScrobbleEdit {\n        artist_name_original: \"Pink Floyd\".to_string(),\n        track_name_original: Some(\"Shine on You Crazy Diamond\".to_string()),\n        album_name_original: Some(\"Wish You Were Here\".to_string()),\n        album_artist_name_original: None,\n\n        artist_name: \"Pink Floyd\".to_string(), // Same\n        track_name: Some(\"Shine On You Crazy Diamond\".to_string()), // Changed\n        album_name: Some(\"Wish You Were Here (Remastered)\".to_string()), // Changed\n        album_artist_name: None,               // Same\n\n        timestamp: Some(1640995200),\n        edit_all: true,\n    };\n    println!(\"\\n📝 Track and album changes:\");\n    println!(\"   {edit2}\");\n\n    // Example 3: Adding album artist information\n    let edit3 = ScrobbleEdit {\n        artist_name_original: \"Various Artists\".to_string(),\n        track_name_original: Some(\"Hotel California\".to_string()),\n        album_name_original: Some(\"Greatest Hits Collection\".to_string()),\n        album_artist_name_original: None,\n\n        artist_name: \"Eagles\".to_string(),                // Changed\n        track_name: Some(\"Hotel California\".to_string()), // Same\n        album_name: Some(\"Hotel California\".to_string()), // Changed\n        album_artist_name: Some(\"Eagles\".to_string()),    // Added\n\n        timestamp: None,\n        edit_all: false,\n    };\n    println!(\"\\n📝 Multiple changes including adding album artist:\");\n    println!(\"   {edit3}\");\n\n    // Example 4: No changes (should show \"No changes\")\n    let edit4 = ScrobbleEdit {\n        artist_name_original: \"Radiohead\".to_string(),\n        track_name_original: Some(\"Paranoid Android\".to_string()),\n        album_name_original: Some(\"OK Computer\".to_string()),\n        album_artist_name_original: Some(\"Radiohead\".to_string()),\n\n        artist_name: \"Radiohead\".to_string(),             // Same\n        track_name: Some(\"Paranoid Android\".to_string()), // Same\n        album_name: Some(\"OK Computer\".to_string()),      // Same\n        album_artist_name: Some(\"Radiohead\".to_string()), // Same\n\n        timestamp: None,\n        edit_all: false,\n    };\n    println!(\"\\n📝 No changes:\");\n    println!(\"   {edit4}\");\n\n    // Example 5: ExactScrobbleEdit (all fields required)\n    let exact_edit = ExactScrobbleEdit {\n        artist_name_original: \"Led Zeppelin\".to_string(),\n        track_name_original: \"Stairway to Heaven\".to_string(),\n        album_name_original: \"Led Zeppelin IV\".to_string(),\n        album_artist_name_original: \"Led Zeppelin\".to_string(),\n\n        artist_name: \"Led Zeppelin\".to_string(),      // Same\n        track_name: \"Stairway To Heaven\".to_string(), // Changed (capitalization)\n        album_name: \"Led Zeppelin IV (Remaster)\".to_string(), // Changed\n        album_artist_name: \"Led Zeppelin\".to_string(), // Same\n\n        timestamp: 1640995200,\n        edit_all: true,\n    };\n    println!(\"\\n📝 ExactScrobbleEdit changes:\");\n    println!(\"   {exact_edit}\");\n\n    println!(\"\\n✨ Features demonstrated:\");\n    println!(\"   • Only shows fields that are actually changing\");\n    println!(\"   • Uses → arrow to show old → new values\");\n    println!(\"   • Handles optional fields (None to Some transitions)\");\n    println!(\"   • Shows scope with '(all instances)' when edit_all is true\");\n    println!(\"   • Shows 'No changes' when nothing is being modified\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","test_album_tracks.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    let artist = std::env::args()\n        .nth(1)\n        .unwrap_or_else(|| \"The Beatles\".to_string());\n    let album = std::env::args()\n        .nth(2)\n        .unwrap_or_else(|| \"Abbey Road\".to_string());\n\n    println!(\"=== Album Tracks Test ===\\n\");\n    println!(\"🎵 Testing get_album_tracks() with: '{album}' by '{artist}'\\n\");\n\n    // Test the album_tracks iterator method\n    let mut tracks_iterator = client.album_tracks(\u0026album, \u0026artist);\n    let mut tracks = Vec::new();\n\n    while let Some(track) = tracks_iterator.next().await.transpose() {\n        match track {\n            Ok(track) =\u003e tracks.push(track),\n            Err(e) =\u003e {\n                println!(\"❌ ERROR: Failed to get track: {e}\");\n                break;\n            }\n        }\n    }\n\n    println!(\"✅ SUCCESS: Got {} tracks\", tracks.len());\n    if tracks.is_empty() {\n        println!(\"   (Album not found in your library, but no crash!)\");\n    } else {\n        println!(\"   Tracks:\");\n        for (i, track) in tracks.iter().enumerate().take(10) {\n            println!(\"   [{:2}] {}\", i + 1, track.name);\n        }\n        if tracks.len() \u003e 10 {\n            println!(\"   ... and {} more tracks\", tracks.len() - 10);\n        }\n    }\n\n    // Also test the iterator directly\n    println!(\"\\n=== Album Tracks Iterator Test ===\");\n    let mut tracks_iterator = client.album_tracks(\u0026album, \u0026artist);\n    let mut count = 0;\n\n    println!(\"🔍 Testing iterator...\");\n    while let Some(track) = tracks_iterator.next().await? {\n        count += 1;\n        if count \u003c= 5 {\n            println!(\"   [{count}] {}\", track.name);\n        }\n        if count \u003e= 5 {\n            break;\n        }\n    }\n\n    if count == 0 {\n        println!(\"   No tracks found via iterator (album not in library)\");\n    } else {\n        println!(\"   Iterator works - got {count} tracks\");\n    }\n\n    println!(\"\\n🎉 Both methods completed without crashing!\");\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","test_artist_tracks_with_albums.rs"],"content":"use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    println!(\"=== Testing Artist Tracks with Album Information ===\\n\");\n\n    // Create a test session (this won't work without real credentials)\n    let test_session = LastFmEditSession::new(\n        \"test\".to_string(),\n        vec![\"sessionid=.test123\".to_string()],\n        Some(\"csrf\".to_string()),\n        \"https://www.last.fm\".to_string(),\n    );\n\n    let client = LastFmEditClientImpl::from_session(\n        Box::new(http_client::native::NativeClient::new()),\n        test_session,\n    );\n\n    println!(\"🎵 Testing artist tracks iteration (album-based approach)\");\n    println!(\"   This will get tracks by iterating through albums first\");\n    println!(\"   Each track should now have album information populated\");\n\n    let mut tracks_iterator = client.artist_tracks(\"The Beatles\");\n\n    // Get first 5 tracks\n    for i in 0..5 {\n        match tracks_iterator.next().await {\n            Ok(Some(track)) =\u003e {\n                let album_info = track.album.as_deref().unwrap_or(\"No album info\");\n                let album_artist_info = track\n                    .album_artist\n                    .as_deref()\n                    .unwrap_or(\"Same as track artist\");\n\n                println!(\n                    \"  [{:2}] {} - {} [{}]\",\n                    i + 1,\n                    track.artist,\n                    track.name,\n                    album_info\n                );\n                println!(\n                    \"       Album Artist: {} | Play Count: {}\",\n                    album_artist_info, track.playcount\n                );\n\n                if let Some(timestamp) = track.timestamp {\n                    println!(\"       Last Played: {timestamp}\");\n                }\n                println!();\n            }\n            Ok(None) =\u003e {\n                println!(\"  No more tracks found\");\n                break;\n            }\n            Err(e) =\u003e {\n                println!(\"  ❌ Error: {e}\");\n                break;\n            }\n        }\n    }\n\n    println!(\"✨ Key improvements:\");\n    println!(\"   • Tracks now include complete album information\");\n    println!(\"   • Album artist information is available when different from track artist\");\n    println!(\"   • Implementation iterates through albums first, then gets tracks per album\");\n    println!(\"   • This provides richer metadata compared to the previous direct track approach\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","python","src","lib.rs"],"content":"use lastfm_edit::{\n    Album, Artist, EditResponse,\n    LastFmEditClient, LastFmEditClientImpl, LastFmEditSession,\n    ScrobbleEdit, Track,\n};\nuse pyo3::prelude::*;\nuse pyo3::types::{PyModule, PyType};\nuse std::sync::Arc;\nuse tokio::runtime::Runtime;\n\n/// Python wrapper for the Last.fm Edit Client\n#[pyclass]\npub struct PyLastFmEditClient {\n    client: LastFmEditClientImpl,\n    runtime: Arc\u003cRuntime\u003e,\n}\n\n/// Python wrapper for Track\n#[pyclass]\n#[derive(Clone)]\npub struct PyTrack {\n    #[pyo3(get)]\n    pub name: String,\n    #[pyo3(get)]\n    pub artist: String,\n    #[pyo3(get)]\n    pub playcount: u32,\n    #[pyo3(get)]\n    pub timestamp: Option\u003cu64\u003e,\n    #[pyo3(get)]\n    pub album: Option\u003cString\u003e,\n    #[pyo3(get)]\n    pub album_artist: Option\u003cString\u003e,\n}\n\n/// Python wrapper for Album\n#[pyclass]\n#[derive(Clone)]\npub struct PyAlbum {\n    #[pyo3(get)]\n    pub name: String,\n    #[pyo3(get)]\n    pub artist: String,\n    #[pyo3(get)]\n    pub playcount: u32,\n    #[pyo3(get)]\n    pub timestamp: Option\u003cu64\u003e,\n}\n\n/// Python wrapper for Artist\n#[pyclass]\n#[derive(Clone)]\npub struct PyArtist {\n    #[pyo3(get)]\n    pub name: String,\n    #[pyo3(get)]\n    pub playcount: u32,\n    #[pyo3(get)]\n    pub timestamp: Option\u003cu64\u003e,\n}\n\n/// Python wrapper for ScrobbleEdit\n#[pyclass]\n#[derive(Clone)]\npub struct PyScrobbleEdit {\n    inner: ScrobbleEdit,\n}\n\n/// Python wrapper for EditResponse\n#[pyclass]\npub struct PyEditResponse {\n    inner: EditResponse,\n}\n\n/// Python wrapper for LastFmEditSession\n#[pyclass]\npub struct PyLastFmEditSession {\n    #[pyo3(get)]\n    pub username: String,\n    #[pyo3(get)]\n    pub base_url: String,\n}\n\nimpl From\u003cTrack\u003e for PyTrack {\n    fn from(track: Track) -\u003e Self {\n        Self {\n            name: track.name,\n            artist: track.artist,\n            playcount: track.playcount,\n            timestamp: track.timestamp,\n            album: track.album,\n            album_artist: track.album_artist,\n        }\n    }\n}\n\nimpl From\u003cAlbum\u003e for PyAlbum {\n    fn from(album: Album) -\u003e Self {\n        Self {\n            name: album.name,\n            artist: album.artist,\n            playcount: album.playcount,\n            timestamp: album.timestamp,\n        }\n    }\n}\n\nimpl From\u003cArtist\u003e for PyArtist {\n    fn from(artist: Artist) -\u003e Self {\n        Self {\n            name: artist.name,\n            playcount: artist.playcount,\n            timestamp: artist.timestamp,\n        }\n    }\n}\n\n#[pymethods]\nimpl PyTrack {\n    #[new]\n    #[pyo3(signature = (name, artist, playcount, timestamp=None, album=None, album_artist=None))]\n    fn new(\n        name: String,\n        artist: String,\n        playcount: u32,\n        timestamp: Option\u003cu64\u003e,\n        album: Option\u003cString\u003e,\n        album_artist: Option\u003cString\u003e,\n    ) -\u003e Self {\n        Self {\n            name,\n            artist,\n            playcount,\n            timestamp,\n            album,\n            album_artist,\n        }\n    }\n\n    fn __str__(\u0026self) -\u003e String {\n        let album_part = if let Some(ref album) = self.album {\n            format!(\" [{}]\", album)\n        } else {\n            String::new()\n        };\n        format!(\"{} - {}{}\", self.artist, self.name, album_part)\n    }\n\n    fn __repr__(\u0026self) -\u003e String {\n        format!(\n            \"PyTrack(name='{}', artist='{}', playcount={}, timestamp={:?}, album={:?}, album_artist={:?})\",\n            self.name, self.artist, self.playcount, self.timestamp, self.album, self.album_artist\n        )\n    }\n}\n\n#[pymethods]\nimpl PyAlbum {\n    #[new]\n    #[pyo3(signature = (name, artist, playcount, timestamp=None))]\n    fn new(name: String, artist: String, playcount: u32, timestamp: Option\u003cu64\u003e) -\u003e Self {\n        Self {\n            name,\n            artist,\n            playcount,\n            timestamp,\n        }\n    }\n\n    fn __str__(\u0026self) -\u003e String {\n        format!(\"{} - {}\", self.artist, self.name)\n    }\n\n    fn __repr__(\u0026self) -\u003e String {\n        format!(\n            \"PyAlbum(name='{}', artist='{}', playcount={}, timestamp={:?})\",\n            self.name, self.artist, self.playcount, self.timestamp\n        )\n    }\n}\n\n#[pymethods]\nimpl PyArtist {\n    #[new]\n    #[pyo3(signature = (name, playcount, timestamp=None))]\n    fn new(name: String, playcount: u32, timestamp: Option\u003cu64\u003e) -\u003e Self {\n        Self {\n            name,\n            playcount,\n            timestamp,\n        }\n    }\n\n    fn __str__(\u0026self) -\u003e String {\n        self.name.clone()\n    }\n\n    fn __repr__(\u0026self) -\u003e String {\n        format!(\n            \"PyArtist(name='{}', playcount={}, timestamp={:?})\",\n            self.name, self.playcount, self.timestamp\n        )\n    }\n}\n\n#[pymethods]\nimpl PyScrobbleEdit {\n    #[new]\n    #[pyo3(signature = (\n        artist_name_original,\n        artist_name,\n        track_name_original = None,\n        track_name = None,\n        album_name_original = None,\n        album_name = None,\n        album_artist_name_original = None,\n        album_artist_name = None,\n        timestamp = None,\n        edit_all = true\n    ))]\n    fn new(\n        artist_name_original: String,\n        artist_name: String,\n        track_name_original: Option\u003cString\u003e,\n        track_name: Option\u003cString\u003e,\n        album_name_original: Option\u003cString\u003e,\n        album_name: Option\u003cString\u003e,\n        album_artist_name_original: Option\u003cString\u003e,\n        album_artist_name: Option\u003cString\u003e,\n        timestamp: Option\u003cu64\u003e,\n        edit_all: bool,\n    ) -\u003e Self {\n        let edit = ScrobbleEdit::new(\n            track_name_original,\n            album_name_original,\n            artist_name_original,\n            album_artist_name_original,\n            track_name,\n            album_name,\n            artist_name,\n            album_artist_name,\n            timestamp,\n            edit_all,\n        );\n        Self { inner: edit }\n    }\n\n    #[classmethod]\n    fn from_track_info(\n        _cls: \u0026Bound\u003c'_, PyType\u003e,\n        original_track: \u0026str,\n        original_album: \u0026str,\n        original_artist: \u0026str,\n        timestamp: u64,\n    ) -\u003e Self {\n        let edit = ScrobbleEdit::from_track_info(\n            original_track,\n            original_album,\n            original_artist,\n            timestamp,\n        );\n        Self { inner: edit }\n    }\n\n    #[classmethod]\n    fn from_track_and_artist(_cls: \u0026Bound\u003c'_, PyType\u003e, track_name: \u0026str, artist_name: \u0026str) -\u003e Self {\n        let edit = ScrobbleEdit::from_track_and_artist(track_name, artist_name);\n        Self { inner: edit }\n    }\n\n    #[classmethod]\n    fn for_artist(_cls: \u0026Bound\u003c'_, PyType\u003e, old_artist_name: \u0026str, new_artist_name: \u0026str) -\u003e Self {\n        let edit = ScrobbleEdit::for_artist(old_artist_name, new_artist_name);\n        Self { inner: edit }\n    }\n\n    #[classmethod]\n    fn for_album(\n        _cls: \u0026Bound\u003c'_, PyType\u003e,\n        album_name: \u0026str,\n        old_artist_name: \u0026str,\n        new_artist_name: \u0026str,\n    ) -\u003e Self {\n        let edit = ScrobbleEdit::for_album(album_name, old_artist_name, new_artist_name);\n        Self { inner: edit }\n    }\n\n    fn with_track_name(\u0026mut self, track_name: \u0026str) -\u003e Self {\n        let edit = self.inner.clone().with_track_name(track_name);\n        Self { inner: edit }\n    }\n\n    fn with_album_name(\u0026mut self, album_name: \u0026str) -\u003e Self {\n        let edit = self.inner.clone().with_album_name(album_name);\n        Self { inner: edit }\n    }\n\n    fn with_artist_name(\u0026mut self, artist_name: \u0026str) -\u003e Self {\n        let edit = self.inner.clone().with_artist_name(artist_name);\n        Self { inner: edit }\n    }\n\n    fn with_edit_all(\u0026mut self, edit_all: bool) -\u003e Self {\n        let edit = self.inner.clone().with_edit_all(edit_all);\n        Self { inner: edit }\n    }\n\n    fn __str__(\u0026self) -\u003e String {\n        format!(\"{}\", self.inner)\n    }\n\n    fn __repr__(\u0026self) -\u003e String {\n        format!(\"PyScrobbleEdit({})\", self.inner)\n    }\n\n    #[getter]\n    fn track_name_original(\u0026self) -\u003e Option\u003cString\u003e {\n        self.inner.track_name_original.clone()\n    }\n\n    #[getter]\n    fn album_name_original(\u0026self) -\u003e Option\u003cString\u003e {\n        self.inner.album_name_original.clone()\n    }\n\n    #[getter]\n    fn artist_name_original(\u0026self) -\u003e String {\n        self.inner.artist_name_original.clone()\n    }\n\n    #[getter]\n    fn album_artist_name_original(\u0026self) -\u003e Option\u003cString\u003e {\n        self.inner.album_artist_name_original.clone()\n    }\n\n    #[getter]\n    fn track_name(\u0026self) -\u003e Option\u003cString\u003e {\n        self.inner.track_name.clone()\n    }\n\n    #[getter]\n    fn album_name(\u0026self) -\u003e Option\u003cString\u003e {\n        self.inner.album_name.clone()\n    }\n\n    #[getter]\n    fn artist_name(\u0026self) -\u003e String {\n        self.inner.artist_name.clone()\n    }\n\n    #[getter]\n    fn album_artist_name(\u0026self) -\u003e Option\u003cString\u003e {\n        self.inner.album_artist_name.clone()\n    }\n\n    #[getter]\n    fn timestamp(\u0026self) -\u003e Option\u003cu64\u003e {\n        self.inner.timestamp\n    }\n\n    #[getter]\n    fn edit_all(\u0026self) -\u003e bool {\n        self.inner.edit_all\n    }\n}\n\n#[pymethods]\nimpl PyEditResponse {\n    fn success(\u0026self) -\u003e bool {\n        self.inner.success()\n    }\n\n    fn all_successful(\u0026self) -\u003e bool {\n        self.inner.all_successful()\n    }\n\n    fn any_successful(\u0026self) -\u003e bool {\n        self.inner.any_successful()\n    }\n\n    fn total_edits(\u0026self) -\u003e usize {\n        self.inner.total_edits()\n    }\n\n    fn successful_edits(\u0026self) -\u003e usize {\n        self.inner.successful_edits()\n    }\n\n    fn failed_edits(\u0026self) -\u003e usize {\n        self.inner.failed_edits()\n    }\n\n    fn summary_message(\u0026self) -\u003e String {\n        self.inner.summary_message()\n    }\n\n    fn detailed_messages(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.inner.detailed_messages()\n    }\n\n    fn message(\u0026self) -\u003e Option\u003cString\u003e {\n        self.inner.message()\n    }\n\n    fn __str__(\u0026self) -\u003e String {\n        self.inner.summary_message()\n    }\n\n    fn __repr__(\u0026self) -\u003e String {\n        format!(\n            \"PyEditResponse(success={}, total_edits={})\",\n            self.success(),\n            self.total_edits()\n        )\n    }\n}\n\n#[pymethods]\nimpl PyLastFmEditSession {\n    #[new]\n    #[pyo3(signature = (username, _cookies, _csrf_token=None, base_url=\"https://www.last.fm\".to_string()))]\n    fn new(\n        username: String,\n        _cookies: Vec\u003cString\u003e,\n        _csrf_token: Option\u003cString\u003e,\n        base_url: String,\n    ) -\u003e Self {\n        Self { username, base_url }\n    }\n\n    fn __repr__(\u0026self) -\u003e String {\n        format!(\n            \"PyLastFmEditSession(username='{}', base_url='{}')\",\n            self.username, self.base_url\n        )\n    }\n}\n\n#[pymethods]\nimpl PyLastFmEditClient {\n    #[new]\n    fn new() -\u003e PyResult\u003cSelf\u003e {\n        let runtime = Arc::new(Runtime::new().map_err(|e| {\n            PyErr::new::\u003cpyo3::exceptions::PyRuntimeError, _\u003e(format!(\n                \"Failed to create async runtime: {}\",\n                e\n            ))\n        })?);\n\n        // We'll need to initialize the client later with login\n        // For now, create a placeholder that will be replaced\n        let http_client = Box::new(http_client::native::NativeClient::new());\n        let session = LastFmEditSession::new(\n            \"\".to_string(),\n            vec![],\n            None,\n            \"https://www.last.fm\".to_string(),\n        );\n        let client = LastFmEditClientImpl::from_session(http_client, session);\n\n        Ok(Self { client, runtime })\n    }\n\n    /// Login with username and password\n    #[pyo3(signature = (username, password, base_url = None))]\n    fn login(\u0026mut self, username: \u0026str, password: \u0026str, base_url: Option\u003c\u0026str\u003e) -\u003e PyResult\u003c()\u003e {\n        let _base_url = base_url.unwrap_or(\"https://www.last.fm\");\n\n        let result = self.runtime.block_on(async {\n            let http_client = Box::new(http_client::native::NativeClient::new());\n            LastFmEditClientImpl::login_with_credentials(http_client, username, password).await\n        });\n\n        match result {\n            Ok(client) =\u003e {\n                self.client = client;\n                Ok(())\n            }\n            Err(e) =\u003e Err(PyErr::new::\u003cpyo3::exceptions::PyException, _\u003e(format!(\n                \"Login failed: {}\",\n                e\n            ))),\n        }\n    }\n\n    /// Get the username of the logged-in user\n    fn username(\u0026self) -\u003e String {\n        self.client.username()\n    }\n\n    /// Validate the current session\n    fn validate_session(\u0026self) -\u003e bool {\n        self.runtime.block_on(self.client.validate_session())\n    }\n\n    /// Get recent scrobbles for a specific page\n    fn get_recent_scrobbles(\u0026self, page: u32) -\u003e PyResult\u003cVec\u003cPyTrack\u003e\u003e {\n        let result = self\n            .runtime\n            .block_on(self.client.get_recent_scrobbles(page));\n        match result {\n            Ok(tracks) =\u003e Ok(tracks.into_iter().map(PyTrack::from).collect()),\n            Err(e) =\u003e Err(PyErr::new::\u003cpyo3::exceptions::PyException, _\u003e(format!(\n                \"Failed to get recent scrobbles: {}\",\n                e\n            ))),\n        }\n    }\n\n    /// Get all tracks by an artist (returns up to limit tracks)\n    #[pyo3(signature = (artist, limit = None))]\n    fn get_artist_tracks(\u0026self, artist: \u0026str, limit: Option\u003cusize\u003e) -\u003e PyResult\u003cVec\u003cPyTrack\u003e\u003e {\n        let result = self.runtime.block_on(async {\n            let mut iterator = self.client.artist_tracks(artist);\n            if let Some(limit) = limit {\n                iterator.take(limit).await\n            } else {\n                iterator.collect_all().await\n            }\n        });\n\n        match result {\n            Ok(tracks) =\u003e Ok(tracks.into_iter().map(PyTrack::from).collect()),\n            Err(e) =\u003e Err(PyErr::new::\u003cpyo3::exceptions::PyException, _\u003e(format!(\n                \"Failed to get artist tracks: {}\",\n                e\n            ))),\n        }\n    }\n\n    /// Get all albums by an artist (returns up to limit albums)\n    #[pyo3(signature = (artist, limit = None))]\n    fn get_artist_albums(\u0026self, artist: \u0026str, limit: Option\u003cusize\u003e) -\u003e PyResult\u003cVec\u003cPyAlbum\u003e\u003e {\n        let result = self.runtime.block_on(async {\n            let mut iterator = self.client.artist_albums(artist);\n            if let Some(limit) = limit {\n                iterator.take(limit).await\n            } else {\n                iterator.collect_all().await\n            }\n        });\n\n        match result {\n            Ok(albums) =\u003e Ok(albums.into_iter().map(PyAlbum::from).collect()),\n            Err(e) =\u003e Err(PyErr::new::\u003cpyo3::exceptions::PyException, _\u003e(format!(\n                \"Failed to get artist albums: {}\",\n                e\n            ))),\n        }\n    }\n\n    /// Get all tracks from a specific album (returns up to limit tracks)\n    #[pyo3(signature = (album_name, artist_name, limit = None))]\n    fn get_album_tracks(\n        \u0026self,\n        album_name: \u0026str,\n        artist_name: \u0026str,\n        limit: Option\u003cusize\u003e,\n    ) -\u003e PyResult\u003cVec\u003cPyTrack\u003e\u003e {\n        let result = self.runtime.block_on(async {\n            let mut iterator = self.client.album_tracks(album_name, artist_name);\n            if let Some(limit) = limit {\n                iterator.take(limit).await\n            } else {\n                iterator.collect_all().await\n            }\n        });\n\n        match result {\n            Ok(tracks) =\u003e Ok(tracks.into_iter().map(PyTrack::from).collect()),\n            Err(e) =\u003e Err(PyErr::new::\u003cpyo3::exceptions::PyException, _\u003e(format!(\n                \"Failed to get album tracks: {}\",\n                e\n            ))),\n        }\n    }\n\n    /// Get recent tracks (returns up to limit tracks)\n    #[pyo3(signature = (limit = None))]\n    fn get_recent_tracks(\u0026self, limit: Option\u003cusize\u003e) -\u003e PyResult\u003cVec\u003cPyTrack\u003e\u003e {\n        let result = self.runtime.block_on(async {\n            let mut iterator = self.client.recent_tracks();\n            if let Some(limit) = limit {\n                iterator.take(limit).await\n            } else {\n                iterator.collect_all().await\n            }\n        });\n\n        match result {\n            Ok(tracks) =\u003e Ok(tracks.into_iter().map(PyTrack::from).collect()),\n            Err(e) =\u003e Err(PyErr::new::\u003cpyo3::exceptions::PyException, _\u003e(format!(\n                \"Failed to get recent tracks: {}\",\n                e\n            ))),\n        }\n    }\n\n    /// Get all artists (returns up to limit artists)\n    #[pyo3(signature = (limit = None))]\n    fn get_artists(\u0026self, limit: Option\u003cusize\u003e) -\u003e PyResult\u003cVec\u003cPyArtist\u003e\u003e {\n        let result = self.runtime.block_on(async {\n            let mut iterator = self.client.artists();\n            if let Some(limit) = limit {\n                iterator.take(limit).await\n            } else {\n                iterator.collect_all().await\n            }\n        });\n\n        match result {\n            Ok(artists) =\u003e Ok(artists.into_iter().map(PyArtist::from).collect()),\n            Err(e) =\u003e Err(PyErr::new::\u003cpyo3::exceptions::PyException, _\u003e(format!(\n                \"Failed to get artists: {}\",\n                e\n            ))),\n        }\n    }\n\n    /// Search for tracks\n    #[pyo3(signature = (query, limit = None))]\n    fn search_tracks(\u0026self, query: \u0026str, limit: Option\u003cusize\u003e) -\u003e PyResult\u003cVec\u003cPyTrack\u003e\u003e {\n        let result = self.runtime.block_on(async {\n            let mut iterator = self.client.search_tracks(query);\n            if let Some(limit) = limit {\n                iterator.take(limit).await\n            } else {\n                iterator.collect_all().await\n            }\n        });\n\n        match result {\n            Ok(tracks) =\u003e Ok(tracks.into_iter().map(PyTrack::from).collect()),\n            Err(e) =\u003e Err(PyErr::new::\u003cpyo3::exceptions::PyException, _\u003e(format!(\n                \"Failed to search tracks: {}\",\n                e\n            ))),\n        }\n    }\n\n    /// Search for albums\n    #[pyo3(signature = (query, limit = None))]\n    fn search_albums(\u0026self, query: \u0026str, limit: Option\u003cusize\u003e) -\u003e PyResult\u003cVec\u003cPyAlbum\u003e\u003e {\n        let result = self.runtime.block_on(async {\n            let mut iterator = self.client.search_albums(query);\n            if let Some(limit) = limit {\n                iterator.take(limit).await\n            } else {\n                iterator.collect_all().await\n            }\n        });\n\n        match result {\n            Ok(albums) =\u003e Ok(albums.into_iter().map(PyAlbum::from).collect()),\n            Err(e) =\u003e Err(PyErr::new::\u003cpyo3::exceptions::PyException, _\u003e(format!(\n                \"Failed to search albums: {}\",\n                e\n            ))),\n        }\n    }\n\n    /// Edit a scrobble\n    fn edit_scrobble(\u0026self, edit: \u0026PyScrobbleEdit) -\u003e PyResult\u003cPyEditResponse\u003e {\n        let result = self\n            .runtime\n            .block_on(self.client.edit_scrobble(\u0026edit.inner));\n        match result {\n            Ok(response) =\u003e Ok(PyEditResponse { inner: response }),\n            Err(e) =\u003e Err(PyErr::new::\u003cpyo3::exceptions::PyException, _\u003e(format!(\n                \"Failed to edit scrobble: {}\",\n                e\n            ))),\n        }\n    }\n\n    /// Delete a scrobble\n    fn delete_scrobble(\n        \u0026self,\n        artist_name: \u0026str,\n        track_name: \u0026str,\n        timestamp: u64,\n    ) -\u003e PyResult\u003cbool\u003e {\n        let result = self.runtime.block_on(self.client.delete_scrobble(\n            artist_name,\n            track_name,\n            timestamp,\n        ));\n        match result {\n            Ok(success) =\u003e Ok(success),\n            Err(e) =\u003e Err(PyErr::new::\u003cpyo3::exceptions::PyException, _\u003e(format!(\n                \"Failed to delete scrobble: {}\",\n                e\n            ))),\n        }\n    }\n\n    /// Find a recent scrobble for a specific track\n    #[pyo3(signature = (track_name, artist_name, max_pages = 5))]\n    fn find_recent_scrobble_for_track(\n        \u0026self,\n        track_name: \u0026str,\n        artist_name: \u0026str,\n        max_pages: u32,\n    ) -\u003e PyResult\u003cOption\u003cPyTrack\u003e\u003e {\n        let result = self\n            .runtime\n            .block_on(self.client.find_recent_scrobble_for_track(\n                track_name,\n                artist_name,\n                max_pages,\n            ));\n        match result {\n            Ok(track) =\u003e Ok(track.map(PyTrack::from)),\n            Err(e) =\u003e Err(PyErr::new::\u003cpyo3::exceptions::PyException, _\u003e(format!(\n                \"Failed to find recent scrobble: {}\",\n                e\n            ))),\n        }\n    }\n\n    /// Get session information\n    fn get_session(\u0026self) -\u003e PyLastFmEditSession {\n        let session = self.client.get_session();\n        PyLastFmEditSession {\n            username: session.username,\n            base_url: session.base_url,\n        }\n    }\n}\n\n/// A Python module implemented in Rust.\n#[pymodule]\nfn _lastfm_edit(_py: Python, m: \u0026Bound\u003c'_, PyModule\u003e) -\u003e PyResult\u003c()\u003e {\n    m.add_class::\u003cPyLastFmEditClient\u003e()?;\n    m.add_class::\u003cPyTrack\u003e()?;\n    m.add_class::\u003cPyAlbum\u003e()?;\n    m.add_class::\u003cPyArtist\u003e()?;\n    m.add_class::\u003cPyScrobbleEdit\u003e()?;\n    m.add_class::\u003cPyEditResponse\u003e()?;\n    m.add_class::\u003cPyLastFmEditSession\u003e()?;\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","python","target","release","build","http-types-2-cf730347a9d71cd3","out","probe.rs"],"content":"\n    #![feature(backtrace)]\n    #![allow(dead_code)]\n\n    use std::backtrace::{Backtrace, BacktraceStatus};\n    use std::error::Error;\n    use std::fmt::{self, Display};\n\n    #[derive(Debug)]\n    struct E;\n\n    impl Display for E {\n        fn fmt(\u0026self, _formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            unimplemented!()\n        }\n    }\n\n    impl Error for E {\n        fn backtrace(\u0026self) -\u003e Option\u003c\u0026Backtrace\u003e {\n            let backtrace = Backtrace::capture();\n            match backtrace.status() {\n                BacktraceStatus::Captured | BacktraceStatus::Disabled | _ =\u003e {}\n            }\n            unimplemented!()\n        }\n    }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","python","target","release","build","markup5ever-a337ab0d82c5f354","out","generated.rs"],"content":"pub type LocalName = :: string_cache :: Atom \u003c LocalNameStaticSet \u003e ;\n# [derive (PartialEq , Eq , PartialOrd , Ord)] pub struct LocalNameStaticSet ;\nimpl :: string_cache :: StaticAtomSet for LocalNameStaticSet { fn get () -\u003e \u0026 'static :: string_cache :: PhfStrSet { static SET : :: string_cache :: PhfStrSet = :: string_cache :: PhfStrSet { key : 12913932095322966823u64 , disps : \u0026 [(0u32 , 0u32) , (0u32 , 1u32) , (0u32 , 41u32) , (0u32 , 281u32) , (0u32 , 11u32) , (0u32 , 35u32) , (8u32 , 60u32) , (0u32 , 0u32) , (0u32 , 91u32) , (1u32 , 1u32) , (0u32 , 433u32) , (0u32 , 1u32) , (0u32 , 250u32) , (0u32 , 5u32) , (0u32 , 3u32) , (0u32 , 4u32) , (0u32 , 11u32) , (5u32 , 351u32) , (0u32 , 0u32) , (0u32 , 46u32) , (0u32 , 66u32) , (0u32 , 32u32) , (0u32 , 0u32) , (0u32 , 1u32) , (0u32 , 109u32) , (0u32 , 88u32) , (0u32 , 44u32) , (7u32 , 548u32) , (0u32 , 0u32) , (0u32 , 9u32) , (0u32 , 3u32) , (0u32 , 80u32) , (0u32 , 15u32) , (2u32 , 320u32) , (2u32 , 92u32) , (0u32 , 0u32) , (3u32 , 7u32) , (0u32 , 0u32) , (0u32 , 68u32) , (0u32 , 539u32) , (0u32 , 0u32) , (1u32 , 1u32) , (0u32 , 16u32) , (0u32 , 3u32) , (0u32 , 303u32) , (0u32 , 0u32) , (1u32 , 588u32) , (0u32 , 0u32) , (0u32 , 380u32) , (0u32 , 164u32) , (0u32 , 524u32) , (3u32 , 355u32) , (0u32 , 77u32) , (0u32 , 6u32) , (0u32 , 5u32) , (0u32 , 67u32) , (0u32 , 54u32) , (0u32 , 16u32) , (8u32 , 390u32) , (2u32 , 199u32) , (5u32 , 7u32) , (0u32 , 0u32) , (1u32 , 382u32) , (0u32 , 3u32) , (0u32 , 171u32) , (1u32 , 102u32) , (2u32 , 418u32) , (0u32 , 399u32) , (0u32 , 172u32) , (0u32 , 521u32) , (0u32 , 7u32) , (11u32 , 388u32) , (0u32 , 143u32) , (0u32 , 0u32) , (0u32 , 12u32) , (0u32 , 0u32) , (0u32 , 489u32) , (38u32 , 486u32) , (0u32 , 227u32) , (0u32 , 378u32) , (0u32 , 55u32) , (0u32 , 56u32) , (0u32 , 37u32) , (48u32 , 12u32) , (0u32 , 78u32) , (7u32 , 150u32) , (0u32 , 11u32) , (40u32 , 550u32) , (32u32 , 141u32) , (0u32 , 244u32) , (7u32 , 367u32) , (0u32 , 0u32) , (0u32 , 101u32) , (31u32 , 445u32) , (1u32 , 534u32) , (9u32 , 443u32) , (7u32 , 154u32) , (1u32 , 433u32) , (0u32 , 596u32) , (6u32 , 425u32) , (0u32 , 17u32) , (0u32 , 150u32) , (0u32 , 6u32) , (3u32 , 178u32) , (0u32 , 6u32) , (0u32 , 19u32) , (0u32 , 27u32) , (0u32 , 62u32) , (0u32 , 4u32) , (1u32 , 582u32) , (1u32 , 394u32) , (33u32 , 354u32) , (0u32 , 3u32) , (0u32 , 402u32) , (2u32 , 185u32) , (10u32 , 584u32) , (25u32 , 83u32) , (0u32 , 10u32) , (0u32 , 7u32) , (0u32 , 33u32) , (0u32 , 42u32)] , atoms : \u0026 [\"requiredfeatures\",\n\"pointsAtZ\",\n\"xlink:role\",\n\"markerheight\",\n\"text-rendering\",\n\"stroke-opacity\",\n\"stitchtiles\",\n\"onoffline\",\n\"vert-adv-y\",\n\"columnspan\",\n\"calcmode\",\n\"stroke-linecap\",\n\"complexes\",\n\"crossorigin\",\n\"unselectable\",\n\"fePointLight\",\n\"exponentiale\",\n\"markerUnits\",\n\"cartesianproduct\",\n\"feoffset\",\n\"spreadmethod\",\n\"marker-end\",\n\"lighting-color\",\n\"textpath\",\n\"ondragdrop\",\n\"autoplay\",\n\"controllerchange\",\n\"primitiveUnits\",\n\"ondragenter\",\n\"dominant-baseline\",\n\"language\",\n\"xml:lang\",\n\"autocomplete\",\n\"edgemode\",\n\"repeatCount\",\n\"surfacescale\",\n\"lengthAdjust\",\n\"aria-colindex\",\n\"stop-opacity\",\n\"frameborder\",\n\"textlength\",\n\"alignment-baseline\",\n\"additive\",\n\"preserveAspectRatio\",\n\"accesskey\",\n\"stitchTiles\",\n\"feSpotLight\",\n\"transpose\",\n\"horiz-adv-x\",\n\"textPath\",\n\"overline-thickness\",\n\"flood-opacity\",\n\"bevelled\",\n\"notanumber\",\n\"onstorage\",\n\"patterncontentunits\",\n\"markerHeight\",\n\"aria-colcount\",\n\"spreadMethod\",\n\"feColorMatrix\",\n\"aria-atomic\",\n\"fecomposite\",\n\"xlink:actuate\",\n\"itemscope\",\n\"onpageshow\",\n\"onbeforeunload\",\n\"pointsatx\",\n\"longdesc\",\n\"aria-disabled\",\n\"exponent\",\n\"rationals\",\n\"foreignObject\",\n\"altGlyphItem\",\n\"markerWidth\",\n\"selection\",\n\"aria-hidden\",\n\"figcaption\",\n\"datatemplate\",\n\"onmousedown\",\n\"maligngroup\",\n\"colgroup\",\n\"determinant\",\n\"attributeType\",\n\"marker-mid\",\n\"shadowrootserializable\",\n\"property\",\n\"onbeforeeditfocus\",\n\"glyphRef\",\n\"aria-roledescription\",\n\"aria-relevant\",\n\"femergenode\",\n\"filterunits\",\n\"feDropShadow\",\n\"novalidate\",\n\"thickmathspace\",\n\"feOffset\",\n\"verythickmathspace\",\n\"clip-path\",\n\"marginwidth\",\n\"text-decoration\",\n\"definitionURL\",\n\"download\",\n\"mediummathspace\",\n\"aria-labelledby\",\n\"pointsatz\",\n\"semantics\",\n\"autosubmit\",\n\"http-equiv\",\n\"emptyset\",\n\"aria-checked\",\n\"onactivate\",\n\"variance\",\n\"fepointlight\",\n\"menclose\",\n\"gradientTransform\",\n\"shadowrootmode\",\n\"font-stretch\",\n\"alignmentscope\",\n\"ondragleave\",\n\"onresize\",\n\"referrerpolicy\",\n\"stroke-miterlimit\",\n\"linearGradient\",\n\"strikethrough-thickness\",\n\"color-profile\",\n\"onlanguagechange\",\n\"xlink:arcrole\",\n\"visibility\",\n\"itemtype\",\n\"onselectstart\",\n\"scrolldelay\",\n\"noframes\",\n\"mathsize\",\n\"onafterprint\",\n\"aria-flowto\",\n\"vert-origin-y\",\n\"onunload\",\n\"marginheight\",\n\"onbounce\",\n\"startoffset\",\n\"metadata\",\n\"aria-multiline\",\n\"word-spacing\",\n\"oncontrolselect\",\n\"blockquote\",\n\"font-size-adjust\",\n\"interval\",\n\"seamless\",\n\"xlink:type\",\n\"fill-rule\",\n\"aria-colindextext\",\n\"partialdiff\",\n\"scriptsizemultiplier\",\n\"matrixrow\",\n\"equalrows\",\n\"onmessage\",\n\"numOctaves\",\n\"\",\n\"fontstyle\",\n\"listener\",\n\"onbeforepaste\",\n\"linebreak\",\n\"transform\",\n\"zoomandpan\",\n\"aria-orientation\",\n\"aria-rowspan\",\n\"kernelMatrix\",\n\"domainofapplication\",\n\"noresize\",\n\"pathLength\",\n\"viewTarget\",\n\"onfocusin\",\n\"diffuseConstant\",\n\"aria-channel\",\n\"color-interpolation-filters\",\n\"repeatDur\",\n\"divergence\",\n\"fedropshadow\",\n\"formmethod\",\n\"alphabetic\",\n\"onchange\",\n\"thinmathspace\",\n\"feSpecularLighting\",\n\"fediffuselighting\",\n\"onbeforeupdate\",\n\"columnlines\",\n\"ondataavailable\",\n\"aria-valuemax\",\n\"aria-setsize\",\n\"pointsaty\",\n\"horiz-origin-x\",\n\"aria-grab\",\n\"diffuseconstant\",\n\"aria-posinset\",\n\"aria-sort\",\n\"baseline-shift\",\n\"clippathunits\",\n\"aria-controls\",\n\"image-rendering\",\n\"ondragend\",\n\"xchannelselector\",\n\"altglyph\",\n\"preserveaspectratio\",\n\"contentScriptType\",\n\"subscriptshift\",\n\"onmouseleave\",\n\"attributename\",\n\"fespecularlighting\",\n\"integers\",\n\"preservealpha\",\n\"horiz-origin-y\",\n\"xlink:show\",\n\"filterRes\",\n\"onforminput\",\n\"font-face-format\",\n\"annotation\",\n\"onkeypress\",\n\"repeat-template\",\n\"font-face\",\n\"ideographic\",\n\"statechange\",\n\"ondatasetcomplete\",\n\"equivalent\",\n\"specularexponent\",\n\"altGlyphDef\",\n\"accumulate\",\n\"onmouseover\",\n\"basefrequency\",\n\"onmouseout\",\n\"mathcolor\",\n\"feTurbulence\",\n\"aria-readonly\",\n\"stroke-dasharray\",\n\"stroke-linejoin\",\n\"feComposite\",\n\"altglyphdef\",\n\"stdDeviation\",\n\"feMorphology\",\n\"feDistantLight\",\n\"fedistantlight\",\n\"animatetransform\",\n\"groupalign\",\n\"limitingConeAngle\",\n\"elevation\",\n\"systemLanguage\",\n\"irrelevant\",\n\"requiredExtensions\",\n\"aria-autocomplete\",\n\"color-rendering\",\n\"background\",\n\"malignmark\",\n\"onmousewheel\",\n\"animatecolor\",\n\"aria-braillelabel\",\n\"aria-details\",\n\"glyph-name\",\n\"missing-glyph\",\n\"aria-busy\",\n\"x-height\",\n\"fontweight\",\n\"multicol\",\n\"onlosecapture\",\n\"font-face-uri\",\n\"zoomAndPan\",\n\"optgroup\",\n\"xml:space\",\n\"specification\",\n\"laplacian\",\n\"scrolling\",\n\"movablelimits\",\n\"mprescripts\",\n\"onformchange\",\n\"v-mathematical\",\n\"maskContentUnits\",\n\"separator\",\n\"nomodule\",\n\"aria-colspan\",\n\"operator\",\n\"onsubmit\",\n\"aria-description\",\n\"repeat-max\",\n\"startOffset\",\n\"radialgradient\",\n\"symmetric\",\n\"codetype\",\n\"altGlyph\",\n\"cellspacing\",\n\"patternContentUnits\",\n\"fontfamily\",\n\"rowlines\",\n\"datetime\",\n\"draggable\",\n\"onrepeat\",\n\"pathlength\",\n\"noscript\",\n\"v-ideographic\",\n\"onfocusout\",\n\"v-alphabetic\",\n\"repeatdur\",\n\"glyphref\",\n\"stroke-dashoffset\",\n\"animation\",\n\"keyTimes\",\n\"notsubset\",\n\"factorof\",\n\"externalresourcesrequired\",\n\"aria-secret\",\n\"factorial\",\n\"eulergamma\",\n\"separators\",\n\"repeat-start\",\n\"aria-expanded\",\n\"pointsAtX\",\n\"vectorproduct\",\n\"enable-background\",\n\"framespacing\",\n\"contentscripttype\",\n\"basefont\",\n\"unicode-range\",\n\"foreignobject\",\n\"polyline\",\n\"patternunits\",\n\"specularExponent\",\n\"radiogroup\",\n\"codomain\",\n\"ononline\",\n\"requiredFeatures\",\n\"font-variant\",\n\"aria-level\",\n\"columnalign\",\n\"notation\",\n\"onrowenter\",\n\"feMergeNode\",\n\"glyph-orientation-horizontal\",\n\"patterntransform\",\n\"patternUnits\",\n\"onmoveend\",\n\"prefetch\",\n\"lineargradient\",\n\"controls\",\n\"autofocus\",\n\"contenteditable\",\n\"hidefocus\",\n\"numoctaves\",\n\"aria-activedescendant\",\n\"filterres\",\n\"aria-placeholder\",\n\"momentabout\",\n\"font-face-src\",\n\"mathematical\",\n\"clipPathUnits\",\n\"accept-charset\",\n\"condition\",\n\"formaction\",\n\"surfaceScale\",\n\"oninvalid\",\n\"plaintext\",\n\"baseprofile\",\n\"onpropertychange\",\n\"feComponentTransfer\",\n\"imaginary\",\n\"onscroll\",\n\"cellpadding\",\n\"overline-position\",\n\"disabled\",\n\"intercept\",\n\"kernelunitlength\",\n\"aria-valuetext\",\n\"rendering-intent\",\n\"preserveAlpha\",\n\"aria-rowindextext\",\n\"aria-templateid\",\n\"selector\",\n\"vert-origin-x\",\n\"contentstyletype\",\n\"encoding\",\n\"markerwidth\",\n\"attributeName\",\n\"lengthadjust\",\n\"kernelUnitLength\",\n\"font-size\",\n\"actiontype\",\n\"onfilterchange\",\n\"aria-live\",\n\"units-per-em\",\n\"viewtarget\",\n\"onmousemove\",\n\"maskunits\",\n\"mmultiscripts\",\n\"attributetype\",\n\"ondragover\",\n\"outerproduct\",\n\"aria-dropeffect\",\n\"animateColor\",\n\"aria-keyshortcuts\",\n\"clipPath\",\n\"gradienttransform\",\n\"onbeforeprint\",\n\"letter-spacing\",\n\"calcMode\",\n\"scalarproduct\",\n\"v-hanging\",\n\"panose-1\",\n\"font-weight\",\n\"aria-selected\",\n\"aria-haspopup\",\n\"onbeforecut\",\n\"onselect\",\n\"keysplines\",\n\"keytimes\",\n\"onrowexit\",\n\"repeat-min\",\n\"aria-pressed\",\n\"glyph-orientation-vertical\",\n\"minlength\",\n\"contextmenu\",\n\"onerrorupdate\",\n\"aria-label\",\n\"fieldset\",\n\"columnspacing\",\n\"allowfullscreen\",\n\"accentunder\",\n\"yChannelSelector\",\n\"ondblclick\",\n\"unicode-bidi\",\n\"feGaussianBlur\",\n\"onkeydown\",\n\"radialGradient\",\n\"veryverythickmathspace\",\n\"font-family\",\n\"menuitem\",\n\"orientation\",\n\"aria-rowindex\",\n\"readonly\",\n\"quotient\",\n\"externalResourcesRequired\",\n\"aria-required\",\n\"required\",\n\"onrowsinserted\",\n\"onpopstate\",\n\"hreflang\",\n\"aria-brailleroledescription\",\n\"markerunits\",\n\"aria-current\",\n\"aria-errormessage\",\n\"aria-multiselectable\",\n\"arabic-form\",\n\"textarea\",\n\"tableValues\",\n\"infinity\",\n\"aria-valuenow\",\n\"lowlimit\",\n\"notprsubset\",\n\"marker-start\",\n\"occurrence\",\n\"fecomponenttransfer\",\n\"fontsize\",\n\"translate\",\n\"direction\",\n\"repeatcount\",\n\"xmlns:xlink\",\n\"shadowrootclonable\",\n\"reversed\",\n\"baseProfile\",\n\"patternTransform\",\n\"scriptminsize\",\n\"mathbackground\",\n\"contentStyleType\",\n\"multiple\",\n\"baseline\",\n\"oncontextmenu\",\n\"textLength\",\n\"decoding\",\n\"maskUnits\",\n\"tabindex\",\n\"clippath\",\n\"limitingconeangle\",\n\"flood-color\",\n\"otherwise\",\n\"naturalnumbers\",\n\"fedisplacementmap\",\n\"formnovalidate\",\n\"linethickness\",\n\"line-height\",\n\"animatemotion\",\n\"definition-src\",\n\"maskcontentunits\",\n\"ondatasetchanged\",\n\"color-interpolation\",\n\"aria-rowcount\",\n\"aria-invalid\",\n\"mozbrowser\",\n\"stop-color\",\n\"xChannelSelector\",\n\"specularconstant\",\n\"onreadystatechange\",\n\"onmovestart\",\n\"dataformatas\",\n\"fegaussianblur\",\n\"onmouseup\",\n\"feturbulence\",\n\"requiredextensions\",\n\"codebase\",\n\"xml:base\",\n\"shape-rendering\",\n\"tablevalues\",\n\"selected\",\n\"gradientunits\",\n\"template\",\n\"mphantom\",\n\"gradientUnits\",\n\"superscriptshift\",\n\"onrowsdelete\",\n\"onmouseenter\",\n\"valuetype\",\n\"progress\",\n\"onbeforeactivate\",\n\"pointsAtY\",\n\"feDisplacementMap\",\n\"aria-valuemin\",\n\"text-anchor\",\n\"onpagehide\",\n\"stddeviation\",\n\"systemlanguage\",\n\"formenctype\",\n\"pointer-events\",\n\"xlink:title\",\n\"inputmode\",\n\"amplitude\",\n\"aria-describedby\",\n\"stretchy\",\n\"shadowrootdelegatesfocus\",\n\"ondragstart\",\n\"rowalign\",\n\"font-style\",\n\"keypoints\",\n\"femorphology\",\n\"aria-datatype\",\n\"feDiffuseLighting\",\n\"mlabeledtr\",\n\"datalist\",\n\"animateTransform\",\n\"clip-rule\",\n\"filterUnits\",\n\"specularConstant\",\n\"onhashchange\",\n\"onafterupdate\",\n\"primitiveunits\",\n\"imaginaryi\",\n\"strikethrough-position\",\n\"overflow\",\n\"solidcolor\",\n\"aria-modal\",\n\"placeholder\",\n\"edgeMode\",\n\"itemprop\",\n\"feConvolveMatrix\",\n\"fespotlight\",\n\"onbeforecopy\",\n\"baseFrequency\",\n\"keyPoints\",\n\"definitionurl\",\n\"stroke-width\",\n\"onfinish\",\n\"conjugate\",\n\"veryverythinmathspace\",\n\"fetchpriority\",\n\"keySplines\",\n\"intersect\",\n\"spellcheck\",\n\"mathvariant\",\n\"integrity\",\n\"piecewise\",\n\"oncellchange\",\n\"maxlength\",\n\"prsubset\",\n\"aria-owns\",\n\"feconvolvematrix\",\n\"manifest\",\n\"ondeactivate\",\n\"columnwidth\",\n\"rowspacing\",\n\"underline-position\",\n\"annotation-xml\",\n\"fill-opacity\",\n\"ychannelselector\",\n\"xlink:href\",\n\"frameset\",\n\"animateMotion\",\n\"cap-height\",\n\"formtarget\",\n\"font-face-name\",\n\"altglyphitem\",\n\"onbefordeactivate\",\n\"scriptlevel\",\n\"writing-mode\",\n\"equalcolumns\",\n\"munderover\",\n\"accent-height\",\n\"verythinmathspace\",\n\"displaystyle\",\n\"underline-thickness\",\n\"kernelmatrix\",\n\"fecolormatrix\"] , hashes : \u0026 [3368766693u32 , 2162760400u32 , 2705478669u32 , 3367662520u32 , 1466152561u32 , 2007550408u32 , 1578024761u32 , 496466373u32 , 3857554377u32 , 1113648994u32 , 1924991364u32 , 859546789u32 , 3761485389u32 , 1099196523u32 , 1459652027u32 , 2112894915u32 , 527925402u32 , 3390498297u32 , 3650491062u32 , 1281759160u32 , 2338483475u32 , 1639866691u32 , 3799256240u32 , 1290517656u32 , 4174481087u32 , 2113798551u32 , 3888122413u32 , 235814134u32 , 1346406727u32 , 3173400481u32 , 3213189697u32 , 2577707114u32 , 139625561u32 , 3522778558u32 , 4004244404u32 , 4193230156u32 , 3766194097u32 , 699250933u32 , 2377326793u32 , 1670804630u32 , 1704100245u32 , 3727352922u32 , 2271299428u32 , 4080036470u32 , 1340705914u32 , 1906307066u32 , 2701977759u32 , 2231254690u32 , 3480491085u32 , 2005060454u32 , 1764594812u32 , 1048020461u32 , 42180808u32 , 3471797576u32 , 1081021937u32 , 2965230298u32 , 3420533286u32 , 2762337148u32 , 150393700u32 , 3819629636u32 , 3441525639u32 , 2660037162u32 , 497920229u32 , 1437637129u32 , 1784393862u32 , 1327970202u32 , 2196595662u32 , 3838527384u32 , 520649620u32 , 1700718142u32 , 1659529969u32 , 917510687u32 , 1660726878u32 , 3535003966u32 , 1529410224u32 , 4016453314u32 , 2771320901u32 , 1013909549u32 , 1494292933u32 , 4287406983u32 , 482099679u32 , 4114830095u32 , 4001891308u32 , 3503166008u32 , 13535145u32 , 551601771u32 , 977519882u32 , 3756296120u32 , 1070642373u32 , 3895686923u32 , 2229477384u32 , 3520680811u32 , 3543883658u32 , 1694998203u32 , 2488889144u32 , 1406178112u32 , 4274065971u32 , 3745411061u32 , 517970045u32 , 857129565u32 , 1411183032u32 , 3224307212u32 , 1867791235u32 , 1696233065u32 , 2980412961u32 , 189988860u32 , 3174660173u32 , 1465547969u32 , 3608092222u32 , 2710653095u32 , 2720850668u32 , 540156035u32 , 3031015162u32 , 2825708013u32 , 1313537745u32 , 123115520u32 , 1060911337u32 , 428550904u32 , 1356155463u32 , 1397943031u32 , 326494834u32 , 1597870884u32 , 1956396338u32 , 3978549325u32 , 3123322936u32 , 625288246u32 , 1674115585u32 , 680267915u32 , 876893636u32 , 3044528111u32 , 3588373335u32 , 1622799733u32 , 191876287u32 , 3088760233u32 , 1462083347u32 , 1137297938u32 , 1270941540u32 , 1341662051u32 , 236464811u32 , 3023844475u32 , 1638551108u32 , 688563368u32 , 225950890u32 , 1085252765u32 , 1289880550u32 , 909579565u32 , 3813953811u32 , 1967061597u32 , 3629415669u32 , 183626286u32 , 1721701609u32 , 3140418151u32 , 1106010321u32 , 1980444132u32 , 610893786u32 , 2526332624u32 , 2190494129u32 , 4082073077u32 , 89533980u32 , 1289272887u32 , 835417400u32 , 1751032114u32 , 2990288183u32 , 3653391143u32 , 1855625123u32 , 4118614427u32 , 1727774507u32 , 1000927536u32 , 3709793219u32 , 2152634883u32 , 3081310440u32 , 3349181976u32 , 898067958u32 , 4257931290u32 , 840604679u32 , 642136761u32 , 3590479039u32 , 1776997671u32 , 2901051737u32 , 635163395u32 , 671909442u32 , 3172500845u32 , 2875176293u32 , 582074557u32 , 1064789251u32 , 3139000449u32 , 2986159298u32 , 2627759492u32 , 2440702496u32 , 2145215358u32 , 960352296u32 , 1733779952u32 , 2909783456u32 , 1086403303u32 , 2172529172u32 , 1372447217u32 , 2648768565u32 , 269731020u32 , 3725445512u32 , 4019205149u32 , 4064199297u32 , 3473820876u32 , 13967138u32 , 4019313672u32 , 1324932700u32 , 1746599759u32 , 3359083184u32 , 968834697u32 , 1359418558u32 , 328232673u32 , 1582153498u32 , 731340681u32 , 23332298u32 , 872051764u32 , 2351838155u32 , 1960989138u32 , 491646294u32 , 1363498200u32 , 59658625u32 , 3468989663u32 , 2075053822u32 , 297387744u32 , 487396000u32 , 2458868732u32 , 631093780u32 , 3278498399u32 , 2062376914u32 , 4219469015u32 , 1563912927u32 , 1159398089u32 , 2410855252u32 , 2753608321u32 , 2806594463u32 , 388019751u32 , 149474300u32 , 2282081120u32 , 577943792u32 , 1969026116u32 , 3022346510u32 , 597485693u32 , 4088548386u32 , 3978774502u32 , 175932733u32 , 3074935477u32 , 2994067376u32 , 2998850704u32 , 297767543u32 , 1695163510u32 , 3517724257u32 , 540984354u32 , 4197990453u32 , 825000363u32 , 3862168567u32 , 3099170635u32 , 4213661298u32 , 3953335784u32 , 4214847380u32 , 1443202521u32 , 67060975u32 , 1436742140u32 , 284653812u32 , 3937191824u32 , 3038336232u32 , 251844155u32 , 3251283326u32 , 544785510u32 , 2052860768u32 , 3564373280u32 , 372536167u32 , 1490652026u32 , 4279947214u32 , 2407704912u32 , 4032437431u32 , 2761967137u32 , 259654618u32 , 2731266052u32 , 3483791417u32 , 671572742u32 , 2591735095u32 , 2550357363u32 , 742460070u32 , 33840900u32 , 2038498193u32 , 3391938715u32 , 1715378710u32 , 3482160649u32 , 3087731897u32 , 624093324u32 , 4133853804u32 , 1943821868u32 , 2832170387u32 , 1213081654u32 , 1328456326u32 , 3041455211u32 , 3496513502u32 , 143478574u32 , 4266430317u32 , 2192643058u32 , 3173625849u32 , 53892155u32 , 1493588833u32 , 1344436999u32 , 1135843586u32 , 1123905875u32 , 340120193u32 , 1068196084u32 , 3391050331u32 , 3182531199u32 , 2798901808u32 , 2509936390u32 , 3247137570u32 , 2813597207u32 , 1713409972u32 , 2271863710u32 , 839481326u32 , 2384049441u32 , 4018656289u32 , 3805722218u32 , 3054316836u32 , 904157188u32 , 2537656704u32 , 3221036252u32 , 3353385752u32 , 906623274u32 , 3848540887u32 , 1545307082u32 , 1784113404u32 , 3735993810u32 , 948133874u32 , 95564789u32 , 1196494198u32 , 1285071230u32 , 11851321u32 , 2143535654u32 , 3469436088u32 , 718491279u32 , 722849851u32 , 2884343567u32 , 797499465u32 , 623782337u32 , 2488083091u32 , 1026931307u32 , 1421968030u32 , 3505831613u32 , 3356497412u32 , 314533796u32 , 369465691u32 , 3467076559u32 , 3569972244u32 , 631162154u32 , 193163341u32 , 3668239605u32 , 1492357159u32 , 3859396703u32 , 3311581079u32 , 849353939u32 , 498024801u32 , 2146706716u32 , 1268358839u32 , 1003700867u32 , 155801033u32 , 3263344947u32 , 3303937590u32 , 24676607u32 , 2253042667u32 , 2250640510u32 , 3434111473u32 , 3336988988u32 , 986461641u32 , 1054325476u32 , 844290399u32 , 2869380463u32 , 1151125310u32 , 2286720981u32 , 787973706u32 , 1857928766u32 , 1961077096u32 , 3148690945u32 , 322837783u32 , 3394829011u32 , 938548574u32 , 3674106722u32 , 990264918u32 , 26369323u32 , 2673802232u32 , 1754753923u32 , 3598404451u32 , 1008080924u32 , 3595420161u32 , 3447324541u32 , 2620153124u32 , 4151148662u32 , 1402964693u32 , 2274933261u32 , 431655942u32 , 4110733451u32 , 2468381339u32 , 1853897548u32 , 4104071589u32 , 1713731671u32 , 742853127u32 , 3574495545u32 , 798432117u32 , 2754786514u32 , 940673285u32 , 2893479988u32 , 2363338602u32 , 1904259492u32 , 1980252733u32 , 1343823872u32 , 130627326u32 , 3231125223u32 , 962337312u32 , 3720179864u32 , 1114315443u32 , 2389793136u32 , 2176790048u32 , 581625092u32 , 167018041u32 , 3072954000u32 , 3553740950u32 , 1039356818u32 , 898289440u32 , 3318082606u32 , 4260186941u32 , 127349794u32 , 3792741489u32 , 1642132156u32 , 1964478094u32 , 4121432320u32 , 3273539984u32 , 1545869555u32 , 998270762u32 , 290068694u32 , 890471348u32 , 4114207458u32 , 303986147u32 , 1014874794u32 , 697370994u32 , 507264248u32 , 2619524090u32 , 832628307u32 , 3173477931u32 , 121548787u32 , 516688877u32 , 882636649u32 , 3199297686u32 , 471362903u32 , 836037603u32 , 3064390904u32 , 3377397637u32 , 2766318564u32 , 3646787135u32 , 1704381425u32 , 4123782853u32 , 1390052554u32 , 2140727092u32 , 1647114263u32 , 316404133u32 , 4144887102u32 , 3949169397u32 , 2383700325u32 , 3776643770u32 , 268294220u32 , 2555432291u32 , 776053845u32 , 41264406u32 , 1496007974u32 , 2907088801u32 , 2047753258u32 , 1031843807u32 , 3015830598u32 , 4208387215u32 , 585557574u32 , 441619653u32 , 1365633322u32 , 4086049772u32 , 2068298677u32 , 909665113u32 , 3315223323u32 , 2324745345u32 , 3572217425u32 , 611308476u32 , 1029483847u32 , 1846373592u32 , 1425318046u32 , 3648607726u32 , 4067843623u32 , 2938551886u32 , 1025361169u32 , 3472575083u32 , 2352150961u32 , 1531081973u32 , 738404731u32 , 4048787516u32 , 1081225797u32 , 1271998022u32 , 3538034810u32 , 2606928828u32 , 3337178u32 , 2817038524u32 , 2117758015u32 , 1918948260u32 , 3107512368u32 , 207807063u32 , 2974337319u32 , 1326112048u32 , 2770211272u32 , 3192182081u32 , 2213967518u32 , 1089255496u32 , 4197022858u32 , 3436454788u32 , 745064063u32 , 3006277213u32 , 3164895664u32 , 1833541319u32 , 3717621328u32 , 2091062413u32 , 1737183206u32 , 1747256964u32 , 3730423347u32 , 2791371120u32 , 6175338u32 , 510569370u32 , 570359024u32 , 115637463u32 , 1634030783u32 , 1004995609u32 , 2730644329u32 , 4157184116u32 , 1934553247u32 , 2331857769u32 , 11175636u32 , 1109713652u32 , 1882820659u32 , 1031924441u32 , 3084283302u32 , 3017840974u32 , 167340041u32 , 2481108222u32 , 1122986055u32 , 4179141959u32 , 717168679u32 , 1503507106u32 , 3316294029u32 , 1463711312u32 , 660920321u32 , 3225919750u32 , 2055579803u32 , 4010765371u32 , 3200099719u32 , 413668059u32 , 4227008938u32 , 427162403u32 , 3364582022u32 , 3296146244u32 , 1469020628u32 , 3855161187u32 , 214212608u32 , 3937177209u32 , 790236809u32 , 2961964106u32 , 1500515759u32 , 357019207u32 , 4125580644u32 , 3637562920u32 , 2607187618u32 , 1270424231u32 , 3345816294u32 , 1585700207u32 , 3290302249u32 , 1340310784u32 , 3561280171u32 , 4155473355u32 , 1932517039u32 , 1528320406u32 , 1038372645u32 , 2927217335u32 , 1622957280u32 , 3931194778u32 , 1152797465u32 , 3161172129u32 , 1040004347u32 , 2519983718u32 , 1079146945u32 , 2985998690u32 , 2822081788u32 , 3708044859u32 , 1209573904u32 , 1265818470u32 , 951933631u32 , 1160497299u32 , 3022377460u32 , 261387879u32 , 3812424145u32 , 3371793166u32 , 1108361085u32 , 2749033157u32 , 868058960u32 , 1693167880u32 , 657335448u32 , 1511898050u32 , 2627228424u32] } ;\n\u0026 SET } fn empty_string_index () -\u003e u32 { 157u32 } } pub const ATOM_LOCALNAME__72_65_71_75_69_72_65_64_66_65_61_74_75_72_65_73 : LocalName = LocalName :: pack_static (0u32) ;\npub const ATOM_LOCALNAME__70_6F_69_6E_74_73_41_74_5A : LocalName = LocalName :: pack_static (1u32) ;\npub const ATOM_LOCALNAME__78_6C_69_6E_6B_3A_72_6F_6C_65 : LocalName = LocalName :: pack_static (2u32) ;\npub const ATOM_LOCALNAME__6D_61_72_6B_65_72_68_65_69_67_68_74 : LocalName = LocalName :: pack_static (3u32) ;\npub const ATOM_LOCALNAME__74_65_78_74_2D_72_65_6E_64_65_72_69_6E_67 : LocalName = LocalName :: pack_static (4u32) ;\npub const ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_6F_70_61_63_69_74_79 : LocalName = LocalName :: pack_static (5u32) ;\npub const ATOM_LOCALNAME__73_74_69_74_63_68_74_69_6C_65_73 : LocalName = LocalName :: pack_static (6u32) ;\npub const ATOM_LOCALNAME__6F_6E_6F_66_66_6C_69_6E_65 : LocalName = LocalName :: pack_static (7u32) ;\npub const ATOM_LOCALNAME__76_65_72_74_2D_61_64_76_2D_79 : LocalName = LocalName :: pack_static (8u32) ;\npub const ATOM_LOCALNAME__63_6F_6C_75_6D_6E_73_70_61_6E : LocalName = LocalName :: pack_static (9u32) ;\npub const ATOM_LOCALNAME__63_61_6C_63_6D_6F_64_65 : LocalName = LocalName :: pack_static (10u32) ;\npub const ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_6C_69_6E_65_63_61_70 : LocalName = LocalName :: pack_static (11u32) ;\npub const ATOM_LOCALNAME__63_6F_6D_70_6C_65_78_65_73 : LocalName = LocalName :: pack_static (12u32) ;\npub const ATOM_LOCALNAME__63_72_6F_73_73_6F_72_69_67_69_6E : LocalName = LocalName :: pack_static (13u32) ;\npub const ATOM_LOCALNAME__75_6E_73_65_6C_65_63_74_61_62_6C_65 : LocalName = LocalName :: pack_static (14u32) ;\npub const ATOM_LOCALNAME__66_65_50_6F_69_6E_74_4C_69_67_68_74 : LocalName = LocalName :: pack_static (15u32) ;\npub const ATOM_LOCALNAME__65_78_70_6F_6E_65_6E_74_69_61_6C_65 : LocalName = LocalName :: pack_static (16u32) ;\npub const ATOM_LOCALNAME__6D_61_72_6B_65_72_55_6E_69_74_73 : LocalName = LocalName :: pack_static (17u32) ;\npub const ATOM_LOCALNAME__63_61_72_74_65_73_69_61_6E_70_72_6F_64_75_63_74 : LocalName = LocalName :: pack_static (18u32) ;\npub const ATOM_LOCALNAME__66_65_6F_66_66_73_65_74 : LocalName = LocalName :: pack_static (19u32) ;\npub const ATOM_LOCALNAME__73_70_72_65_61_64_6D_65_74_68_6F_64 : LocalName = LocalName :: pack_static (20u32) ;\npub const ATOM_LOCALNAME__6D_61_72_6B_65_72_2D_65_6E_64 : LocalName = LocalName :: pack_static (21u32) ;\npub const ATOM_LOCALNAME__6C_69_67_68_74_69_6E_67_2D_63_6F_6C_6F_72 : LocalName = LocalName :: pack_static (22u32) ;\npub const ATOM_LOCALNAME__74_65_78_74_70_61_74_68 : LocalName = LocalName :: pack_static (23u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_72_61_67_64_72_6F_70 : LocalName = LocalName :: pack_static (24u32) ;\npub const ATOM_LOCALNAME__61_75_74_6F_70_6C_61_79 : LocalName = LocalName :: pack_static (25u32) ;\npub const ATOM_LOCALNAME__63_6F_6E_74_72_6F_6C_6C_65_72_63_68_61_6E_67_65 : LocalName = LocalName :: pack_static (26u32) ;\npub const ATOM_LOCALNAME__70_72_69_6D_69_74_69_76_65_55_6E_69_74_73 : LocalName = LocalName :: pack_static (27u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_72_61_67_65_6E_74_65_72 : LocalName = LocalName :: pack_static (28u32) ;\npub const ATOM_LOCALNAME__64_6F_6D_69_6E_61_6E_74_2D_62_61_73_65_6C_69_6E_65 : LocalName = LocalName :: pack_static (29u32) ;\npub const ATOM_LOCALNAME__6C_61_6E_67_75_61_67_65 : LocalName = LocalName :: pack_static (30u32) ;\npub const ATOM_LOCALNAME__78_6D_6C_3A_6C_61_6E_67 : LocalName = LocalName :: pack_static (31u32) ;\npub const ATOM_LOCALNAME__61_75_74_6F_63_6F_6D_70_6C_65_74_65 : LocalName = LocalName :: pack_static (32u32) ;\npub const ATOM_LOCALNAME__65_64_67_65_6D_6F_64_65 : LocalName = LocalName :: pack_static (33u32) ;\npub const ATOM_LOCALNAME__72_65_70_65_61_74_43_6F_75_6E_74 : LocalName = LocalName :: pack_static (34u32) ;\npub const ATOM_LOCALNAME__73_75_72_66_61_63_65_73_63_61_6C_65 : LocalName = LocalName :: pack_static (35u32) ;\npub const ATOM_LOCALNAME__6C_65_6E_67_74_68_41_64_6A_75_73_74 : LocalName = LocalName :: pack_static (36u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_63_6F_6C_69_6E_64_65_78 : LocalName = LocalName :: pack_static (37u32) ;\npub const ATOM_LOCALNAME__73_74_6F_70_2D_6F_70_61_63_69_74_79 : LocalName = LocalName :: pack_static (38u32) ;\npub const ATOM_LOCALNAME__66_72_61_6D_65_62_6F_72_64_65_72 : LocalName = LocalName :: pack_static (39u32) ;\npub const ATOM_LOCALNAME__74_65_78_74_6C_65_6E_67_74_68 : LocalName = LocalName :: pack_static (40u32) ;\npub const ATOM_LOCALNAME__61_6C_69_67_6E_6D_65_6E_74_2D_62_61_73_65_6C_69_6E_65 : LocalName = LocalName :: pack_static (41u32) ;\npub const ATOM_LOCALNAME__61_64_64_69_74_69_76_65 : LocalName = LocalName :: pack_static (42u32) ;\npub const ATOM_LOCALNAME__70_72_65_73_65_72_76_65_41_73_70_65_63_74_52_61_74_69_6F : LocalName = LocalName :: pack_static (43u32) ;\npub const ATOM_LOCALNAME__61_63_63_65_73_73_6B_65_79 : LocalName = LocalName :: pack_static (44u32) ;\npub const ATOM_LOCALNAME__73_74_69_74_63_68_54_69_6C_65_73 : LocalName = LocalName :: pack_static (45u32) ;\npub const ATOM_LOCALNAME__66_65_53_70_6F_74_4C_69_67_68_74 : LocalName = LocalName :: pack_static (46u32) ;\npub const ATOM_LOCALNAME__74_72_61_6E_73_70_6F_73_65 : LocalName = LocalName :: pack_static (47u32) ;\npub const ATOM_LOCALNAME__68_6F_72_69_7A_2D_61_64_76_2D_78 : LocalName = LocalName :: pack_static (48u32) ;\npub const ATOM_LOCALNAME__74_65_78_74_50_61_74_68 : LocalName = LocalName :: pack_static (49u32) ;\npub const ATOM_LOCALNAME__6F_76_65_72_6C_69_6E_65_2D_74_68_69_63_6B_6E_65_73_73 : LocalName = LocalName :: pack_static (50u32) ;\npub const ATOM_LOCALNAME__66_6C_6F_6F_64_2D_6F_70_61_63_69_74_79 : LocalName = LocalName :: pack_static (51u32) ;\npub const ATOM_LOCALNAME__62_65_76_65_6C_6C_65_64 : LocalName = LocalName :: pack_static (52u32) ;\npub const ATOM_LOCALNAME__6E_6F_74_61_6E_75_6D_62_65_72 : LocalName = LocalName :: pack_static (53u32) ;\npub const ATOM_LOCALNAME__6F_6E_73_74_6F_72_61_67_65 : LocalName = LocalName :: pack_static (54u32) ;\npub const ATOM_LOCALNAME__70_61_74_74_65_72_6E_63_6F_6E_74_65_6E_74_75_6E_69_74_73 : LocalName = LocalName :: pack_static (55u32) ;\npub const ATOM_LOCALNAME__6D_61_72_6B_65_72_48_65_69_67_68_74 : LocalName = LocalName :: pack_static (56u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_63_6F_6C_63_6F_75_6E_74 : LocalName = LocalName :: pack_static (57u32) ;\npub const ATOM_LOCALNAME__73_70_72_65_61_64_4D_65_74_68_6F_64 : LocalName = LocalName :: pack_static (58u32) ;\npub const ATOM_LOCALNAME__66_65_43_6F_6C_6F_72_4D_61_74_72_69_78 : LocalName = LocalName :: pack_static (59u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_61_74_6F_6D_69_63 : LocalName = LocalName :: pack_static (60u32) ;\npub const ATOM_LOCALNAME__66_65_63_6F_6D_70_6F_73_69_74_65 : LocalName = LocalName :: pack_static (61u32) ;\npub const ATOM_LOCALNAME__78_6C_69_6E_6B_3A_61_63_74_75_61_74_65 : LocalName = LocalName :: pack_static (62u32) ;\npub const ATOM_LOCALNAME__69_74_65_6D_73_63_6F_70_65 : LocalName = LocalName :: pack_static (63u32) ;\npub const ATOM_LOCALNAME__6F_6E_70_61_67_65_73_68_6F_77 : LocalName = LocalName :: pack_static (64u32) ;\npub const ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_75_6E_6C_6F_61_64 : LocalName = LocalName :: pack_static (65u32) ;\npub const ATOM_LOCALNAME__70_6F_69_6E_74_73_61_74_78 : LocalName = LocalName :: pack_static (66u32) ;\npub const ATOM_LOCALNAME__6C_6F_6E_67_64_65_73_63 : LocalName = LocalName :: pack_static (67u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_64_69_73_61_62_6C_65_64 : LocalName = LocalName :: pack_static (68u32) ;\npub const ATOM_LOCALNAME__65_78_70_6F_6E_65_6E_74 : LocalName = LocalName :: pack_static (69u32) ;\npub const ATOM_LOCALNAME__72_61_74_69_6F_6E_61_6C_73 : LocalName = LocalName :: pack_static (70u32) ;\npub const ATOM_LOCALNAME__66_6F_72_65_69_67_6E_4F_62_6A_65_63_74 : LocalName = LocalName :: pack_static (71u32) ;\npub const ATOM_LOCALNAME__61_6C_74_47_6C_79_70_68_49_74_65_6D : LocalName = LocalName :: pack_static (72u32) ;\npub const ATOM_LOCALNAME__6D_61_72_6B_65_72_57_69_64_74_68 : LocalName = LocalName :: pack_static (73u32) ;\npub const ATOM_LOCALNAME__73_65_6C_65_63_74_69_6F_6E : LocalName = LocalName :: pack_static (74u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_68_69_64_64_65_6E : LocalName = LocalName :: pack_static (75u32) ;\npub const ATOM_LOCALNAME__66_69_67_63_61_70_74_69_6F_6E : LocalName = LocalName :: pack_static (76u32) ;\npub const ATOM_LOCALNAME__64_61_74_61_74_65_6D_70_6C_61_74_65 : LocalName = LocalName :: pack_static (77u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_64_6F_77_6E : LocalName = LocalName :: pack_static (78u32) ;\npub const ATOM_LOCALNAME__6D_61_6C_69_67_6E_67_72_6F_75_70 : LocalName = LocalName :: pack_static (79u32) ;\npub const ATOM_LOCALNAME__63_6F_6C_67_72_6F_75_70 : LocalName = LocalName :: pack_static (80u32) ;\npub const ATOM_LOCALNAME__64_65_74_65_72_6D_69_6E_61_6E_74 : LocalName = LocalName :: pack_static (81u32) ;\npub const ATOM_LOCALNAME__61_74_74_72_69_62_75_74_65_54_79_70_65 : LocalName = LocalName :: pack_static (82u32) ;\npub const ATOM_LOCALNAME__6D_61_72_6B_65_72_2D_6D_69_64 : LocalName = LocalName :: pack_static (83u32) ;\npub const ATOM_LOCALNAME__73_68_61_64_6F_77_72_6F_6F_74_73_65_72_69_61_6C_69_7A_61_62_6C_65 : LocalName = LocalName :: pack_static (84u32) ;\npub const ATOM_LOCALNAME__70_72_6F_70_65_72_74_79 : LocalName = LocalName :: pack_static (85u32) ;\npub const ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_65_64_69_74_66_6F_63_75_73 : LocalName = LocalName :: pack_static (86u32) ;\npub const ATOM_LOCALNAME__67_6C_79_70_68_52_65_66 : LocalName = LocalName :: pack_static (87u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_72_6F_6C_65_64_65_73_63_72_69_70_74_69_6F_6E : LocalName = LocalName :: pack_static (88u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_72_65_6C_65_76_61_6E_74 : LocalName = LocalName :: pack_static (89u32) ;\npub const ATOM_LOCALNAME__66_65_6D_65_72_67_65_6E_6F_64_65 : LocalName = LocalName :: pack_static (90u32) ;\npub const ATOM_LOCALNAME__66_69_6C_74_65_72_75_6E_69_74_73 : LocalName = LocalName :: pack_static (91u32) ;\npub const ATOM_LOCALNAME__66_65_44_72_6F_70_53_68_61_64_6F_77 : LocalName = LocalName :: pack_static (92u32) ;\npub const ATOM_LOCALNAME__6E_6F_76_61_6C_69_64_61_74_65 : LocalName = LocalName :: pack_static (93u32) ;\npub const ATOM_LOCALNAME__74_68_69_63_6B_6D_61_74_68_73_70_61_63_65 : LocalName = LocalName :: pack_static (94u32) ;\npub const ATOM_LOCALNAME__66_65_4F_66_66_73_65_74 : LocalName = LocalName :: pack_static (95u32) ;\npub const ATOM_LOCALNAME__76_65_72_79_74_68_69_63_6B_6D_61_74_68_73_70_61_63_65 : LocalName = LocalName :: pack_static (96u32) ;\npub const ATOM_LOCALNAME__63_6C_69_70_2D_70_61_74_68 : LocalName = LocalName :: pack_static (97u32) ;\npub const ATOM_LOCALNAME__6D_61_72_67_69_6E_77_69_64_74_68 : LocalName = LocalName :: pack_static (98u32) ;\npub const ATOM_LOCALNAME__74_65_78_74_2D_64_65_63_6F_72_61_74_69_6F_6E : LocalName = LocalName :: pack_static (99u32) ;\npub const ATOM_LOCALNAME__64_65_66_69_6E_69_74_69_6F_6E_55_52_4C : LocalName = LocalName :: pack_static (100u32) ;\npub const ATOM_LOCALNAME__64_6F_77_6E_6C_6F_61_64 : LocalName = LocalName :: pack_static (101u32) ;\npub const ATOM_LOCALNAME__6D_65_64_69_75_6D_6D_61_74_68_73_70_61_63_65 : LocalName = LocalName :: pack_static (102u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_6C_61_62_65_6C_6C_65_64_62_79 : LocalName = LocalName :: pack_static (103u32) ;\npub const ATOM_LOCALNAME__70_6F_69_6E_74_73_61_74_7A : LocalName = LocalName :: pack_static (104u32) ;\npub const ATOM_LOCALNAME__73_65_6D_61_6E_74_69_63_73 : LocalName = LocalName :: pack_static (105u32) ;\npub const ATOM_LOCALNAME__61_75_74_6F_73_75_62_6D_69_74 : LocalName = LocalName :: pack_static (106u32) ;\npub const ATOM_LOCALNAME__68_74_74_70_2D_65_71_75_69_76 : LocalName = LocalName :: pack_static (107u32) ;\npub const ATOM_LOCALNAME__65_6D_70_74_79_73_65_74 : LocalName = LocalName :: pack_static (108u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_63_68_65_63_6B_65_64 : LocalName = LocalName :: pack_static (109u32) ;\npub const ATOM_LOCALNAME__6F_6E_61_63_74_69_76_61_74_65 : LocalName = LocalName :: pack_static (110u32) ;\npub const ATOM_LOCALNAME__76_61_72_69_61_6E_63_65 : LocalName = LocalName :: pack_static (111u32) ;\npub const ATOM_LOCALNAME__66_65_70_6F_69_6E_74_6C_69_67_68_74 : LocalName = LocalName :: pack_static (112u32) ;\npub const ATOM_LOCALNAME__6D_65_6E_63_6C_6F_73_65 : LocalName = LocalName :: pack_static (113u32) ;\npub const ATOM_LOCALNAME__67_72_61_64_69_65_6E_74_54_72_61_6E_73_66_6F_72_6D : LocalName = LocalName :: pack_static (114u32) ;\npub const ATOM_LOCALNAME__73_68_61_64_6F_77_72_6F_6F_74_6D_6F_64_65 : LocalName = LocalName :: pack_static (115u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_73_74_72_65_74_63_68 : LocalName = LocalName :: pack_static (116u32) ;\npub const ATOM_LOCALNAME__61_6C_69_67_6E_6D_65_6E_74_73_63_6F_70_65 : LocalName = LocalName :: pack_static (117u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_72_61_67_6C_65_61_76_65 : LocalName = LocalName :: pack_static (118u32) ;\npub const ATOM_LOCALNAME__6F_6E_72_65_73_69_7A_65 : LocalName = LocalName :: pack_static (119u32) ;\npub const ATOM_LOCALNAME__72_65_66_65_72_72_65_72_70_6F_6C_69_63_79 : LocalName = LocalName :: pack_static (120u32) ;\npub const ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_6D_69_74_65_72_6C_69_6D_69_74 : LocalName = LocalName :: pack_static (121u32) ;\npub const ATOM_LOCALNAME__6C_69_6E_65_61_72_47_72_61_64_69_65_6E_74 : LocalName = LocalName :: pack_static (122u32) ;\npub const ATOM_LOCALNAME__73_74_72_69_6B_65_74_68_72_6F_75_67_68_2D_74_68_69_63_6B_6E_65_73_73 : LocalName = LocalName :: pack_static (123u32) ;\npub const ATOM_LOCALNAME__63_6F_6C_6F_72_2D_70_72_6F_66_69_6C_65 : LocalName = LocalName :: pack_static (124u32) ;\npub const ATOM_LOCALNAME__6F_6E_6C_61_6E_67_75_61_67_65_63_68_61_6E_67_65 : LocalName = LocalName :: pack_static (125u32) ;\npub const ATOM_LOCALNAME__78_6C_69_6E_6B_3A_61_72_63_72_6F_6C_65 : LocalName = LocalName :: pack_static (126u32) ;\npub const ATOM_LOCALNAME__76_69_73_69_62_69_6C_69_74_79 : LocalName = LocalName :: pack_static (127u32) ;\npub const ATOM_LOCALNAME__69_74_65_6D_74_79_70_65 : LocalName = LocalName :: pack_static (128u32) ;\npub const ATOM_LOCALNAME__6F_6E_73_65_6C_65_63_74_73_74_61_72_74 : LocalName = LocalName :: pack_static (129u32) ;\npub const ATOM_LOCALNAME__73_63_72_6F_6C_6C_64_65_6C_61_79 : LocalName = LocalName :: pack_static (130u32) ;\npub const ATOM_LOCALNAME__6E_6F_66_72_61_6D_65_73 : LocalName = LocalName :: pack_static (131u32) ;\npub const ATOM_LOCALNAME__6D_61_74_68_73_69_7A_65 : LocalName = LocalName :: pack_static (132u32) ;\npub const ATOM_LOCALNAME__6F_6E_61_66_74_65_72_70_72_69_6E_74 : LocalName = LocalName :: pack_static (133u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_66_6C_6F_77_74_6F : LocalName = LocalName :: pack_static (134u32) ;\npub const ATOM_LOCALNAME__76_65_72_74_2D_6F_72_69_67_69_6E_2D_79 : LocalName = LocalName :: pack_static (135u32) ;\npub const ATOM_LOCALNAME__6F_6E_75_6E_6C_6F_61_64 : LocalName = LocalName :: pack_static (136u32) ;\npub const ATOM_LOCALNAME__6D_61_72_67_69_6E_68_65_69_67_68_74 : LocalName = LocalName :: pack_static (137u32) ;\npub const ATOM_LOCALNAME__6F_6E_62_6F_75_6E_63_65 : LocalName = LocalName :: pack_static (138u32) ;\npub const ATOM_LOCALNAME__73_74_61_72_74_6F_66_66_73_65_74 : LocalName = LocalName :: pack_static (139u32) ;\npub const ATOM_LOCALNAME__6D_65_74_61_64_61_74_61 : LocalName = LocalName :: pack_static (140u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_6D_75_6C_74_69_6C_69_6E_65 : LocalName = LocalName :: pack_static (141u32) ;\npub const ATOM_LOCALNAME__77_6F_72_64_2D_73_70_61_63_69_6E_67 : LocalName = LocalName :: pack_static (142u32) ;\npub const ATOM_LOCALNAME__6F_6E_63_6F_6E_74_72_6F_6C_73_65_6C_65_63_74 : LocalName = LocalName :: pack_static (143u32) ;\npub const ATOM_LOCALNAME__62_6C_6F_63_6B_71_75_6F_74_65 : LocalName = LocalName :: pack_static (144u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_73_69_7A_65_2D_61_64_6A_75_73_74 : LocalName = LocalName :: pack_static (145u32) ;\npub const ATOM_LOCALNAME__69_6E_74_65_72_76_61_6C : LocalName = LocalName :: pack_static (146u32) ;\npub const ATOM_LOCALNAME__73_65_61_6D_6C_65_73_73 : LocalName = LocalName :: pack_static (147u32) ;\npub const ATOM_LOCALNAME__78_6C_69_6E_6B_3A_74_79_70_65 : LocalName = LocalName :: pack_static (148u32) ;\npub const ATOM_LOCALNAME__66_69_6C_6C_2D_72_75_6C_65 : LocalName = LocalName :: pack_static (149u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_63_6F_6C_69_6E_64_65_78_74_65_78_74 : LocalName = LocalName :: pack_static (150u32) ;\npub const ATOM_LOCALNAME__70_61_72_74_69_61_6C_64_69_66_66 : LocalName = LocalName :: pack_static (151u32) ;\npub const ATOM_LOCALNAME__73_63_72_69_70_74_73_69_7A_65_6D_75_6C_74_69_70_6C_69_65_72 : LocalName = LocalName :: pack_static (152u32) ;\npub const ATOM_LOCALNAME__6D_61_74_72_69_78_72_6F_77 : LocalName = LocalName :: pack_static (153u32) ;\npub const ATOM_LOCALNAME__65_71_75_61_6C_72_6F_77_73 : LocalName = LocalName :: pack_static (154u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_65_73_73_61_67_65 : LocalName = LocalName :: pack_static (155u32) ;\npub const ATOM_LOCALNAME__6E_75_6D_4F_63_74_61_76_65_73 : LocalName = LocalName :: pack_static (156u32) ;\npub const ATOM_LOCALNAME_ : LocalName = LocalName :: pack_static (157u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_73_74_79_6C_65 : LocalName = LocalName :: pack_static (158u32) ;\npub const ATOM_LOCALNAME__6C_69_73_74_65_6E_65_72 : LocalName = LocalName :: pack_static (159u32) ;\npub const ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_70_61_73_74_65 : LocalName = LocalName :: pack_static (160u32) ;\npub const ATOM_LOCALNAME__6C_69_6E_65_62_72_65_61_6B : LocalName = LocalName :: pack_static (161u32) ;\npub const ATOM_LOCALNAME__74_72_61_6E_73_66_6F_72_6D : LocalName = LocalName :: pack_static (162u32) ;\npub const ATOM_LOCALNAME__7A_6F_6F_6D_61_6E_64_70_61_6E : LocalName = LocalName :: pack_static (163u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_6F_72_69_65_6E_74_61_74_69_6F_6E : LocalName = LocalName :: pack_static (164u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_72_6F_77_73_70_61_6E : LocalName = LocalName :: pack_static (165u32) ;\npub const ATOM_LOCALNAME__6B_65_72_6E_65_6C_4D_61_74_72_69_78 : LocalName = LocalName :: pack_static (166u32) ;\npub const ATOM_LOCALNAME__64_6F_6D_61_69_6E_6F_66_61_70_70_6C_69_63_61_74_69_6F_6E : LocalName = LocalName :: pack_static (167u32) ;\npub const ATOM_LOCALNAME__6E_6F_72_65_73_69_7A_65 : LocalName = LocalName :: pack_static (168u32) ;\npub const ATOM_LOCALNAME__70_61_74_68_4C_65_6E_67_74_68 : LocalName = LocalName :: pack_static (169u32) ;\npub const ATOM_LOCALNAME__76_69_65_77_54_61_72_67_65_74 : LocalName = LocalName :: pack_static (170u32) ;\npub const ATOM_LOCALNAME__6F_6E_66_6F_63_75_73_69_6E : LocalName = LocalName :: pack_static (171u32) ;\npub const ATOM_LOCALNAME__64_69_66_66_75_73_65_43_6F_6E_73_74_61_6E_74 : LocalName = LocalName :: pack_static (172u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_63_68_61_6E_6E_65_6C : LocalName = LocalName :: pack_static (173u32) ;\npub const ATOM_LOCALNAME__63_6F_6C_6F_72_2D_69_6E_74_65_72_70_6F_6C_61_74_69_6F_6E_2D_66_69_6C_74_65_72_73 : LocalName = LocalName :: pack_static (174u32) ;\npub const ATOM_LOCALNAME__72_65_70_65_61_74_44_75_72 : LocalName = LocalName :: pack_static (175u32) ;\npub const ATOM_LOCALNAME__64_69_76_65_72_67_65_6E_63_65 : LocalName = LocalName :: pack_static (176u32) ;\npub const ATOM_LOCALNAME__66_65_64_72_6F_70_73_68_61_64_6F_77 : LocalName = LocalName :: pack_static (177u32) ;\npub const ATOM_LOCALNAME__66_6F_72_6D_6D_65_74_68_6F_64 : LocalName = LocalName :: pack_static (178u32) ;\npub const ATOM_LOCALNAME__61_6C_70_68_61_62_65_74_69_63 : LocalName = LocalName :: pack_static (179u32) ;\npub const ATOM_LOCALNAME__6F_6E_63_68_61_6E_67_65 : LocalName = LocalName :: pack_static (180u32) ;\npub const ATOM_LOCALNAME__74_68_69_6E_6D_61_74_68_73_70_61_63_65 : LocalName = LocalName :: pack_static (181u32) ;\npub const ATOM_LOCALNAME__66_65_53_70_65_63_75_6C_61_72_4C_69_67_68_74_69_6E_67 : LocalName = LocalName :: pack_static (182u32) ;\npub const ATOM_LOCALNAME__66_65_64_69_66_66_75_73_65_6C_69_67_68_74_69_6E_67 : LocalName = LocalName :: pack_static (183u32) ;\npub const ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_75_70_64_61_74_65 : LocalName = LocalName :: pack_static (184u32) ;\npub const ATOM_LOCALNAME__63_6F_6C_75_6D_6E_6C_69_6E_65_73 : LocalName = LocalName :: pack_static (185u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_61_74_61_61_76_61_69_6C_61_62_6C_65 : LocalName = LocalName :: pack_static (186u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_76_61_6C_75_65_6D_61_78 : LocalName = LocalName :: pack_static (187u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_73_65_74_73_69_7A_65 : LocalName = LocalName :: pack_static (188u32) ;\npub const ATOM_LOCALNAME__70_6F_69_6E_74_73_61_74_79 : LocalName = LocalName :: pack_static (189u32) ;\npub const ATOM_LOCALNAME__68_6F_72_69_7A_2D_6F_72_69_67_69_6E_2D_78 : LocalName = LocalName :: pack_static (190u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_67_72_61_62 : LocalName = LocalName :: pack_static (191u32) ;\npub const ATOM_LOCALNAME__64_69_66_66_75_73_65_63_6F_6E_73_74_61_6E_74 : LocalName = LocalName :: pack_static (192u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_70_6F_73_69_6E_73_65_74 : LocalName = LocalName :: pack_static (193u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_73_6F_72_74 : LocalName = LocalName :: pack_static (194u32) ;\npub const ATOM_LOCALNAME__62_61_73_65_6C_69_6E_65_2D_73_68_69_66_74 : LocalName = LocalName :: pack_static (195u32) ;\npub const ATOM_LOCALNAME__63_6C_69_70_70_61_74_68_75_6E_69_74_73 : LocalName = LocalName :: pack_static (196u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_63_6F_6E_74_72_6F_6C_73 : LocalName = LocalName :: pack_static (197u32) ;\npub const ATOM_LOCALNAME__69_6D_61_67_65_2D_72_65_6E_64_65_72_69_6E_67 : LocalName = LocalName :: pack_static (198u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_72_61_67_65_6E_64 : LocalName = LocalName :: pack_static (199u32) ;\npub const ATOM_LOCALNAME__78_63_68_61_6E_6E_65_6C_73_65_6C_65_63_74_6F_72 : LocalName = LocalName :: pack_static (200u32) ;\npub const ATOM_LOCALNAME__61_6C_74_67_6C_79_70_68 : LocalName = LocalName :: pack_static (201u32) ;\npub const ATOM_LOCALNAME__70_72_65_73_65_72_76_65_61_73_70_65_63_74_72_61_74_69_6F : LocalName = LocalName :: pack_static (202u32) ;\npub const ATOM_LOCALNAME__63_6F_6E_74_65_6E_74_53_63_72_69_70_74_54_79_70_65 : LocalName = LocalName :: pack_static (203u32) ;\npub const ATOM_LOCALNAME__73_75_62_73_63_72_69_70_74_73_68_69_66_74 : LocalName = LocalName :: pack_static (204u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_6C_65_61_76_65 : LocalName = LocalName :: pack_static (205u32) ;\npub const ATOM_LOCALNAME__61_74_74_72_69_62_75_74_65_6E_61_6D_65 : LocalName = LocalName :: pack_static (206u32) ;\npub const ATOM_LOCALNAME__66_65_73_70_65_63_75_6C_61_72_6C_69_67_68_74_69_6E_67 : LocalName = LocalName :: pack_static (207u32) ;\npub const ATOM_LOCALNAME__69_6E_74_65_67_65_72_73 : LocalName = LocalName :: pack_static (208u32) ;\npub const ATOM_LOCALNAME__70_72_65_73_65_72_76_65_61_6C_70_68_61 : LocalName = LocalName :: pack_static (209u32) ;\npub const ATOM_LOCALNAME__68_6F_72_69_7A_2D_6F_72_69_67_69_6E_2D_79 : LocalName = LocalName :: pack_static (210u32) ;\npub const ATOM_LOCALNAME__78_6C_69_6E_6B_3A_73_68_6F_77 : LocalName = LocalName :: pack_static (211u32) ;\npub const ATOM_LOCALNAME__66_69_6C_74_65_72_52_65_73 : LocalName = LocalName :: pack_static (212u32) ;\npub const ATOM_LOCALNAME__6F_6E_66_6F_72_6D_69_6E_70_75_74 : LocalName = LocalName :: pack_static (213u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_63_65_2D_66_6F_72_6D_61_74 : LocalName = LocalName :: pack_static (214u32) ;\npub const ATOM_LOCALNAME__61_6E_6E_6F_74_61_74_69_6F_6E : LocalName = LocalName :: pack_static (215u32) ;\npub const ATOM_LOCALNAME__6F_6E_6B_65_79_70_72_65_73_73 : LocalName = LocalName :: pack_static (216u32) ;\npub const ATOM_LOCALNAME__72_65_70_65_61_74_2D_74_65_6D_70_6C_61_74_65 : LocalName = LocalName :: pack_static (217u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_63_65 : LocalName = LocalName :: pack_static (218u32) ;\npub const ATOM_LOCALNAME__69_64_65_6F_67_72_61_70_68_69_63 : LocalName = LocalName :: pack_static (219u32) ;\npub const ATOM_LOCALNAME__73_74_61_74_65_63_68_61_6E_67_65 : LocalName = LocalName :: pack_static (220u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_61_74_61_73_65_74_63_6F_6D_70_6C_65_74_65 : LocalName = LocalName :: pack_static (221u32) ;\npub const ATOM_LOCALNAME__65_71_75_69_76_61_6C_65_6E_74 : LocalName = LocalName :: pack_static (222u32) ;\npub const ATOM_LOCALNAME__73_70_65_63_75_6C_61_72_65_78_70_6F_6E_65_6E_74 : LocalName = LocalName :: pack_static (223u32) ;\npub const ATOM_LOCALNAME__61_6C_74_47_6C_79_70_68_44_65_66 : LocalName = LocalName :: pack_static (224u32) ;\npub const ATOM_LOCALNAME__61_63_63_75_6D_75_6C_61_74_65 : LocalName = LocalName :: pack_static (225u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_6F_76_65_72 : LocalName = LocalName :: pack_static (226u32) ;\npub const ATOM_LOCALNAME__62_61_73_65_66_72_65_71_75_65_6E_63_79 : LocalName = LocalName :: pack_static (227u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_6F_75_74 : LocalName = LocalName :: pack_static (228u32) ;\npub const ATOM_LOCALNAME__6D_61_74_68_63_6F_6C_6F_72 : LocalName = LocalName :: pack_static (229u32) ;\npub const ATOM_LOCALNAME__66_65_54_75_72_62_75_6C_65_6E_63_65 : LocalName = LocalName :: pack_static (230u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_72_65_61_64_6F_6E_6C_79 : LocalName = LocalName :: pack_static (231u32) ;\npub const ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_64_61_73_68_61_72_72_61_79 : LocalName = LocalName :: pack_static (232u32) ;\npub const ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_6C_69_6E_65_6A_6F_69_6E : LocalName = LocalName :: pack_static (233u32) ;\npub const ATOM_LOCALNAME__66_65_43_6F_6D_70_6F_73_69_74_65 : LocalName = LocalName :: pack_static (234u32) ;\npub const ATOM_LOCALNAME__61_6C_74_67_6C_79_70_68_64_65_66 : LocalName = LocalName :: pack_static (235u32) ;\npub const ATOM_LOCALNAME__73_74_64_44_65_76_69_61_74_69_6F_6E : LocalName = LocalName :: pack_static (236u32) ;\npub const ATOM_LOCALNAME__66_65_4D_6F_72_70_68_6F_6C_6F_67_79 : LocalName = LocalName :: pack_static (237u32) ;\npub const ATOM_LOCALNAME__66_65_44_69_73_74_61_6E_74_4C_69_67_68_74 : LocalName = LocalName :: pack_static (238u32) ;\npub const ATOM_LOCALNAME__66_65_64_69_73_74_61_6E_74_6C_69_67_68_74 : LocalName = LocalName :: pack_static (239u32) ;\npub const ATOM_LOCALNAME__61_6E_69_6D_61_74_65_74_72_61_6E_73_66_6F_72_6D : LocalName = LocalName :: pack_static (240u32) ;\npub const ATOM_LOCALNAME__67_72_6F_75_70_61_6C_69_67_6E : LocalName = LocalName :: pack_static (241u32) ;\npub const ATOM_LOCALNAME__6C_69_6D_69_74_69_6E_67_43_6F_6E_65_41_6E_67_6C_65 : LocalName = LocalName :: pack_static (242u32) ;\npub const ATOM_LOCALNAME__65_6C_65_76_61_74_69_6F_6E : LocalName = LocalName :: pack_static (243u32) ;\npub const ATOM_LOCALNAME__73_79_73_74_65_6D_4C_61_6E_67_75_61_67_65 : LocalName = LocalName :: pack_static (244u32) ;\npub const ATOM_LOCALNAME__69_72_72_65_6C_65_76_61_6E_74 : LocalName = LocalName :: pack_static (245u32) ;\npub const ATOM_LOCALNAME__72_65_71_75_69_72_65_64_45_78_74_65_6E_73_69_6F_6E_73 : LocalName = LocalName :: pack_static (246u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_61_75_74_6F_63_6F_6D_70_6C_65_74_65 : LocalName = LocalName :: pack_static (247u32) ;\npub const ATOM_LOCALNAME__63_6F_6C_6F_72_2D_72_65_6E_64_65_72_69_6E_67 : LocalName = LocalName :: pack_static (248u32) ;\npub const ATOM_LOCALNAME__62_61_63_6B_67_72_6F_75_6E_64 : LocalName = LocalName :: pack_static (249u32) ;\npub const ATOM_LOCALNAME__6D_61_6C_69_67_6E_6D_61_72_6B : LocalName = LocalName :: pack_static (250u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_77_68_65_65_6C : LocalName = LocalName :: pack_static (251u32) ;\npub const ATOM_LOCALNAME__61_6E_69_6D_61_74_65_63_6F_6C_6F_72 : LocalName = LocalName :: pack_static (252u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_62_72_61_69_6C_6C_65_6C_61_62_65_6C : LocalName = LocalName :: pack_static (253u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_64_65_74_61_69_6C_73 : LocalName = LocalName :: pack_static (254u32) ;\npub const ATOM_LOCALNAME__67_6C_79_70_68_2D_6E_61_6D_65 : LocalName = LocalName :: pack_static (255u32) ;\npub const ATOM_LOCALNAME__6D_69_73_73_69_6E_67_2D_67_6C_79_70_68 : LocalName = LocalName :: pack_static (256u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_62_75_73_79 : LocalName = LocalName :: pack_static (257u32) ;\npub const ATOM_LOCALNAME__78_2D_68_65_69_67_68_74 : LocalName = LocalName :: pack_static (258u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_77_65_69_67_68_74 : LocalName = LocalName :: pack_static (259u32) ;\npub const ATOM_LOCALNAME__6D_75_6C_74_69_63_6F_6C : LocalName = LocalName :: pack_static (260u32) ;\npub const ATOM_LOCALNAME__6F_6E_6C_6F_73_65_63_61_70_74_75_72_65 : LocalName = LocalName :: pack_static (261u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_63_65_2D_75_72_69 : LocalName = LocalName :: pack_static (262u32) ;\npub const ATOM_LOCALNAME__7A_6F_6F_6D_41_6E_64_50_61_6E : LocalName = LocalName :: pack_static (263u32) ;\npub const ATOM_LOCALNAME__6F_70_74_67_72_6F_75_70 : LocalName = LocalName :: pack_static (264u32) ;\npub const ATOM_LOCALNAME__78_6D_6C_3A_73_70_61_63_65 : LocalName = LocalName :: pack_static (265u32) ;\npub const ATOM_LOCALNAME__73_70_65_63_69_66_69_63_61_74_69_6F_6E : LocalName = LocalName :: pack_static (266u32) ;\npub const ATOM_LOCALNAME__6C_61_70_6C_61_63_69_61_6E : LocalName = LocalName :: pack_static (267u32) ;\npub const ATOM_LOCALNAME__73_63_72_6F_6C_6C_69_6E_67 : LocalName = LocalName :: pack_static (268u32) ;\npub const ATOM_LOCALNAME__6D_6F_76_61_62_6C_65_6C_69_6D_69_74_73 : LocalName = LocalName :: pack_static (269u32) ;\npub const ATOM_LOCALNAME__6D_70_72_65_73_63_72_69_70_74_73 : LocalName = LocalName :: pack_static (270u32) ;\npub const ATOM_LOCALNAME__6F_6E_66_6F_72_6D_63_68_61_6E_67_65 : LocalName = LocalName :: pack_static (271u32) ;\npub const ATOM_LOCALNAME__76_2D_6D_61_74_68_65_6D_61_74_69_63_61_6C : LocalName = LocalName :: pack_static (272u32) ;\npub const ATOM_LOCALNAME__6D_61_73_6B_43_6F_6E_74_65_6E_74_55_6E_69_74_73 : LocalName = LocalName :: pack_static (273u32) ;\npub const ATOM_LOCALNAME__73_65_70_61_72_61_74_6F_72 : LocalName = LocalName :: pack_static (274u32) ;\npub const ATOM_LOCALNAME__6E_6F_6D_6F_64_75_6C_65 : LocalName = LocalName :: pack_static (275u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_63_6F_6C_73_70_61_6E : LocalName = LocalName :: pack_static (276u32) ;\npub const ATOM_LOCALNAME__6F_70_65_72_61_74_6F_72 : LocalName = LocalName :: pack_static (277u32) ;\npub const ATOM_LOCALNAME__6F_6E_73_75_62_6D_69_74 : LocalName = LocalName :: pack_static (278u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_64_65_73_63_72_69_70_74_69_6F_6E : LocalName = LocalName :: pack_static (279u32) ;\npub const ATOM_LOCALNAME__72_65_70_65_61_74_2D_6D_61_78 : LocalName = LocalName :: pack_static (280u32) ;\npub const ATOM_LOCALNAME__73_74_61_72_74_4F_66_66_73_65_74 : LocalName = LocalName :: pack_static (281u32) ;\npub const ATOM_LOCALNAME__72_61_64_69_61_6C_67_72_61_64_69_65_6E_74 : LocalName = LocalName :: pack_static (282u32) ;\npub const ATOM_LOCALNAME__73_79_6D_6D_65_74_72_69_63 : LocalName = LocalName :: pack_static (283u32) ;\npub const ATOM_LOCALNAME__63_6F_64_65_74_79_70_65 : LocalName = LocalName :: pack_static (284u32) ;\npub const ATOM_LOCALNAME__61_6C_74_47_6C_79_70_68 : LocalName = LocalName :: pack_static (285u32) ;\npub const ATOM_LOCALNAME__63_65_6C_6C_73_70_61_63_69_6E_67 : LocalName = LocalName :: pack_static (286u32) ;\npub const ATOM_LOCALNAME__70_61_74_74_65_72_6E_43_6F_6E_74_65_6E_74_55_6E_69_74_73 : LocalName = LocalName :: pack_static (287u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_66_61_6D_69_6C_79 : LocalName = LocalName :: pack_static (288u32) ;\npub const ATOM_LOCALNAME__72_6F_77_6C_69_6E_65_73 : LocalName = LocalName :: pack_static (289u32) ;\npub const ATOM_LOCALNAME__64_61_74_65_74_69_6D_65 : LocalName = LocalName :: pack_static (290u32) ;\npub const ATOM_LOCALNAME__64_72_61_67_67_61_62_6C_65 : LocalName = LocalName :: pack_static (291u32) ;\npub const ATOM_LOCALNAME__6F_6E_72_65_70_65_61_74 : LocalName = LocalName :: pack_static (292u32) ;\npub const ATOM_LOCALNAME__70_61_74_68_6C_65_6E_67_74_68 : LocalName = LocalName :: pack_static (293u32) ;\npub const ATOM_LOCALNAME__6E_6F_73_63_72_69_70_74 : LocalName = LocalName :: pack_static (294u32) ;\npub const ATOM_LOCALNAME__76_2D_69_64_65_6F_67_72_61_70_68_69_63 : LocalName = LocalName :: pack_static (295u32) ;\npub const ATOM_LOCALNAME__6F_6E_66_6F_63_75_73_6F_75_74 : LocalName = LocalName :: pack_static (296u32) ;\npub const ATOM_LOCALNAME__76_2D_61_6C_70_68_61_62_65_74_69_63 : LocalName = LocalName :: pack_static (297u32) ;\npub const ATOM_LOCALNAME__72_65_70_65_61_74_64_75_72 : LocalName = LocalName :: pack_static (298u32) ;\npub const ATOM_LOCALNAME__67_6C_79_70_68_72_65_66 : LocalName = LocalName :: pack_static (299u32) ;\npub const ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_64_61_73_68_6F_66_66_73_65_74 : LocalName = LocalName :: pack_static (300u32) ;\npub const ATOM_LOCALNAME__61_6E_69_6D_61_74_69_6F_6E : LocalName = LocalName :: pack_static (301u32) ;\npub const ATOM_LOCALNAME__6B_65_79_54_69_6D_65_73 : LocalName = LocalName :: pack_static (302u32) ;\npub const ATOM_LOCALNAME__6E_6F_74_73_75_62_73_65_74 : LocalName = LocalName :: pack_static (303u32) ;\npub const ATOM_LOCALNAME__66_61_63_74_6F_72_6F_66 : LocalName = LocalName :: pack_static (304u32) ;\npub const ATOM_LOCALNAME__65_78_74_65_72_6E_61_6C_72_65_73_6F_75_72_63_65_73_72_65_71_75_69_72_65_64 : LocalName = LocalName :: pack_static (305u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_73_65_63_72_65_74 : LocalName = LocalName :: pack_static (306u32) ;\npub const ATOM_LOCALNAME__66_61_63_74_6F_72_69_61_6C : LocalName = LocalName :: pack_static (307u32) ;\npub const ATOM_LOCALNAME__65_75_6C_65_72_67_61_6D_6D_61 : LocalName = LocalName :: pack_static (308u32) ;\npub const ATOM_LOCALNAME__73_65_70_61_72_61_74_6F_72_73 : LocalName = LocalName :: pack_static (309u32) ;\npub const ATOM_LOCALNAME__72_65_70_65_61_74_2D_73_74_61_72_74 : LocalName = LocalName :: pack_static (310u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_65_78_70_61_6E_64_65_64 : LocalName = LocalName :: pack_static (311u32) ;\npub const ATOM_LOCALNAME__70_6F_69_6E_74_73_41_74_58 : LocalName = LocalName :: pack_static (312u32) ;\npub const ATOM_LOCALNAME__76_65_63_74_6F_72_70_72_6F_64_75_63_74 : LocalName = LocalName :: pack_static (313u32) ;\npub const ATOM_LOCALNAME__65_6E_61_62_6C_65_2D_62_61_63_6B_67_72_6F_75_6E_64 : LocalName = LocalName :: pack_static (314u32) ;\npub const ATOM_LOCALNAME__66_72_61_6D_65_73_70_61_63_69_6E_67 : LocalName = LocalName :: pack_static (315u32) ;\npub const ATOM_LOCALNAME__63_6F_6E_74_65_6E_74_73_63_72_69_70_74_74_79_70_65 : LocalName = LocalName :: pack_static (316u32) ;\npub const ATOM_LOCALNAME__62_61_73_65_66_6F_6E_74 : LocalName = LocalName :: pack_static (317u32) ;\npub const ATOM_LOCALNAME__75_6E_69_63_6F_64_65_2D_72_61_6E_67_65 : LocalName = LocalName :: pack_static (318u32) ;\npub const ATOM_LOCALNAME__66_6F_72_65_69_67_6E_6F_62_6A_65_63_74 : LocalName = LocalName :: pack_static (319u32) ;\npub const ATOM_LOCALNAME__70_6F_6C_79_6C_69_6E_65 : LocalName = LocalName :: pack_static (320u32) ;\npub const ATOM_LOCALNAME__70_61_74_74_65_72_6E_75_6E_69_74_73 : LocalName = LocalName :: pack_static (321u32) ;\npub const ATOM_LOCALNAME__73_70_65_63_75_6C_61_72_45_78_70_6F_6E_65_6E_74 : LocalName = LocalName :: pack_static (322u32) ;\npub const ATOM_LOCALNAME__72_61_64_69_6F_67_72_6F_75_70 : LocalName = LocalName :: pack_static (323u32) ;\npub const ATOM_LOCALNAME__63_6F_64_6F_6D_61_69_6E : LocalName = LocalName :: pack_static (324u32) ;\npub const ATOM_LOCALNAME__6F_6E_6F_6E_6C_69_6E_65 : LocalName = LocalName :: pack_static (325u32) ;\npub const ATOM_LOCALNAME__72_65_71_75_69_72_65_64_46_65_61_74_75_72_65_73 : LocalName = LocalName :: pack_static (326u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_76_61_72_69_61_6E_74 : LocalName = LocalName :: pack_static (327u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_6C_65_76_65_6C : LocalName = LocalName :: pack_static (328u32) ;\npub const ATOM_LOCALNAME__63_6F_6C_75_6D_6E_61_6C_69_67_6E : LocalName = LocalName :: pack_static (329u32) ;\npub const ATOM_LOCALNAME__6E_6F_74_61_74_69_6F_6E : LocalName = LocalName :: pack_static (330u32) ;\npub const ATOM_LOCALNAME__6F_6E_72_6F_77_65_6E_74_65_72 : LocalName = LocalName :: pack_static (331u32) ;\npub const ATOM_LOCALNAME__66_65_4D_65_72_67_65_4E_6F_64_65 : LocalName = LocalName :: pack_static (332u32) ;\npub const ATOM_LOCALNAME__67_6C_79_70_68_2D_6F_72_69_65_6E_74_61_74_69_6F_6E_2D_68_6F_72_69_7A_6F_6E_74_61_6C : LocalName = LocalName :: pack_static (333u32) ;\npub const ATOM_LOCALNAME__70_61_74_74_65_72_6E_74_72_61_6E_73_66_6F_72_6D : LocalName = LocalName :: pack_static (334u32) ;\npub const ATOM_LOCALNAME__70_61_74_74_65_72_6E_55_6E_69_74_73 : LocalName = LocalName :: pack_static (335u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_76_65_65_6E_64 : LocalName = LocalName :: pack_static (336u32) ;\npub const ATOM_LOCALNAME__70_72_65_66_65_74_63_68 : LocalName = LocalName :: pack_static (337u32) ;\npub const ATOM_LOCALNAME__6C_69_6E_65_61_72_67_72_61_64_69_65_6E_74 : LocalName = LocalName :: pack_static (338u32) ;\npub const ATOM_LOCALNAME__63_6F_6E_74_72_6F_6C_73 : LocalName = LocalName :: pack_static (339u32) ;\npub const ATOM_LOCALNAME__61_75_74_6F_66_6F_63_75_73 : LocalName = LocalName :: pack_static (340u32) ;\npub const ATOM_LOCALNAME__63_6F_6E_74_65_6E_74_65_64_69_74_61_62_6C_65 : LocalName = LocalName :: pack_static (341u32) ;\npub const ATOM_LOCALNAME__68_69_64_65_66_6F_63_75_73 : LocalName = LocalName :: pack_static (342u32) ;\npub const ATOM_LOCALNAME__6E_75_6D_6F_63_74_61_76_65_73 : LocalName = LocalName :: pack_static (343u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_61_63_74_69_76_65_64_65_73_63_65_6E_64_61_6E_74 : LocalName = LocalName :: pack_static (344u32) ;\npub const ATOM_LOCALNAME__66_69_6C_74_65_72_72_65_73 : LocalName = LocalName :: pack_static (345u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_70_6C_61_63_65_68_6F_6C_64_65_72 : LocalName = LocalName :: pack_static (346u32) ;\npub const ATOM_LOCALNAME__6D_6F_6D_65_6E_74_61_62_6F_75_74 : LocalName = LocalName :: pack_static (347u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_63_65_2D_73_72_63 : LocalName = LocalName :: pack_static (348u32) ;\npub const ATOM_LOCALNAME__6D_61_74_68_65_6D_61_74_69_63_61_6C : LocalName = LocalName :: pack_static (349u32) ;\npub const ATOM_LOCALNAME__63_6C_69_70_50_61_74_68_55_6E_69_74_73 : LocalName = LocalName :: pack_static (350u32) ;\npub const ATOM_LOCALNAME__61_63_63_65_70_74_2D_63_68_61_72_73_65_74 : LocalName = LocalName :: pack_static (351u32) ;\npub const ATOM_LOCALNAME__63_6F_6E_64_69_74_69_6F_6E : LocalName = LocalName :: pack_static (352u32) ;\npub const ATOM_LOCALNAME__66_6F_72_6D_61_63_74_69_6F_6E : LocalName = LocalName :: pack_static (353u32) ;\npub const ATOM_LOCALNAME__73_75_72_66_61_63_65_53_63_61_6C_65 : LocalName = LocalName :: pack_static (354u32) ;\npub const ATOM_LOCALNAME__6F_6E_69_6E_76_61_6C_69_64 : LocalName = LocalName :: pack_static (355u32) ;\npub const ATOM_LOCALNAME__70_6C_61_69_6E_74_65_78_74 : LocalName = LocalName :: pack_static (356u32) ;\npub const ATOM_LOCALNAME__62_61_73_65_70_72_6F_66_69_6C_65 : LocalName = LocalName :: pack_static (357u32) ;\npub const ATOM_LOCALNAME__6F_6E_70_72_6F_70_65_72_74_79_63_68_61_6E_67_65 : LocalName = LocalName :: pack_static (358u32) ;\npub const ATOM_LOCALNAME__66_65_43_6F_6D_70_6F_6E_65_6E_74_54_72_61_6E_73_66_65_72 : LocalName = LocalName :: pack_static (359u32) ;\npub const ATOM_LOCALNAME__69_6D_61_67_69_6E_61_72_79 : LocalName = LocalName :: pack_static (360u32) ;\npub const ATOM_LOCALNAME__6F_6E_73_63_72_6F_6C_6C : LocalName = LocalName :: pack_static (361u32) ;\npub const ATOM_LOCALNAME__63_65_6C_6C_70_61_64_64_69_6E_67 : LocalName = LocalName :: pack_static (362u32) ;\npub const ATOM_LOCALNAME__6F_76_65_72_6C_69_6E_65_2D_70_6F_73_69_74_69_6F_6E : LocalName = LocalName :: pack_static (363u32) ;\npub const ATOM_LOCALNAME__64_69_73_61_62_6C_65_64 : LocalName = LocalName :: pack_static (364u32) ;\npub const ATOM_LOCALNAME__69_6E_74_65_72_63_65_70_74 : LocalName = LocalName :: pack_static (365u32) ;\npub const ATOM_LOCALNAME__6B_65_72_6E_65_6C_75_6E_69_74_6C_65_6E_67_74_68 : LocalName = LocalName :: pack_static (366u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_76_61_6C_75_65_74_65_78_74 : LocalName = LocalName :: pack_static (367u32) ;\npub const ATOM_LOCALNAME__72_65_6E_64_65_72_69_6E_67_2D_69_6E_74_65_6E_74 : LocalName = LocalName :: pack_static (368u32) ;\npub const ATOM_LOCALNAME__70_72_65_73_65_72_76_65_41_6C_70_68_61 : LocalName = LocalName :: pack_static (369u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_72_6F_77_69_6E_64_65_78_74_65_78_74 : LocalName = LocalName :: pack_static (370u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_74_65_6D_70_6C_61_74_65_69_64 : LocalName = LocalName :: pack_static (371u32) ;\npub const ATOM_LOCALNAME__73_65_6C_65_63_74_6F_72 : LocalName = LocalName :: pack_static (372u32) ;\npub const ATOM_LOCALNAME__76_65_72_74_2D_6F_72_69_67_69_6E_2D_78 : LocalName = LocalName :: pack_static (373u32) ;\npub const ATOM_LOCALNAME__63_6F_6E_74_65_6E_74_73_74_79_6C_65_74_79_70_65 : LocalName = LocalName :: pack_static (374u32) ;\npub const ATOM_LOCALNAME__65_6E_63_6F_64_69_6E_67 : LocalName = LocalName :: pack_static (375u32) ;\npub const ATOM_LOCALNAME__6D_61_72_6B_65_72_77_69_64_74_68 : LocalName = LocalName :: pack_static (376u32) ;\npub const ATOM_LOCALNAME__61_74_74_72_69_62_75_74_65_4E_61_6D_65 : LocalName = LocalName :: pack_static (377u32) ;\npub const ATOM_LOCALNAME__6C_65_6E_67_74_68_61_64_6A_75_73_74 : LocalName = LocalName :: pack_static (378u32) ;\npub const ATOM_LOCALNAME__6B_65_72_6E_65_6C_55_6E_69_74_4C_65_6E_67_74_68 : LocalName = LocalName :: pack_static (379u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_73_69_7A_65 : LocalName = LocalName :: pack_static (380u32) ;\npub const ATOM_LOCALNAME__61_63_74_69_6F_6E_74_79_70_65 : LocalName = LocalName :: pack_static (381u32) ;\npub const ATOM_LOCALNAME__6F_6E_66_69_6C_74_65_72_63_68_61_6E_67_65 : LocalName = LocalName :: pack_static (382u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_6C_69_76_65 : LocalName = LocalName :: pack_static (383u32) ;\npub const ATOM_LOCALNAME__75_6E_69_74_73_2D_70_65_72_2D_65_6D : LocalName = LocalName :: pack_static (384u32) ;\npub const ATOM_LOCALNAME__76_69_65_77_74_61_72_67_65_74 : LocalName = LocalName :: pack_static (385u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_6D_6F_76_65 : LocalName = LocalName :: pack_static (386u32) ;\npub const ATOM_LOCALNAME__6D_61_73_6B_75_6E_69_74_73 : LocalName = LocalName :: pack_static (387u32) ;\npub const ATOM_LOCALNAME__6D_6D_75_6C_74_69_73_63_72_69_70_74_73 : LocalName = LocalName :: pack_static (388u32) ;\npub const ATOM_LOCALNAME__61_74_74_72_69_62_75_74_65_74_79_70_65 : LocalName = LocalName :: pack_static (389u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_72_61_67_6F_76_65_72 : LocalName = LocalName :: pack_static (390u32) ;\npub const ATOM_LOCALNAME__6F_75_74_65_72_70_72_6F_64_75_63_74 : LocalName = LocalName :: pack_static (391u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_64_72_6F_70_65_66_66_65_63_74 : LocalName = LocalName :: pack_static (392u32) ;\npub const ATOM_LOCALNAME__61_6E_69_6D_61_74_65_43_6F_6C_6F_72 : LocalName = LocalName :: pack_static (393u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_6B_65_79_73_68_6F_72_74_63_75_74_73 : LocalName = LocalName :: pack_static (394u32) ;\npub const ATOM_LOCALNAME__63_6C_69_70_50_61_74_68 : LocalName = LocalName :: pack_static (395u32) ;\npub const ATOM_LOCALNAME__67_72_61_64_69_65_6E_74_74_72_61_6E_73_66_6F_72_6D : LocalName = LocalName :: pack_static (396u32) ;\npub const ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_70_72_69_6E_74 : LocalName = LocalName :: pack_static (397u32) ;\npub const ATOM_LOCALNAME__6C_65_74_74_65_72_2D_73_70_61_63_69_6E_67 : LocalName = LocalName :: pack_static (398u32) ;\npub const ATOM_LOCALNAME__63_61_6C_63_4D_6F_64_65 : LocalName = LocalName :: pack_static (399u32) ;\npub const ATOM_LOCALNAME__73_63_61_6C_61_72_70_72_6F_64_75_63_74 : LocalName = LocalName :: pack_static (400u32) ;\npub const ATOM_LOCALNAME__76_2D_68_61_6E_67_69_6E_67 : LocalName = LocalName :: pack_static (401u32) ;\npub const ATOM_LOCALNAME__70_61_6E_6F_73_65_2D_31 : LocalName = LocalName :: pack_static (402u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_77_65_69_67_68_74 : LocalName = LocalName :: pack_static (403u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_73_65_6C_65_63_74_65_64 : LocalName = LocalName :: pack_static (404u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_68_61_73_70_6F_70_75_70 : LocalName = LocalName :: pack_static (405u32) ;\npub const ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_63_75_74 : LocalName = LocalName :: pack_static (406u32) ;\npub const ATOM_LOCALNAME__6F_6E_73_65_6C_65_63_74 : LocalName = LocalName :: pack_static (407u32) ;\npub const ATOM_LOCALNAME__6B_65_79_73_70_6C_69_6E_65_73 : LocalName = LocalName :: pack_static (408u32) ;\npub const ATOM_LOCALNAME__6B_65_79_74_69_6D_65_73 : LocalName = LocalName :: pack_static (409u32) ;\npub const ATOM_LOCALNAME__6F_6E_72_6F_77_65_78_69_74 : LocalName = LocalName :: pack_static (410u32) ;\npub const ATOM_LOCALNAME__72_65_70_65_61_74_2D_6D_69_6E : LocalName = LocalName :: pack_static (411u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_70_72_65_73_73_65_64 : LocalName = LocalName :: pack_static (412u32) ;\npub const ATOM_LOCALNAME__67_6C_79_70_68_2D_6F_72_69_65_6E_74_61_74_69_6F_6E_2D_76_65_72_74_69_63_61_6C : LocalName = LocalName :: pack_static (413u32) ;\npub const ATOM_LOCALNAME__6D_69_6E_6C_65_6E_67_74_68 : LocalName = LocalName :: pack_static (414u32) ;\npub const ATOM_LOCALNAME__63_6F_6E_74_65_78_74_6D_65_6E_75 : LocalName = LocalName :: pack_static (415u32) ;\npub const ATOM_LOCALNAME__6F_6E_65_72_72_6F_72_75_70_64_61_74_65 : LocalName = LocalName :: pack_static (416u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_6C_61_62_65_6C : LocalName = LocalName :: pack_static (417u32) ;\npub const ATOM_LOCALNAME__66_69_65_6C_64_73_65_74 : LocalName = LocalName :: pack_static (418u32) ;\npub const ATOM_LOCALNAME__63_6F_6C_75_6D_6E_73_70_61_63_69_6E_67 : LocalName = LocalName :: pack_static (419u32) ;\npub const ATOM_LOCALNAME__61_6C_6C_6F_77_66_75_6C_6C_73_63_72_65_65_6E : LocalName = LocalName :: pack_static (420u32) ;\npub const ATOM_LOCALNAME__61_63_63_65_6E_74_75_6E_64_65_72 : LocalName = LocalName :: pack_static (421u32) ;\npub const ATOM_LOCALNAME__79_43_68_61_6E_6E_65_6C_53_65_6C_65_63_74_6F_72 : LocalName = LocalName :: pack_static (422u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_62_6C_63_6C_69_63_6B : LocalName = LocalName :: pack_static (423u32) ;\npub const ATOM_LOCALNAME__75_6E_69_63_6F_64_65_2D_62_69_64_69 : LocalName = LocalName :: pack_static (424u32) ;\npub const ATOM_LOCALNAME__66_65_47_61_75_73_73_69_61_6E_42_6C_75_72 : LocalName = LocalName :: pack_static (425u32) ;\npub const ATOM_LOCALNAME__6F_6E_6B_65_79_64_6F_77_6E : LocalName = LocalName :: pack_static (426u32) ;\npub const ATOM_LOCALNAME__72_61_64_69_61_6C_47_72_61_64_69_65_6E_74 : LocalName = LocalName :: pack_static (427u32) ;\npub const ATOM_LOCALNAME__76_65_72_79_76_65_72_79_74_68_69_63_6B_6D_61_74_68_73_70_61_63_65 : LocalName = LocalName :: pack_static (428u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_6D_69_6C_79 : LocalName = LocalName :: pack_static (429u32) ;\npub const ATOM_LOCALNAME__6D_65_6E_75_69_74_65_6D : LocalName = LocalName :: pack_static (430u32) ;\npub const ATOM_LOCALNAME__6F_72_69_65_6E_74_61_74_69_6F_6E : LocalName = LocalName :: pack_static (431u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_72_6F_77_69_6E_64_65_78 : LocalName = LocalName :: pack_static (432u32) ;\npub const ATOM_LOCALNAME__72_65_61_64_6F_6E_6C_79 : LocalName = LocalName :: pack_static (433u32) ;\npub const ATOM_LOCALNAME__71_75_6F_74_69_65_6E_74 : LocalName = LocalName :: pack_static (434u32) ;\npub const ATOM_LOCALNAME__65_78_74_65_72_6E_61_6C_52_65_73_6F_75_72_63_65_73_52_65_71_75_69_72_65_64 : LocalName = LocalName :: pack_static (435u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_72_65_71_75_69_72_65_64 : LocalName = LocalName :: pack_static (436u32) ;\npub const ATOM_LOCALNAME__72_65_71_75_69_72_65_64 : LocalName = LocalName :: pack_static (437u32) ;\npub const ATOM_LOCALNAME__6F_6E_72_6F_77_73_69_6E_73_65_72_74_65_64 : LocalName = LocalName :: pack_static (438u32) ;\npub const ATOM_LOCALNAME__6F_6E_70_6F_70_73_74_61_74_65 : LocalName = LocalName :: pack_static (439u32) ;\npub const ATOM_LOCALNAME__68_72_65_66_6C_61_6E_67 : LocalName = LocalName :: pack_static (440u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_62_72_61_69_6C_6C_65_72_6F_6C_65_64_65_73_63_72_69_70_74_69_6F_6E : LocalName = LocalName :: pack_static (441u32) ;\npub const ATOM_LOCALNAME__6D_61_72_6B_65_72_75_6E_69_74_73 : LocalName = LocalName :: pack_static (442u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_63_75_72_72_65_6E_74 : LocalName = LocalName :: pack_static (443u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_65_72_72_6F_72_6D_65_73_73_61_67_65 : LocalName = LocalName :: pack_static (444u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_6D_75_6C_74_69_73_65_6C_65_63_74_61_62_6C_65 : LocalName = LocalName :: pack_static (445u32) ;\npub const ATOM_LOCALNAME__61_72_61_62_69_63_2D_66_6F_72_6D : LocalName = LocalName :: pack_static (446u32) ;\npub const ATOM_LOCALNAME__74_65_78_74_61_72_65_61 : LocalName = LocalName :: pack_static (447u32) ;\npub const ATOM_LOCALNAME__74_61_62_6C_65_56_61_6C_75_65_73 : LocalName = LocalName :: pack_static (448u32) ;\npub const ATOM_LOCALNAME__69_6E_66_69_6E_69_74_79 : LocalName = LocalName :: pack_static (449u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_76_61_6C_75_65_6E_6F_77 : LocalName = LocalName :: pack_static (450u32) ;\npub const ATOM_LOCALNAME__6C_6F_77_6C_69_6D_69_74 : LocalName = LocalName :: pack_static (451u32) ;\npub const ATOM_LOCALNAME__6E_6F_74_70_72_73_75_62_73_65_74 : LocalName = LocalName :: pack_static (452u32) ;\npub const ATOM_LOCALNAME__6D_61_72_6B_65_72_2D_73_74_61_72_74 : LocalName = LocalName :: pack_static (453u32) ;\npub const ATOM_LOCALNAME__6F_63_63_75_72_72_65_6E_63_65 : LocalName = LocalName :: pack_static (454u32) ;\npub const ATOM_LOCALNAME__66_65_63_6F_6D_70_6F_6E_65_6E_74_74_72_61_6E_73_66_65_72 : LocalName = LocalName :: pack_static (455u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_73_69_7A_65 : LocalName = LocalName :: pack_static (456u32) ;\npub const ATOM_LOCALNAME__74_72_61_6E_73_6C_61_74_65 : LocalName = LocalName :: pack_static (457u32) ;\npub const ATOM_LOCALNAME__64_69_72_65_63_74_69_6F_6E : LocalName = LocalName :: pack_static (458u32) ;\npub const ATOM_LOCALNAME__72_65_70_65_61_74_63_6F_75_6E_74 : LocalName = LocalName :: pack_static (459u32) ;\npub const ATOM_LOCALNAME__78_6D_6C_6E_73_3A_78_6C_69_6E_6B : LocalName = LocalName :: pack_static (460u32) ;\npub const ATOM_LOCALNAME__73_68_61_64_6F_77_72_6F_6F_74_63_6C_6F_6E_61_62_6C_65 : LocalName = LocalName :: pack_static (461u32) ;\npub const ATOM_LOCALNAME__72_65_76_65_72_73_65_64 : LocalName = LocalName :: pack_static (462u32) ;\npub const ATOM_LOCALNAME__62_61_73_65_50_72_6F_66_69_6C_65 : LocalName = LocalName :: pack_static (463u32) ;\npub const ATOM_LOCALNAME__70_61_74_74_65_72_6E_54_72_61_6E_73_66_6F_72_6D : LocalName = LocalName :: pack_static (464u32) ;\npub const ATOM_LOCALNAME__73_63_72_69_70_74_6D_69_6E_73_69_7A_65 : LocalName = LocalName :: pack_static (465u32) ;\npub const ATOM_LOCALNAME__6D_61_74_68_62_61_63_6B_67_72_6F_75_6E_64 : LocalName = LocalName :: pack_static (466u32) ;\npub const ATOM_LOCALNAME__63_6F_6E_74_65_6E_74_53_74_79_6C_65_54_79_70_65 : LocalName = LocalName :: pack_static (467u32) ;\npub const ATOM_LOCALNAME__6D_75_6C_74_69_70_6C_65 : LocalName = LocalName :: pack_static (468u32) ;\npub const ATOM_LOCALNAME__62_61_73_65_6C_69_6E_65 : LocalName = LocalName :: pack_static (469u32) ;\npub const ATOM_LOCALNAME__6F_6E_63_6F_6E_74_65_78_74_6D_65_6E_75 : LocalName = LocalName :: pack_static (470u32) ;\npub const ATOM_LOCALNAME__74_65_78_74_4C_65_6E_67_74_68 : LocalName = LocalName :: pack_static (471u32) ;\npub const ATOM_LOCALNAME__64_65_63_6F_64_69_6E_67 : LocalName = LocalName :: pack_static (472u32) ;\npub const ATOM_LOCALNAME__6D_61_73_6B_55_6E_69_74_73 : LocalName = LocalName :: pack_static (473u32) ;\npub const ATOM_LOCALNAME__74_61_62_69_6E_64_65_78 : LocalName = LocalName :: pack_static (474u32) ;\npub const ATOM_LOCALNAME__63_6C_69_70_70_61_74_68 : LocalName = LocalName :: pack_static (475u32) ;\npub const ATOM_LOCALNAME__6C_69_6D_69_74_69_6E_67_63_6F_6E_65_61_6E_67_6C_65 : LocalName = LocalName :: pack_static (476u32) ;\npub const ATOM_LOCALNAME__66_6C_6F_6F_64_2D_63_6F_6C_6F_72 : LocalName = LocalName :: pack_static (477u32) ;\npub const ATOM_LOCALNAME__6F_74_68_65_72_77_69_73_65 : LocalName = LocalName :: pack_static (478u32) ;\npub const ATOM_LOCALNAME__6E_61_74_75_72_61_6C_6E_75_6D_62_65_72_73 : LocalName = LocalName :: pack_static (479u32) ;\npub const ATOM_LOCALNAME__66_65_64_69_73_70_6C_61_63_65_6D_65_6E_74_6D_61_70 : LocalName = LocalName :: pack_static (480u32) ;\npub const ATOM_LOCALNAME__66_6F_72_6D_6E_6F_76_61_6C_69_64_61_74_65 : LocalName = LocalName :: pack_static (481u32) ;\npub const ATOM_LOCALNAME__6C_69_6E_65_74_68_69_63_6B_6E_65_73_73 : LocalName = LocalName :: pack_static (482u32) ;\npub const ATOM_LOCALNAME__6C_69_6E_65_2D_68_65_69_67_68_74 : LocalName = LocalName :: pack_static (483u32) ;\npub const ATOM_LOCALNAME__61_6E_69_6D_61_74_65_6D_6F_74_69_6F_6E : LocalName = LocalName :: pack_static (484u32) ;\npub const ATOM_LOCALNAME__64_65_66_69_6E_69_74_69_6F_6E_2D_73_72_63 : LocalName = LocalName :: pack_static (485u32) ;\npub const ATOM_LOCALNAME__6D_61_73_6B_63_6F_6E_74_65_6E_74_75_6E_69_74_73 : LocalName = LocalName :: pack_static (486u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_61_74_61_73_65_74_63_68_61_6E_67_65_64 : LocalName = LocalName :: pack_static (487u32) ;\npub const ATOM_LOCALNAME__63_6F_6C_6F_72_2D_69_6E_74_65_72_70_6F_6C_61_74_69_6F_6E : LocalName = LocalName :: pack_static (488u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_72_6F_77_63_6F_75_6E_74 : LocalName = LocalName :: pack_static (489u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_69_6E_76_61_6C_69_64 : LocalName = LocalName :: pack_static (490u32) ;\npub const ATOM_LOCALNAME__6D_6F_7A_62_72_6F_77_73_65_72 : LocalName = LocalName :: pack_static (491u32) ;\npub const ATOM_LOCALNAME__73_74_6F_70_2D_63_6F_6C_6F_72 : LocalName = LocalName :: pack_static (492u32) ;\npub const ATOM_LOCALNAME__78_43_68_61_6E_6E_65_6C_53_65_6C_65_63_74_6F_72 : LocalName = LocalName :: pack_static (493u32) ;\npub const ATOM_LOCALNAME__73_70_65_63_75_6C_61_72_63_6F_6E_73_74_61_6E_74 : LocalName = LocalName :: pack_static (494u32) ;\npub const ATOM_LOCALNAME__6F_6E_72_65_61_64_79_73_74_61_74_65_63_68_61_6E_67_65 : LocalName = LocalName :: pack_static (495u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_76_65_73_74_61_72_74 : LocalName = LocalName :: pack_static (496u32) ;\npub const ATOM_LOCALNAME__64_61_74_61_66_6F_72_6D_61_74_61_73 : LocalName = LocalName :: pack_static (497u32) ;\npub const ATOM_LOCALNAME__66_65_67_61_75_73_73_69_61_6E_62_6C_75_72 : LocalName = LocalName :: pack_static (498u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_75_70 : LocalName = LocalName :: pack_static (499u32) ;\npub const ATOM_LOCALNAME__66_65_74_75_72_62_75_6C_65_6E_63_65 : LocalName = LocalName :: pack_static (500u32) ;\npub const ATOM_LOCALNAME__72_65_71_75_69_72_65_64_65_78_74_65_6E_73_69_6F_6E_73 : LocalName = LocalName :: pack_static (501u32) ;\npub const ATOM_LOCALNAME__63_6F_64_65_62_61_73_65 : LocalName = LocalName :: pack_static (502u32) ;\npub const ATOM_LOCALNAME__78_6D_6C_3A_62_61_73_65 : LocalName = LocalName :: pack_static (503u32) ;\npub const ATOM_LOCALNAME__73_68_61_70_65_2D_72_65_6E_64_65_72_69_6E_67 : LocalName = LocalName :: pack_static (504u32) ;\npub const ATOM_LOCALNAME__74_61_62_6C_65_76_61_6C_75_65_73 : LocalName = LocalName :: pack_static (505u32) ;\npub const ATOM_LOCALNAME__73_65_6C_65_63_74_65_64 : LocalName = LocalName :: pack_static (506u32) ;\npub const ATOM_LOCALNAME__67_72_61_64_69_65_6E_74_75_6E_69_74_73 : LocalName = LocalName :: pack_static (507u32) ;\npub const ATOM_LOCALNAME__74_65_6D_70_6C_61_74_65 : LocalName = LocalName :: pack_static (508u32) ;\npub const ATOM_LOCALNAME__6D_70_68_61_6E_74_6F_6D : LocalName = LocalName :: pack_static (509u32) ;\npub const ATOM_LOCALNAME__67_72_61_64_69_65_6E_74_55_6E_69_74_73 : LocalName = LocalName :: pack_static (510u32) ;\npub const ATOM_LOCALNAME__73_75_70_65_72_73_63_72_69_70_74_73_68_69_66_74 : LocalName = LocalName :: pack_static (511u32) ;\npub const ATOM_LOCALNAME__6F_6E_72_6F_77_73_64_65_6C_65_74_65 : LocalName = LocalName :: pack_static (512u32) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_65_6E_74_65_72 : LocalName = LocalName :: pack_static (513u32) ;\npub const ATOM_LOCALNAME__76_61_6C_75_65_74_79_70_65 : LocalName = LocalName :: pack_static (514u32) ;\npub const ATOM_LOCALNAME__70_72_6F_67_72_65_73_73 : LocalName = LocalName :: pack_static (515u32) ;\npub const ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_61_63_74_69_76_61_74_65 : LocalName = LocalName :: pack_static (516u32) ;\npub const ATOM_LOCALNAME__70_6F_69_6E_74_73_41_74_59 : LocalName = LocalName :: pack_static (517u32) ;\npub const ATOM_LOCALNAME__66_65_44_69_73_70_6C_61_63_65_6D_65_6E_74_4D_61_70 : LocalName = LocalName :: pack_static (518u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_76_61_6C_75_65_6D_69_6E : LocalName = LocalName :: pack_static (519u32) ;\npub const ATOM_LOCALNAME__74_65_78_74_2D_61_6E_63_68_6F_72 : LocalName = LocalName :: pack_static (520u32) ;\npub const ATOM_LOCALNAME__6F_6E_70_61_67_65_68_69_64_65 : LocalName = LocalName :: pack_static (521u32) ;\npub const ATOM_LOCALNAME__73_74_64_64_65_76_69_61_74_69_6F_6E : LocalName = LocalName :: pack_static (522u32) ;\npub const ATOM_LOCALNAME__73_79_73_74_65_6D_6C_61_6E_67_75_61_67_65 : LocalName = LocalName :: pack_static (523u32) ;\npub const ATOM_LOCALNAME__66_6F_72_6D_65_6E_63_74_79_70_65 : LocalName = LocalName :: pack_static (524u32) ;\npub const ATOM_LOCALNAME__70_6F_69_6E_74_65_72_2D_65_76_65_6E_74_73 : LocalName = LocalName :: pack_static (525u32) ;\npub const ATOM_LOCALNAME__78_6C_69_6E_6B_3A_74_69_74_6C_65 : LocalName = LocalName :: pack_static (526u32) ;\npub const ATOM_LOCALNAME__69_6E_70_75_74_6D_6F_64_65 : LocalName = LocalName :: pack_static (527u32) ;\npub const ATOM_LOCALNAME__61_6D_70_6C_69_74_75_64_65 : LocalName = LocalName :: pack_static (528u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_64_65_73_63_72_69_62_65_64_62_79 : LocalName = LocalName :: pack_static (529u32) ;\npub const ATOM_LOCALNAME__73_74_72_65_74_63_68_79 : LocalName = LocalName :: pack_static (530u32) ;\npub const ATOM_LOCALNAME__73_68_61_64_6F_77_72_6F_6F_74_64_65_6C_65_67_61_74_65_73_66_6F_63_75_73 : LocalName = LocalName :: pack_static (531u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_72_61_67_73_74_61_72_74 : LocalName = LocalName :: pack_static (532u32) ;\npub const ATOM_LOCALNAME__72_6F_77_61_6C_69_67_6E : LocalName = LocalName :: pack_static (533u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_73_74_79_6C_65 : LocalName = LocalName :: pack_static (534u32) ;\npub const ATOM_LOCALNAME__6B_65_79_70_6F_69_6E_74_73 : LocalName = LocalName :: pack_static (535u32) ;\npub const ATOM_LOCALNAME__66_65_6D_6F_72_70_68_6F_6C_6F_67_79 : LocalName = LocalName :: pack_static (536u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_64_61_74_61_74_79_70_65 : LocalName = LocalName :: pack_static (537u32) ;\npub const ATOM_LOCALNAME__66_65_44_69_66_66_75_73_65_4C_69_67_68_74_69_6E_67 : LocalName = LocalName :: pack_static (538u32) ;\npub const ATOM_LOCALNAME__6D_6C_61_62_65_6C_65_64_74_72 : LocalName = LocalName :: pack_static (539u32) ;\npub const ATOM_LOCALNAME__64_61_74_61_6C_69_73_74 : LocalName = LocalName :: pack_static (540u32) ;\npub const ATOM_LOCALNAME__61_6E_69_6D_61_74_65_54_72_61_6E_73_66_6F_72_6D : LocalName = LocalName :: pack_static (541u32) ;\npub const ATOM_LOCALNAME__63_6C_69_70_2D_72_75_6C_65 : LocalName = LocalName :: pack_static (542u32) ;\npub const ATOM_LOCALNAME__66_69_6C_74_65_72_55_6E_69_74_73 : LocalName = LocalName :: pack_static (543u32) ;\npub const ATOM_LOCALNAME__73_70_65_63_75_6C_61_72_43_6F_6E_73_74_61_6E_74 : LocalName = LocalName :: pack_static (544u32) ;\npub const ATOM_LOCALNAME__6F_6E_68_61_73_68_63_68_61_6E_67_65 : LocalName = LocalName :: pack_static (545u32) ;\npub const ATOM_LOCALNAME__6F_6E_61_66_74_65_72_75_70_64_61_74_65 : LocalName = LocalName :: pack_static (546u32) ;\npub const ATOM_LOCALNAME__70_72_69_6D_69_74_69_76_65_75_6E_69_74_73 : LocalName = LocalName :: pack_static (547u32) ;\npub const ATOM_LOCALNAME__69_6D_61_67_69_6E_61_72_79_69 : LocalName = LocalName :: pack_static (548u32) ;\npub const ATOM_LOCALNAME__73_74_72_69_6B_65_74_68_72_6F_75_67_68_2D_70_6F_73_69_74_69_6F_6E : LocalName = LocalName :: pack_static (549u32) ;\npub const ATOM_LOCALNAME__6F_76_65_72_66_6C_6F_77 : LocalName = LocalName :: pack_static (550u32) ;\npub const ATOM_LOCALNAME__73_6F_6C_69_64_63_6F_6C_6F_72 : LocalName = LocalName :: pack_static (551u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_6D_6F_64_61_6C : LocalName = LocalName :: pack_static (552u32) ;\npub const ATOM_LOCALNAME__70_6C_61_63_65_68_6F_6C_64_65_72 : LocalName = LocalName :: pack_static (553u32) ;\npub const ATOM_LOCALNAME__65_64_67_65_4D_6F_64_65 : LocalName = LocalName :: pack_static (554u32) ;\npub const ATOM_LOCALNAME__69_74_65_6D_70_72_6F_70 : LocalName = LocalName :: pack_static (555u32) ;\npub const ATOM_LOCALNAME__66_65_43_6F_6E_76_6F_6C_76_65_4D_61_74_72_69_78 : LocalName = LocalName :: pack_static (556u32) ;\npub const ATOM_LOCALNAME__66_65_73_70_6F_74_6C_69_67_68_74 : LocalName = LocalName :: pack_static (557u32) ;\npub const ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_63_6F_70_79 : LocalName = LocalName :: pack_static (558u32) ;\npub const ATOM_LOCALNAME__62_61_73_65_46_72_65_71_75_65_6E_63_79 : LocalName = LocalName :: pack_static (559u32) ;\npub const ATOM_LOCALNAME__6B_65_79_50_6F_69_6E_74_73 : LocalName = LocalName :: pack_static (560u32) ;\npub const ATOM_LOCALNAME__64_65_66_69_6E_69_74_69_6F_6E_75_72_6C : LocalName = LocalName :: pack_static (561u32) ;\npub const ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_77_69_64_74_68 : LocalName = LocalName :: pack_static (562u32) ;\npub const ATOM_LOCALNAME__6F_6E_66_69_6E_69_73_68 : LocalName = LocalName :: pack_static (563u32) ;\npub const ATOM_LOCALNAME__63_6F_6E_6A_75_67_61_74_65 : LocalName = LocalName :: pack_static (564u32) ;\npub const ATOM_LOCALNAME__76_65_72_79_76_65_72_79_74_68_69_6E_6D_61_74_68_73_70_61_63_65 : LocalName = LocalName :: pack_static (565u32) ;\npub const ATOM_LOCALNAME__66_65_74_63_68_70_72_69_6F_72_69_74_79 : LocalName = LocalName :: pack_static (566u32) ;\npub const ATOM_LOCALNAME__6B_65_79_53_70_6C_69_6E_65_73 : LocalName = LocalName :: pack_static (567u32) ;\npub const ATOM_LOCALNAME__69_6E_74_65_72_73_65_63_74 : LocalName = LocalName :: pack_static (568u32) ;\npub const ATOM_LOCALNAME__73_70_65_6C_6C_63_68_65_63_6B : LocalName = LocalName :: pack_static (569u32) ;\npub const ATOM_LOCALNAME__6D_61_74_68_76_61_72_69_61_6E_74 : LocalName = LocalName :: pack_static (570u32) ;\npub const ATOM_LOCALNAME__69_6E_74_65_67_72_69_74_79 : LocalName = LocalName :: pack_static (571u32) ;\npub const ATOM_LOCALNAME__70_69_65_63_65_77_69_73_65 : LocalName = LocalName :: pack_static (572u32) ;\npub const ATOM_LOCALNAME__6F_6E_63_65_6C_6C_63_68_61_6E_67_65 : LocalName = LocalName :: pack_static (573u32) ;\npub const ATOM_LOCALNAME__6D_61_78_6C_65_6E_67_74_68 : LocalName = LocalName :: pack_static (574u32) ;\npub const ATOM_LOCALNAME__70_72_73_75_62_73_65_74 : LocalName = LocalName :: pack_static (575u32) ;\npub const ATOM_LOCALNAME__61_72_69_61_2D_6F_77_6E_73 : LocalName = LocalName :: pack_static (576u32) ;\npub const ATOM_LOCALNAME__66_65_63_6F_6E_76_6F_6C_76_65_6D_61_74_72_69_78 : LocalName = LocalName :: pack_static (577u32) ;\npub const ATOM_LOCALNAME__6D_61_6E_69_66_65_73_74 : LocalName = LocalName :: pack_static (578u32) ;\npub const ATOM_LOCALNAME__6F_6E_64_65_61_63_74_69_76_61_74_65 : LocalName = LocalName :: pack_static (579u32) ;\npub const ATOM_LOCALNAME__63_6F_6C_75_6D_6E_77_69_64_74_68 : LocalName = LocalName :: pack_static (580u32) ;\npub const ATOM_LOCALNAME__72_6F_77_73_70_61_63_69_6E_67 : LocalName = LocalName :: pack_static (581u32) ;\npub const ATOM_LOCALNAME__75_6E_64_65_72_6C_69_6E_65_2D_70_6F_73_69_74_69_6F_6E : LocalName = LocalName :: pack_static (582u32) ;\npub const ATOM_LOCALNAME__61_6E_6E_6F_74_61_74_69_6F_6E_2D_78_6D_6C : LocalName = LocalName :: pack_static (583u32) ;\npub const ATOM_LOCALNAME__66_69_6C_6C_2D_6F_70_61_63_69_74_79 : LocalName = LocalName :: pack_static (584u32) ;\npub const ATOM_LOCALNAME__79_63_68_61_6E_6E_65_6C_73_65_6C_65_63_74_6F_72 : LocalName = LocalName :: pack_static (585u32) ;\npub const ATOM_LOCALNAME__78_6C_69_6E_6B_3A_68_72_65_66 : LocalName = LocalName :: pack_static (586u32) ;\npub const ATOM_LOCALNAME__66_72_61_6D_65_73_65_74 : LocalName = LocalName :: pack_static (587u32) ;\npub const ATOM_LOCALNAME__61_6E_69_6D_61_74_65_4D_6F_74_69_6F_6E : LocalName = LocalName :: pack_static (588u32) ;\npub const ATOM_LOCALNAME__63_61_70_2D_68_65_69_67_68_74 : LocalName = LocalName :: pack_static (589u32) ;\npub const ATOM_LOCALNAME__66_6F_72_6D_74_61_72_67_65_74 : LocalName = LocalName :: pack_static (590u32) ;\npub const ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_63_65_2D_6E_61_6D_65 : LocalName = LocalName :: pack_static (591u32) ;\npub const ATOM_LOCALNAME__61_6C_74_67_6C_79_70_68_69_74_65_6D : LocalName = LocalName :: pack_static (592u32) ;\npub const ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_64_65_61_63_74_69_76_61_74_65 : LocalName = LocalName :: pack_static (593u32) ;\npub const ATOM_LOCALNAME__73_63_72_69_70_74_6C_65_76_65_6C : LocalName = LocalName :: pack_static (594u32) ;\npub const ATOM_LOCALNAME__77_72_69_74_69_6E_67_2D_6D_6F_64_65 : LocalName = LocalName :: pack_static (595u32) ;\npub const ATOM_LOCALNAME__65_71_75_61_6C_63_6F_6C_75_6D_6E_73 : LocalName = LocalName :: pack_static (596u32) ;\npub const ATOM_LOCALNAME__6D_75_6E_64_65_72_6F_76_65_72 : LocalName = LocalName :: pack_static (597u32) ;\npub const ATOM_LOCALNAME__61_63_63_65_6E_74_2D_68_65_69_67_68_74 : LocalName = LocalName :: pack_static (598u32) ;\npub const ATOM_LOCALNAME__76_65_72_79_74_68_69_6E_6D_61_74_68_73_70_61_63_65 : LocalName = LocalName :: pack_static (599u32) ;\npub const ATOM_LOCALNAME__64_69_73_70_6C_61_79_73_74_79_6C_65 : LocalName = LocalName :: pack_static (600u32) ;\npub const ATOM_LOCALNAME__75_6E_64_65_72_6C_69_6E_65_2D_74_68_69_63_6B_6E_65_73_73 : LocalName = LocalName :: pack_static (601u32) ;\npub const ATOM_LOCALNAME__6B_65_72_6E_65_6C_6D_61_74_72_69_78 : LocalName = LocalName :: pack_static (602u32) ;\npub const ATOM_LOCALNAME__66_65_63_6F_6C_6F_72_6D_61_74_72_69_78 : LocalName = LocalName :: pack_static (603u32) ;\npub const ATOM_LOCALNAME__2A : LocalName = LocalName :: pack_inline (10752u64 , 1u8) ;\npub const ATOM_LOCALNAME__61 : LocalName = LocalName :: pack_inline (24832u64 , 1u8) ;\npub const ATOM_LOCALNAME__61_62_62_72 : LocalName = LocalName :: pack_inline (491276886272u64 , 4u8) ;\npub const ATOM_LOCALNAME__61_62_73 : LocalName = LocalName :: pack_inline (1935827200u64 , 3u8) ;\npub const ATOM_LOCALNAME__61_63_63_65_6E_74 : LocalName = LocalName :: pack_inline (32772479036645632u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_63_63_65_70_74 : LocalName = LocalName :: pack_inline (32774678059901184u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_63_72_6F_6E_79_6D : LocalName = LocalName :: pack_inline (7888457647255675136u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_63_74_69_6F_6E : LocalName = LocalName :: pack_inline (31084746153091328u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_63_74_69_76_65 : LocalName = LocalName :: pack_inline (28559167944089856u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_63_74_75_61_74_65 : LocalName = LocalName :: pack_inline (7310575252220895488u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_64_64_72_65_73_73 : LocalName = LocalName :: pack_inline (8319104478668415232u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_6C_69_67_6E : LocalName = LocalName :: pack_inline (121390429397248u64 , 5u8) ;\npub const ATOM_LOCALNAME__61_6C_69_6E_6B : LocalName = LocalName :: pack_inline (118121959284992u64 , 5u8) ;\npub const ATOM_LOCALNAME__61_6C_74 : LocalName = LocalName :: pack_inline (1953259776u64 , 3u8) ;\npub const ATOM_LOCALNAME__61_6C_74_69_6D_67 : LocalName = LocalName :: pack_inline (29112222293451008u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_6C_74_74_65_78_74 : LocalName = LocalName :: pack_inline (8392569456448790784u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_6E_64 : LocalName = LocalName :: pack_inline (1684955392u64 , 3u8) ;\npub const ATOM_LOCALNAME__61_6E_69_6D_61_74_65 : LocalName = LocalName :: pack_inline (7310575217677328640u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_70_70_6C_65_74 : LocalName = LocalName :: pack_inline (32762613715722496u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_70_70_6C_79 : LocalName = LocalName :: pack_inline (133506649841920u64 , 5u8) ;\npub const ATOM_LOCALNAME__61_70_70_72_6F_78 : LocalName = LocalName :: pack_inline (33899534508646656u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_72_63_63_6F_73 : LocalName = LocalName :: pack_inline (32492094982611200u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_72_63_63_6F_73_68 : LocalName = LocalName :: pack_inline (7526481874927116544u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_72_63_63_6F_74 : LocalName = LocalName :: pack_inline (32773569959321856u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_72_63_63_6F_74_68 : LocalName = LocalName :: pack_inline (7526763349903827200u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_72_63_63_73_63 : LocalName = LocalName :: pack_inline (27992893401751808u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_72_63_63_73_63_68 : LocalName = LocalName :: pack_inline (7521982673346257152u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_72_63_68_69_76_65 : LocalName = LocalName :: pack_inline (7311146942148534528u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_72_63_72_6F_6C_65 : LocalName = LocalName :: pack_inline (7308338832400867584u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_72_63_73_65_63 : LocalName = LocalName :: pack_inline (27977568958439680u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_72_63_73_65_63_68 : LocalName = LocalName :: pack_inline (7521967348902945024u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_72_63_73_69_6E : LocalName = LocalName :: pack_inline (31078191748768000u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_72_63_73_69_6E_68 : LocalName = LocalName :: pack_inline (7525067971693273344u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_72_63_74_61_6E : LocalName = LocalName :: pack_inline (31069399950713088u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_72_63_74_61_6E_68 : LocalName = LocalName :: pack_inline (7525059179895218432u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_72_65_61 : LocalName = LocalName :: pack_inline (418313822464u64 , 4u8) ;\npub const ATOM_LOCALNAME__61_72_67 : LocalName = LocalName :: pack_inline (1735549184u64 , 3u8) ;\npub const ATOM_LOCALNAME__61_72_74_69_63_6C_65 : LocalName = LocalName :: pack_inline (7308325599891841280u64 , 7u8) ;\npub const ATOM_LOCALNAME__61_73 : LocalName = LocalName :: pack_inline (7561472u64 , 2u8) ;\npub const ATOM_LOCALNAME__61_73_63_65_6E_74 : LocalName = LocalName :: pack_inline (32772479037694208u64 , 6u8) ;\npub const ATOM_LOCALNAME__61_73_69_64_65 : LocalName = LocalName :: pack_inline (111481940304128u64 , 5u8) ;\npub const ATOM_LOCALNAME__61_73_79_6E_63 : LocalName = LocalName :: pack_inline (109326135156992u64 , 5u8) ;\npub const ATOM_LOCALNAME__61_75_64_69_6F : LocalName = LocalName :: pack_inline (122498447663360u64 , 5u8) ;\npub const ATOM_LOCALNAME__61_78_69_73 : LocalName = LocalName :: pack_inline (495690735872u64 , 4u8) ;\npub const ATOM_LOCALNAME__61_7A_69_6D_75_74_68 : LocalName = LocalName :: pack_inline (7526769990024454400u64 , 7u8) ;\npub const ATOM_LOCALNAME__62 : LocalName = LocalName :: pack_inline (25088u64 , 1u8) ;\npub const ATOM_LOCALNAME__62_61_73_65 : LocalName = LocalName :: pack_inline (435727458816u64 , 4u8) ;\npub const ATOM_LOCALNAME__62_62_6F_78 : LocalName = LocalName :: pack_inline (517264794112u64 , 4u8) ;\npub const ATOM_LOCALNAME__62_64_69 : LocalName = LocalName :: pack_inline (1768186368u64 , 3u8) ;\npub const ATOM_LOCALNAME__62_64_6F : LocalName = LocalName :: pack_inline (1868849664u64 , 3u8) ;\npub const ATOM_LOCALNAME__62_65_67_69_6E : LocalName = LocalName :: pack_inline (121398985318912u64 , 5u8) ;\npub const ATOM_LOCALNAME__62_67_63_6F_6C_6F_72 : LocalName = LocalName :: pack_inline (8245928668403556864u64 , 7u8) ;\npub const ATOM_LOCALNAME__62_67_73_6F_75_6E_64 : LocalName = LocalName :: pack_inline (7236850772768940544u64 , 7u8) ;\npub const ATOM_LOCALNAME__62_69_61_73 : LocalName = LocalName :: pack_inline (495555535360u64 , 4u8) ;\npub const ATOM_LOCALNAME__62_69_67 : LocalName = LocalName :: pack_inline (1734959616u64 , 3u8) ;\npub const ATOM_LOCALNAME__62_6C_69_6E_6B : LocalName = LocalName :: pack_inline (118121959285248u64 , 5u8) ;\npub const ATOM_LOCALNAME__62_6F_64_79 : LocalName = LocalName :: pack_inline (521376064000u64 , 4u8) ;\npub const ATOM_LOCALNAME__62_6F_72_64_65_72 : LocalName = LocalName :: pack_inline (32199629436051968u64 , 6u8) ;\npub const ATOM_LOCALNAME__62_72 : LocalName = LocalName :: pack_inline (7496192u64 , 2u8) ;\npub const ATOM_LOCALNAME__62_75_74_74_6F_6E : LocalName = LocalName :: pack_inline (31084793398911488u64 , 6u8) ;\npub const ATOM_LOCALNAME__62_76_61_72 : LocalName = LocalName :: pack_inline (491261420032u64 , 4u8) ;\npub const ATOM_LOCALNAME__62_79 : LocalName = LocalName :: pack_inline (7954944u64 , 2u8) ;\npub const ATOM_LOCALNAME__63_61_6E_76_61_73 : LocalName = LocalName :: pack_inline (32476783607636736u64 , 6u8) ;\npub const ATOM_LOCALNAME__63_61_70_74_69_6F_6E : LocalName = LocalName :: pack_inline (7957695015409509120u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_61_72_64 : LocalName = LocalName :: pack_inline (431415714560u64 , 4u8) ;\npub const ATOM_LOCALNAME__63_65_69_6C_69_6E_67 : LocalName = LocalName :: pack_inline (7453010347690386176u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_65_6E_74_65_72 : LocalName = LocalName :: pack_inline (32199698087764736u64 , 6u8) ;\npub const ATOM_LOCALNAME__63_68_61_72 : LocalName = LocalName :: pack_inline (491260502784u64 , 4u8) ;\npub const ATOM_LOCALNAME__63_68_61_72_6F_66_66 : LocalName = LocalName :: pack_inline (7378707576544322304u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_68_61_72_73_65_74 : LocalName = LocalName :: pack_inline (8387236816145113856u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_68_65_63_6B_65_64 : LocalName = LocalName :: pack_inline (7234306451087844096u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_69 : LocalName = LocalName :: pack_inline (6906624u64 , 2u8) ;\npub const ATOM_LOCALNAME__63_69_72_63_6C_65 : LocalName = LocalName :: pack_inline (28548147024847616u64 , 6u8) ;\npub const ATOM_LOCALNAME__63_69_74_65 : LocalName = LocalName :: pack_inline (435744760576u64 , 4u8) ;\npub const ATOM_LOCALNAME__63_6C_61_73_73 : LocalName = LocalName :: pack_inline (126939392926464u64 , 5u8) ;\npub const ATOM_LOCALNAME__63_6C_61_73_73_69_64 : LocalName = LocalName :: pack_inline (7235441215740338944u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_6C_65_61_72 : LocalName = LocalName :: pack_inline (125762638996224u64 , 5u8) ;\npub const ATOM_LOCALNAME__63_6C_69_70 : LocalName = LocalName :: pack_inline (482805048064u64 , 4u8) ;\npub const ATOM_LOCALNAME__63_6C_6F_73_65 : LocalName = LocalName :: pack_inline (111546465018624u64 , 5u8) ;\npub const ATOM_LOCALNAME__63_6C_6F_73_75_72_65 : LocalName = LocalName :: pack_inline (7310034283826799360u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_6E : LocalName = LocalName :: pack_inline (7234304u64 , 2u8) ;\npub const ATOM_LOCALNAME__63_6F_64_65 : LocalName = LocalName :: pack_inline (435476718336u64 , 4u8) ;\npub const ATOM_LOCALNAME__63_6F_6C : LocalName = LocalName :: pack_inline (1819239168u64 , 3u8) ;\npub const ATOM_LOCALNAME__63_6F_6C_6F_72 : LocalName = LocalName :: pack_inline (125822886175488u64 , 5u8) ;\npub const ATOM_LOCALNAME__63_6F_6C_73 : LocalName = LocalName :: pack_inline (495740478208u64 , 4u8) ;\npub const ATOM_LOCALNAME__63_6F_6C_73_70_61_6E : LocalName = LocalName :: pack_inline (7953762057955795712u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_6F_6D_70_61_63_74 : LocalName = LocalName :: pack_inline (8386654066594243328u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_6F_6D_70_6F_73_65 : LocalName = LocalName :: pack_inline (7310309148815483648u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_6F_6E_74_65_6E_74 : LocalName = LocalName :: pack_inline (8389754706581218048u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_6F_6F_72_64_73 : LocalName = LocalName :: pack_inline (32480064980345600u64 , 6u8) ;\npub const ATOM_LOCALNAME__63_6F_73 : LocalName = LocalName :: pack_inline (1936679680u64 , 3u8) ;\npub const ATOM_LOCALNAME__63_6F_73_68 : LocalName = LocalName :: pack_inline (448613278464u64 , 4u8) ;\npub const ATOM_LOCALNAME__63_6F_74 : LocalName = LocalName :: pack_inline (1953456896u64 , 3u8) ;\npub const ATOM_LOCALNAME__63_6F_74_68 : LocalName = LocalName :: pack_inline (448630055680u64 , 4u8) ;\npub const ATOM_LOCALNAME__63_73_63 : LocalName = LocalName :: pack_inline (1668506368u64 , 3u8) ;\npub const ATOM_LOCALNAME__63_73_63_68 : LocalName = LocalName :: pack_inline (448345105152u64 , 4u8) ;\npub const ATOM_LOCALNAME__63_73_79_6D_62_6F_6C : LocalName = LocalName :: pack_inline (7813572100839662336u64 , 7u8) ;\npub const ATOM_LOCALNAME__63_75_72_6C : LocalName = LocalName :: pack_inline (465776763648u64 , 4u8) ;\npub const ATOM_LOCALNAME__63_75_72_73_6F_72 : LocalName = LocalName :: pack_inline (32210688977232640u64 , 6u8) ;\npub const ATOM_LOCALNAME__63_78 : LocalName = LocalName :: pack_inline (7889664u64 , 2u8) ;\npub const ATOM_LOCALNAME__63_79 : LocalName = LocalName :: pack_inline (7955200u64 , 2u8) ;\npub const ATOM_LOCALNAME__64 : LocalName = LocalName :: pack_inline (25600u64 , 1u8) ;\npub const ATOM_LOCALNAME__64_61_74_61 : LocalName = LocalName :: pack_inline (418564367360u64 , 4u8) ;\npub const ATOM_LOCALNAME__64_61_74_61_66_6C_64 : LocalName = LocalName :: pack_inline (7236271270027944960u64 , 7u8) ;\npub const ATOM_LOCALNAME__64_61_74_61_73_72_63 : LocalName = LocalName :: pack_inline (7165916819501442048u64 , 7u8) ;\npub const ATOM_LOCALNAME__64_64 : LocalName = LocalName :: pack_inline (6579200u64 , 2u8) ;\npub const ATOM_LOCALNAME__64_65_63_6C_61_72_65 : LocalName = LocalName :: pack_inline (7310012263327687680u64 , 7u8) ;\npub const ATOM_LOCALNAME__64_65_66_61_75_6C_74 : LocalName = LocalName :: pack_inline (8389209267074589696u64 , 7u8) ;\npub const ATOM_LOCALNAME__64_65_66_65_72 : LocalName = LocalName :: pack_inline (125779835184128u64 , 5u8) ;\npub const ATOM_LOCALNAME__64_65_66_73 : LocalName = LocalName :: pack_inline (495639159808u64 , 4u8) ;\npub const ATOM_LOCALNAME__64_65_67_72_65_65 : LocalName = LocalName :: pack_inline (28540514683151360u64 , 6u8) ;\npub const ATOM_LOCALNAME__64_65_6C : LocalName = LocalName :: pack_inline (1818584064u64 , 3u8) ;\npub const ATOM_LOCALNAME__64_65_70_74_68 : LocalName = LocalName :: pack_inline (114849311187968u64 , 5u8) ;\npub const ATOM_LOCALNAME__64_65_73_63 : LocalName = LocalName :: pack_inline (427137786880u64 , 4u8) ;\npub const ATOM_LOCALNAME__64_65_73_63_65_6E_74 : LocalName = LocalName :: pack_inline (8389754633650004992u64 , 7u8) ;\npub const ATOM_LOCALNAME__64_65_74_61_69_6C_73 : LocalName = LocalName :: pack_inline (8317138479132009472u64 , 7u8) ;\npub const ATOM_LOCALNAME__64_66_6E : LocalName = LocalName :: pack_inline (1852204032u64 , 3u8) ;\npub const ATOM_LOCALNAME__64_69_61_6C_6F_67 : LocalName = LocalName :: pack_inline (29114433882645504u64 , 6u8) ;\npub const ATOM_LOCALNAME__64_69_66_66 : LocalName = LocalName :: pack_inline (439804847104u64 , 4u8) ;\npub const ATOM_LOCALNAME__64_69_72 : LocalName = LocalName :: pack_inline (1919509504u64 , 3u8) ;\npub const ATOM_LOCALNAME__64_69_72_6E_61_6D_65 : LocalName = LocalName :: pack_inline (7308604897285989376u64 , 7u8) ;\npub const ATOM_LOCALNAME__64_69_73_63_61_72_64 : LocalName = LocalName :: pack_inline (7237954630903751680u64 , 7u8) ;\npub const ATOM_LOCALNAME__64_69_73_70_6C_61_79 : LocalName = LocalName :: pack_inline (8746391181558637568u64 , 7u8) ;\npub const ATOM_LOCALNAME__64_69_76 : LocalName = LocalName :: pack_inline (1986618368u64 , 3u8) ;\npub const ATOM_LOCALNAME__64_69_76_69_64_65 : LocalName = LocalName :: pack_inline (28539376768738304u64 , 6u8) ;\npub const ATOM_LOCALNAME__64_69_76_69_73_6F_72 : LocalName = LocalName :: pack_inline (8245936339534046208u64 , 7u8) ;\npub const ATOM_LOCALNAME__64_6C : LocalName = LocalName :: pack_inline (7103488u64 , 2u8) ;\npub const ATOM_LOCALNAME__64_6F_6D_61_69_6E : LocalName = LocalName :: pack_inline (31078114606932992u64 , 6u8) ;\npub const ATOM_LOCALNAME__64_74 : LocalName = LocalName :: pack_inline (7627776u64 , 2u8) ;\npub const ATOM_LOCALNAME__64_75_72 : LocalName = LocalName :: pack_inline (1920295936u64 , 3u8) ;\npub const ATOM_LOCALNAME__64_78 : LocalName = LocalName :: pack_inline (7889920u64 , 2u8) ;\npub const ATOM_LOCALNAME__64_79 : LocalName = LocalName :: pack_inline (7955456u64 , 2u8) ;\npub const ATOM_LOCALNAME__65_64_67_65 : LocalName = LocalName :: pack_inline (435526329600u64 , 4u8) ;\npub const ATOM_LOCALNAME__65_6C_6C_69_70_73_65 : LocalName = LocalName :: pack_inline (7310310218245367040u64 , 7u8) ;\npub const ATOM_LOCALNAME__65_6D : LocalName = LocalName :: pack_inline (7169280u64 , 2u8) ;\npub const ATOM_LOCALNAME__65_6D_62_65_64 : LocalName = LocalName :: pack_inline (110386605810944u64 , 5u8) ;\npub const ATOM_LOCALNAME__65_6E_63_74_79_70_65 : LocalName = LocalName :: pack_inline (7309475736013661440u64 , 7u8) ;\npub const ATOM_LOCALNAME__65_6E_64 : LocalName = LocalName :: pack_inline (1684956416u64 , 3u8) ;\npub const ATOM_LOCALNAME__65_71 : LocalName = LocalName :: pack_inline (7431424u64 , 2u8) ;\npub const ATOM_LOCALNAME__65_76_65_6E_74 : LocalName = LocalName :: pack_inline (128017497482496u64 , 5u8) ;\npub const ATOM_LOCALNAME__65_78_69_73_74_73 : LocalName = LocalName :: pack_inline (32497661361284352u64 , 6u8) ;\npub const ATOM_LOCALNAME__65_78_70 : LocalName = LocalName :: pack_inline (1886938368u64 , 3u8) ;\npub const ATOM_LOCALNAME__66_61_63_65 : LocalName = LocalName :: pack_inline (435459024384u64 , 4u8) ;\npub const ATOM_LOCALNAME__66_61_6C_73_65 : LocalName = LocalName :: pack_inline (111546413966848u64 , 5u8) ;\npub const ATOM_LOCALNAME__66_65_42_6C_65_6E_64 : LocalName = LocalName :: pack_inline (7236833166875780608u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_46_6C_6F_6F_64 : LocalName = LocalName :: pack_inline (7237125637035877888u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_46_75_6E_63_41 : LocalName = LocalName :: pack_inline (4711731085130950144u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_46_75_6E_63_42 : LocalName = LocalName :: pack_inline (4783788679168878080u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_46_75_6E_63_47 : LocalName = LocalName :: pack_inline (5144076649358517760u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_46_75_6E_63_52 : LocalName = LocalName :: pack_inline (5936710183775725056u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_49_6D_61_67_65 : LocalName = LocalName :: pack_inline (7306916042442630656u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_4D_65_72_67_65 : LocalName = LocalName :: pack_inline (7306934699847673344u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_54_69_6C_65 : LocalName = LocalName :: pack_inline (28548172291073536u64 , 6u8) ;\npub const ATOM_LOCALNAME__66_65_62_6C_65_6E_64 : LocalName = LocalName :: pack_inline (7236833167412651520u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_66_6C_6F_6F_64 : LocalName = LocalName :: pack_inline (7237125637572748800u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_66_75_6E_63_61 : LocalName = LocalName :: pack_inline (7017574094881515008u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_66_75_6E_63_62 : LocalName = LocalName :: pack_inline (7089631688919442944u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_66_75_6E_63_67 : LocalName = LocalName :: pack_inline (7449919659109082624u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_66_75_6E_63_72 : LocalName = LocalName :: pack_inline (8242553193526289920u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_69_6D_61_67_65 : LocalName = LocalName :: pack_inline (7306916042979501568u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_6D_65_72_67_65 : LocalName = LocalName :: pack_inline (7306934700384544256u64 , 7u8) ;\npub const ATOM_LOCALNAME__66_65_6E_63_65 : LocalName = LocalName :: pack_inline (111477728306688u64 , 5u8) ;\npub const ATOM_LOCALNAME__66_65_74_63_68 : LocalName = LocalName :: pack_inline (114776363853312u64 , 5u8) ;\npub const ATOM_LOCALNAME__66_65_74_69_6C_65 : LocalName = LocalName :: pack_inline (28548172827944448u64 , 6u8) ;\npub const ATOM_LOCALNAME__66_69_67_75_72_65 : LocalName = LocalName :: pack_inline (28554821219476992u64 , 6u8) ;\npub const ATOM_LOCALNAME__66_69_6C_6C : LocalName = LocalName :: pack_inline (465675314688u64 , 4u8) ;\npub const ATOM_LOCALNAME__66_69_6C_74_65_72 : LocalName = LocalName :: pack_inline (32199698054473216u64 , 6u8) ;\npub const ATOM_LOCALNAME__66_6C_6F_6F_72 : LocalName = LocalName :: pack_inline (125822936311296u64 , 5u8) ;\npub const ATOM_LOCALNAME__66_6E : LocalName = LocalName :: pack_inline (7235072u64 , 2u8) ;\npub const ATOM_LOCALNAME__66_6F_6E_74 : LocalName = LocalName :: pack_inline (500069000704u64 , 4u8) ;\npub const ATOM_LOCALNAME__66_6F_6F_74_65_72 : LocalName = LocalName :: pack_inline (32199698105198080u64 , 6u8) ;\npub const ATOM_LOCALNAME__66_6F_72 : LocalName = LocalName :: pack_inline (1919903232u64 , 3u8) ;\npub const ATOM_LOCALNAME__66_6F_72_61_6C_6C : LocalName = LocalName :: pack_inline (30518463272281600u64 , 6u8) ;\npub const ATOM_LOCALNAME__66_6F_72_6D : LocalName = LocalName :: pack_inline (470071338496u64 , 4u8) ;\npub const ATOM_LOCALNAME__66_6F_72_6D_61_74 : LocalName = LocalName :: pack_inline (32758219997668864u64 , 6u8) ;\npub const ATOM_LOCALNAME__66_72_61_6D_65 : LocalName = LocalName :: pack_inline (111520460727808u64 , 5u8) ;\npub const ATOM_LOCALNAME__66_72_6F_6D : LocalName = LocalName :: pack_inline (470021203456u64 , 4u8) ;\npub const ATOM_LOCALNAME__66_78 : LocalName = LocalName :: pack_inline (7890432u64 , 2u8) ;\npub const ATOM_LOCALNAME__66_79 : LocalName = LocalName :: pack_inline (7955968u64 , 2u8) ;\npub const ATOM_LOCALNAME__67 : LocalName = LocalName :: pack_inline (26368u64 , 1u8) ;\npub const ATOM_LOCALNAME__67_31 : LocalName = LocalName :: pack_inline (3237632u64 , 2u8) ;\npub const ATOM_LOCALNAME__67_32 : LocalName = LocalName :: pack_inline (3303168u64 , 2u8) ;\npub const ATOM_LOCALNAME__67_63_64 : LocalName = LocalName :: pack_inline (1684236032u64 , 3u8) ;\npub const ATOM_LOCALNAME__67_65_71 : LocalName = LocalName :: pack_inline (1902470912u64 , 3u8) ;\npub const ATOM_LOCALNAME__67_6C_79_70_68 : LocalName = LocalName :: pack_inline (114832282773248u64 , 5u8) ;\npub const ATOM_LOCALNAME__67_72_61_64 : LocalName = LocalName :: pack_inline (431131617024u64 , 4u8) ;\npub const ATOM_LOCALNAME__67_74 : LocalName = LocalName :: pack_inline (7628544u64 , 2u8) ;\npub const ATOM_LOCALNAME__68_31 : LocalName = LocalName :: pack_inline (3237888u64 , 2u8) ;\npub const ATOM_LOCALNAME__68_32 : LocalName = LocalName :: pack_inline (3303424u64 , 2u8) ;\npub const ATOM_LOCALNAME__68_33 : LocalName = LocalName :: pack_inline (3368960u64 , 2u8) ;\npub const ATOM_LOCALNAME__68_34 : LocalName = LocalName :: pack_inline (3434496u64 , 2u8) ;\npub const ATOM_LOCALNAME__68_35 : LocalName = LocalName :: pack_inline (3500032u64 , 2u8) ;\npub const ATOM_LOCALNAME__68_36 : LocalName = LocalName :: pack_inline (3565568u64 , 2u8) ;\npub const ATOM_LOCALNAME__68_61_6E_64_6C_65_72 : LocalName = LocalName :: pack_inline (8243113871575967744u64 , 7u8) ;\npub const ATOM_LOCALNAME__68_61_6E_67_69_6E_67 : LocalName = LocalName :: pack_inline (7453010326299174912u64 , 7u8) ;\npub const ATOM_LOCALNAME__68_65_61_64 : LocalName = LocalName :: pack_inline (431130765312u64 , 4u8) ;\npub const ATOM_LOCALNAME__68_65_61_64_65_72 : LocalName = LocalName :: pack_inline (32199629150185472u64 , 6u8) ;\npub const ATOM_LOCALNAME__68_65_61_64_65_72_73 : LocalName = LocalName :: pack_inline (8318822943511898112u64 , 7u8) ;\npub const ATOM_LOCALNAME__68_65_69_67_68_74 : LocalName = LocalName :: pack_inline (32765890657609728u64 , 6u8) ;\npub const ATOM_LOCALNAME__68_67_72_6F_75_70 : LocalName = LocalName :: pack_inline (31654318912792576u64 , 6u8) ;\npub const ATOM_LOCALNAME__68_69_64_64_65_6E : LocalName = LocalName :: pack_inline (31073729293936640u64 , 6u8) ;\npub const ATOM_LOCALNAME__68_69_67_68 : LocalName = LocalName :: pack_inline (448411559936u64 , 4u8) ;\npub const ATOM_LOCALNAME__68_6B_65_72_6E : LocalName = LocalName :: pack_inline (121437606864896u64 , 5u8) ;\npub const ATOM_LOCALNAME__68_72 : LocalName = LocalName :: pack_inline (7497728u64 , 2u8) ;\npub const ATOM_LOCALNAME__68_72_65_66 : LocalName = LocalName :: pack_inline (439788660736u64 , 4u8) ;\npub const ATOM_LOCALNAME__68_73_70_61_63_65 : LocalName = LocalName :: pack_inline (28538242797365248u64 , 6u8) ;\npub const ATOM_LOCALNAME__68_74_6D_6C : LocalName = LocalName :: pack_inline (465692813312u64 , 4u8) ;\npub const ATOM_LOCALNAME__69 : LocalName = LocalName :: pack_inline (26880u64 , 1u8) ;\npub const ATOM_LOCALNAME__69_63_6F_6E : LocalName = LocalName :: pack_inline (474315188480u64 , 4u8) ;\npub const ATOM_LOCALNAME__69_64 : LocalName = LocalName :: pack_inline (6580480u64 , 2u8) ;\npub const ATOM_LOCALNAME__69_64_65_6E_74 : LocalName = LocalName :: pack_inline (128017496303872u64 , 5u8) ;\npub const ATOM_LOCALNAME__69_66_72_61_6D_65 : LocalName = LocalName :: pack_inline (28549237946345728u64 , 6u8) ;\npub const ATOM_LOCALNAME__69_6D_61_67_65 : LocalName = LocalName :: pack_inline (111494690597120u64 , 5u8) ;\npub const ATOM_LOCALNAME__69_6D_67 : LocalName = LocalName :: pack_inline (1735223552u64 , 3u8) ;\npub const ATOM_LOCALNAME__69_6D_70_6C_69_65_73 : LocalName = LocalName :: pack_inline (8315168201473091840u64 , 7u8) ;\npub const ATOM_LOCALNAME__69_6E : LocalName = LocalName :: pack_inline (7235840u64 , 2u8) ;\npub const ATOM_LOCALNAME__69_6E_32 : LocalName = LocalName :: pack_inline (846096640u64 , 3u8) ;\npub const ATOM_LOCALNAME__69_6E_64_65_78 : LocalName = LocalName :: pack_inline (132376871987456u64 , 5u8) ;\npub const ATOM_LOCALNAME__69_6E_70_75_74 : LocalName = LocalName :: pack_inline (128047746279680u64 , 5u8) ;\npub const ATOM_LOCALNAME__69_6E_73 : LocalName = LocalName :: pack_inline (1936615680u64 , 3u8) ;\npub const ATOM_LOCALNAME__69_6E_74 : LocalName = LocalName :: pack_inline (1953392896u64 , 3u8) ;\npub const ATOM_LOCALNAME__69_6E_76_65_72_73_65 : LocalName = LocalName :: pack_inline (7310312400256657664u64 , 7u8) ;\npub const ATOM_LOCALNAME__69_73_69_6E_64_65_78 : LocalName = LocalName :: pack_inline (8675450682577479936u64 , 7u8) ;\npub const ATOM_LOCALNAME__69_73_6D_61_70 : LocalName = LocalName :: pack_inline (123563750418688u64 , 5u8) ;\npub const ATOM_LOCALNAME__69_74_65_6D_69_64 : LocalName = LocalName :: pack_inline (28263416245545216u64 , 6u8) ;\npub const ATOM_LOCALNAME__69_74_65_6D_72_65_66 : LocalName = LocalName :: pack_inline (7378429378695555328u64 , 7u8) ;\npub const ATOM_LOCALNAME__6B : LocalName = LocalName :: pack_inline (27392u64 , 1u8) ;\npub const ATOM_LOCALNAME__6B_31 : LocalName = LocalName :: pack_inline (3238656u64 , 2u8) ;\npub const ATOM_LOCALNAME__6B_32 : LocalName = LocalName :: pack_inline (3304192u64 , 2u8) ;\npub const ATOM_LOCALNAME__6B_33 : LocalName = LocalName :: pack_inline (3369728u64 , 2u8) ;\npub const ATOM_LOCALNAME__6B_34 : LocalName = LocalName :: pack_inline (3435264u64 , 2u8) ;\npub const ATOM_LOCALNAME__6B_62_64 : LocalName = LocalName :: pack_inline (1684171520u64 , 3u8) ;\npub const ATOM_LOCALNAME__6B_65_72_6E_69_6E_67 : LocalName = LocalName :: pack_inline (7453010356431317760u64 , 7u8) ;\npub const ATOM_LOCALNAME__6B_65_79_67_65_6E : LocalName = LocalName :: pack_inline (31073742530898688u64 , 6u8) ;\npub const ATOM_LOCALNAME__6B_69_6E_64 : LocalName = LocalName :: pack_inline (431349132032u64 , 4u8) ;\npub const ATOM_LOCALNAME__6C_61_62_65_6C : LocalName = LocalName :: pack_inline (119182698048512u64 , 5u8) ;\npub const ATOM_LOCALNAME__6C_61_6D_62_64_61 : LocalName = LocalName :: pack_inline (27413446645607424u64 , 6u8) ;\npub const ATOM_LOCALNAME__6C_61_6E_67 : LocalName = LocalName :: pack_inline (444233509888u64 , 4u8) ;\npub const ATOM_LOCALNAME__6C_61_72_67_65_6F_70 : LocalName = LocalName :: pack_inline (8101805749637835776u64 , 7u8) ;\npub const ATOM_LOCALNAME__6C_63_6D : LocalName = LocalName :: pack_inline (1835232256u64 , 3u8) ;\npub const ATOM_LOCALNAME__6C_65_67_65_6E_64 : LocalName = LocalName :: pack_inline (28268879476517888u64 , 6u8) ;\npub const ATOM_LOCALNAME__6C_65_71 : LocalName = LocalName :: pack_inline (1902472192u64 , 3u8) ;\npub const ATOM_LOCALNAME__6C_69 : LocalName = LocalName :: pack_inline (6908928u64 , 2u8) ;\npub const ATOM_LOCALNAME__6C_69_6D_69_74 : LocalName = LocalName :: pack_inline (127996156013568u64 , 5u8) ;\npub const ATOM_LOCALNAME__6C_69_6E_65 : LocalName = LocalName :: pack_inline (435644099584u64 , 4u8) ;\npub const ATOM_LOCALNAME__6C_69_6E_6B : LocalName = LocalName :: pack_inline (461413903360u64 , 4u8) ;\npub const ATOM_LOCALNAME__6C_69_73_74 : LocalName = LocalName :: pack_inline (500152495104u64 , 4u8) ;\npub const ATOM_LOCALNAME__6C_69_73_74_69_6E_67 : LocalName = LocalName :: pack_inline (7453010382218161152u64 , 7u8) ;\npub const ATOM_LOCALNAME__6C_6E : LocalName = LocalName :: pack_inline (7236608u64 , 2u8) ;\npub const ATOM_LOCALNAME__6C_6F_61_64_69_6E_67 : LocalName = LocalName :: pack_inline (7453010313197087744u64 , 7u8) ;\npub const ATOM_LOCALNAME__6C_6F_63_61_6C : LocalName = LocalName :: pack_inline (119165535874048u64 , 5u8) ;\npub const ATOM_LOCALNAME__6C_6F_67 : LocalName = LocalName :: pack_inline (1735355392u64 , 3u8) ;\npub const ATOM_LOCALNAME__6C_6F_67_62_61_73_65 : LocalName = LocalName :: pack_inline (7310293695422491648u64 , 7u8) ;\npub const ATOM_LOCALNAME__6C_6F_6F_70 : LocalName = LocalName :: pack_inline (482905910272u64 , 4u8) ;\npub const ATOM_LOCALNAME__6C_6F_77 : LocalName = LocalName :: pack_inline (2003790848u64 , 3u8) ;\npub const ATOM_LOCALNAME__6C_6F_77_73_72_63 : LocalName = LocalName :: pack_inline (27991862944951296u64 , 6u8) ;\npub const ATOM_LOCALNAME__6C_71_75_6F_74_65 : LocalName = LocalName :: pack_inline (28556994708335616u64 , 6u8) ;\npub const ATOM_LOCALNAME__6C_73_70_61_63_65 : LocalName = LocalName :: pack_inline (28538242797366272u64 , 6u8) ;\npub const ATOM_LOCALNAME__6C_74 : LocalName = LocalName :: pack_inline (7629824u64 , 2u8) ;\npub const ATOM_LOCALNAME__6D_61_63_72_6F_73 : LocalName = LocalName :: pack_inline (32492159406009600u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_61_63_74_69_6F_6E : LocalName = LocalName :: pack_inline (7957695015191407872u64 , 7u8) ;\npub const ATOM_LOCALNAME__6D_61_69_6E : LocalName = LocalName :: pack_inline (474214395136u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_61_70 : LocalName = LocalName :: pack_inline (1885433088u64 , 3u8) ;\npub const ATOM_LOCALNAME__6D_61_72_6B : LocalName = LocalName :: pack_inline (461480488192u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_61_72_6B_65_72 : LocalName = LocalName :: pack_inline (32199659499908352u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_61_72_71_75_65_65 : LocalName = LocalName :: pack_inline (7306375100589239552u64 , 7u8) ;\npub const ATOM_LOCALNAME__6D_61_73_6B : LocalName = LocalName :: pack_inline (461497265408u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_61_74_68 : LocalName = LocalName :: pack_inline (448629140736u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_61_74_72_69_78 : LocalName = LocalName :: pack_inline (33892937505008896u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_61_78 : LocalName = LocalName :: pack_inline (2019650816u64 , 3u8) ;\npub const ATOM_LOCALNAME__6D_61_78_73_69_7A_65 : LocalName = LocalName :: pack_inline (7312272889651227904u64 , 7u8) ;\npub const ATOM_LOCALNAME__6D_65_61_6E : LocalName = LocalName :: pack_inline (474080439552u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_65_64_69_61 : LocalName = LocalName :: pack_inline (107105283828992u64 , 5u8) ;\npub const ATOM_LOCALNAME__6D_65_64_69_61_6E : LocalName = LocalName :: pack_inline (31069352722001152u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_65_6E_75 : LocalName = LocalName :: pack_inline (504363314432u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_65_72_72_6F_72 : LocalName = LocalName :: pack_inline (32210684681219328u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_65_74_61 : LocalName = LocalName :: pack_inline (418564631808u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_65_74_65_72 : LocalName = LocalName :: pack_inline (125780070067456u64 , 5u8) ;\npub const ATOM_LOCALNAME__6D_65_74_68_6F_64 : LocalName = LocalName :: pack_inline (28269992091151616u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_66_65_6E_63_65_64 : LocalName = LocalName :: pack_inline (7234297702239333632u64 , 7u8) ;\npub const ATOM_LOCALNAME__6D_66_72_61_63 : LocalName = LocalName :: pack_inline (109270182292736u64 , 5u8) ;\npub const ATOM_LOCALNAME__6D_67_6C_79_70_68 : LocalName = LocalName :: pack_inline (29397064389979392u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_69 : LocalName = LocalName :: pack_inline (6909184u64 , 2u8) ;\npub const ATOM_LOCALNAME__6D_69_6E : LocalName = LocalName :: pack_inline (1852402944u64 , 3u8) ;\npub const ATOM_LOCALNAME__6D_69_6E_73_69_7A_65 : LocalName = LocalName :: pack_inline (7312272889483980032u64 , 7u8) ;\npub const ATOM_LOCALNAME__6D_69_6E_75_73 : LocalName = LocalName :: pack_inline (126948200770816u64 , 5u8) ;\npub const ATOM_LOCALNAME__6D_6E : LocalName = LocalName :: pack_inline (7236864u64 , 2u8) ;\npub const ATOM_LOCALNAME__6D_6F : LocalName = LocalName :: pack_inline (7302400u64 , 2u8) ;\npub const ATOM_LOCALNAME__6D_6F_64_65 : LocalName = LocalName :: pack_inline (435476720896u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_6F_6D_65_6E_74 : LocalName = LocalName :: pack_inline (32772479205207296u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_6F_76_65_72 : LocalName = LocalName :: pack_inline (125780104277248u64 , 5u8) ;\npub const ATOM_LOCALNAME__6D_70_61_64_64_65_64 : LocalName = LocalName :: pack_inline (7234298758734834944u64 , 7u8) ;\npub const ATOM_LOCALNAME__6D_70_61_74_68 : LocalName = LocalName :: pack_inline (114849060252928u64 , 5u8) ;\npub const ATOM_LOCALNAME__6D_72_6F_6F_74 : LocalName = LocalName :: pack_inline (128021959961856u64 , 5u8) ;\npub const ATOM_LOCALNAME__6D_72_6F_77 : LocalName = LocalName :: pack_inline (512970878208u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_73 : LocalName = LocalName :: pack_inline (7564544u64 , 2u8) ;\npub const ATOM_LOCALNAME__6D_73_70_61_63_65 : LocalName = LocalName :: pack_inline (28538242797366528u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_73_71_72_74 : LocalName = LocalName :: pack_inline (128034878483712u64 , 5u8) ;\npub const ATOM_LOCALNAME__6D_73_74_79_6C_65 : LocalName = LocalName :: pack_inline (28548241548340480u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_73_75_62 : LocalName = LocalName :: pack_inline (422877293824u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_73_75_62_73_75_70 : LocalName = LocalName :: pack_inline (8103509971237563648u64 , 7u8) ;\npub const ATOM_LOCALNAME__6D_73_75_70 : LocalName = LocalName :: pack_inline (483006835968u64 , 4u8) ;\npub const ATOM_LOCALNAME__6D_74_61_62_6C_65 : LocalName = LocalName :: pack_inline (28548142445391104u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_74_64 : LocalName = LocalName :: pack_inline (1685351680u64 , 3u8) ;\npub const ATOM_LOCALNAME__6D_74_65_78_74 : LocalName = LocalName :: pack_inline (128060447026432u64 , 5u8) ;\npub const ATOM_LOCALNAME__6D_74_72 : LocalName = LocalName :: pack_inline (1920232704u64 , 3u8) ;\npub const ATOM_LOCALNAME__6D_75_6E_64_65_72 : LocalName = LocalName :: pack_inline (32199629369339136u64 , 6u8) ;\npub const ATOM_LOCALNAME__6D_75_74_65_64 : LocalName = LocalName :: pack_inline (110386908327168u64 , 5u8) ;\npub const ATOM_LOCALNAME__6E_61_6D_65 : LocalName = LocalName :: pack_inline (435626798592u64 , 4u8) ;\npub const ATOM_LOCALNAME__6E_61_72_67_73 : LocalName = LocalName :: pack_inline (126888137813504u64 , 5u8) ;\npub const ATOM_LOCALNAME__6E_61_76 : LocalName = LocalName :: pack_inline (1986096640u64 , 3u8) ;\npub const ATOM_LOCALNAME__6E_65_71 : LocalName = LocalName :: pack_inline (1902472704u64 , 3u8) ;\npub const ATOM_LOCALNAME__6E_65_73_74 : LocalName = LocalName :: pack_inline (500152233472u64 , 4u8) ;\npub const ATOM_LOCALNAME__6E_65_78_74_69_64 : LocalName = LocalName :: pack_inline (28263446628101632u64 , 6u8) ;\npub const ATOM_LOCALNAME__6E_6F_62_72 : LocalName = LocalName :: pack_inline (491277741568u64 , 4u8) ;\npub const ATOM_LOCALNAME__6E_6F_65_6D_62_65_64 : LocalName = LocalName :: pack_inline (7234296598433328640u64 , 7u8) ;\npub const ATOM_LOCALNAME__6E_6F_68_72_65_66 : LocalName = LocalName :: pack_inline (28821989677297152u64 , 6u8) ;\npub const ATOM_LOCALNAME__6E_6F_6E_63_65 : LocalName = LocalName :: pack_inline (111477728964096u64 , 5u8) ;\npub const ATOM_LOCALNAME__6E_6F_6E_65 : LocalName = LocalName :: pack_inline (435644493312u64 , 4u8) ;\npub const ATOM_LOCALNAME__6E_6F_73_68_61_64_65 : LocalName = LocalName :: pack_inline (7306071596742962688u64 , 7u8) ;\npub const ATOM_LOCALNAME__6E_6F_74 : LocalName = LocalName :: pack_inline (1953459712u64 , 3u8) ;\npub const ATOM_LOCALNAME__6E_6F_74_69_6E : LocalName = LocalName :: pack_inline (121399204081152u64 , 5u8) ;\npub const ATOM_LOCALNAME__6E_6F_77_72_61_70 : LocalName = LocalName :: pack_inline (31632341649550848u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_62_6A_65_63_74 : LocalName = LocalName :: pack_inline (32760384526118656u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_66_66_73_65_74 : LocalName = LocalName :: pack_inline (32762643612069632u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_6C : LocalName = LocalName :: pack_inline (7106304u64 , 2u8) ;\npub const ATOM_LOCALNAME__6F_6E_61_62_6F_72_74 : LocalName = LocalName :: pack_inline (8390891524076760832u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_6E_62_65_67_69_6E : LocalName = LocalName :: pack_inline (7956003901867454208u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_6E_62_6C_75_72 : LocalName = LocalName :: pack_inline (32217255713337088u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_6E_63_6C_69_63_6B : LocalName = LocalName :: pack_inline (7738144498998210304u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_6E_63_6F_70_79 : LocalName = LocalName :: pack_inline (34182095893851904u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_6E_63_75_74 : LocalName = LocalName :: pack_inline (128047528177408u64 , 5u8) ;\npub const ATOM_LOCALNAME__6F_6E_64_72_61_67 : LocalName = LocalName :: pack_inline (29099066540322560u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_6E_64_72_6F_70 : LocalName = LocalName :: pack_inline (31647734493507328u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_6E_65_6E_64 : LocalName = LocalName :: pack_inline (110425310916352u64 , 5u8) ;\npub const ATOM_LOCALNAME__6F_6E_65_72_72_6F_72 : LocalName = LocalName :: pack_inline (8245935278392241920u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_6E_66_6F_63_75_73 : LocalName = LocalName :: pack_inline (8319665216747892480u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_6E_68_65_6C_70 : LocalName = LocalName :: pack_inline (31644380191158016u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_6E_69_6E_70_75_74 : LocalName = LocalName :: pack_inline (8391737100192345856u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_6E_6B_65_79_75_70 : LocalName = LocalName :: pack_inline (8103516581024132864u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_6E_6C_6F_61_64 : LocalName = LocalName :: pack_inline (28254628859506432u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_6E_6D_6F_76_65 : LocalName = LocalName :: pack_inline (28559193597177600u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_6E_70_61_73_74_65 : LocalName = LocalName :: pack_inline (7310594957464465152u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_6E_72_65_73_65_74 : LocalName = LocalName :: pack_inline (8387236760596147968u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_6E_73_74_61_72_74 : LocalName = LocalName :: pack_inline (8390876208525373184u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_6E_73_74_6F_70 : LocalName = LocalName :: pack_inline (31647743335100160u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_6E_7A_6F_6F_6D : LocalName = LocalName :: pack_inline (30803297047572224u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_70_61_63_69_74_79 : LocalName = LocalName :: pack_inline (8751735851445153536u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_70_65_6E : LocalName = LocalName :: pack_inline (474148269824u64 , 4u8) ;\npub const ATOM_LOCALNAME__6F_70_74_69_6D_75_6D : LocalName = LocalName :: pack_inline (7887330622101810944u64 , 7u8) ;\npub const ATOM_LOCALNAME__6F_70_74_69_6F_6E : LocalName = LocalName :: pack_inline (31084746153946880u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_72 : LocalName = LocalName :: pack_inline (7499520u64 , 2u8) ;\npub const ATOM_LOCALNAME__6F_72_64_65_72 : LocalName = LocalName :: pack_inline (125779802484480u64 , 5u8) ;\npub const ATOM_LOCALNAME__6F_72_69_65_6E_74 : LocalName = LocalName :: pack_inline (32772479138295552u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_72_69_67_69_6E : LocalName = LocalName :: pack_inline (31078140309827328u64 , 6u8) ;\npub const ATOM_LOCALNAME__6F_74_68_65_72 : LocalName = LocalName :: pack_inline (125779869724416u64 , 5u8) ;\npub const ATOM_LOCALNAME__6F_75_74_70_75_74 : LocalName = LocalName :: pack_inline (32780223149076224u64 , 6u8) ;\npub const ATOM_LOCALNAME__70 : LocalName = LocalName :: pack_inline (28672u64 , 1u8) ;\npub const ATOM_LOCALNAME__70_61_72_61_6D : LocalName = LocalName :: pack_inline (120265298243584u64 , 5u8) ;\npub const ATOM_LOCALNAME__70_61_72_73_65 : LocalName = LocalName :: pack_inline (111546514632704u64 , 5u8) ;\npub const ATOM_LOCALNAME__70_61_74_68 : LocalName = LocalName :: pack_inline (448629141504u64 , 4u8) ;\npub const ATOM_LOCALNAME__70_61_74_74_65_72_6E : LocalName = LocalName :: pack_inline (7958535042360242176u64 , 7u8) ;\npub const ATOM_LOCALNAME__70_69 : LocalName = LocalName :: pack_inline (6909952u64 , 2u8) ;\npub const ATOM_LOCALNAME__70_69_63_74_75_72_65 : LocalName = LocalName :: pack_inline (7310034287920246784u64 , 7u8) ;\npub const ATOM_LOCALNAME__70_69_65_63_65 : LocalName = LocalName :: pack_inline (111477577576448u64 , 5u8) ;\npub const ATOM_LOCALNAME__70_69_6E_67 : LocalName = LocalName :: pack_inline (444234035200u64 , 4u8) ;\npub const ATOM_LOCALNAME__70_6C_75_73 : LocalName = LocalName :: pack_inline (495891279872u64 , 4u8) ;\npub const ATOM_LOCALNAME__70_6F_69_6E_74_73 : LocalName = LocalName :: pack_inline (32497639885860864u64 , 6u8) ;\npub const ATOM_LOCALNAME__70_6F_6C_79_67_6F_6E : LocalName = LocalName :: pack_inline (7957692837794902016u64 , 7u8) ;\npub const ATOM_LOCALNAME__70_6F_73_74_65_72 : LocalName = LocalName :: pack_inline (32199698172309504u64 , 6u8) ;\npub const ATOM_LOCALNAME__70_6F_77_65_72 : LocalName = LocalName :: pack_inline (125780121055232u64 , 5u8) ;\npub const ATOM_LOCALNAME__70_72_65 : LocalName = LocalName :: pack_inline (1701998592u64 , 3u8) ;\npub const ATOM_LOCALNAME__70_72_65_6C_6F_61_64 : LocalName = LocalName :: pack_inline (7233184987882876928u64 , 7u8) ;\npub const ATOM_LOCALNAME__70_72_69_6D_65_73 : LocalName = LocalName :: pack_inline (32481142916673536u64 , 6u8) ;\npub const ATOM_LOCALNAME__70_72_6F_64_75_63_74 : LocalName = LocalName :: pack_inline (8386676005320945664u64 , 7u8) ;\npub const ATOM_LOCALNAME__70_72_6F_66_69_6C_65 : LocalName = LocalName :: pack_inline (7308332183992823808u64 , 7u8) ;\npub const ATOM_LOCALNAME__70_72_6F_6D_70_74 : LocalName = LocalName :: pack_inline (32774712621953024u64 , 6u8) ;\npub const ATOM_LOCALNAME__71 : LocalName = LocalName :: pack_inline (28928u64 , 1u8) ;\npub const ATOM_LOCALNAME__72 : LocalName = LocalName :: pack_inline (29184u64 , 1u8) ;\npub const ATOM_LOCALNAME__72_61_64_69_75_73 : LocalName = LocalName :: pack_inline (32498717837849088u64 , 6u8) ;\npub const ATOM_LOCALNAME__72_62 : LocalName = LocalName :: pack_inline (6451712u64 , 2u8) ;\npub const ATOM_LOCALNAME__72_65_61_6C : LocalName = LocalName :: pack_inline (465490506240u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_65_61_6C_73 : LocalName = LocalName :: pack_inline (126909327700480u64 , 5u8) ;\npub const ATOM_LOCALNAME__72_65_63_74 : LocalName = LocalName :: pack_inline (499883799040u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_65_66_58 : LocalName = LocalName :: pack_inline (379675046400u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_65_66_59 : LocalName = LocalName :: pack_inline (383970013696u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_65_66_78 : LocalName = LocalName :: pack_inline (517113999872u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_65_66_79 : LocalName = LocalName :: pack_inline (521408967168u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_65_6C : LocalName = LocalName :: pack_inline (1818587648u64 , 3u8) ;\npub const ATOM_LOCALNAME__72_65_6C_6E : LocalName = LocalName :: pack_inline (474264990208u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_65_6D : LocalName = LocalName :: pack_inline (1835364864u64 , 3u8) ;\npub const ATOM_LOCALNAME__72_65_70_65_61_74 : LocalName = LocalName :: pack_inline (32758185603723776u64 , 6u8) ;\npub const ATOM_LOCALNAME__72_65_70_6C_61_63_65 : LocalName = LocalName :: pack_inline (7305790138895135232u64 , 7u8) ;\npub const ATOM_LOCALNAME__72_65_73_74_61_72_74 : LocalName = LocalName :: pack_inline (8390876208524784128u64 , 7u8) ;\npub const ATOM_LOCALNAME__72_65_73_75_6C_74 : LocalName = LocalName :: pack_inline (32770349001437696u64 , 6u8) ;\npub const ATOM_LOCALNAME__72_65_76 : LocalName = LocalName :: pack_inline (1986359808u64 , 3u8) ;\npub const ATOM_LOCALNAME__72_6F_6C_65 : LocalName = LocalName :: pack_inline (435610939904u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_6F_6F_74 : LocalName = LocalName :: pack_inline (500085780992u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_6F_74_61_74_65 : LocalName = LocalName :: pack_inline (28556934561886720u64 , 6u8) ;\npub const ATOM_LOCALNAME__72_6F_77_73 : LocalName = LocalName :: pack_inline (495925031424u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_6F_77_73_70_61_6E : LocalName = LocalName :: pack_inline (7953762058140348928u64 , 7u8) ;\npub const ATOM_LOCALNAME__72_70 : LocalName = LocalName :: pack_inline (7369216u64 , 2u8) ;\npub const ATOM_LOCALNAME__72_71_75_6F_74_65 : LocalName = LocalName :: pack_inline (28556994708337152u64 , 6u8) ;\npub const ATOM_LOCALNAME__72_73_70_61_63_65 : LocalName = LocalName :: pack_inline (28538242797367808u64 , 6u8) ;\npub const ATOM_LOCALNAME__72_74 : LocalName = LocalName :: pack_inline (7631360u64 , 2u8) ;\npub const ATOM_LOCALNAME__72_74_63 : LocalName = LocalName :: pack_inline (1668575744u64 , 3u8) ;\npub const ATOM_LOCALNAME__72_75_62_79 : LocalName = LocalName :: pack_inline (521342906880u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_75_6C_65 : LocalName = LocalName :: pack_inline (435611333120u64 , 4u8) ;\npub const ATOM_LOCALNAME__72_75_6C_65_73 : LocalName = LocalName :: pack_inline (126879448527360u64 , 5u8) ;\npub const ATOM_LOCALNAME__72_78 : LocalName = LocalName :: pack_inline (7893504u64 , 2u8) ;\npub const ATOM_LOCALNAME__72_79 : LocalName = LocalName :: pack_inline (7959040u64 , 2u8) ;\npub const ATOM_LOCALNAME__73 : LocalName = LocalName :: pack_inline (29440u64 , 1u8) ;\npub const ATOM_LOCALNAME__73_61_6D_70 : LocalName = LocalName :: pack_inline (482871440128u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_61_6E_64_62_6F_78 : LocalName = LocalName :: pack_inline (8678263190454366976u64 , 7u8) ;\npub const ATOM_LOCALNAME__73_63_61_6C_65 : LocalName = LocalName :: pack_inline (111516164780800u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_63_68_65_6D_65 : LocalName = LocalName :: pack_inline (28549254958248704u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_63_6F_70_65 : LocalName = LocalName :: pack_inline (111533579531008u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_63_6F_70_65_64 : LocalName = LocalName :: pack_inline (28259031250596608u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_63_72_69_70_74 : LocalName = LocalName :: pack_inline (32774695491433216u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_64_65_76 : LocalName = LocalName :: pack_inline (508507222784u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_65_61_72_63_68 : LocalName = LocalName :: pack_inline (29382740489368320u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_65_63 : LocalName = LocalName :: pack_inline (1667592960u64 , 3u8) ;\npub const ATOM_LOCALNAME__73_65_63_68 : LocalName = LocalName :: pack_inline (448344191744u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_65_63_74_69_6F_6E : LocalName = LocalName :: pack_inline (7957695015191671552u64 , 7u8) ;\npub const ATOM_LOCALNAME__73_65_65_64 : LocalName = LocalName :: pack_inline (431197876992u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_65_6C_65_63_74 : LocalName = LocalName :: pack_inline (32760384559870720u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_65_70 : LocalName = LocalName :: pack_inline (1885696768u64 , 3u8) ;\npub const ATOM_LOCALNAME__73_65_74 : LocalName = LocalName :: pack_inline (1952805632u64 , 3u8) ;\npub const ATOM_LOCALNAME__73_65_74_64_69_66_66 : LocalName = LocalName :: pack_inline (7378700919663588096u64 , 7u8) ;\npub const ATOM_LOCALNAME__73_68_61_70_65 : LocalName = LocalName :: pack_inline (111533344977664u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_68_6F_77 : LocalName = LocalName :: pack_inline (512970224384u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_69_6E : LocalName = LocalName :: pack_inline (1852404480u64 , 3u8) ;\npub const ATOM_LOCALNAME__73_69_6E_68 : LocalName = LocalName :: pack_inline (448529003264u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_69_7A_65 : LocalName = LocalName :: pack_inline (435845427968u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_69_7A_65_73 : LocalName = LocalName :: pack_inline (126879682622208u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_6C_6F_70_65 : LocalName = LocalName :: pack_inline (111533580120832u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_6C_6F_74 : LocalName = LocalName :: pack_inline (500085584640u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_6D_61_6C_6C : LocalName = LocalName :: pack_inline (119212746830592u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_6F_75_72_63_65 : LocalName = LocalName :: pack_inline (28538315895436032u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_70_61_63_65 : LocalName = LocalName :: pack_inline (111477510927104u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_70_61_63_65_72 : LocalName = LocalName :: pack_inline (32199624855941888u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_70_61_63_69_6E_67 : LocalName = LocalName :: pack_inline (7453010308902187776u64 , 7u8) ;\npub const ATOM_LOCALNAME__73_70_61_6E : LocalName = LocalName :: pack_inline (474081161984u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_70_65_65_64 : LocalName = LocalName :: pack_inline (110386656342784u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_72_63 : LocalName = LocalName :: pack_inline (1668444928u64 , 3u8) ;\npub const ATOM_LOCALNAME__73_72_63_64_6F_63 : LocalName = LocalName :: pack_inline (27988499650212608u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_72_63_6C_61_6E_67 : LocalName = LocalName :: pack_inline (7453001551497556736u64 , 7u8) ;\npub const ATOM_LOCALNAME__73_72_63_73_65_74 : LocalName = LocalName :: pack_inline (32762643562525440u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_74_61_6E_64_62_79 : LocalName = LocalName :: pack_inline (8746663851551126272u64 , 7u8) ;\npub const ATOM_LOCALNAME__73_74_61_72_74 : LocalName = LocalName :: pack_inline (128034610115328u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_74_65_6D_68 : LocalName = LocalName :: pack_inline (114819062854400u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_74_65_6D_76 : LocalName = LocalName :: pack_inline (130212225643264u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_74_65_70 : LocalName = LocalName :: pack_inline (482738467584u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_74_6F_70 : LocalName = LocalName :: pack_inline (482906239744u64 , 4u8) ;\npub const ATOM_LOCALNAME__73_74_72_69_6B_65 : LocalName = LocalName :: pack_inline (28547073283748608u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_74_72_69_6E_67 : LocalName = LocalName :: pack_inline (29113321772053248u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_74_72_6F_6B_65 : LocalName = LocalName :: pack_inline (28547099053552384u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_74_72_6F_6E_67 : LocalName = LocalName :: pack_inline (29113347541857024u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_74_79_6C_65 : LocalName = LocalName :: pack_inline (111516568548096u64 , 5u8) ;\npub const ATOM_LOCALNAME__73_75_62 : LocalName = LocalName :: pack_inline (1651864320u64 , 3u8) ;\npub const ATOM_LOCALNAME__73_75_62_73_65_74 : LocalName = LocalName :: pack_inline (32762643545944832u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_75_6D : LocalName = LocalName :: pack_inline (1836413696u64 , 3u8) ;\npub const ATOM_LOCALNAME__73_75_6D_6D_61_72_79 : LocalName = LocalName :: pack_inline (8751164148550038272u64 , 7u8) ;\npub const ATOM_LOCALNAME__73_75_70 : LocalName = LocalName :: pack_inline (1886745344u64 , 3u8) ;\npub const ATOM_LOCALNAME__73_76_67 : LocalName = LocalName :: pack_inline (1735815936u64 , 3u8) ;\npub const ATOM_LOCALNAME__73_77_69_74_63_68 : LocalName = LocalName :: pack_inline (29382749214700288u64 , 6u8) ;\npub const ATOM_LOCALNAME__73_79_6D_62_6F_6C : LocalName = LocalName :: pack_inline (30521766018904832u64 , 6u8) ;\npub const ATOM_LOCALNAME__74_61_62_6C_65 : LocalName = LocalName :: pack_inline (111516181427200u64 , 5u8) ;\npub const ATOM_LOCALNAME__74_61_6E : LocalName = LocalName :: pack_inline (1851880448u64 , 3u8) ;\npub const ATOM_LOCALNAME__74_61_6E_68 : LocalName = LocalName :: pack_inline (448528479232u64 , 4u8) ;\npub const ATOM_LOCALNAME__74_61_72_67_65_74 : LocalName = LocalName :: pack_inline (32762592273462272u64 , 6u8) ;\npub const ATOM_LOCALNAME__74_61_72_67_65_74_58 : LocalName = LocalName :: pack_inline (6373830867611120640u64 , 7u8) ;\npub const ATOM_LOCALNAME__74_61_72_67_65_74_59 : LocalName = LocalName :: pack_inline (6445888461649048576u64 , 7u8) ;\npub const ATOM_LOCALNAME__74_61_72_67_65_74_78 : LocalName = LocalName :: pack_inline (8679673876824814592u64 , 7u8) ;\npub const ATOM_LOCALNAME__74_61_72_67_65_74_79 : LocalName = LocalName :: pack_inline (8751731470862742528u64 , 7u8) ;\npub const ATOM_LOCALNAME__74_62_6F_64_79 : LocalName = LocalName :: pack_inline (133472272413696u64 , 5u8) ;\npub const ATOM_LOCALNAME__74_62_72_65_61_6B : LocalName = LocalName :: pack_inline (30224910846686208u64 , 6u8) ;\npub const ATOM_LOCALNAME__74_64 : LocalName = LocalName :: pack_inline (6583296u64 , 2u8) ;\npub const ATOM_LOCALNAME__74_65_6E_64_73_74_6F : LocalName = LocalName :: pack_inline (8031170910694503424u64 , 7u8) ;\npub const ATOM_LOCALNAME__74_65_78_74 : LocalName = LocalName :: pack_inline (500236121088u64 , 4u8) ;\npub const ATOM_LOCALNAME__74_66_6F_6F_74 : LocalName = LocalName :: pack_inline (128021959177216u64 , 5u8) ;\npub const ATOM_LOCALNAME__74_68 : LocalName = LocalName :: pack_inline (6845440u64 , 2u8) ;\npub const ATOM_LOCALNAME__74_68_65_61_64 : LocalName = LocalName :: pack_inline (110369475949568u64 , 5u8) ;\npub const ATOM_LOCALNAME__74_69_6D_65 : LocalName = LocalName :: pack_inline (435627324416u64 , 4u8) ;\npub const ATOM_LOCALNAME__74_69_6D_65_73 : LocalName = LocalName :: pack_inline (126879464518656u64 , 5u8) ;\npub const ATOM_LOCALNAME__74_69_74_6C_65 : LocalName = LocalName :: pack_inline (111516483941376u64 , 5u8) ;\npub const ATOM_LOCALNAME__74_6F : LocalName = LocalName :: pack_inline (7304192u64 , 2u8) ;\npub const ATOM_LOCALNAME__74_6F_67_67_6C_65 : LocalName = LocalName :: pack_inline (28548164020564992u64 , 6u8) ;\npub const ATOM_LOCALNAME__74_72 : LocalName = LocalName :: pack_inline (7500800u64 , 2u8) ;\npub const ATOM_LOCALNAME__74_72_61_63_6B : LocalName = LocalName :: pack_inline (118074580825088u64 , 5u8) ;\npub const ATOM_LOCALNAME__74_72_65_66 : LocalName = LocalName :: pack_inline (439788663808u64 , 4u8) ;\npub const ATOM_LOCALNAME__74_72_75_65 : LocalName = LocalName :: pack_inline (435762131968u64 , 4u8) ;\npub const ATOM_LOCALNAME__74_73_70_61_6E : LocalName = LocalName :: pack_inline (121364777497600u64 , 5u8) ;\npub const ATOM_LOCALNAME__74_74 : LocalName = LocalName :: pack_inline (7631872u64 , 2u8) ;\npub const ATOM_LOCALNAME__74_79_70_65 : LocalName = LocalName :: pack_inline (435678704640u64 , 4u8) ;\npub const ATOM_LOCALNAME__75 : LocalName = LocalName :: pack_inline (29952u64 , 1u8) ;\npub const ATOM_LOCALNAME__75_31 : LocalName = LocalName :: pack_inline (3241216u64 , 2u8) ;\npub const ATOM_LOCALNAME__75_32 : LocalName = LocalName :: pack_inline (3306752u64 , 2u8) ;\npub const ATOM_LOCALNAME__75_6C : LocalName = LocalName :: pack_inline (7107840u64 , 2u8) ;\npub const ATOM_LOCALNAME__75_6E_69_63_6F_64_65 : LocalName = LocalName :: pack_inline (7306086968263079168u64 , 7u8) ;\npub const ATOM_LOCALNAME__75_6E_69_6F_6E : LocalName = LocalName :: pack_inline (121424789271808u64 , 5u8) ;\npub const ATOM_LOCALNAME__75_70_6C_69_6D_69_74 : LocalName = LocalName :: pack_inline (8388356080512562432u64 , 7u8) ;\npub const ATOM_LOCALNAME__75_73_65 : LocalName = LocalName :: pack_inline (1702065408u64 , 3u8) ;\npub const ATOM_LOCALNAME__75_73_65_6D_61_70 : LocalName = LocalName :: pack_inline (31632319872988416u64 , 6u8) ;\npub const ATOM_LOCALNAME__76_61_6C_69_67_6E : LocalName = LocalName :: pack_inline (31075949925725696u64 , 6u8) ;\npub const ATOM_LOCALNAME__76_61_6C_75_65 : LocalName = LocalName :: pack_inline (111555003905536u64 , 5u8) ;\npub const ATOM_LOCALNAME__76_61_6C_75_65_73 : LocalName = LocalName :: pack_inline (32481177325630976u64 , 6u8) ;\npub const ATOM_LOCALNAME__76_61_72 : LocalName = LocalName :: pack_inline (1918989824u64 , 3u8) ;\npub const ATOM_LOCALNAME__76_65_63_74_6F_72 : LocalName = LocalName :: pack_inline (32210693019497984u64 , 6u8) ;\npub const ATOM_LOCALNAME__76_65_72_73_69_6F_6E : LocalName = LocalName :: pack_inline (7957695011148363264u64 , 7u8) ;\npub const ATOM_LOCALNAME__76_69_64_65_6F : LocalName = LocalName :: pack_inline (122481267013120u64 , 5u8) ;\npub const ATOM_LOCALNAME__76_69_65_77 : LocalName = LocalName :: pack_inline (512802518528u64 , 4u8) ;\npub const ATOM_LOCALNAME__76_69_65_77_42_6F_78 : LocalName = LocalName :: pack_inline (8678228087536186880u64 , 7u8) ;\npub const ATOM_LOCALNAME__76_69_65_77_62_6F_78 : LocalName = LocalName :: pack_inline (8678263271908275712u64 , 7u8) ;\npub const ATOM_LOCALNAME__76_6B_65_72_6E : LocalName = LocalName :: pack_inline (121437606868480u64 , 5u8) ;\npub const ATOM_LOCALNAME__76_6C_69_6E_6B : LocalName = LocalName :: pack_inline (118121959290368u64 , 5u8) ;\npub const ATOM_LOCALNAME__76_73_70_61_63_65 : LocalName = LocalName :: pack_inline (28538242797368832u64 , 6u8) ;\npub const ATOM_LOCALNAME__77_62_72 : LocalName = LocalName :: pack_inline (1919055616u64 , 3u8) ;\npub const ATOM_LOCALNAME__77_68_65_6E : LocalName = LocalName :: pack_inline (474147747584u64 , 4u8) ;\npub const ATOM_LOCALNAME__77_69_64_74_68 : LocalName = LocalName :: pack_inline (114849110128384u64 , 5u8) ;\npub const ATOM_LOCALNAME__77_69_64_74_68_73 : LocalName = LocalName :: pack_inline (32484471431853824u64 , 6u8) ;\npub const ATOM_LOCALNAME__77_72_61_70 : LocalName = LocalName :: pack_inline (482671228672u64 , 4u8) ;\npub const ATOM_LOCALNAME__78 : LocalName = LocalName :: pack_inline (30720u64 , 1u8) ;\npub const ATOM_LOCALNAME__78_31 : LocalName = LocalName :: pack_inline (3241984u64 , 2u8) ;\npub const ATOM_LOCALNAME__78_32 : LocalName = LocalName :: pack_inline (3307520u64 , 2u8) ;\npub const ATOM_LOCALNAME__78_6C_69_6E_6B : LocalName = LocalName :: pack_inline (118121959290880u64 , 5u8) ;\npub const ATOM_LOCALNAME__78_6D_6C_6E_73 : LocalName = LocalName :: pack_inline (126918102710272u64 , 5u8) ;\npub const ATOM_LOCALNAME__78_6D_70 : LocalName = LocalName :: pack_inline (1886222336u64 , 3u8) ;\npub const ATOM_LOCALNAME__78_6F_72 : LocalName = LocalName :: pack_inline (1919907840u64 , 3u8) ;\npub const ATOM_LOCALNAME__78_72_65_66 : LocalName = LocalName :: pack_inline (439788664832u64 , 4u8) ;\npub const ATOM_LOCALNAME__79 : LocalName = LocalName :: pack_inline (30976u64 , 1u8) ;\npub const ATOM_LOCALNAME__79_31 : LocalName = LocalName :: pack_inline (3242240u64 , 2u8) ;\npub const ATOM_LOCALNAME__79_32 : LocalName = LocalName :: pack_inline (3307776u64 , 2u8) ;\npub const ATOM_LOCALNAME__7A : LocalName = LocalName :: pack_inline (31232u64 , 1u8) ;\n# [doc = \"Takes a local name as a string and returns its key in the string cache.\"] # [macro_export] macro_rules ! local_name { (\"requiredfeatures\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_71_75_69_72_65_64_66_65_61_74_75_72_65_73 } ;\n(\"pointsAtZ\") =\u003e { $ crate :: ATOM_LOCALNAME__70_6F_69_6E_74_73_41_74_5A } ;\n(\"xlink:role\") =\u003e { $ crate :: ATOM_LOCALNAME__78_6C_69_6E_6B_3A_72_6F_6C_65 } ;\n(\"markerheight\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_72_6B_65_72_68_65_69_67_68_74 } ;\n(\"text-rendering\") =\u003e { $ crate :: ATOM_LOCALNAME__74_65_78_74_2D_72_65_6E_64_65_72_69_6E_67 } ;\n(\"stroke-opacity\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_6F_70_61_63_69_74_79 } ;\n(\"stitchtiles\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_69_74_63_68_74_69_6C_65_73 } ;\n(\"onoffline\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_6F_66_66_6C_69_6E_65 } ;\n(\"vert-adv-y\") =\u003e { $ crate :: ATOM_LOCALNAME__76_65_72_74_2D_61_64_76_2D_79 } ;\n(\"columnspan\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6C_75_6D_6E_73_70_61_6E } ;\n(\"calcmode\") =\u003e { $ crate :: ATOM_LOCALNAME__63_61_6C_63_6D_6F_64_65 } ;\n(\"stroke-linecap\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_6C_69_6E_65_63_61_70 } ;\n(\"complexes\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6D_70_6C_65_78_65_73 } ;\n(\"crossorigin\") =\u003e { $ crate :: ATOM_LOCALNAME__63_72_6F_73_73_6F_72_69_67_69_6E } ;\n(\"unselectable\") =\u003e { $ crate :: ATOM_LOCALNAME__75_6E_73_65_6C_65_63_74_61_62_6C_65 } ;\n(\"fePointLight\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_50_6F_69_6E_74_4C_69_67_68_74 } ;\n(\"exponentiale\") =\u003e { $ crate :: ATOM_LOCALNAME__65_78_70_6F_6E_65_6E_74_69_61_6C_65 } ;\n(\"markerUnits\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_72_6B_65_72_55_6E_69_74_73 } ;\n(\"cartesianproduct\") =\u003e { $ crate :: ATOM_LOCALNAME__63_61_72_74_65_73_69_61_6E_70_72_6F_64_75_63_74 } ;\n(\"feoffset\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_6F_66_66_73_65_74 } ;\n(\"spreadmethod\") =\u003e { $ crate :: ATOM_LOCALNAME__73_70_72_65_61_64_6D_65_74_68_6F_64 } ;\n(\"marker-end\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_72_6B_65_72_2D_65_6E_64 } ;\n(\"lighting-color\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_69_67_68_74_69_6E_67_2D_63_6F_6C_6F_72 } ;\n(\"textpath\") =\u003e { $ crate :: ATOM_LOCALNAME__74_65_78_74_70_61_74_68 } ;\n(\"ondragdrop\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_64_72_61_67_64_72_6F_70 } ;\n(\"autoplay\") =\u003e { $ crate :: ATOM_LOCALNAME__61_75_74_6F_70_6C_61_79 } ;\n(\"controllerchange\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6E_74_72_6F_6C_6C_65_72_63_68_61_6E_67_65 } ;\n(\"primitiveUnits\") =\u003e { $ crate :: ATOM_LOCALNAME__70_72_69_6D_69_74_69_76_65_55_6E_69_74_73 } ;\n(\"ondragenter\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_64_72_61_67_65_6E_74_65_72 } ;\n(\"dominant-baseline\") =\u003e { $ crate :: ATOM_LOCALNAME__64_6F_6D_69_6E_61_6E_74_2D_62_61_73_65_6C_69_6E_65 } ;\n(\"language\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_61_6E_67_75_61_67_65 } ;\n(\"xml:lang\") =\u003e { $ crate :: ATOM_LOCALNAME__78_6D_6C_3A_6C_61_6E_67 } ;\n(\"autocomplete\") =\u003e { $ crate :: ATOM_LOCALNAME__61_75_74_6F_63_6F_6D_70_6C_65_74_65 } ;\n(\"edgemode\") =\u003e { $ crate :: ATOM_LOCALNAME__65_64_67_65_6D_6F_64_65 } ;\n(\"repeatCount\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_70_65_61_74_43_6F_75_6E_74 } ;\n(\"surfacescale\") =\u003e { $ crate :: ATOM_LOCALNAME__73_75_72_66_61_63_65_73_63_61_6C_65 } ;\n(\"lengthAdjust\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_65_6E_67_74_68_41_64_6A_75_73_74 } ;\n(\"aria-colindex\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_63_6F_6C_69_6E_64_65_78 } ;\n(\"stop-opacity\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_6F_70_2D_6F_70_61_63_69_74_79 } ;\n(\"frameborder\") =\u003e { $ crate :: ATOM_LOCALNAME__66_72_61_6D_65_62_6F_72_64_65_72 } ;\n(\"textlength\") =\u003e { $ crate :: ATOM_LOCALNAME__74_65_78_74_6C_65_6E_67_74_68 } ;\n(\"alignment-baseline\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6C_69_67_6E_6D_65_6E_74_2D_62_61_73_65_6C_69_6E_65 } ;\n(\"additive\") =\u003e { $ crate :: ATOM_LOCALNAME__61_64_64_69_74_69_76_65 } ;\n(\"preserveAspectRatio\") =\u003e { $ crate :: ATOM_LOCALNAME__70_72_65_73_65_72_76_65_41_73_70_65_63_74_52_61_74_69_6F } ;\n(\"accesskey\") =\u003e { $ crate :: ATOM_LOCALNAME__61_63_63_65_73_73_6B_65_79 } ;\n(\"stitchTiles\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_69_74_63_68_54_69_6C_65_73 } ;\n(\"feSpotLight\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_53_70_6F_74_4C_69_67_68_74 } ;\n(\"transpose\") =\u003e { $ crate :: ATOM_LOCALNAME__74_72_61_6E_73_70_6F_73_65 } ;\n(\"horiz-adv-x\") =\u003e { $ crate :: ATOM_LOCALNAME__68_6F_72_69_7A_2D_61_64_76_2D_78 } ;\n(\"textPath\") =\u003e { $ crate :: ATOM_LOCALNAME__74_65_78_74_50_61_74_68 } ;\n(\"overline-thickness\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_76_65_72_6C_69_6E_65_2D_74_68_69_63_6B_6E_65_73_73 } ;\n(\"flood-opacity\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6C_6F_6F_64_2D_6F_70_61_63_69_74_79 } ;\n(\"bevelled\") =\u003e { $ crate :: ATOM_LOCALNAME__62_65_76_65_6C_6C_65_64 } ;\n(\"notanumber\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_6F_74_61_6E_75_6D_62_65_72 } ;\n(\"onstorage\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_73_74_6F_72_61_67_65 } ;\n(\"patterncontentunits\") =\u003e { $ crate :: ATOM_LOCALNAME__70_61_74_74_65_72_6E_63_6F_6E_74_65_6E_74_75_6E_69_74_73 } ;\n(\"markerHeight\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_72_6B_65_72_48_65_69_67_68_74 } ;\n(\"aria-colcount\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_63_6F_6C_63_6F_75_6E_74 } ;\n(\"spreadMethod\") =\u003e { $ crate :: ATOM_LOCALNAME__73_70_72_65_61_64_4D_65_74_68_6F_64 } ;\n(\"feColorMatrix\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_43_6F_6C_6F_72_4D_61_74_72_69_78 } ;\n(\"aria-atomic\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_61_74_6F_6D_69_63 } ;\n(\"fecomposite\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_63_6F_6D_70_6F_73_69_74_65 } ;\n(\"xlink:actuate\") =\u003e { $ crate :: ATOM_LOCALNAME__78_6C_69_6E_6B_3A_61_63_74_75_61_74_65 } ;\n(\"itemscope\") =\u003e { $ crate :: ATOM_LOCALNAME__69_74_65_6D_73_63_6F_70_65 } ;\n(\"onpageshow\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_70_61_67_65_73_68_6F_77 } ;\n(\"onbeforeunload\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_75_6E_6C_6F_61_64 } ;\n(\"pointsatx\") =\u003e { $ crate :: ATOM_LOCALNAME__70_6F_69_6E_74_73_61_74_78 } ;\n(\"longdesc\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_6F_6E_67_64_65_73_63 } ;\n(\"aria-disabled\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_64_69_73_61_62_6C_65_64 } ;\n(\"exponent\") =\u003e { $ crate :: ATOM_LOCALNAME__65_78_70_6F_6E_65_6E_74 } ;\n(\"rationals\") =\u003e { $ crate :: ATOM_LOCALNAME__72_61_74_69_6F_6E_61_6C_73 } ;\n(\"foreignObject\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_72_65_69_67_6E_4F_62_6A_65_63_74 } ;\n(\"altGlyphItem\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6C_74_47_6C_79_70_68_49_74_65_6D } ;\n(\"markerWidth\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_72_6B_65_72_57_69_64_74_68 } ;\n(\"selection\") =\u003e { $ crate :: ATOM_LOCALNAME__73_65_6C_65_63_74_69_6F_6E } ;\n(\"aria-hidden\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_68_69_64_64_65_6E } ;\n(\"figcaption\") =\u003e { $ crate :: ATOM_LOCALNAME__66_69_67_63_61_70_74_69_6F_6E } ;\n(\"datatemplate\") =\u003e { $ crate :: ATOM_LOCALNAME__64_61_74_61_74_65_6D_70_6C_61_74_65 } ;\n(\"onmousedown\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_64_6F_77_6E } ;\n(\"maligngroup\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_6C_69_67_6E_67_72_6F_75_70 } ;\n(\"colgroup\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6C_67_72_6F_75_70 } ;\n(\"determinant\") =\u003e { $ crate :: ATOM_LOCALNAME__64_65_74_65_72_6D_69_6E_61_6E_74 } ;\n(\"attributeType\") =\u003e { $ crate :: ATOM_LOCALNAME__61_74_74_72_69_62_75_74_65_54_79_70_65 } ;\n(\"marker-mid\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_72_6B_65_72_2D_6D_69_64 } ;\n(\"shadowrootserializable\") =\u003e { $ crate :: ATOM_LOCALNAME__73_68_61_64_6F_77_72_6F_6F_74_73_65_72_69_61_6C_69_7A_61_62_6C_65 } ;\n(\"property\") =\u003e { $ crate :: ATOM_LOCALNAME__70_72_6F_70_65_72_74_79 } ;\n(\"onbeforeeditfocus\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_65_64_69_74_66_6F_63_75_73 } ;\n(\"glyphRef\") =\u003e { $ crate :: ATOM_LOCALNAME__67_6C_79_70_68_52_65_66 } ;\n(\"aria-roledescription\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_72_6F_6C_65_64_65_73_63_72_69_70_74_69_6F_6E } ;\n(\"aria-relevant\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_72_65_6C_65_76_61_6E_74 } ;\n(\"femergenode\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_6D_65_72_67_65_6E_6F_64_65 } ;\n(\"filterunits\") =\u003e { $ crate :: ATOM_LOCALNAME__66_69_6C_74_65_72_75_6E_69_74_73 } ;\n(\"feDropShadow\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_44_72_6F_70_53_68_61_64_6F_77 } ;\n(\"novalidate\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_6F_76_61_6C_69_64_61_74_65 } ;\n(\"thickmathspace\") =\u003e { $ crate :: ATOM_LOCALNAME__74_68_69_63_6B_6D_61_74_68_73_70_61_63_65 } ;\n(\"feOffset\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_4F_66_66_73_65_74 } ;\n(\"verythickmathspace\") =\u003e { $ crate :: ATOM_LOCALNAME__76_65_72_79_74_68_69_63_6B_6D_61_74_68_73_70_61_63_65 } ;\n(\"clip-path\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6C_69_70_2D_70_61_74_68 } ;\n(\"marginwidth\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_72_67_69_6E_77_69_64_74_68 } ;\n(\"text-decoration\") =\u003e { $ crate :: ATOM_LOCALNAME__74_65_78_74_2D_64_65_63_6F_72_61_74_69_6F_6E } ;\n(\"definitionURL\") =\u003e { $ crate :: ATOM_LOCALNAME__64_65_66_69_6E_69_74_69_6F_6E_55_52_4C } ;\n(\"download\") =\u003e { $ crate :: ATOM_LOCALNAME__64_6F_77_6E_6C_6F_61_64 } ;\n(\"mediummathspace\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_65_64_69_75_6D_6D_61_74_68_73_70_61_63_65 } ;\n(\"aria-labelledby\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_6C_61_62_65_6C_6C_65_64_62_79 } ;\n(\"pointsatz\") =\u003e { $ crate :: ATOM_LOCALNAME__70_6F_69_6E_74_73_61_74_7A } ;\n(\"semantics\") =\u003e { $ crate :: ATOM_LOCALNAME__73_65_6D_61_6E_74_69_63_73 } ;\n(\"autosubmit\") =\u003e { $ crate :: ATOM_LOCALNAME__61_75_74_6F_73_75_62_6D_69_74 } ;\n(\"http-equiv\") =\u003e { $ crate :: ATOM_LOCALNAME__68_74_74_70_2D_65_71_75_69_76 } ;\n(\"emptyset\") =\u003e { $ crate :: ATOM_LOCALNAME__65_6D_70_74_79_73_65_74 } ;\n(\"aria-checked\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_63_68_65_63_6B_65_64 } ;\n(\"onactivate\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_61_63_74_69_76_61_74_65 } ;\n(\"variance\") =\u003e { $ crate :: ATOM_LOCALNAME__76_61_72_69_61_6E_63_65 } ;\n(\"fepointlight\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_70_6F_69_6E_74_6C_69_67_68_74 } ;\n(\"menclose\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_65_6E_63_6C_6F_73_65 } ;\n(\"gradientTransform\") =\u003e { $ crate :: ATOM_LOCALNAME__67_72_61_64_69_65_6E_74_54_72_61_6E_73_66_6F_72_6D } ;\n(\"shadowrootmode\") =\u003e { $ crate :: ATOM_LOCALNAME__73_68_61_64_6F_77_72_6F_6F_74_6D_6F_64_65 } ;\n(\"font-stretch\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_73_74_72_65_74_63_68 } ;\n(\"alignmentscope\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6C_69_67_6E_6D_65_6E_74_73_63_6F_70_65 } ;\n(\"ondragleave\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_64_72_61_67_6C_65_61_76_65 } ;\n(\"onresize\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_72_65_73_69_7A_65 } ;\n(\"referrerpolicy\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_66_65_72_72_65_72_70_6F_6C_69_63_79 } ;\n(\"stroke-miterlimit\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_6D_69_74_65_72_6C_69_6D_69_74 } ;\n(\"linearGradient\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_69_6E_65_61_72_47_72_61_64_69_65_6E_74 } ;\n(\"strikethrough-thickness\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_72_69_6B_65_74_68_72_6F_75_67_68_2D_74_68_69_63_6B_6E_65_73_73 } ;\n(\"color-profile\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6C_6F_72_2D_70_72_6F_66_69_6C_65 } ;\n(\"onlanguagechange\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_6C_61_6E_67_75_61_67_65_63_68_61_6E_67_65 } ;\n(\"xlink:arcrole\") =\u003e { $ crate :: ATOM_LOCALNAME__78_6C_69_6E_6B_3A_61_72_63_72_6F_6C_65 } ;\n(\"visibility\") =\u003e { $ crate :: ATOM_LOCALNAME__76_69_73_69_62_69_6C_69_74_79 } ;\n(\"itemtype\") =\u003e { $ crate :: ATOM_LOCALNAME__69_74_65_6D_74_79_70_65 } ;\n(\"onselectstart\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_73_65_6C_65_63_74_73_74_61_72_74 } ;\n(\"scrolldelay\") =\u003e { $ crate :: ATOM_LOCALNAME__73_63_72_6F_6C_6C_64_65_6C_61_79 } ;\n(\"noframes\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_6F_66_72_61_6D_65_73 } ;\n(\"mathsize\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_74_68_73_69_7A_65 } ;\n(\"onafterprint\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_61_66_74_65_72_70_72_69_6E_74 } ;\n(\"aria-flowto\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_66_6C_6F_77_74_6F } ;\n(\"vert-origin-y\") =\u003e { $ crate :: ATOM_LOCALNAME__76_65_72_74_2D_6F_72_69_67_69_6E_2D_79 } ;\n(\"onunload\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_75_6E_6C_6F_61_64 } ;\n(\"marginheight\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_72_67_69_6E_68_65_69_67_68_74 } ;\n(\"onbounce\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_62_6F_75_6E_63_65 } ;\n(\"startoffset\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_61_72_74_6F_66_66_73_65_74 } ;\n(\"metadata\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_65_74_61_64_61_74_61 } ;\n(\"aria-multiline\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_6D_75_6C_74_69_6C_69_6E_65 } ;\n(\"word-spacing\") =\u003e { $ crate :: ATOM_LOCALNAME__77_6F_72_64_2D_73_70_61_63_69_6E_67 } ;\n(\"oncontrolselect\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_63_6F_6E_74_72_6F_6C_73_65_6C_65_63_74 } ;\n(\"blockquote\") =\u003e { $ crate :: ATOM_LOCALNAME__62_6C_6F_63_6B_71_75_6F_74_65 } ;\n(\"font-size-adjust\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_73_69_7A_65_2D_61_64_6A_75_73_74 } ;\n(\"interval\") =\u003e { $ crate :: ATOM_LOCALNAME__69_6E_74_65_72_76_61_6C } ;\n(\"seamless\") =\u003e { $ crate :: ATOM_LOCALNAME__73_65_61_6D_6C_65_73_73 } ;\n(\"xlink:type\") =\u003e { $ crate :: ATOM_LOCALNAME__78_6C_69_6E_6B_3A_74_79_70_65 } ;\n(\"fill-rule\") =\u003e { $ crate :: ATOM_LOCALNAME__66_69_6C_6C_2D_72_75_6C_65 } ;\n(\"aria-colindextext\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_63_6F_6C_69_6E_64_65_78_74_65_78_74 } ;\n(\"partialdiff\") =\u003e { $ crate :: ATOM_LOCALNAME__70_61_72_74_69_61_6C_64_69_66_66 } ;\n(\"scriptsizemultiplier\") =\u003e { $ crate :: ATOM_LOCALNAME__73_63_72_69_70_74_73_69_7A_65_6D_75_6C_74_69_70_6C_69_65_72 } ;\n(\"matrixrow\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_74_72_69_78_72_6F_77 } ;\n(\"equalrows\") =\u003e { $ crate :: ATOM_LOCALNAME__65_71_75_61_6C_72_6F_77_73 } ;\n(\"onmessage\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_6D_65_73_73_61_67_65 } ;\n(\"numOctaves\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_75_6D_4F_63_74_61_76_65_73 } ;\n(\"\") =\u003e { $ crate :: ATOM_LOCALNAME_ } ;\n(\"fontstyle\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_73_74_79_6C_65 } ;\n(\"listener\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_69_73_74_65_6E_65_72 } ;\n(\"onbeforepaste\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_70_61_73_74_65 } ;\n(\"linebreak\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_69_6E_65_62_72_65_61_6B } ;\n(\"transform\") =\u003e { $ crate :: ATOM_LOCALNAME__74_72_61_6E_73_66_6F_72_6D } ;\n(\"zoomandpan\") =\u003e { $ crate :: ATOM_LOCALNAME__7A_6F_6F_6D_61_6E_64_70_61_6E } ;\n(\"aria-orientation\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_6F_72_69_65_6E_74_61_74_69_6F_6E } ;\n(\"aria-rowspan\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_72_6F_77_73_70_61_6E } ;\n(\"kernelMatrix\") =\u003e { $ crate :: ATOM_LOCALNAME__6B_65_72_6E_65_6C_4D_61_74_72_69_78 } ;\n(\"domainofapplication\") =\u003e { $ crate :: ATOM_LOCALNAME__64_6F_6D_61_69_6E_6F_66_61_70_70_6C_69_63_61_74_69_6F_6E } ;\n(\"noresize\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_6F_72_65_73_69_7A_65 } ;\n(\"pathLength\") =\u003e { $ crate :: ATOM_LOCALNAME__70_61_74_68_4C_65_6E_67_74_68 } ;\n(\"viewTarget\") =\u003e { $ crate :: ATOM_LOCALNAME__76_69_65_77_54_61_72_67_65_74 } ;\n(\"onfocusin\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_66_6F_63_75_73_69_6E } ;\n(\"diffuseConstant\") =\u003e { $ crate :: ATOM_LOCALNAME__64_69_66_66_75_73_65_43_6F_6E_73_74_61_6E_74 } ;\n(\"aria-channel\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_63_68_61_6E_6E_65_6C } ;\n(\"color-interpolation-filters\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6C_6F_72_2D_69_6E_74_65_72_70_6F_6C_61_74_69_6F_6E_2D_66_69_6C_74_65_72_73 } ;\n(\"repeatDur\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_70_65_61_74_44_75_72 } ;\n(\"divergence\") =\u003e { $ crate :: ATOM_LOCALNAME__64_69_76_65_72_67_65_6E_63_65 } ;\n(\"fedropshadow\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_64_72_6F_70_73_68_61_64_6F_77 } ;\n(\"formmethod\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_72_6D_6D_65_74_68_6F_64 } ;\n(\"alphabetic\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6C_70_68_61_62_65_74_69_63 } ;\n(\"onchange\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_63_68_61_6E_67_65 } ;\n(\"thinmathspace\") =\u003e { $ crate :: ATOM_LOCALNAME__74_68_69_6E_6D_61_74_68_73_70_61_63_65 } ;\n(\"feSpecularLighting\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_53_70_65_63_75_6C_61_72_4C_69_67_68_74_69_6E_67 } ;\n(\"fediffuselighting\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_64_69_66_66_75_73_65_6C_69_67_68_74_69_6E_67 } ;\n(\"onbeforeupdate\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_75_70_64_61_74_65 } ;\n(\"columnlines\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6C_75_6D_6E_6C_69_6E_65_73 } ;\n(\"ondataavailable\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_64_61_74_61_61_76_61_69_6C_61_62_6C_65 } ;\n(\"aria-valuemax\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_76_61_6C_75_65_6D_61_78 } ;\n(\"aria-setsize\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_73_65_74_73_69_7A_65 } ;\n(\"pointsaty\") =\u003e { $ crate :: ATOM_LOCALNAME__70_6F_69_6E_74_73_61_74_79 } ;\n(\"horiz-origin-x\") =\u003e { $ crate :: ATOM_LOCALNAME__68_6F_72_69_7A_2D_6F_72_69_67_69_6E_2D_78 } ;\n(\"aria-grab\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_67_72_61_62 } ;\n(\"diffuseconstant\") =\u003e { $ crate :: ATOM_LOCALNAME__64_69_66_66_75_73_65_63_6F_6E_73_74_61_6E_74 } ;\n(\"aria-posinset\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_70_6F_73_69_6E_73_65_74 } ;\n(\"aria-sort\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_73_6F_72_74 } ;\n(\"baseline-shift\") =\u003e { $ crate :: ATOM_LOCALNAME__62_61_73_65_6C_69_6E_65_2D_73_68_69_66_74 } ;\n(\"clippathunits\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6C_69_70_70_61_74_68_75_6E_69_74_73 } ;\n(\"aria-controls\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_63_6F_6E_74_72_6F_6C_73 } ;\n(\"image-rendering\") =\u003e { $ crate :: ATOM_LOCALNAME__69_6D_61_67_65_2D_72_65_6E_64_65_72_69_6E_67 } ;\n(\"ondragend\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_64_72_61_67_65_6E_64 } ;\n(\"xchannelselector\") =\u003e { $ crate :: ATOM_LOCALNAME__78_63_68_61_6E_6E_65_6C_73_65_6C_65_63_74_6F_72 } ;\n(\"altglyph\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6C_74_67_6C_79_70_68 } ;\n(\"preserveaspectratio\") =\u003e { $ crate :: ATOM_LOCALNAME__70_72_65_73_65_72_76_65_61_73_70_65_63_74_72_61_74_69_6F } ;\n(\"contentScriptType\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6E_74_65_6E_74_53_63_72_69_70_74_54_79_70_65 } ;\n(\"subscriptshift\") =\u003e { $ crate :: ATOM_LOCALNAME__73_75_62_73_63_72_69_70_74_73_68_69_66_74 } ;\n(\"onmouseleave\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_6C_65_61_76_65 } ;\n(\"attributename\") =\u003e { $ crate :: ATOM_LOCALNAME__61_74_74_72_69_62_75_74_65_6E_61_6D_65 } ;\n(\"fespecularlighting\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_73_70_65_63_75_6C_61_72_6C_69_67_68_74_69_6E_67 } ;\n(\"integers\") =\u003e { $ crate :: ATOM_LOCALNAME__69_6E_74_65_67_65_72_73 } ;\n(\"preservealpha\") =\u003e { $ crate :: ATOM_LOCALNAME__70_72_65_73_65_72_76_65_61_6C_70_68_61 } ;\n(\"horiz-origin-y\") =\u003e { $ crate :: ATOM_LOCALNAME__68_6F_72_69_7A_2D_6F_72_69_67_69_6E_2D_79 } ;\n(\"xlink:show\") =\u003e { $ crate :: ATOM_LOCALNAME__78_6C_69_6E_6B_3A_73_68_6F_77 } ;\n(\"filterRes\") =\u003e { $ crate :: ATOM_LOCALNAME__66_69_6C_74_65_72_52_65_73 } ;\n(\"onforminput\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_66_6F_72_6D_69_6E_70_75_74 } ;\n(\"font-face-format\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_63_65_2D_66_6F_72_6D_61_74 } ;\n(\"annotation\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6E_6E_6F_74_61_74_69_6F_6E } ;\n(\"onkeypress\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_6B_65_79_70_72_65_73_73 } ;\n(\"repeat-template\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_70_65_61_74_2D_74_65_6D_70_6C_61_74_65 } ;\n(\"font-face\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_63_65 } ;\n(\"ideographic\") =\u003e { $ crate :: ATOM_LOCALNAME__69_64_65_6F_67_72_61_70_68_69_63 } ;\n(\"statechange\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_61_74_65_63_68_61_6E_67_65 } ;\n(\"ondatasetcomplete\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_64_61_74_61_73_65_74_63_6F_6D_70_6C_65_74_65 } ;\n(\"equivalent\") =\u003e { $ crate :: ATOM_LOCALNAME__65_71_75_69_76_61_6C_65_6E_74 } ;\n(\"specularexponent\") =\u003e { $ crate :: ATOM_LOCALNAME__73_70_65_63_75_6C_61_72_65_78_70_6F_6E_65_6E_74 } ;\n(\"altGlyphDef\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6C_74_47_6C_79_70_68_44_65_66 } ;\n(\"accumulate\") =\u003e { $ crate :: ATOM_LOCALNAME__61_63_63_75_6D_75_6C_61_74_65 } ;\n(\"onmouseover\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_6F_76_65_72 } ;\n(\"basefrequency\") =\u003e { $ crate :: ATOM_LOCALNAME__62_61_73_65_66_72_65_71_75_65_6E_63_79 } ;\n(\"onmouseout\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_6F_75_74 } ;\n(\"mathcolor\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_74_68_63_6F_6C_6F_72 } ;\n(\"feTurbulence\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_54_75_72_62_75_6C_65_6E_63_65 } ;\n(\"aria-readonly\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_72_65_61_64_6F_6E_6C_79 } ;\n(\"stroke-dasharray\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_64_61_73_68_61_72_72_61_79 } ;\n(\"stroke-linejoin\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_6C_69_6E_65_6A_6F_69_6E } ;\n(\"feComposite\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_43_6F_6D_70_6F_73_69_74_65 } ;\n(\"altglyphdef\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6C_74_67_6C_79_70_68_64_65_66 } ;\n(\"stdDeviation\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_64_44_65_76_69_61_74_69_6F_6E } ;\n(\"feMorphology\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_4D_6F_72_70_68_6F_6C_6F_67_79 } ;\n(\"feDistantLight\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_44_69_73_74_61_6E_74_4C_69_67_68_74 } ;\n(\"fedistantlight\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_64_69_73_74_61_6E_74_6C_69_67_68_74 } ;\n(\"animatetransform\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6E_69_6D_61_74_65_74_72_61_6E_73_66_6F_72_6D } ;\n(\"groupalign\") =\u003e { $ crate :: ATOM_LOCALNAME__67_72_6F_75_70_61_6C_69_67_6E } ;\n(\"limitingConeAngle\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_69_6D_69_74_69_6E_67_43_6F_6E_65_41_6E_67_6C_65 } ;\n(\"elevation\") =\u003e { $ crate :: ATOM_LOCALNAME__65_6C_65_76_61_74_69_6F_6E } ;\n(\"systemLanguage\") =\u003e { $ crate :: ATOM_LOCALNAME__73_79_73_74_65_6D_4C_61_6E_67_75_61_67_65 } ;\n(\"irrelevant\") =\u003e { $ crate :: ATOM_LOCALNAME__69_72_72_65_6C_65_76_61_6E_74 } ;\n(\"requiredExtensions\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_71_75_69_72_65_64_45_78_74_65_6E_73_69_6F_6E_73 } ;\n(\"aria-autocomplete\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_61_75_74_6F_63_6F_6D_70_6C_65_74_65 } ;\n(\"color-rendering\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6C_6F_72_2D_72_65_6E_64_65_72_69_6E_67 } ;\n(\"background\") =\u003e { $ crate :: ATOM_LOCALNAME__62_61_63_6B_67_72_6F_75_6E_64 } ;\n(\"malignmark\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_6C_69_67_6E_6D_61_72_6B } ;\n(\"onmousewheel\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_77_68_65_65_6C } ;\n(\"animatecolor\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6E_69_6D_61_74_65_63_6F_6C_6F_72 } ;\n(\"aria-braillelabel\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_62_72_61_69_6C_6C_65_6C_61_62_65_6C } ;\n(\"aria-details\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_64_65_74_61_69_6C_73 } ;\n(\"glyph-name\") =\u003e { $ crate :: ATOM_LOCALNAME__67_6C_79_70_68_2D_6E_61_6D_65 } ;\n(\"missing-glyph\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_69_73_73_69_6E_67_2D_67_6C_79_70_68 } ;\n(\"aria-busy\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_62_75_73_79 } ;\n(\"x-height\") =\u003e { $ crate :: ATOM_LOCALNAME__78_2D_68_65_69_67_68_74 } ;\n(\"fontweight\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_77_65_69_67_68_74 } ;\n(\"multicol\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_75_6C_74_69_63_6F_6C } ;\n(\"onlosecapture\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_6C_6F_73_65_63_61_70_74_75_72_65 } ;\n(\"font-face-uri\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_63_65_2D_75_72_69 } ;\n(\"zoomAndPan\") =\u003e { $ crate :: ATOM_LOCALNAME__7A_6F_6F_6D_41_6E_64_50_61_6E } ;\n(\"optgroup\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_70_74_67_72_6F_75_70 } ;\n(\"xml:space\") =\u003e { $ crate :: ATOM_LOCALNAME__78_6D_6C_3A_73_70_61_63_65 } ;\n(\"specification\") =\u003e { $ crate :: ATOM_LOCALNAME__73_70_65_63_69_66_69_63_61_74_69_6F_6E } ;\n(\"laplacian\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_61_70_6C_61_63_69_61_6E } ;\n(\"scrolling\") =\u003e { $ crate :: ATOM_LOCALNAME__73_63_72_6F_6C_6C_69_6E_67 } ;\n(\"movablelimits\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_6F_76_61_62_6C_65_6C_69_6D_69_74_73 } ;\n(\"mprescripts\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_70_72_65_73_63_72_69_70_74_73 } ;\n(\"onformchange\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_66_6F_72_6D_63_68_61_6E_67_65 } ;\n(\"v-mathematical\") =\u003e { $ crate :: ATOM_LOCALNAME__76_2D_6D_61_74_68_65_6D_61_74_69_63_61_6C } ;\n(\"maskContentUnits\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_73_6B_43_6F_6E_74_65_6E_74_55_6E_69_74_73 } ;\n(\"separator\") =\u003e { $ crate :: ATOM_LOCALNAME__73_65_70_61_72_61_74_6F_72 } ;\n(\"nomodule\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_6F_6D_6F_64_75_6C_65 } ;\n(\"aria-colspan\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_63_6F_6C_73_70_61_6E } ;\n(\"operator\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_70_65_72_61_74_6F_72 } ;\n(\"onsubmit\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_73_75_62_6D_69_74 } ;\n(\"aria-description\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_64_65_73_63_72_69_70_74_69_6F_6E } ;\n(\"repeat-max\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_70_65_61_74_2D_6D_61_78 } ;\n(\"startOffset\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_61_72_74_4F_66_66_73_65_74 } ;\n(\"radialgradient\") =\u003e { $ crate :: ATOM_LOCALNAME__72_61_64_69_61_6C_67_72_61_64_69_65_6E_74 } ;\n(\"symmetric\") =\u003e { $ crate :: ATOM_LOCALNAME__73_79_6D_6D_65_74_72_69_63 } ;\n(\"codetype\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_64_65_74_79_70_65 } ;\n(\"altGlyph\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6C_74_47_6C_79_70_68 } ;\n(\"cellspacing\") =\u003e { $ crate :: ATOM_LOCALNAME__63_65_6C_6C_73_70_61_63_69_6E_67 } ;\n(\"patternContentUnits\") =\u003e { $ crate :: ATOM_LOCALNAME__70_61_74_74_65_72_6E_43_6F_6E_74_65_6E_74_55_6E_69_74_73 } ;\n(\"fontfamily\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_66_61_6D_69_6C_79 } ;\n(\"rowlines\") =\u003e { $ crate :: ATOM_LOCALNAME__72_6F_77_6C_69_6E_65_73 } ;\n(\"datetime\") =\u003e { $ crate :: ATOM_LOCALNAME__64_61_74_65_74_69_6D_65 } ;\n(\"draggable\") =\u003e { $ crate :: ATOM_LOCALNAME__64_72_61_67_67_61_62_6C_65 } ;\n(\"onrepeat\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_72_65_70_65_61_74 } ;\n(\"pathlength\") =\u003e { $ crate :: ATOM_LOCALNAME__70_61_74_68_6C_65_6E_67_74_68 } ;\n(\"noscript\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_6F_73_63_72_69_70_74 } ;\n(\"v-ideographic\") =\u003e { $ crate :: ATOM_LOCALNAME__76_2D_69_64_65_6F_67_72_61_70_68_69_63 } ;\n(\"onfocusout\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_66_6F_63_75_73_6F_75_74 } ;\n(\"v-alphabetic\") =\u003e { $ crate :: ATOM_LOCALNAME__76_2D_61_6C_70_68_61_62_65_74_69_63 } ;\n(\"repeatdur\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_70_65_61_74_64_75_72 } ;\n(\"glyphref\") =\u003e { $ crate :: ATOM_LOCALNAME__67_6C_79_70_68_72_65_66 } ;\n(\"stroke-dashoffset\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_64_61_73_68_6F_66_66_73_65_74 } ;\n(\"animation\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6E_69_6D_61_74_69_6F_6E } ;\n(\"keyTimes\") =\u003e { $ crate :: ATOM_LOCALNAME__6B_65_79_54_69_6D_65_73 } ;\n(\"notsubset\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_6F_74_73_75_62_73_65_74 } ;\n(\"factorof\") =\u003e { $ crate :: ATOM_LOCALNAME__66_61_63_74_6F_72_6F_66 } ;\n(\"externalresourcesrequired\") =\u003e { $ crate :: ATOM_LOCALNAME__65_78_74_65_72_6E_61_6C_72_65_73_6F_75_72_63_65_73_72_65_71_75_69_72_65_64 } ;\n(\"aria-secret\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_73_65_63_72_65_74 } ;\n(\"factorial\") =\u003e { $ crate :: ATOM_LOCALNAME__66_61_63_74_6F_72_69_61_6C } ;\n(\"eulergamma\") =\u003e { $ crate :: ATOM_LOCALNAME__65_75_6C_65_72_67_61_6D_6D_61 } ;\n(\"separators\") =\u003e { $ crate :: ATOM_LOCALNAME__73_65_70_61_72_61_74_6F_72_73 } ;\n(\"repeat-start\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_70_65_61_74_2D_73_74_61_72_74 } ;\n(\"aria-expanded\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_65_78_70_61_6E_64_65_64 } ;\n(\"pointsAtX\") =\u003e { $ crate :: ATOM_LOCALNAME__70_6F_69_6E_74_73_41_74_58 } ;\n(\"vectorproduct\") =\u003e { $ crate :: ATOM_LOCALNAME__76_65_63_74_6F_72_70_72_6F_64_75_63_74 } ;\n(\"enable-background\") =\u003e { $ crate :: ATOM_LOCALNAME__65_6E_61_62_6C_65_2D_62_61_63_6B_67_72_6F_75_6E_64 } ;\n(\"framespacing\") =\u003e { $ crate :: ATOM_LOCALNAME__66_72_61_6D_65_73_70_61_63_69_6E_67 } ;\n(\"contentscripttype\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6E_74_65_6E_74_73_63_72_69_70_74_74_79_70_65 } ;\n(\"basefont\") =\u003e { $ crate :: ATOM_LOCALNAME__62_61_73_65_66_6F_6E_74 } ;\n(\"unicode-range\") =\u003e { $ crate :: ATOM_LOCALNAME__75_6E_69_63_6F_64_65_2D_72_61_6E_67_65 } ;\n(\"foreignobject\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_72_65_69_67_6E_6F_62_6A_65_63_74 } ;\n(\"polyline\") =\u003e { $ crate :: ATOM_LOCALNAME__70_6F_6C_79_6C_69_6E_65 } ;\n(\"patternunits\") =\u003e { $ crate :: ATOM_LOCALNAME__70_61_74_74_65_72_6E_75_6E_69_74_73 } ;\n(\"specularExponent\") =\u003e { $ crate :: ATOM_LOCALNAME__73_70_65_63_75_6C_61_72_45_78_70_6F_6E_65_6E_74 } ;\n(\"radiogroup\") =\u003e { $ crate :: ATOM_LOCALNAME__72_61_64_69_6F_67_72_6F_75_70 } ;\n(\"codomain\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_64_6F_6D_61_69_6E } ;\n(\"ononline\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_6F_6E_6C_69_6E_65 } ;\n(\"requiredFeatures\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_71_75_69_72_65_64_46_65_61_74_75_72_65_73 } ;\n(\"font-variant\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_76_61_72_69_61_6E_74 } ;\n(\"aria-level\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_6C_65_76_65_6C } ;\n(\"columnalign\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6C_75_6D_6E_61_6C_69_67_6E } ;\n(\"notation\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_6F_74_61_74_69_6F_6E } ;\n(\"onrowenter\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_72_6F_77_65_6E_74_65_72 } ;\n(\"feMergeNode\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_4D_65_72_67_65_4E_6F_64_65 } ;\n(\"glyph-orientation-horizontal\") =\u003e { $ crate :: ATOM_LOCALNAME__67_6C_79_70_68_2D_6F_72_69_65_6E_74_61_74_69_6F_6E_2D_68_6F_72_69_7A_6F_6E_74_61_6C } ;\n(\"patterntransform\") =\u003e { $ crate :: ATOM_LOCALNAME__70_61_74_74_65_72_6E_74_72_61_6E_73_66_6F_72_6D } ;\n(\"patternUnits\") =\u003e { $ crate :: ATOM_LOCALNAME__70_61_74_74_65_72_6E_55_6E_69_74_73 } ;\n(\"onmoveend\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_76_65_65_6E_64 } ;\n(\"prefetch\") =\u003e { $ crate :: ATOM_LOCALNAME__70_72_65_66_65_74_63_68 } ;\n(\"lineargradient\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_69_6E_65_61_72_67_72_61_64_69_65_6E_74 } ;\n(\"controls\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6E_74_72_6F_6C_73 } ;\n(\"autofocus\") =\u003e { $ crate :: ATOM_LOCALNAME__61_75_74_6F_66_6F_63_75_73 } ;\n(\"contenteditable\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6E_74_65_6E_74_65_64_69_74_61_62_6C_65 } ;\n(\"hidefocus\") =\u003e { $ crate :: ATOM_LOCALNAME__68_69_64_65_66_6F_63_75_73 } ;\n(\"numoctaves\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_75_6D_6F_63_74_61_76_65_73 } ;\n(\"aria-activedescendant\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_61_63_74_69_76_65_64_65_73_63_65_6E_64_61_6E_74 } ;\n(\"filterres\") =\u003e { $ crate :: ATOM_LOCALNAME__66_69_6C_74_65_72_72_65_73 } ;\n(\"aria-placeholder\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_70_6C_61_63_65_68_6F_6C_64_65_72 } ;\n(\"momentabout\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_6F_6D_65_6E_74_61_62_6F_75_74 } ;\n(\"font-face-src\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_63_65_2D_73_72_63 } ;\n(\"mathematical\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_74_68_65_6D_61_74_69_63_61_6C } ;\n(\"clipPathUnits\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6C_69_70_50_61_74_68_55_6E_69_74_73 } ;\n(\"accept-charset\") =\u003e { $ crate :: ATOM_LOCALNAME__61_63_63_65_70_74_2D_63_68_61_72_73_65_74 } ;\n(\"condition\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6E_64_69_74_69_6F_6E } ;\n(\"formaction\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_72_6D_61_63_74_69_6F_6E } ;\n(\"surfaceScale\") =\u003e { $ crate :: ATOM_LOCALNAME__73_75_72_66_61_63_65_53_63_61_6C_65 } ;\n(\"oninvalid\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_69_6E_76_61_6C_69_64 } ;\n(\"plaintext\") =\u003e { $ crate :: ATOM_LOCALNAME__70_6C_61_69_6E_74_65_78_74 } ;\n(\"baseprofile\") =\u003e { $ crate :: ATOM_LOCALNAME__62_61_73_65_70_72_6F_66_69_6C_65 } ;\n(\"onpropertychange\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_70_72_6F_70_65_72_74_79_63_68_61_6E_67_65 } ;\n(\"feComponentTransfer\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_43_6F_6D_70_6F_6E_65_6E_74_54_72_61_6E_73_66_65_72 } ;\n(\"imaginary\") =\u003e { $ crate :: ATOM_LOCALNAME__69_6D_61_67_69_6E_61_72_79 } ;\n(\"onscroll\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_73_63_72_6F_6C_6C } ;\n(\"cellpadding\") =\u003e { $ crate :: ATOM_LOCALNAME__63_65_6C_6C_70_61_64_64_69_6E_67 } ;\n(\"overline-position\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_76_65_72_6C_69_6E_65_2D_70_6F_73_69_74_69_6F_6E } ;\n(\"disabled\") =\u003e { $ crate :: ATOM_LOCALNAME__64_69_73_61_62_6C_65_64 } ;\n(\"intercept\") =\u003e { $ crate :: ATOM_LOCALNAME__69_6E_74_65_72_63_65_70_74 } ;\n(\"kernelunitlength\") =\u003e { $ crate :: ATOM_LOCALNAME__6B_65_72_6E_65_6C_75_6E_69_74_6C_65_6E_67_74_68 } ;\n(\"aria-valuetext\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_76_61_6C_75_65_74_65_78_74 } ;\n(\"rendering-intent\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_6E_64_65_72_69_6E_67_2D_69_6E_74_65_6E_74 } ;\n(\"preserveAlpha\") =\u003e { $ crate :: ATOM_LOCALNAME__70_72_65_73_65_72_76_65_41_6C_70_68_61 } ;\n(\"aria-rowindextext\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_72_6F_77_69_6E_64_65_78_74_65_78_74 } ;\n(\"aria-templateid\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_74_65_6D_70_6C_61_74_65_69_64 } ;\n(\"selector\") =\u003e { $ crate :: ATOM_LOCALNAME__73_65_6C_65_63_74_6F_72 } ;\n(\"vert-origin-x\") =\u003e { $ crate :: ATOM_LOCALNAME__76_65_72_74_2D_6F_72_69_67_69_6E_2D_78 } ;\n(\"contentstyletype\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6E_74_65_6E_74_73_74_79_6C_65_74_79_70_65 } ;\n(\"encoding\") =\u003e { $ crate :: ATOM_LOCALNAME__65_6E_63_6F_64_69_6E_67 } ;\n(\"markerwidth\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_72_6B_65_72_77_69_64_74_68 } ;\n(\"attributeName\") =\u003e { $ crate :: ATOM_LOCALNAME__61_74_74_72_69_62_75_74_65_4E_61_6D_65 } ;\n(\"lengthadjust\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_65_6E_67_74_68_61_64_6A_75_73_74 } ;\n(\"kernelUnitLength\") =\u003e { $ crate :: ATOM_LOCALNAME__6B_65_72_6E_65_6C_55_6E_69_74_4C_65_6E_67_74_68 } ;\n(\"font-size\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_73_69_7A_65 } ;\n(\"actiontype\") =\u003e { $ crate :: ATOM_LOCALNAME__61_63_74_69_6F_6E_74_79_70_65 } ;\n(\"onfilterchange\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_66_69_6C_74_65_72_63_68_61_6E_67_65 } ;\n(\"aria-live\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_6C_69_76_65 } ;\n(\"units-per-em\") =\u003e { $ crate :: ATOM_LOCALNAME__75_6E_69_74_73_2D_70_65_72_2D_65_6D } ;\n(\"viewtarget\") =\u003e { $ crate :: ATOM_LOCALNAME__76_69_65_77_74_61_72_67_65_74 } ;\n(\"onmousemove\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_6D_6F_76_65 } ;\n(\"maskunits\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_73_6B_75_6E_69_74_73 } ;\n(\"mmultiscripts\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_6D_75_6C_74_69_73_63_72_69_70_74_73 } ;\n(\"attributetype\") =\u003e { $ crate :: ATOM_LOCALNAME__61_74_74_72_69_62_75_74_65_74_79_70_65 } ;\n(\"ondragover\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_64_72_61_67_6F_76_65_72 } ;\n(\"outerproduct\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_75_74_65_72_70_72_6F_64_75_63_74 } ;\n(\"aria-dropeffect\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_64_72_6F_70_65_66_66_65_63_74 } ;\n(\"animateColor\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6E_69_6D_61_74_65_43_6F_6C_6F_72 } ;\n(\"aria-keyshortcuts\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_6B_65_79_73_68_6F_72_74_63_75_74_73 } ;\n(\"clipPath\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6C_69_70_50_61_74_68 } ;\n(\"gradienttransform\") =\u003e { $ crate :: ATOM_LOCALNAME__67_72_61_64_69_65_6E_74_74_72_61_6E_73_66_6F_72_6D } ;\n(\"onbeforeprint\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_70_72_69_6E_74 } ;\n(\"letter-spacing\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_65_74_74_65_72_2D_73_70_61_63_69_6E_67 } ;\n(\"calcMode\") =\u003e { $ crate :: ATOM_LOCALNAME__63_61_6C_63_4D_6F_64_65 } ;\n(\"scalarproduct\") =\u003e { $ crate :: ATOM_LOCALNAME__73_63_61_6C_61_72_70_72_6F_64_75_63_74 } ;\n(\"v-hanging\") =\u003e { $ crate :: ATOM_LOCALNAME__76_2D_68_61_6E_67_69_6E_67 } ;\n(\"panose-1\") =\u003e { $ crate :: ATOM_LOCALNAME__70_61_6E_6F_73_65_2D_31 } ;\n(\"font-weight\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_77_65_69_67_68_74 } ;\n(\"aria-selected\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_73_65_6C_65_63_74_65_64 } ;\n(\"aria-haspopup\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_68_61_73_70_6F_70_75_70 } ;\n(\"onbeforecut\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_63_75_74 } ;\n(\"onselect\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_73_65_6C_65_63_74 } ;\n(\"keysplines\") =\u003e { $ crate :: ATOM_LOCALNAME__6B_65_79_73_70_6C_69_6E_65_73 } ;\n(\"keytimes\") =\u003e { $ crate :: ATOM_LOCALNAME__6B_65_79_74_69_6D_65_73 } ;\n(\"onrowexit\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_72_6F_77_65_78_69_74 } ;\n(\"repeat-min\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_70_65_61_74_2D_6D_69_6E } ;\n(\"aria-pressed\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_70_72_65_73_73_65_64 } ;\n(\"glyph-orientation-vertical\") =\u003e { $ crate :: ATOM_LOCALNAME__67_6C_79_70_68_2D_6F_72_69_65_6E_74_61_74_69_6F_6E_2D_76_65_72_74_69_63_61_6C } ;\n(\"minlength\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_69_6E_6C_65_6E_67_74_68 } ;\n(\"contextmenu\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6E_74_65_78_74_6D_65_6E_75 } ;\n(\"onerrorupdate\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_65_72_72_6F_72_75_70_64_61_74_65 } ;\n(\"aria-label\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_6C_61_62_65_6C } ;\n(\"fieldset\") =\u003e { $ crate :: ATOM_LOCALNAME__66_69_65_6C_64_73_65_74 } ;\n(\"columnspacing\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6C_75_6D_6E_73_70_61_63_69_6E_67 } ;\n(\"allowfullscreen\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6C_6C_6F_77_66_75_6C_6C_73_63_72_65_65_6E } ;\n(\"accentunder\") =\u003e { $ crate :: ATOM_LOCALNAME__61_63_63_65_6E_74_75_6E_64_65_72 } ;\n(\"yChannelSelector\") =\u003e { $ crate :: ATOM_LOCALNAME__79_43_68_61_6E_6E_65_6C_53_65_6C_65_63_74_6F_72 } ;\n(\"ondblclick\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_64_62_6C_63_6C_69_63_6B } ;\n(\"unicode-bidi\") =\u003e { $ crate :: ATOM_LOCALNAME__75_6E_69_63_6F_64_65_2D_62_69_64_69 } ;\n(\"feGaussianBlur\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_47_61_75_73_73_69_61_6E_42_6C_75_72 } ;\n(\"onkeydown\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_6B_65_79_64_6F_77_6E } ;\n(\"radialGradient\") =\u003e { $ crate :: ATOM_LOCALNAME__72_61_64_69_61_6C_47_72_61_64_69_65_6E_74 } ;\n(\"veryverythickmathspace\") =\u003e { $ crate :: ATOM_LOCALNAME__76_65_72_79_76_65_72_79_74_68_69_63_6B_6D_61_74_68_73_70_61_63_65 } ;\n(\"font-family\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_6D_69_6C_79 } ;\n(\"menuitem\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_65_6E_75_69_74_65_6D } ;\n(\"orientation\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_72_69_65_6E_74_61_74_69_6F_6E } ;\n(\"aria-rowindex\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_72_6F_77_69_6E_64_65_78 } ;\n(\"readonly\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_61_64_6F_6E_6C_79 } ;\n(\"quotient\") =\u003e { $ crate :: ATOM_LOCALNAME__71_75_6F_74_69_65_6E_74 } ;\n(\"externalResourcesRequired\") =\u003e { $ crate :: ATOM_LOCALNAME__65_78_74_65_72_6E_61_6C_52_65_73_6F_75_72_63_65_73_52_65_71_75_69_72_65_64 } ;\n(\"aria-required\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_72_65_71_75_69_72_65_64 } ;\n(\"required\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_71_75_69_72_65_64 } ;\n(\"onrowsinserted\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_72_6F_77_73_69_6E_73_65_72_74_65_64 } ;\n(\"onpopstate\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_70_6F_70_73_74_61_74_65 } ;\n(\"hreflang\") =\u003e { $ crate :: ATOM_LOCALNAME__68_72_65_66_6C_61_6E_67 } ;\n(\"aria-brailleroledescription\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_62_72_61_69_6C_6C_65_72_6F_6C_65_64_65_73_63_72_69_70_74_69_6F_6E } ;\n(\"markerunits\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_72_6B_65_72_75_6E_69_74_73 } ;\n(\"aria-current\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_63_75_72_72_65_6E_74 } ;\n(\"aria-errormessage\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_65_72_72_6F_72_6D_65_73_73_61_67_65 } ;\n(\"aria-multiselectable\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_6D_75_6C_74_69_73_65_6C_65_63_74_61_62_6C_65 } ;\n(\"arabic-form\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_61_62_69_63_2D_66_6F_72_6D } ;\n(\"textarea\") =\u003e { $ crate :: ATOM_LOCALNAME__74_65_78_74_61_72_65_61 } ;\n(\"tableValues\") =\u003e { $ crate :: ATOM_LOCALNAME__74_61_62_6C_65_56_61_6C_75_65_73 } ;\n(\"infinity\") =\u003e { $ crate :: ATOM_LOCALNAME__69_6E_66_69_6E_69_74_79 } ;\n(\"aria-valuenow\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_76_61_6C_75_65_6E_6F_77 } ;\n(\"lowlimit\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_6F_77_6C_69_6D_69_74 } ;\n(\"notprsubset\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_6F_74_70_72_73_75_62_73_65_74 } ;\n(\"marker-start\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_72_6B_65_72_2D_73_74_61_72_74 } ;\n(\"occurrence\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_63_63_75_72_72_65_6E_63_65 } ;\n(\"fecomponenttransfer\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_63_6F_6D_70_6F_6E_65_6E_74_74_72_61_6E_73_66_65_72 } ;\n(\"fontsize\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_73_69_7A_65 } ;\n(\"translate\") =\u003e { $ crate :: ATOM_LOCALNAME__74_72_61_6E_73_6C_61_74_65 } ;\n(\"direction\") =\u003e { $ crate :: ATOM_LOCALNAME__64_69_72_65_63_74_69_6F_6E } ;\n(\"repeatcount\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_70_65_61_74_63_6F_75_6E_74 } ;\n(\"xmlns:xlink\") =\u003e { $ crate :: ATOM_LOCALNAME__78_6D_6C_6E_73_3A_78_6C_69_6E_6B } ;\n(\"shadowrootclonable\") =\u003e { $ crate :: ATOM_LOCALNAME__73_68_61_64_6F_77_72_6F_6F_74_63_6C_6F_6E_61_62_6C_65 } ;\n(\"reversed\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_76_65_72_73_65_64 } ;\n(\"baseProfile\") =\u003e { $ crate :: ATOM_LOCALNAME__62_61_73_65_50_72_6F_66_69_6C_65 } ;\n(\"patternTransform\") =\u003e { $ crate :: ATOM_LOCALNAME__70_61_74_74_65_72_6E_54_72_61_6E_73_66_6F_72_6D } ;\n(\"scriptminsize\") =\u003e { $ crate :: ATOM_LOCALNAME__73_63_72_69_70_74_6D_69_6E_73_69_7A_65 } ;\n(\"mathbackground\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_74_68_62_61_63_6B_67_72_6F_75_6E_64 } ;\n(\"contentStyleType\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6E_74_65_6E_74_53_74_79_6C_65_54_79_70_65 } ;\n(\"multiple\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_75_6C_74_69_70_6C_65 } ;\n(\"baseline\") =\u003e { $ crate :: ATOM_LOCALNAME__62_61_73_65_6C_69_6E_65 } ;\n(\"oncontextmenu\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_63_6F_6E_74_65_78_74_6D_65_6E_75 } ;\n(\"textLength\") =\u003e { $ crate :: ATOM_LOCALNAME__74_65_78_74_4C_65_6E_67_74_68 } ;\n(\"decoding\") =\u003e { $ crate :: ATOM_LOCALNAME__64_65_63_6F_64_69_6E_67 } ;\n(\"maskUnits\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_73_6B_55_6E_69_74_73 } ;\n(\"tabindex\") =\u003e { $ crate :: ATOM_LOCALNAME__74_61_62_69_6E_64_65_78 } ;\n(\"clippath\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6C_69_70_70_61_74_68 } ;\n(\"limitingconeangle\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_69_6D_69_74_69_6E_67_63_6F_6E_65_61_6E_67_6C_65 } ;\n(\"flood-color\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6C_6F_6F_64_2D_63_6F_6C_6F_72 } ;\n(\"otherwise\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_74_68_65_72_77_69_73_65 } ;\n(\"naturalnumbers\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_61_74_75_72_61_6C_6E_75_6D_62_65_72_73 } ;\n(\"fedisplacementmap\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_64_69_73_70_6C_61_63_65_6D_65_6E_74_6D_61_70 } ;\n(\"formnovalidate\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_72_6D_6E_6F_76_61_6C_69_64_61_74_65 } ;\n(\"linethickness\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_69_6E_65_74_68_69_63_6B_6E_65_73_73 } ;\n(\"line-height\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_69_6E_65_2D_68_65_69_67_68_74 } ;\n(\"animatemotion\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6E_69_6D_61_74_65_6D_6F_74_69_6F_6E } ;\n(\"definition-src\") =\u003e { $ crate :: ATOM_LOCALNAME__64_65_66_69_6E_69_74_69_6F_6E_2D_73_72_63 } ;\n(\"maskcontentunits\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_73_6B_63_6F_6E_74_65_6E_74_75_6E_69_74_73 } ;\n(\"ondatasetchanged\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_64_61_74_61_73_65_74_63_68_61_6E_67_65_64 } ;\n(\"color-interpolation\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6C_6F_72_2D_69_6E_74_65_72_70_6F_6C_61_74_69_6F_6E } ;\n(\"aria-rowcount\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_72_6F_77_63_6F_75_6E_74 } ;\n(\"aria-invalid\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_69_6E_76_61_6C_69_64 } ;\n(\"mozbrowser\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_6F_7A_62_72_6F_77_73_65_72 } ;\n(\"stop-color\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_6F_70_2D_63_6F_6C_6F_72 } ;\n(\"xChannelSelector\") =\u003e { $ crate :: ATOM_LOCALNAME__78_43_68_61_6E_6E_65_6C_53_65_6C_65_63_74_6F_72 } ;\n(\"specularconstant\") =\u003e { $ crate :: ATOM_LOCALNAME__73_70_65_63_75_6C_61_72_63_6F_6E_73_74_61_6E_74 } ;\n(\"onreadystatechange\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_72_65_61_64_79_73_74_61_74_65_63_68_61_6E_67_65 } ;\n(\"onmovestart\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_76_65_73_74_61_72_74 } ;\n(\"dataformatas\") =\u003e { $ crate :: ATOM_LOCALNAME__64_61_74_61_66_6F_72_6D_61_74_61_73 } ;\n(\"fegaussianblur\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_67_61_75_73_73_69_61_6E_62_6C_75_72 } ;\n(\"onmouseup\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_75_70 } ;\n(\"feturbulence\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_74_75_72_62_75_6C_65_6E_63_65 } ;\n(\"requiredextensions\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_71_75_69_72_65_64_65_78_74_65_6E_73_69_6F_6E_73 } ;\n(\"codebase\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_64_65_62_61_73_65 } ;\n(\"xml:base\") =\u003e { $ crate :: ATOM_LOCALNAME__78_6D_6C_3A_62_61_73_65 } ;\n(\"shape-rendering\") =\u003e { $ crate :: ATOM_LOCALNAME__73_68_61_70_65_2D_72_65_6E_64_65_72_69_6E_67 } ;\n(\"tablevalues\") =\u003e { $ crate :: ATOM_LOCALNAME__74_61_62_6C_65_76_61_6C_75_65_73 } ;\n(\"selected\") =\u003e { $ crate :: ATOM_LOCALNAME__73_65_6C_65_63_74_65_64 } ;\n(\"gradientunits\") =\u003e { $ crate :: ATOM_LOCALNAME__67_72_61_64_69_65_6E_74_75_6E_69_74_73 } ;\n(\"template\") =\u003e { $ crate :: ATOM_LOCALNAME__74_65_6D_70_6C_61_74_65 } ;\n(\"mphantom\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_70_68_61_6E_74_6F_6D } ;\n(\"gradientUnits\") =\u003e { $ crate :: ATOM_LOCALNAME__67_72_61_64_69_65_6E_74_55_6E_69_74_73 } ;\n(\"superscriptshift\") =\u003e { $ crate :: ATOM_LOCALNAME__73_75_70_65_72_73_63_72_69_70_74_73_68_69_66_74 } ;\n(\"onrowsdelete\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_72_6F_77_73_64_65_6C_65_74_65 } ;\n(\"onmouseenter\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_75_73_65_65_6E_74_65_72 } ;\n(\"valuetype\") =\u003e { $ crate :: ATOM_LOCALNAME__76_61_6C_75_65_74_79_70_65 } ;\n(\"progress\") =\u003e { $ crate :: ATOM_LOCALNAME__70_72_6F_67_72_65_73_73 } ;\n(\"onbeforeactivate\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_61_63_74_69_76_61_74_65 } ;\n(\"pointsAtY\") =\u003e { $ crate :: ATOM_LOCALNAME__70_6F_69_6E_74_73_41_74_59 } ;\n(\"feDisplacementMap\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_44_69_73_70_6C_61_63_65_6D_65_6E_74_4D_61_70 } ;\n(\"aria-valuemin\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_76_61_6C_75_65_6D_69_6E } ;\n(\"text-anchor\") =\u003e { $ crate :: ATOM_LOCALNAME__74_65_78_74_2D_61_6E_63_68_6F_72 } ;\n(\"onpagehide\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_70_61_67_65_68_69_64_65 } ;\n(\"stddeviation\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_64_64_65_76_69_61_74_69_6F_6E } ;\n(\"systemlanguage\") =\u003e { $ crate :: ATOM_LOCALNAME__73_79_73_74_65_6D_6C_61_6E_67_75_61_67_65 } ;\n(\"formenctype\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_72_6D_65_6E_63_74_79_70_65 } ;\n(\"pointer-events\") =\u003e { $ crate :: ATOM_LOCALNAME__70_6F_69_6E_74_65_72_2D_65_76_65_6E_74_73 } ;\n(\"xlink:title\") =\u003e { $ crate :: ATOM_LOCALNAME__78_6C_69_6E_6B_3A_74_69_74_6C_65 } ;\n(\"inputmode\") =\u003e { $ crate :: ATOM_LOCALNAME__69_6E_70_75_74_6D_6F_64_65 } ;\n(\"amplitude\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6D_70_6C_69_74_75_64_65 } ;\n(\"aria-describedby\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_64_65_73_63_72_69_62_65_64_62_79 } ;\n(\"stretchy\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_72_65_74_63_68_79 } ;\n(\"shadowrootdelegatesfocus\") =\u003e { $ crate :: ATOM_LOCALNAME__73_68_61_64_6F_77_72_6F_6F_74_64_65_6C_65_67_61_74_65_73_66_6F_63_75_73 } ;\n(\"ondragstart\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_64_72_61_67_73_74_61_72_74 } ;\n(\"rowalign\") =\u003e { $ crate :: ATOM_LOCALNAME__72_6F_77_61_6C_69_67_6E } ;\n(\"font-style\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_73_74_79_6C_65 } ;\n(\"keypoints\") =\u003e { $ crate :: ATOM_LOCALNAME__6B_65_79_70_6F_69_6E_74_73 } ;\n(\"femorphology\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_6D_6F_72_70_68_6F_6C_6F_67_79 } ;\n(\"aria-datatype\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_64_61_74_61_74_79_70_65 } ;\n(\"feDiffuseLighting\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_44_69_66_66_75_73_65_4C_69_67_68_74_69_6E_67 } ;\n(\"mlabeledtr\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_6C_61_62_65_6C_65_64_74_72 } ;\n(\"datalist\") =\u003e { $ crate :: ATOM_LOCALNAME__64_61_74_61_6C_69_73_74 } ;\n(\"animateTransform\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6E_69_6D_61_74_65_54_72_61_6E_73_66_6F_72_6D } ;\n(\"clip-rule\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6C_69_70_2D_72_75_6C_65 } ;\n(\"filterUnits\") =\u003e { $ crate :: ATOM_LOCALNAME__66_69_6C_74_65_72_55_6E_69_74_73 } ;\n(\"specularConstant\") =\u003e { $ crate :: ATOM_LOCALNAME__73_70_65_63_75_6C_61_72_43_6F_6E_73_74_61_6E_74 } ;\n(\"onhashchange\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_68_61_73_68_63_68_61_6E_67_65 } ;\n(\"onafterupdate\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_61_66_74_65_72_75_70_64_61_74_65 } ;\n(\"primitiveunits\") =\u003e { $ crate :: ATOM_LOCALNAME__70_72_69_6D_69_74_69_76_65_75_6E_69_74_73 } ;\n(\"imaginaryi\") =\u003e { $ crate :: ATOM_LOCALNAME__69_6D_61_67_69_6E_61_72_79_69 } ;\n(\"strikethrough-position\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_72_69_6B_65_74_68_72_6F_75_67_68_2D_70_6F_73_69_74_69_6F_6E } ;\n(\"overflow\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_76_65_72_66_6C_6F_77 } ;\n(\"solidcolor\") =\u003e { $ crate :: ATOM_LOCALNAME__73_6F_6C_69_64_63_6F_6C_6F_72 } ;\n(\"aria-modal\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_6D_6F_64_61_6C } ;\n(\"placeholder\") =\u003e { $ crate :: ATOM_LOCALNAME__70_6C_61_63_65_68_6F_6C_64_65_72 } ;\n(\"edgeMode\") =\u003e { $ crate :: ATOM_LOCALNAME__65_64_67_65_4D_6F_64_65 } ;\n(\"itemprop\") =\u003e { $ crate :: ATOM_LOCALNAME__69_74_65_6D_70_72_6F_70 } ;\n(\"feConvolveMatrix\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_43_6F_6E_76_6F_6C_76_65_4D_61_74_72_69_78 } ;\n(\"fespotlight\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_73_70_6F_74_6C_69_67_68_74 } ;\n(\"onbeforecopy\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_65_63_6F_70_79 } ;\n(\"baseFrequency\") =\u003e { $ crate :: ATOM_LOCALNAME__62_61_73_65_46_72_65_71_75_65_6E_63_79 } ;\n(\"keyPoints\") =\u003e { $ crate :: ATOM_LOCALNAME__6B_65_79_50_6F_69_6E_74_73 } ;\n(\"definitionurl\") =\u003e { $ crate :: ATOM_LOCALNAME__64_65_66_69_6E_69_74_69_6F_6E_75_72_6C } ;\n(\"stroke-width\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_72_6F_6B_65_2D_77_69_64_74_68 } ;\n(\"onfinish\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_66_69_6E_69_73_68 } ;\n(\"conjugate\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6E_6A_75_67_61_74_65 } ;\n(\"veryverythinmathspace\") =\u003e { $ crate :: ATOM_LOCALNAME__76_65_72_79_76_65_72_79_74_68_69_6E_6D_61_74_68_73_70_61_63_65 } ;\n(\"fetchpriority\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_74_63_68_70_72_69_6F_72_69_74_79 } ;\n(\"keySplines\") =\u003e { $ crate :: ATOM_LOCALNAME__6B_65_79_53_70_6C_69_6E_65_73 } ;\n(\"intersect\") =\u003e { $ crate :: ATOM_LOCALNAME__69_6E_74_65_72_73_65_63_74 } ;\n(\"spellcheck\") =\u003e { $ crate :: ATOM_LOCALNAME__73_70_65_6C_6C_63_68_65_63_6B } ;\n(\"mathvariant\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_74_68_76_61_72_69_61_6E_74 } ;\n(\"integrity\") =\u003e { $ crate :: ATOM_LOCALNAME__69_6E_74_65_67_72_69_74_79 } ;\n(\"piecewise\") =\u003e { $ crate :: ATOM_LOCALNAME__70_69_65_63_65_77_69_73_65 } ;\n(\"oncellchange\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_63_65_6C_6C_63_68_61_6E_67_65 } ;\n(\"maxlength\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_78_6C_65_6E_67_74_68 } ;\n(\"prsubset\") =\u003e { $ crate :: ATOM_LOCALNAME__70_72_73_75_62_73_65_74 } ;\n(\"aria-owns\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_69_61_2D_6F_77_6E_73 } ;\n(\"feconvolvematrix\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_63_6F_6E_76_6F_6C_76_65_6D_61_74_72_69_78 } ;\n(\"manifest\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_6E_69_66_65_73_74 } ;\n(\"ondeactivate\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_64_65_61_63_74_69_76_61_74_65 } ;\n(\"columnwidth\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6C_75_6D_6E_77_69_64_74_68 } ;\n(\"rowspacing\") =\u003e { $ crate :: ATOM_LOCALNAME__72_6F_77_73_70_61_63_69_6E_67 } ;\n(\"underline-position\") =\u003e { $ crate :: ATOM_LOCALNAME__75_6E_64_65_72_6C_69_6E_65_2D_70_6F_73_69_74_69_6F_6E } ;\n(\"annotation-xml\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6E_6E_6F_74_61_74_69_6F_6E_2D_78_6D_6C } ;\n(\"fill-opacity\") =\u003e { $ crate :: ATOM_LOCALNAME__66_69_6C_6C_2D_6F_70_61_63_69_74_79 } ;\n(\"ychannelselector\") =\u003e { $ crate :: ATOM_LOCALNAME__79_63_68_61_6E_6E_65_6C_73_65_6C_65_63_74_6F_72 } ;\n(\"xlink:href\") =\u003e { $ crate :: ATOM_LOCALNAME__78_6C_69_6E_6B_3A_68_72_65_66 } ;\n(\"frameset\") =\u003e { $ crate :: ATOM_LOCALNAME__66_72_61_6D_65_73_65_74 } ;\n(\"animateMotion\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6E_69_6D_61_74_65_4D_6F_74_69_6F_6E } ;\n(\"cap-height\") =\u003e { $ crate :: ATOM_LOCALNAME__63_61_70_2D_68_65_69_67_68_74 } ;\n(\"formtarget\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_72_6D_74_61_72_67_65_74 } ;\n(\"font-face-name\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_6E_74_2D_66_61_63_65_2D_6E_61_6D_65 } ;\n(\"altglyphitem\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6C_74_67_6C_79_70_68_69_74_65_6D } ;\n(\"onbefordeactivate\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_62_65_66_6F_72_64_65_61_63_74_69_76_61_74_65 } ;\n(\"scriptlevel\") =\u003e { $ crate :: ATOM_LOCALNAME__73_63_72_69_70_74_6C_65_76_65_6C } ;\n(\"writing-mode\") =\u003e { $ crate :: ATOM_LOCALNAME__77_72_69_74_69_6E_67_2D_6D_6F_64_65 } ;\n(\"equalcolumns\") =\u003e { $ crate :: ATOM_LOCALNAME__65_71_75_61_6C_63_6F_6C_75_6D_6E_73 } ;\n(\"munderover\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_75_6E_64_65_72_6F_76_65_72 } ;\n(\"accent-height\") =\u003e { $ crate :: ATOM_LOCALNAME__61_63_63_65_6E_74_2D_68_65_69_67_68_74 } ;\n(\"verythinmathspace\") =\u003e { $ crate :: ATOM_LOCALNAME__76_65_72_79_74_68_69_6E_6D_61_74_68_73_70_61_63_65 } ;\n(\"displaystyle\") =\u003e { $ crate :: ATOM_LOCALNAME__64_69_73_70_6C_61_79_73_74_79_6C_65 } ;\n(\"underline-thickness\") =\u003e { $ crate :: ATOM_LOCALNAME__75_6E_64_65_72_6C_69_6E_65_2D_74_68_69_63_6B_6E_65_73_73 } ;\n(\"kernelmatrix\") =\u003e { $ crate :: ATOM_LOCALNAME__6B_65_72_6E_65_6C_6D_61_74_72_69_78 } ;\n(\"fecolormatrix\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_63_6F_6C_6F_72_6D_61_74_72_69_78 } ;\n(\"*\") =\u003e { $ crate :: ATOM_LOCALNAME__2A } ;\n(\"a\") =\u003e { $ crate :: ATOM_LOCALNAME__61 } ;\n(\"abbr\") =\u003e { $ crate :: ATOM_LOCALNAME__61_62_62_72 } ;\n(\"abs\") =\u003e { $ crate :: ATOM_LOCALNAME__61_62_73 } ;\n(\"accent\") =\u003e { $ crate :: ATOM_LOCALNAME__61_63_63_65_6E_74 } ;\n(\"accept\") =\u003e { $ crate :: ATOM_LOCALNAME__61_63_63_65_70_74 } ;\n(\"acronym\") =\u003e { $ crate :: ATOM_LOCALNAME__61_63_72_6F_6E_79_6D } ;\n(\"action\") =\u003e { $ crate :: ATOM_LOCALNAME__61_63_74_69_6F_6E } ;\n(\"active\") =\u003e { $ crate :: ATOM_LOCALNAME__61_63_74_69_76_65 } ;\n(\"actuate\") =\u003e { $ crate :: ATOM_LOCALNAME__61_63_74_75_61_74_65 } ;\n(\"address\") =\u003e { $ crate :: ATOM_LOCALNAME__61_64_64_72_65_73_73 } ;\n(\"align\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6C_69_67_6E } ;\n(\"alink\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6C_69_6E_6B } ;\n(\"alt\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6C_74 } ;\n(\"altimg\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6C_74_69_6D_67 } ;\n(\"alttext\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6C_74_74_65_78_74 } ;\n(\"and\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6E_64 } ;\n(\"animate\") =\u003e { $ crate :: ATOM_LOCALNAME__61_6E_69_6D_61_74_65 } ;\n(\"applet\") =\u003e { $ crate :: ATOM_LOCALNAME__61_70_70_6C_65_74 } ;\n(\"apply\") =\u003e { $ crate :: ATOM_LOCALNAME__61_70_70_6C_79 } ;\n(\"approx\") =\u003e { $ crate :: ATOM_LOCALNAME__61_70_70_72_6F_78 } ;\n(\"arccos\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_63_63_6F_73 } ;\n(\"arccosh\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_63_63_6F_73_68 } ;\n(\"arccot\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_63_63_6F_74 } ;\n(\"arccoth\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_63_63_6F_74_68 } ;\n(\"arccsc\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_63_63_73_63 } ;\n(\"arccsch\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_63_63_73_63_68 } ;\n(\"archive\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_63_68_69_76_65 } ;\n(\"arcrole\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_63_72_6F_6C_65 } ;\n(\"arcsec\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_63_73_65_63 } ;\n(\"arcsech\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_63_73_65_63_68 } ;\n(\"arcsin\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_63_73_69_6E } ;\n(\"arcsinh\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_63_73_69_6E_68 } ;\n(\"arctan\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_63_74_61_6E } ;\n(\"arctanh\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_63_74_61_6E_68 } ;\n(\"area\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_65_61 } ;\n(\"arg\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_67 } ;\n(\"article\") =\u003e { $ crate :: ATOM_LOCALNAME__61_72_74_69_63_6C_65 } ;\n(\"as\") =\u003e { $ crate :: ATOM_LOCALNAME__61_73 } ;\n(\"ascent\") =\u003e { $ crate :: ATOM_LOCALNAME__61_73_63_65_6E_74 } ;\n(\"aside\") =\u003e { $ crate :: ATOM_LOCALNAME__61_73_69_64_65 } ;\n(\"async\") =\u003e { $ crate :: ATOM_LOCALNAME__61_73_79_6E_63 } ;\n(\"audio\") =\u003e { $ crate :: ATOM_LOCALNAME__61_75_64_69_6F } ;\n(\"axis\") =\u003e { $ crate :: ATOM_LOCALNAME__61_78_69_73 } ;\n(\"azimuth\") =\u003e { $ crate :: ATOM_LOCALNAME__61_7A_69_6D_75_74_68 } ;\n(\"b\") =\u003e { $ crate :: ATOM_LOCALNAME__62 } ;\n(\"base\") =\u003e { $ crate :: ATOM_LOCALNAME__62_61_73_65 } ;\n(\"bbox\") =\u003e { $ crate :: ATOM_LOCALNAME__62_62_6F_78 } ;\n(\"bdi\") =\u003e { $ crate :: ATOM_LOCALNAME__62_64_69 } ;\n(\"bdo\") =\u003e { $ crate :: ATOM_LOCALNAME__62_64_6F } ;\n(\"begin\") =\u003e { $ crate :: ATOM_LOCALNAME__62_65_67_69_6E } ;\n(\"bgcolor\") =\u003e { $ crate :: ATOM_LOCALNAME__62_67_63_6F_6C_6F_72 } ;\n(\"bgsound\") =\u003e { $ crate :: ATOM_LOCALNAME__62_67_73_6F_75_6E_64 } ;\n(\"bias\") =\u003e { $ crate :: ATOM_LOCALNAME__62_69_61_73 } ;\n(\"big\") =\u003e { $ crate :: ATOM_LOCALNAME__62_69_67 } ;\n(\"blink\") =\u003e { $ crate :: ATOM_LOCALNAME__62_6C_69_6E_6B } ;\n(\"body\") =\u003e { $ crate :: ATOM_LOCALNAME__62_6F_64_79 } ;\n(\"border\") =\u003e { $ crate :: ATOM_LOCALNAME__62_6F_72_64_65_72 } ;\n(\"br\") =\u003e { $ crate :: ATOM_LOCALNAME__62_72 } ;\n(\"button\") =\u003e { $ crate :: ATOM_LOCALNAME__62_75_74_74_6F_6E } ;\n(\"bvar\") =\u003e { $ crate :: ATOM_LOCALNAME__62_76_61_72 } ;\n(\"by\") =\u003e { $ crate :: ATOM_LOCALNAME__62_79 } ;\n(\"canvas\") =\u003e { $ crate :: ATOM_LOCALNAME__63_61_6E_76_61_73 } ;\n(\"caption\") =\u003e { $ crate :: ATOM_LOCALNAME__63_61_70_74_69_6F_6E } ;\n(\"card\") =\u003e { $ crate :: ATOM_LOCALNAME__63_61_72_64 } ;\n(\"ceiling\") =\u003e { $ crate :: ATOM_LOCALNAME__63_65_69_6C_69_6E_67 } ;\n(\"center\") =\u003e { $ crate :: ATOM_LOCALNAME__63_65_6E_74_65_72 } ;\n(\"char\") =\u003e { $ crate :: ATOM_LOCALNAME__63_68_61_72 } ;\n(\"charoff\") =\u003e { $ crate :: ATOM_LOCALNAME__63_68_61_72_6F_66_66 } ;\n(\"charset\") =\u003e { $ crate :: ATOM_LOCALNAME__63_68_61_72_73_65_74 } ;\n(\"checked\") =\u003e { $ crate :: ATOM_LOCALNAME__63_68_65_63_6B_65_64 } ;\n(\"ci\") =\u003e { $ crate :: ATOM_LOCALNAME__63_69 } ;\n(\"circle\") =\u003e { $ crate :: ATOM_LOCALNAME__63_69_72_63_6C_65 } ;\n(\"cite\") =\u003e { $ crate :: ATOM_LOCALNAME__63_69_74_65 } ;\n(\"class\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6C_61_73_73 } ;\n(\"classid\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6C_61_73_73_69_64 } ;\n(\"clear\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6C_65_61_72 } ;\n(\"clip\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6C_69_70 } ;\n(\"close\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6C_6F_73_65 } ;\n(\"closure\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6C_6F_73_75_72_65 } ;\n(\"cn\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6E } ;\n(\"code\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_64_65 } ;\n(\"col\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6C } ;\n(\"color\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6C_6F_72 } ;\n(\"cols\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6C_73 } ;\n(\"colspan\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6C_73_70_61_6E } ;\n(\"compact\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6D_70_61_63_74 } ;\n(\"compose\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6D_70_6F_73_65 } ;\n(\"content\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6E_74_65_6E_74 } ;\n(\"coords\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_6F_72_64_73 } ;\n(\"cos\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_73 } ;\n(\"cosh\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_73_68 } ;\n(\"cot\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_74 } ;\n(\"coth\") =\u003e { $ crate :: ATOM_LOCALNAME__63_6F_74_68 } ;\n(\"csc\") =\u003e { $ crate :: ATOM_LOCALNAME__63_73_63 } ;\n(\"csch\") =\u003e { $ crate :: ATOM_LOCALNAME__63_73_63_68 } ;\n(\"csymbol\") =\u003e { $ crate :: ATOM_LOCALNAME__63_73_79_6D_62_6F_6C } ;\n(\"curl\") =\u003e { $ crate :: ATOM_LOCALNAME__63_75_72_6C } ;\n(\"cursor\") =\u003e { $ crate :: ATOM_LOCALNAME__63_75_72_73_6F_72 } ;\n(\"cx\") =\u003e { $ crate :: ATOM_LOCALNAME__63_78 } ;\n(\"cy\") =\u003e { $ crate :: ATOM_LOCALNAME__63_79 } ;\n(\"d\") =\u003e { $ crate :: ATOM_LOCALNAME__64 } ;\n(\"data\") =\u003e { $ crate :: ATOM_LOCALNAME__64_61_74_61 } ;\n(\"datafld\") =\u003e { $ crate :: ATOM_LOCALNAME__64_61_74_61_66_6C_64 } ;\n(\"datasrc\") =\u003e { $ crate :: ATOM_LOCALNAME__64_61_74_61_73_72_63 } ;\n(\"dd\") =\u003e { $ crate :: ATOM_LOCALNAME__64_64 } ;\n(\"declare\") =\u003e { $ crate :: ATOM_LOCALNAME__64_65_63_6C_61_72_65 } ;\n(\"default\") =\u003e { $ crate :: ATOM_LOCALNAME__64_65_66_61_75_6C_74 } ;\n(\"defer\") =\u003e { $ crate :: ATOM_LOCALNAME__64_65_66_65_72 } ;\n(\"defs\") =\u003e { $ crate :: ATOM_LOCALNAME__64_65_66_73 } ;\n(\"degree\") =\u003e { $ crate :: ATOM_LOCALNAME__64_65_67_72_65_65 } ;\n(\"del\") =\u003e { $ crate :: ATOM_LOCALNAME__64_65_6C } ;\n(\"depth\") =\u003e { $ crate :: ATOM_LOCALNAME__64_65_70_74_68 } ;\n(\"desc\") =\u003e { $ crate :: ATOM_LOCALNAME__64_65_73_63 } ;\n(\"descent\") =\u003e { $ crate :: ATOM_LOCALNAME__64_65_73_63_65_6E_74 } ;\n(\"details\") =\u003e { $ crate :: ATOM_LOCALNAME__64_65_74_61_69_6C_73 } ;\n(\"dfn\") =\u003e { $ crate :: ATOM_LOCALNAME__64_66_6E } ;\n(\"dialog\") =\u003e { $ crate :: ATOM_LOCALNAME__64_69_61_6C_6F_67 } ;\n(\"diff\") =\u003e { $ crate :: ATOM_LOCALNAME__64_69_66_66 } ;\n(\"dir\") =\u003e { $ crate :: ATOM_LOCALNAME__64_69_72 } ;\n(\"dirname\") =\u003e { $ crate :: ATOM_LOCALNAME__64_69_72_6E_61_6D_65 } ;\n(\"discard\") =\u003e { $ crate :: ATOM_LOCALNAME__64_69_73_63_61_72_64 } ;\n(\"display\") =\u003e { $ crate :: ATOM_LOCALNAME__64_69_73_70_6C_61_79 } ;\n(\"div\") =\u003e { $ crate :: ATOM_LOCALNAME__64_69_76 } ;\n(\"divide\") =\u003e { $ crate :: ATOM_LOCALNAME__64_69_76_69_64_65 } ;\n(\"divisor\") =\u003e { $ crate :: ATOM_LOCALNAME__64_69_76_69_73_6F_72 } ;\n(\"dl\") =\u003e { $ crate :: ATOM_LOCALNAME__64_6C } ;\n(\"domain\") =\u003e { $ crate :: ATOM_LOCALNAME__64_6F_6D_61_69_6E } ;\n(\"dt\") =\u003e { $ crate :: ATOM_LOCALNAME__64_74 } ;\n(\"dur\") =\u003e { $ crate :: ATOM_LOCALNAME__64_75_72 } ;\n(\"dx\") =\u003e { $ crate :: ATOM_LOCALNAME__64_78 } ;\n(\"dy\") =\u003e { $ crate :: ATOM_LOCALNAME__64_79 } ;\n(\"edge\") =\u003e { $ crate :: ATOM_LOCALNAME__65_64_67_65 } ;\n(\"ellipse\") =\u003e { $ crate :: ATOM_LOCALNAME__65_6C_6C_69_70_73_65 } ;\n(\"em\") =\u003e { $ crate :: ATOM_LOCALNAME__65_6D } ;\n(\"embed\") =\u003e { $ crate :: ATOM_LOCALNAME__65_6D_62_65_64 } ;\n(\"enctype\") =\u003e { $ crate :: ATOM_LOCALNAME__65_6E_63_74_79_70_65 } ;\n(\"end\") =\u003e { $ crate :: ATOM_LOCALNAME__65_6E_64 } ;\n(\"eq\") =\u003e { $ crate :: ATOM_LOCALNAME__65_71 } ;\n(\"event\") =\u003e { $ crate :: ATOM_LOCALNAME__65_76_65_6E_74 } ;\n(\"exists\") =\u003e { $ crate :: ATOM_LOCALNAME__65_78_69_73_74_73 } ;\n(\"exp\") =\u003e { $ crate :: ATOM_LOCALNAME__65_78_70 } ;\n(\"face\") =\u003e { $ crate :: ATOM_LOCALNAME__66_61_63_65 } ;\n(\"false\") =\u003e { $ crate :: ATOM_LOCALNAME__66_61_6C_73_65 } ;\n(\"feBlend\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_42_6C_65_6E_64 } ;\n(\"feFlood\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_46_6C_6F_6F_64 } ;\n(\"feFuncA\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_46_75_6E_63_41 } ;\n(\"feFuncB\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_46_75_6E_63_42 } ;\n(\"feFuncG\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_46_75_6E_63_47 } ;\n(\"feFuncR\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_46_75_6E_63_52 } ;\n(\"feImage\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_49_6D_61_67_65 } ;\n(\"feMerge\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_4D_65_72_67_65 } ;\n(\"feTile\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_54_69_6C_65 } ;\n(\"feblend\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_62_6C_65_6E_64 } ;\n(\"feflood\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_66_6C_6F_6F_64 } ;\n(\"fefunca\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_66_75_6E_63_61 } ;\n(\"fefuncb\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_66_75_6E_63_62 } ;\n(\"fefuncg\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_66_75_6E_63_67 } ;\n(\"fefuncr\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_66_75_6E_63_72 } ;\n(\"feimage\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_69_6D_61_67_65 } ;\n(\"femerge\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_6D_65_72_67_65 } ;\n(\"fence\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_6E_63_65 } ;\n(\"fetch\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_74_63_68 } ;\n(\"fetile\") =\u003e { $ crate :: ATOM_LOCALNAME__66_65_74_69_6C_65 } ;\n(\"figure\") =\u003e { $ crate :: ATOM_LOCALNAME__66_69_67_75_72_65 } ;\n(\"fill\") =\u003e { $ crate :: ATOM_LOCALNAME__66_69_6C_6C } ;\n(\"filter\") =\u003e { $ crate :: ATOM_LOCALNAME__66_69_6C_74_65_72 } ;\n(\"floor\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6C_6F_6F_72 } ;\n(\"fn\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6E } ;\n(\"font\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_6E_74 } ;\n(\"footer\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_6F_74_65_72 } ;\n(\"for\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_72 } ;\n(\"forall\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_72_61_6C_6C } ;\n(\"form\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_72_6D } ;\n(\"format\") =\u003e { $ crate :: ATOM_LOCALNAME__66_6F_72_6D_61_74 } ;\n(\"frame\") =\u003e { $ crate :: ATOM_LOCALNAME__66_72_61_6D_65 } ;\n(\"from\") =\u003e { $ crate :: ATOM_LOCALNAME__66_72_6F_6D } ;\n(\"fx\") =\u003e { $ crate :: ATOM_LOCALNAME__66_78 } ;\n(\"fy\") =\u003e { $ crate :: ATOM_LOCALNAME__66_79 } ;\n(\"g\") =\u003e { $ crate :: ATOM_LOCALNAME__67 } ;\n(\"g1\") =\u003e { $ crate :: ATOM_LOCALNAME__67_31 } ;\n(\"g2\") =\u003e { $ crate :: ATOM_LOCALNAME__67_32 } ;\n(\"gcd\") =\u003e { $ crate :: ATOM_LOCALNAME__67_63_64 } ;\n(\"geq\") =\u003e { $ crate :: ATOM_LOCALNAME__67_65_71 } ;\n(\"glyph\") =\u003e { $ crate :: ATOM_LOCALNAME__67_6C_79_70_68 } ;\n(\"grad\") =\u003e { $ crate :: ATOM_LOCALNAME__67_72_61_64 } ;\n(\"gt\") =\u003e { $ crate :: ATOM_LOCALNAME__67_74 } ;\n(\"h1\") =\u003e { $ crate :: ATOM_LOCALNAME__68_31 } ;\n(\"h2\") =\u003e { $ crate :: ATOM_LOCALNAME__68_32 } ;\n(\"h3\") =\u003e { $ crate :: ATOM_LOCALNAME__68_33 } ;\n(\"h4\") =\u003e { $ crate :: ATOM_LOCALNAME__68_34 } ;\n(\"h5\") =\u003e { $ crate :: ATOM_LOCALNAME__68_35 } ;\n(\"h6\") =\u003e { $ crate :: ATOM_LOCALNAME__68_36 } ;\n(\"handler\") =\u003e { $ crate :: ATOM_LOCALNAME__68_61_6E_64_6C_65_72 } ;\n(\"hanging\") =\u003e { $ crate :: ATOM_LOCALNAME__68_61_6E_67_69_6E_67 } ;\n(\"head\") =\u003e { $ crate :: ATOM_LOCALNAME__68_65_61_64 } ;\n(\"header\") =\u003e { $ crate :: ATOM_LOCALNAME__68_65_61_64_65_72 } ;\n(\"headers\") =\u003e { $ crate :: ATOM_LOCALNAME__68_65_61_64_65_72_73 } ;\n(\"height\") =\u003e { $ crate :: ATOM_LOCALNAME__68_65_69_67_68_74 } ;\n(\"hgroup\") =\u003e { $ crate :: ATOM_LOCALNAME__68_67_72_6F_75_70 } ;\n(\"hidden\") =\u003e { $ crate :: ATOM_LOCALNAME__68_69_64_64_65_6E } ;\n(\"high\") =\u003e { $ crate :: ATOM_LOCALNAME__68_69_67_68 } ;\n(\"hkern\") =\u003e { $ crate :: ATOM_LOCALNAME__68_6B_65_72_6E } ;\n(\"hr\") =\u003e { $ crate :: ATOM_LOCALNAME__68_72 } ;\n(\"href\") =\u003e { $ crate :: ATOM_LOCALNAME__68_72_65_66 } ;\n(\"hspace\") =\u003e { $ crate :: ATOM_LOCALNAME__68_73_70_61_63_65 } ;\n(\"html\") =\u003e { $ crate :: ATOM_LOCALNAME__68_74_6D_6C } ;\n(\"i\") =\u003e { $ crate :: ATOM_LOCALNAME__69 } ;\n(\"icon\") =\u003e { $ crate :: ATOM_LOCALNAME__69_63_6F_6E } ;\n(\"id\") =\u003e { $ crate :: ATOM_LOCALNAME__69_64 } ;\n(\"ident\") =\u003e { $ crate :: ATOM_LOCALNAME__69_64_65_6E_74 } ;\n(\"iframe\") =\u003e { $ crate :: ATOM_LOCALNAME__69_66_72_61_6D_65 } ;\n(\"image\") =\u003e { $ crate :: ATOM_LOCALNAME__69_6D_61_67_65 } ;\n(\"img\") =\u003e { $ crate :: ATOM_LOCALNAME__69_6D_67 } ;\n(\"implies\") =\u003e { $ crate :: ATOM_LOCALNAME__69_6D_70_6C_69_65_73 } ;\n(\"in\") =\u003e { $ crate :: ATOM_LOCALNAME__69_6E } ;\n(\"in2\") =\u003e { $ crate :: ATOM_LOCALNAME__69_6E_32 } ;\n(\"index\") =\u003e { $ crate :: ATOM_LOCALNAME__69_6E_64_65_78 } ;\n(\"input\") =\u003e { $ crate :: ATOM_LOCALNAME__69_6E_70_75_74 } ;\n(\"ins\") =\u003e { $ crate :: ATOM_LOCALNAME__69_6E_73 } ;\n(\"int\") =\u003e { $ crate :: ATOM_LOCALNAME__69_6E_74 } ;\n(\"inverse\") =\u003e { $ crate :: ATOM_LOCALNAME__69_6E_76_65_72_73_65 } ;\n(\"isindex\") =\u003e { $ crate :: ATOM_LOCALNAME__69_73_69_6E_64_65_78 } ;\n(\"ismap\") =\u003e { $ crate :: ATOM_LOCALNAME__69_73_6D_61_70 } ;\n(\"itemid\") =\u003e { $ crate :: ATOM_LOCALNAME__69_74_65_6D_69_64 } ;\n(\"itemref\") =\u003e { $ crate :: ATOM_LOCALNAME__69_74_65_6D_72_65_66 } ;\n(\"k\") =\u003e { $ crate :: ATOM_LOCALNAME__6B } ;\n(\"k1\") =\u003e { $ crate :: ATOM_LOCALNAME__6B_31 } ;\n(\"k2\") =\u003e { $ crate :: ATOM_LOCALNAME__6B_32 } ;\n(\"k3\") =\u003e { $ crate :: ATOM_LOCALNAME__6B_33 } ;\n(\"k4\") =\u003e { $ crate :: ATOM_LOCALNAME__6B_34 } ;\n(\"kbd\") =\u003e { $ crate :: ATOM_LOCALNAME__6B_62_64 } ;\n(\"kerning\") =\u003e { $ crate :: ATOM_LOCALNAME__6B_65_72_6E_69_6E_67 } ;\n(\"keygen\") =\u003e { $ crate :: ATOM_LOCALNAME__6B_65_79_67_65_6E } ;\n(\"kind\") =\u003e { $ crate :: ATOM_LOCALNAME__6B_69_6E_64 } ;\n(\"label\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_61_62_65_6C } ;\n(\"lambda\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_61_6D_62_64_61 } ;\n(\"lang\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_61_6E_67 } ;\n(\"largeop\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_61_72_67_65_6F_70 } ;\n(\"lcm\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_63_6D } ;\n(\"legend\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_65_67_65_6E_64 } ;\n(\"leq\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_65_71 } ;\n(\"li\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_69 } ;\n(\"limit\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_69_6D_69_74 } ;\n(\"line\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_69_6E_65 } ;\n(\"link\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_69_6E_6B } ;\n(\"list\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_69_73_74 } ;\n(\"listing\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_69_73_74_69_6E_67 } ;\n(\"ln\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_6E } ;\n(\"loading\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_6F_61_64_69_6E_67 } ;\n(\"local\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_6F_63_61_6C } ;\n(\"log\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_6F_67 } ;\n(\"logbase\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_6F_67_62_61_73_65 } ;\n(\"loop\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_6F_6F_70 } ;\n(\"low\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_6F_77 } ;\n(\"lowsrc\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_6F_77_73_72_63 } ;\n(\"lquote\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_71_75_6F_74_65 } ;\n(\"lspace\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_73_70_61_63_65 } ;\n(\"lt\") =\u003e { $ crate :: ATOM_LOCALNAME__6C_74 } ;\n(\"macros\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_63_72_6F_73 } ;\n(\"maction\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_63_74_69_6F_6E } ;\n(\"main\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_69_6E } ;\n(\"map\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_70 } ;\n(\"mark\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_72_6B } ;\n(\"marker\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_72_6B_65_72 } ;\n(\"marquee\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_72_71_75_65_65 } ;\n(\"mask\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_73_6B } ;\n(\"math\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_74_68 } ;\n(\"matrix\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_74_72_69_78 } ;\n(\"max\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_78 } ;\n(\"maxsize\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_61_78_73_69_7A_65 } ;\n(\"mean\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_65_61_6E } ;\n(\"media\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_65_64_69_61 } ;\n(\"median\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_65_64_69_61_6E } ;\n(\"menu\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_65_6E_75 } ;\n(\"merror\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_65_72_72_6F_72 } ;\n(\"meta\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_65_74_61 } ;\n(\"meter\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_65_74_65_72 } ;\n(\"method\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_65_74_68_6F_64 } ;\n(\"mfenced\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_66_65_6E_63_65_64 } ;\n(\"mfrac\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_66_72_61_63 } ;\n(\"mglyph\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_67_6C_79_70_68 } ;\n(\"mi\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_69 } ;\n(\"min\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_69_6E } ;\n(\"minsize\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_69_6E_73_69_7A_65 } ;\n(\"minus\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_69_6E_75_73 } ;\n(\"mn\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_6E } ;\n(\"mo\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_6F } ;\n(\"mode\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_6F_64_65 } ;\n(\"moment\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_6F_6D_65_6E_74 } ;\n(\"mover\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_6F_76_65_72 } ;\n(\"mpadded\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_70_61_64_64_65_64 } ;\n(\"mpath\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_70_61_74_68 } ;\n(\"mroot\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_72_6F_6F_74 } ;\n(\"mrow\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_72_6F_77 } ;\n(\"ms\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_73 } ;\n(\"mspace\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_73_70_61_63_65 } ;\n(\"msqrt\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_73_71_72_74 } ;\n(\"mstyle\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_73_74_79_6C_65 } ;\n(\"msub\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_73_75_62 } ;\n(\"msubsup\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_73_75_62_73_75_70 } ;\n(\"msup\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_73_75_70 } ;\n(\"mtable\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_74_61_62_6C_65 } ;\n(\"mtd\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_74_64 } ;\n(\"mtext\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_74_65_78_74 } ;\n(\"mtr\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_74_72 } ;\n(\"munder\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_75_6E_64_65_72 } ;\n(\"muted\") =\u003e { $ crate :: ATOM_LOCALNAME__6D_75_74_65_64 } ;\n(\"name\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_61_6D_65 } ;\n(\"nargs\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_61_72_67_73 } ;\n(\"nav\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_61_76 } ;\n(\"neq\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_65_71 } ;\n(\"nest\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_65_73_74 } ;\n(\"nextid\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_65_78_74_69_64 } ;\n(\"nobr\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_6F_62_72 } ;\n(\"noembed\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_6F_65_6D_62_65_64 } ;\n(\"nohref\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_6F_68_72_65_66 } ;\n(\"nonce\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_6F_6E_63_65 } ;\n(\"none\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_6F_6E_65 } ;\n(\"noshade\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_6F_73_68_61_64_65 } ;\n(\"not\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_6F_74 } ;\n(\"notin\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_6F_74_69_6E } ;\n(\"nowrap\") =\u003e { $ crate :: ATOM_LOCALNAME__6E_6F_77_72_61_70 } ;\n(\"object\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_62_6A_65_63_74 } ;\n(\"offset\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_66_66_73_65_74 } ;\n(\"ol\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6C } ;\n(\"onabort\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_61_62_6F_72_74 } ;\n(\"onbegin\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_62_65_67_69_6E } ;\n(\"onblur\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_62_6C_75_72 } ;\n(\"onclick\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_63_6C_69_63_6B } ;\n(\"oncopy\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_63_6F_70_79 } ;\n(\"oncut\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_63_75_74 } ;\n(\"ondrag\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_64_72_61_67 } ;\n(\"ondrop\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_64_72_6F_70 } ;\n(\"onend\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_65_6E_64 } ;\n(\"onerror\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_65_72_72_6F_72 } ;\n(\"onfocus\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_66_6F_63_75_73 } ;\n(\"onhelp\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_68_65_6C_70 } ;\n(\"oninput\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_69_6E_70_75_74 } ;\n(\"onkeyup\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_6B_65_79_75_70 } ;\n(\"onload\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_6C_6F_61_64 } ;\n(\"onmove\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_6D_6F_76_65 } ;\n(\"onpaste\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_70_61_73_74_65 } ;\n(\"onreset\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_72_65_73_65_74 } ;\n(\"onstart\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_73_74_61_72_74 } ;\n(\"onstop\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_73_74_6F_70 } ;\n(\"onzoom\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_6E_7A_6F_6F_6D } ;\n(\"opacity\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_70_61_63_69_74_79 } ;\n(\"open\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_70_65_6E } ;\n(\"optimum\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_70_74_69_6D_75_6D } ;\n(\"option\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_70_74_69_6F_6E } ;\n(\"or\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_72 } ;\n(\"order\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_72_64_65_72 } ;\n(\"orient\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_72_69_65_6E_74 } ;\n(\"origin\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_72_69_67_69_6E } ;\n(\"other\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_74_68_65_72 } ;\n(\"output\") =\u003e { $ crate :: ATOM_LOCALNAME__6F_75_74_70_75_74 } ;\n(\"p\") =\u003e { $ crate :: ATOM_LOCALNAME__70 } ;\n(\"param\") =\u003e { $ crate :: ATOM_LOCALNAME__70_61_72_61_6D } ;\n(\"parse\") =\u003e { $ crate :: ATOM_LOCALNAME__70_61_72_73_65 } ;\n(\"path\") =\u003e { $ crate :: ATOM_LOCALNAME__70_61_74_68 } ;\n(\"pattern\") =\u003e { $ crate :: ATOM_LOCALNAME__70_61_74_74_65_72_6E } ;\n(\"pi\") =\u003e { $ crate :: ATOM_LOCALNAME__70_69 } ;\n(\"picture\") =\u003e { $ crate :: ATOM_LOCALNAME__70_69_63_74_75_72_65 } ;\n(\"piece\") =\u003e { $ crate :: ATOM_LOCALNAME__70_69_65_63_65 } ;\n(\"ping\") =\u003e { $ crate :: ATOM_LOCALNAME__70_69_6E_67 } ;\n(\"plus\") =\u003e { $ crate :: ATOM_LOCALNAME__70_6C_75_73 } ;\n(\"points\") =\u003e { $ crate :: ATOM_LOCALNAME__70_6F_69_6E_74_73 } ;\n(\"polygon\") =\u003e { $ crate :: ATOM_LOCALNAME__70_6F_6C_79_67_6F_6E } ;\n(\"poster\") =\u003e { $ crate :: ATOM_LOCALNAME__70_6F_73_74_65_72 } ;\n(\"power\") =\u003e { $ crate :: ATOM_LOCALNAME__70_6F_77_65_72 } ;\n(\"pre\") =\u003e { $ crate :: ATOM_LOCALNAME__70_72_65 } ;\n(\"preload\") =\u003e { $ crate :: ATOM_LOCALNAME__70_72_65_6C_6F_61_64 } ;\n(\"primes\") =\u003e { $ crate :: ATOM_LOCALNAME__70_72_69_6D_65_73 } ;\n(\"product\") =\u003e { $ crate :: ATOM_LOCALNAME__70_72_6F_64_75_63_74 } ;\n(\"profile\") =\u003e { $ crate :: ATOM_LOCALNAME__70_72_6F_66_69_6C_65 } ;\n(\"prompt\") =\u003e { $ crate :: ATOM_LOCALNAME__70_72_6F_6D_70_74 } ;\n(\"q\") =\u003e { $ crate :: ATOM_LOCALNAME__71 } ;\n(\"r\") =\u003e { $ crate :: ATOM_LOCALNAME__72 } ;\n(\"radius\") =\u003e { $ crate :: ATOM_LOCALNAME__72_61_64_69_75_73 } ;\n(\"rb\") =\u003e { $ crate :: ATOM_LOCALNAME__72_62 } ;\n(\"real\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_61_6C } ;\n(\"reals\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_61_6C_73 } ;\n(\"rect\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_63_74 } ;\n(\"refX\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_66_58 } ;\n(\"refY\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_66_59 } ;\n(\"refx\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_66_78 } ;\n(\"refy\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_66_79 } ;\n(\"rel\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_6C } ;\n(\"reln\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_6C_6E } ;\n(\"rem\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_6D } ;\n(\"repeat\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_70_65_61_74 } ;\n(\"replace\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_70_6C_61_63_65 } ;\n(\"restart\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_73_74_61_72_74 } ;\n(\"result\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_73_75_6C_74 } ;\n(\"rev\") =\u003e { $ crate :: ATOM_LOCALNAME__72_65_76 } ;\n(\"role\") =\u003e { $ crate :: ATOM_LOCALNAME__72_6F_6C_65 } ;\n(\"root\") =\u003e { $ crate :: ATOM_LOCALNAME__72_6F_6F_74 } ;\n(\"rotate\") =\u003e { $ crate :: ATOM_LOCALNAME__72_6F_74_61_74_65 } ;\n(\"rows\") =\u003e { $ crate :: ATOM_LOCALNAME__72_6F_77_73 } ;\n(\"rowspan\") =\u003e { $ crate :: ATOM_LOCALNAME__72_6F_77_73_70_61_6E } ;\n(\"rp\") =\u003e { $ crate :: ATOM_LOCALNAME__72_70 } ;\n(\"rquote\") =\u003e { $ crate :: ATOM_LOCALNAME__72_71_75_6F_74_65 } ;\n(\"rspace\") =\u003e { $ crate :: ATOM_LOCALNAME__72_73_70_61_63_65 } ;\n(\"rt\") =\u003e { $ crate :: ATOM_LOCALNAME__72_74 } ;\n(\"rtc\") =\u003e { $ crate :: ATOM_LOCALNAME__72_74_63 } ;\n(\"ruby\") =\u003e { $ crate :: ATOM_LOCALNAME__72_75_62_79 } ;\n(\"rule\") =\u003e { $ crate :: ATOM_LOCALNAME__72_75_6C_65 } ;\n(\"rules\") =\u003e { $ crate :: ATOM_LOCALNAME__72_75_6C_65_73 } ;\n(\"rx\") =\u003e { $ crate :: ATOM_LOCALNAME__72_78 } ;\n(\"ry\") =\u003e { $ crate :: ATOM_LOCALNAME__72_79 } ;\n(\"s\") =\u003e { $ crate :: ATOM_LOCALNAME__73 } ;\n(\"samp\") =\u003e { $ crate :: ATOM_LOCALNAME__73_61_6D_70 } ;\n(\"sandbox\") =\u003e { $ crate :: ATOM_LOCALNAME__73_61_6E_64_62_6F_78 } ;\n(\"scale\") =\u003e { $ crate :: ATOM_LOCALNAME__73_63_61_6C_65 } ;\n(\"scheme\") =\u003e { $ crate :: ATOM_LOCALNAME__73_63_68_65_6D_65 } ;\n(\"scope\") =\u003e { $ crate :: ATOM_LOCALNAME__73_63_6F_70_65 } ;\n(\"scoped\") =\u003e { $ crate :: ATOM_LOCALNAME__73_63_6F_70_65_64 } ;\n(\"script\") =\u003e { $ crate :: ATOM_LOCALNAME__73_63_72_69_70_74 } ;\n(\"sdev\") =\u003e { $ crate :: ATOM_LOCALNAME__73_64_65_76 } ;\n(\"search\") =\u003e { $ crate :: ATOM_LOCALNAME__73_65_61_72_63_68 } ;\n(\"sec\") =\u003e { $ crate :: ATOM_LOCALNAME__73_65_63 } ;\n(\"sech\") =\u003e { $ crate :: ATOM_LOCALNAME__73_65_63_68 } ;\n(\"section\") =\u003e { $ crate :: ATOM_LOCALNAME__73_65_63_74_69_6F_6E } ;\n(\"seed\") =\u003e { $ crate :: ATOM_LOCALNAME__73_65_65_64 } ;\n(\"select\") =\u003e { $ crate :: ATOM_LOCALNAME__73_65_6C_65_63_74 } ;\n(\"sep\") =\u003e { $ crate :: ATOM_LOCALNAME__73_65_70 } ;\n(\"set\") =\u003e { $ crate :: ATOM_LOCALNAME__73_65_74 } ;\n(\"setdiff\") =\u003e { $ crate :: ATOM_LOCALNAME__73_65_74_64_69_66_66 } ;\n(\"shape\") =\u003e { $ crate :: ATOM_LOCALNAME__73_68_61_70_65 } ;\n(\"show\") =\u003e { $ crate :: ATOM_LOCALNAME__73_68_6F_77 } ;\n(\"sin\") =\u003e { $ crate :: ATOM_LOCALNAME__73_69_6E } ;\n(\"sinh\") =\u003e { $ crate :: ATOM_LOCALNAME__73_69_6E_68 } ;\n(\"size\") =\u003e { $ crate :: ATOM_LOCALNAME__73_69_7A_65 } ;\n(\"sizes\") =\u003e { $ crate :: ATOM_LOCALNAME__73_69_7A_65_73 } ;\n(\"slope\") =\u003e { $ crate :: ATOM_LOCALNAME__73_6C_6F_70_65 } ;\n(\"slot\") =\u003e { $ crate :: ATOM_LOCALNAME__73_6C_6F_74 } ;\n(\"small\") =\u003e { $ crate :: ATOM_LOCALNAME__73_6D_61_6C_6C } ;\n(\"source\") =\u003e { $ crate :: ATOM_LOCALNAME__73_6F_75_72_63_65 } ;\n(\"space\") =\u003e { $ crate :: ATOM_LOCALNAME__73_70_61_63_65 } ;\n(\"spacer\") =\u003e { $ crate :: ATOM_LOCALNAME__73_70_61_63_65_72 } ;\n(\"spacing\") =\u003e { $ crate :: ATOM_LOCALNAME__73_70_61_63_69_6E_67 } ;\n(\"span\") =\u003e { $ crate :: ATOM_LOCALNAME__73_70_61_6E } ;\n(\"speed\") =\u003e { $ crate :: ATOM_LOCALNAME__73_70_65_65_64 } ;\n(\"src\") =\u003e { $ crate :: ATOM_LOCALNAME__73_72_63 } ;\n(\"srcdoc\") =\u003e { $ crate :: ATOM_LOCALNAME__73_72_63_64_6F_63 } ;\n(\"srclang\") =\u003e { $ crate :: ATOM_LOCALNAME__73_72_63_6C_61_6E_67 } ;\n(\"srcset\") =\u003e { $ crate :: ATOM_LOCALNAME__73_72_63_73_65_74 } ;\n(\"standby\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_61_6E_64_62_79 } ;\n(\"start\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_61_72_74 } ;\n(\"stemh\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_65_6D_68 } ;\n(\"stemv\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_65_6D_76 } ;\n(\"step\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_65_70 } ;\n(\"stop\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_6F_70 } ;\n(\"strike\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_72_69_6B_65 } ;\n(\"string\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_72_69_6E_67 } ;\n(\"stroke\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_72_6F_6B_65 } ;\n(\"strong\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_72_6F_6E_67 } ;\n(\"style\") =\u003e { $ crate :: ATOM_LOCALNAME__73_74_79_6C_65 } ;\n(\"sub\") =\u003e { $ crate :: ATOM_LOCALNAME__73_75_62 } ;\n(\"subset\") =\u003e { $ crate :: ATOM_LOCALNAME__73_75_62_73_65_74 } ;\n(\"sum\") =\u003e { $ crate :: ATOM_LOCALNAME__73_75_6D } ;\n(\"summary\") =\u003e { $ crate :: ATOM_LOCALNAME__73_75_6D_6D_61_72_79 } ;\n(\"sup\") =\u003e { $ crate :: ATOM_LOCALNAME__73_75_70 } ;\n(\"svg\") =\u003e { $ crate :: ATOM_LOCALNAME__73_76_67 } ;\n(\"switch\") =\u003e { $ crate :: ATOM_LOCALNAME__73_77_69_74_63_68 } ;\n(\"symbol\") =\u003e { $ crate :: ATOM_LOCALNAME__73_79_6D_62_6F_6C } ;\n(\"table\") =\u003e { $ crate :: ATOM_LOCALNAME__74_61_62_6C_65 } ;\n(\"tan\") =\u003e { $ crate :: ATOM_LOCALNAME__74_61_6E } ;\n(\"tanh\") =\u003e { $ crate :: ATOM_LOCALNAME__74_61_6E_68 } ;\n(\"target\") =\u003e { $ crate :: ATOM_LOCALNAME__74_61_72_67_65_74 } ;\n(\"targetX\") =\u003e { $ crate :: ATOM_LOCALNAME__74_61_72_67_65_74_58 } ;\n(\"targetY\") =\u003e { $ crate :: ATOM_LOCALNAME__74_61_72_67_65_74_59 } ;\n(\"targetx\") =\u003e { $ crate :: ATOM_LOCALNAME__74_61_72_67_65_74_78 } ;\n(\"targety\") =\u003e { $ crate :: ATOM_LOCALNAME__74_61_72_67_65_74_79 } ;\n(\"tbody\") =\u003e { $ crate :: ATOM_LOCALNAME__74_62_6F_64_79 } ;\n(\"tbreak\") =\u003e { $ crate :: ATOM_LOCALNAME__74_62_72_65_61_6B } ;\n(\"td\") =\u003e { $ crate :: ATOM_LOCALNAME__74_64 } ;\n(\"tendsto\") =\u003e { $ crate :: ATOM_LOCALNAME__74_65_6E_64_73_74_6F } ;\n(\"text\") =\u003e { $ crate :: ATOM_LOCALNAME__74_65_78_74 } ;\n(\"tfoot\") =\u003e { $ crate :: ATOM_LOCALNAME__74_66_6F_6F_74 } ;\n(\"th\") =\u003e { $ crate :: ATOM_LOCALNAME__74_68 } ;\n(\"thead\") =\u003e { $ crate :: ATOM_LOCALNAME__74_68_65_61_64 } ;\n(\"time\") =\u003e { $ crate :: ATOM_LOCALNAME__74_69_6D_65 } ;\n(\"times\") =\u003e { $ crate :: ATOM_LOCALNAME__74_69_6D_65_73 } ;\n(\"title\") =\u003e { $ crate :: ATOM_LOCALNAME__74_69_74_6C_65 } ;\n(\"to\") =\u003e { $ crate :: ATOM_LOCALNAME__74_6F } ;\n(\"toggle\") =\u003e { $ crate :: ATOM_LOCALNAME__74_6F_67_67_6C_65 } ;\n(\"tr\") =\u003e { $ crate :: ATOM_LOCALNAME__74_72 } ;\n(\"track\") =\u003e { $ crate :: ATOM_LOCALNAME__74_72_61_63_6B } ;\n(\"tref\") =\u003e { $ crate :: ATOM_LOCALNAME__74_72_65_66 } ;\n(\"true\") =\u003e { $ crate :: ATOM_LOCALNAME__74_72_75_65 } ;\n(\"tspan\") =\u003e { $ crate :: ATOM_LOCALNAME__74_73_70_61_6E } ;\n(\"tt\") =\u003e { $ crate :: ATOM_LOCALNAME__74_74 } ;\n(\"type\") =\u003e { $ crate :: ATOM_LOCALNAME__74_79_70_65 } ;\n(\"u\") =\u003e { $ crate :: ATOM_LOCALNAME__75 } ;\n(\"u1\") =\u003e { $ crate :: ATOM_LOCALNAME__75_31 } ;\n(\"u2\") =\u003e { $ crate :: ATOM_LOCALNAME__75_32 } ;\n(\"ul\") =\u003e { $ crate :: ATOM_LOCALNAME__75_6C } ;\n(\"unicode\") =\u003e { $ crate :: ATOM_LOCALNAME__75_6E_69_63_6F_64_65 } ;\n(\"union\") =\u003e { $ crate :: ATOM_LOCALNAME__75_6E_69_6F_6E } ;\n(\"uplimit\") =\u003e { $ crate :: ATOM_LOCALNAME__75_70_6C_69_6D_69_74 } ;\n(\"use\") =\u003e { $ crate :: ATOM_LOCALNAME__75_73_65 } ;\n(\"usemap\") =\u003e { $ crate :: ATOM_LOCALNAME__75_73_65_6D_61_70 } ;\n(\"valign\") =\u003e { $ crate :: ATOM_LOCALNAME__76_61_6C_69_67_6E } ;\n(\"value\") =\u003e { $ crate :: ATOM_LOCALNAME__76_61_6C_75_65 } ;\n(\"values\") =\u003e { $ crate :: ATOM_LOCALNAME__76_61_6C_75_65_73 } ;\n(\"var\") =\u003e { $ crate :: ATOM_LOCALNAME__76_61_72 } ;\n(\"vector\") =\u003e { $ crate :: ATOM_LOCALNAME__76_65_63_74_6F_72 } ;\n(\"version\") =\u003e { $ crate :: ATOM_LOCALNAME__76_65_72_73_69_6F_6E } ;\n(\"video\") =\u003e { $ crate :: ATOM_LOCALNAME__76_69_64_65_6F } ;\n(\"view\") =\u003e { $ crate :: ATOM_LOCALNAME__76_69_65_77 } ;\n(\"viewBox\") =\u003e { $ crate :: ATOM_LOCALNAME__76_69_65_77_42_6F_78 } ;\n(\"viewbox\") =\u003e { $ crate :: ATOM_LOCALNAME__76_69_65_77_62_6F_78 } ;\n(\"vkern\") =\u003e { $ crate :: ATOM_LOCALNAME__76_6B_65_72_6E } ;\n(\"vlink\") =\u003e { $ crate :: ATOM_LOCALNAME__76_6C_69_6E_6B } ;\n(\"vspace\") =\u003e { $ crate :: ATOM_LOCALNAME__76_73_70_61_63_65 } ;\n(\"wbr\") =\u003e { $ crate :: ATOM_LOCALNAME__77_62_72 } ;\n(\"when\") =\u003e { $ crate :: ATOM_LOCALNAME__77_68_65_6E } ;\n(\"width\") =\u003e { $ crate :: ATOM_LOCALNAME__77_69_64_74_68 } ;\n(\"widths\") =\u003e { $ crate :: ATOM_LOCALNAME__77_69_64_74_68_73 } ;\n(\"wrap\") =\u003e { $ crate :: ATOM_LOCALNAME__77_72_61_70 } ;\n(\"x\") =\u003e { $ crate :: ATOM_LOCALNAME__78 } ;\n(\"x1\") =\u003e { $ crate :: ATOM_LOCALNAME__78_31 } ;\n(\"x2\") =\u003e { $ crate :: ATOM_LOCALNAME__78_32 } ;\n(\"xlink\") =\u003e { $ crate :: ATOM_LOCALNAME__78_6C_69_6E_6B } ;\n(\"xmlns\") =\u003e { $ crate :: ATOM_LOCALNAME__78_6D_6C_6E_73 } ;\n(\"xmp\") =\u003e { $ crate :: ATOM_LOCALNAME__78_6D_70 } ;\n(\"xor\") =\u003e { $ crate :: ATOM_LOCALNAME__78_6F_72 } ;\n(\"xref\") =\u003e { $ crate :: ATOM_LOCALNAME__78_72_65_66 } ;\n(\"y\") =\u003e { $ crate :: ATOM_LOCALNAME__79 } ;\n(\"y1\") =\u003e { $ crate :: ATOM_LOCALNAME__79_31 } ;\n(\"y2\") =\u003e { $ crate :: ATOM_LOCALNAME__79_32 } ;\n(\"z\") =\u003e { $ crate :: ATOM_LOCALNAME__7A } ;\n}pub type Prefix = :: string_cache :: Atom \u003c PrefixStaticSet \u003e ;\n# [derive (PartialEq , Eq , PartialOrd , Ord)] pub struct PrefixStaticSet ;\nimpl :: string_cache :: StaticAtomSet for PrefixStaticSet { fn get () -\u003e \u0026 'static :: string_cache :: PhfStrSet { static SET : :: string_cache :: PhfStrSet = :: string_cache :: PhfStrSet { key : 12913932095322966823u64 , disps : \u0026 [(0u32 , 0u32)] , atoms : \u0026 [\"\"] , hashes : \u0026 [4082073077u32] } ;\n\u0026 SET } fn empty_string_index () -\u003e u32 { 0u32 } } pub const ATOM_PREFIX_ : Prefix = Prefix :: pack_static (0u32) ;\npub const ATOM_PREFIX__2A : Prefix = Prefix :: pack_inline (10752u64 , 1u8) ;\npub const ATOM_PREFIX__68_74_6D_6C : Prefix = Prefix :: pack_inline (465692813312u64 , 4u8) ;\npub const ATOM_PREFIX__6D_61_74_68_6D_6C : Prefix = Prefix :: pack_inline (30519592881319168u64 , 6u8) ;\npub const ATOM_PREFIX__73_76_67 : Prefix = Prefix :: pack_inline (1735815936u64 , 3u8) ;\npub const ATOM_PREFIX__78_6C_69_6E_6B : Prefix = Prefix :: pack_inline (118121959290880u64 , 5u8) ;\npub const ATOM_PREFIX__78_6D_6C : Prefix = Prefix :: pack_inline (1819113472u64 , 3u8) ;\npub const ATOM_PREFIX__78_6D_6C_6E_73 : Prefix = Prefix :: pack_inline (126918102710272u64 , 5u8) ;\n# [doc = \"Takes a namespace prefix string and returns its key in a string cache.\"] # [macro_export] macro_rules ! namespace_prefix { (\"\") =\u003e { $ crate :: ATOM_PREFIX_ } ;\n(\"*\") =\u003e { $ crate :: ATOM_PREFIX__2A } ;\n(\"html\") =\u003e { $ crate :: ATOM_PREFIX__68_74_6D_6C } ;\n(\"mathml\") =\u003e { $ crate :: ATOM_PREFIX__6D_61_74_68_6D_6C } ;\n(\"svg\") =\u003e { $ crate :: ATOM_PREFIX__73_76_67 } ;\n(\"xlink\") =\u003e { $ crate :: ATOM_PREFIX__78_6C_69_6E_6B } ;\n(\"xml\") =\u003e { $ crate :: ATOM_PREFIX__78_6D_6C } ;\n(\"xmlns\") =\u003e { $ crate :: ATOM_PREFIX__78_6D_6C_6E_73 } ;\n}pub type Namespace = :: string_cache :: Atom \u003c NamespaceStaticSet \u003e ;\n# [derive (PartialEq , Eq , PartialOrd , Ord)] pub struct NamespaceStaticSet ;\nimpl :: string_cache :: StaticAtomSet for NamespaceStaticSet { fn get () -\u003e \u0026 'static :: string_cache :: PhfStrSet { static SET : :: string_cache :: PhfStrSet = :: string_cache :: PhfStrSet { key : 15467950696543387533u64 , disps : \u0026 [(1u32 , 0u32) , (1u32 , 4u32)] , atoms : \u0026 [\"http://www.w3.org/1999/xhtml\",\n\"http://www.w3.org/2000/svg\",\n\"http://www.w3.org/XML/1998/namespace\",\n\"http://www.w3.org/1998/Math/MathML\",\n\"http://www.w3.org/1999/xlink\",\n\"\",\n\"http://www.w3.org/2000/xmlns/\"] , hashes : \u0026 [1895391709u32 , 3069293938u32 , 2770585642u32 , 1216229735u32 , 2535599242u32 , 811901650u32 , 830072559u32] } ;\n\u0026 SET } fn empty_string_index () -\u003e u32 { 5u32 } } pub const ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_31_39_39_39_2F_78_68_74_6D_6C : Namespace = Namespace :: pack_static (0u32) ;\npub const ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_32_30_30_30_2F_73_76_67 : Namespace = Namespace :: pack_static (1u32) ;\npub const ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_58_4D_4C_2F_31_39_39_38_2F_6E_61_6D_65_73_70_61_63_65 : Namespace = Namespace :: pack_static (2u32) ;\npub const ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_31_39_39_38_2F_4D_61_74_68_2F_4D_61_74_68_4D_4C : Namespace = Namespace :: pack_static (3u32) ;\npub const ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_31_39_39_39_2F_78_6C_69_6E_6B : Namespace = Namespace :: pack_static (4u32) ;\npub const ATOM_NAMESPACE_ : Namespace = Namespace :: pack_static (5u32) ;\npub const ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_32_30_30_30_2F_78_6D_6C_6E_73_2F : Namespace = Namespace :: pack_static (6u32) ;\npub const ATOM_NAMESPACE__2A : Namespace = Namespace :: pack_inline (10752u64 , 1u8) ;\n# [doc = \"Takes a namespace url string and returns its key in a string cache.\"] # [macro_export] macro_rules ! namespace_url { (\"http://www.w3.org/1999/xhtml\") =\u003e { $ crate :: ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_31_39_39_39_2F_78_68_74_6D_6C } ;\n(\"http://www.w3.org/2000/svg\") =\u003e { $ crate :: ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_32_30_30_30_2F_73_76_67 } ;\n(\"http://www.w3.org/XML/1998/namespace\") =\u003e { $ crate :: ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_58_4D_4C_2F_31_39_39_38_2F_6E_61_6D_65_73_70_61_63_65 } ;\n(\"http://www.w3.org/1998/Math/MathML\") =\u003e { $ crate :: ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_31_39_39_38_2F_4D_61_74_68_2F_4D_61_74_68_4D_4C } ;\n(\"http://www.w3.org/1999/xlink\") =\u003e { $ crate :: ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_31_39_39_39_2F_78_6C_69_6E_6B } ;\n(\"\") =\u003e { $ crate :: ATOM_NAMESPACE_ } ;\n(\"http://www.w3.org/2000/xmlns/\") =\u003e { $ crate :: ATOM_NAMESPACE__68_74_74_70_3A_2F_2F_77_77_77_2E_77_33_2E_6F_72_67_2F_32_30_30_30_2F_78_6D_6C_6E_73_2F } ;\n(\"*\") =\u003e { $ crate :: ATOM_NAMESPACE__2A } ;\n}\n        /// Maps the input of [`namespace_prefix!`](macro.namespace_prefix.html) to \n        /// the output of [`namespace_url!`](macro.namespace_url.html).\n        ///\n        #[macro_export] macro_rules! ns {\n        \n() =\u003e { namespace_url!(\"\") };\n(*) =\u003e { namespace_url!(\"*\") };\n(html) =\u003e { namespace_url!(\"http://www.w3.org/1999/xhtml\") };\n(xml) =\u003e { namespace_url!(\"http://www.w3.org/XML/1998/namespace\") };\n(xmlns) =\u003e { namespace_url!(\"http://www.w3.org/2000/xmlns/\") };\n(xlink) =\u003e { namespace_url!(\"http://www.w3.org/1999/xlink\") };\n(svg) =\u003e { namespace_url!(\"http://www.w3.org/2000/svg\") };\n(mathml) =\u003e { namespace_url!(\"http://www.w3.org/1998/Math/MathML\") };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","python","target","release","build","markup5ever-a337ab0d82c5f354","out","named_entities.rs"],"content":"\n/// A map of entity names to their codepoints. The second codepoint will\n/// be 0 if the entity contains a single codepoint. Entities have their preceding '\u0026' removed.\n///\n/// # Examples\n///\n/// ```\n/// use markup5ever::data::NAMED_ENTITIES;\n///\n/// assert_eq!(NAMED_ENTITIES.get(\"gt;\").unwrap(), \u0026(62, 0));\n/// ```\n\npub static NAMED_ENTITIES: Map\u003c\u0026'static str, (u32, u32)\u003e = ::phf::Map {\n    key: 12913932095322966823,\n    disps: \u0026[\n        (0, 147),\n        (0, 2),\n        (0, 236),\n        (0, 9),\n        (0, 66),\n        (0, 0),\n        (0, 38),\n        (0, 154),\n        (0, 0),\n        (0, 2),\n        (0, 777),\n        (0, 73),\n        (0, 65),\n        (0, 0),\n        (0, 1),\n        (0, 0),\n        (0, 24),\n        (0, 131),\n        (0, 0),\n        (0, 5),\n        (0, 0),\n        (0, 193),\n        (0, 25),\n        (0, 7),\n        (0, 442),\n        (0, 154),\n        (0, 240),\n        (0, 8),\n        (0, 6),\n        (0, 53),\n        (0, 17),\n        (0, 4),\n        (0, 35),\n        (0, 346),\n        (0, 91),\n        (0, 85),\n        (0, 89),\n        (0, 0),\n        (0, 787),\n        (0, 27),\n        (0, 1),\n        (0, 4),\n        (0, 7),\n        (0, 79),\n        (0, 7),\n        (0, 44),\n        (0, 82),\n        (0, 437),\n        (0, 4),\n        (0, 58),\n        (0, 3),\n        (0, 51),\n        (0, 1),\n        (0, 65),\n        (0, 249),\n        (0, 9),\n        (0, 1),\n        (0, 66),\n        (0, 30),\n        (0, 1244),\n        (0, 21),\n        (0, 1),\n        (0, 15),\n        (0, 510),\n        (0, 5),\n        (0, 0),\n        (0, 9),\n        (0, 0),\n        (0, 5),\n        (0, 86),\n        (0, 46),\n        (0, 118),\n        (0, 28),\n        (0, 30),\n        (0, 0),\n        (0, 0),\n        (0, 0),\n        (0, 1009),\n        (0, 1),\n        (0, 10),\n        (0, 259),\n        (0, 326),\n        (0, 29),\n        (0, 1),\n        (0, 0),\n        (0, 889),\n        (0, 9),\n        (0, 165),\n        (0, 73),\n        (0, 19),\n        (0, 69),\n        (0, 237),\n        (0, 6),\n        (0, 686),\n        (0, 2),\n        (0, 6),\n        (0, 83),\n        (0, 1955),\n        (0, 116),\n        (0, 161),\n        (0, 2),\n        (0, 88),\n        (0, 10),\n        (0, 1066),\n        (0, 1),\n        (0, 1414),\n        (0, 3),\n        (0, 57),\n        (0, 10),\n        (0, 9),\n        (0, 276),\n        (0, 464),\n        (0, 26),\n        (0, 458),\n        (0, 9),\n        (0, 699),\n        (0, 117),\n        (0, 1136),\n        (0, 26),\n        (0, 218),\n        (0, 31),\n        (0, 46),\n        (0, 261),\n        (0, 183),\n        (0, 319),\n        (0, 1553),\n        (0, 232),\n        (0, 1),\n        (0, 1279),\n        (0, 13),\n        (0, 8),\n        (0, 1),\n        (0, 1728),\n        (0, 600),\n        (0, 4),\n        (0, 584),\n        (0, 1),\n        (0, 146),\n        (0, 342),\n        (0, 1442),\n        (0, 223),\n        (0, 473),\n        (0, 230),\n        (0, 510),\n        (0, 19),\n        (0, 255),\n        (0, 90),\n        (0, 152),\n        (0, 1),\n        (0, 1773),\n        (0, 3333),\n        (0, 1),\n        (0, 1855),\n        (0, 30),\n        (0, 1151),\n        (0, 132),\n        (0, 980),\n        (0, 0),\n        (0, 11),\n        (0, 1021),\n        (0, 398),\n        (0, 2985),\n        (0, 936),\n        (0, 26),\n        (0, 1563),\n        (0, 15),\n        (0, 26),\n        (0, 2),\n        (0, 570),\n        (0, 868),\n        (0, 200),\n        (0, 302),\n        (0, 27),\n        (0, 686),\n        (0, 196),\n        (0, 16),\n        (0, 33),\n        (0, 19),\n        (0, 162),\n        (0, 11),\n        (0, 24),\n        (0, 8),\n        (0, 7),\n        (0, 83),\n        (0, 766),\n        (0, 8),\n        (0, 1639),\n        (0, 555),\n        (0, 191),\n        (0, 0),\n        (0, 4),\n        (0, 28),\n        (0, 32),\n        (0, 25),\n        (0, 564),\n        (0, 11),\n        (0, 3),\n        (0, 8),\n        (0, 25),\n        (0, 3),\n        (0, 225),\n        (0, 47),\n        (0, 274),\n        (0, 51),\n        (0, 60),\n        (0, 2),\n        (0, 142),\n        (0, 84),\n        (0, 1236),\n        (0, 374),\n        (0, 528),\n        (0, 742),\n        (0, 156),\n        (0, 1),\n        (0, 0),\n        (0, 148),\n        (0, 7),\n        (0, 1),\n        (0, 5),\n        (0, 174),\n        (0, 479),\n        (0, 465),\n        (0, 125),\n        (0, 94),\n        (0, 8),\n        (0, 63),\n        (0, 119),\n        (0, 844),\n        (0, 147),\n        (0, 1),\n        (0, 325),\n        (0, 224),\n        (0, 1),\n        (0, 757),\n        (0, 4),\n        (0, 2),\n        (0, 69),\n        (0, 17),\n        (0, 165),\n        (0, 118),\n        (0, 20),\n        (0, 88),\n        (0, 12),\n        (0, 184),\n        (0, 1),\n        (0, 349),\n        (0, 319),\n        (0, 22),\n        (0, 247),\n        (0, 15),\n        (0, 255),\n        (0, 0),\n        (0, 0),\n        (0, 4),\n        (0, 0),\n        (0, 1951),\n        (0, 18),\n        (0, 58),\n        (0, 620),\n        (0, 495),\n        (0, 5),\n        (0, 2),\n        (0, 1166),\n        (0, 2),\n        (0, 0),\n        (0, 29),\n        (0, 2),\n        (0, 51),\n        (0, 7),\n        (0, 1075),\n        (0, 48),\n        (0, 680),\n        (0, 2970),\n        (0, 1),\n        (0, 255),\n        (0, 16),\n        (0, 57),\n        (0, 13),\n        (0, 2),\n        (0, 364),\n        (0, 75),\n        (0, 1821),\n        (0, 1),\n        (0, 0),\n        (0, 2),\n        (0, 10),\n        (0, 372),\n        (0, 6),\n        (0, 123),\n        (0, 1753),\n        (0, 103),\n        (0, 2),\n        (0, 2),\n        (0, 441),\n        (0, 38),\n        (0, 3),\n        (0, 4),\n        (0, 79),\n        (0, 0),\n        (0, 1),\n        (0, 272),\n        (0, 3),\n        (0, 2),\n        (0, 0),\n        (0, 42),\n        (0, 522),\n        (0, 42),\n        (0, 462),\n        (0, 31),\n        (0, 3),\n        (0, 18),\n        (0, 88),\n        (0, 13),\n        (0, 47),\n        (0, 2005),\n        (0, 76),\n        (0, 88),\n        (0, 18),\n        (0, 36),\n        (0, 26),\n        (0, 29),\n        (0, 7),\n        (0, 47),\n        (0, 14),\n        (0, 46),\n        (0, 169),\n        (0, 205),\n        (0, 1),\n        (0, 100),\n        (0, 523),\n        (0, 93),\n        (0, 23),\n        (0, 6),\n        (0, 74),\n        (0, 1),\n        (0, 4),\n        (0, 4),\n        (0, 115),\n        (0, 6),\n        (0, 5511),\n        (0, 6),\n        (0, 815),\n        (0, 2),\n        (0, 123),\n        (0, 332),\n        (0, 693),\n        (0, 328),\n        (0, 752),\n        (0, 39),\n        (0, 13),\n        (0, 101),\n        (0, 0),\n        (0, 2031),\n        (0, 65),\n        (0, 842),\n        (0, 13),\n        (0, 5),\n        (0, 1114),\n        (0, 25),\n        (0, 167),\n        (0, 457),\n        (0, 828),\n        (0, 156),\n        (0, 2),\n        (0, 500),\n        (0, 0),\n        (0, 348),\n        (0, 0),\n        (0, 15),\n        (0, 4),\n        (0, 7),\n        (0, 0),\n        (0, 596),\n        (0, 531),\n        (0, 92),\n        (0, 79),\n        (0, 1122),\n        (0, 108),\n        (0, 44),\n        (0, 75),\n        (0, 225),\n        (0, 438),\n        (0, 37),\n        (0, 12),\n        (0, 1),\n        (0, 1095),\n        (0, 131),\n        (0, 36),\n        (0, 299),\n        (0, 784),\n        (0, 1576),\n        (0, 396),\n        (0, 6),\n        (0, 0),\n        (0, 219),\n        (0, 6),\n        (0, 233),\n        (0, 726),\n        (0, 22),\n        (0, 301),\n        (0, 28),\n        (0, 1363),\n        (0, 45),\n        (0, 1761),\n        (0, 0),\n        (0, 744),\n        (0, 25),\n        (0, 2),\n        (0, 10),\n        (0, 6),\n        (0, 2),\n        (0, 1417),\n        (0, 822),\n        (0, 101),\n        (0, 4),\n        (0, 60),\n        (0, 226),\n        (0, 28),\n        (0, 13),\n        (0, 598),\n        (0, 4),\n        (0, 75),\n        (0, 2555),\n        (0, 6),\n        (0, 0),\n        (0, 74),\n        (0, 256),\n        (0, 11),\n        (0, 0),\n        (0, 231),\n        (0, 0),\n        (0, 4),\n        (0, 409),\n        (0, 68),\n        (0, 19),\n        (0, 176),\n        (0, 1),\n        (0, 416),\n        (0, 903),\n        (0, 28),\n        (0, 4),\n        (0, 287),\n        (0, 1781),\n        (0, 2163),\n        (0, 19),\n        (0, 3),\n        (0, 173),\n        (0, 1),\n        (0, 195),\n        (0, 67),\n        (0, 14),\n        (0, 157),\n        (0, 1),\n        (0, 130),\n        (0, 44),\n        (0, 68),\n        (0, 19),\n        (0, 11),\n        (0, 14),\n        (0, 198),\n        (0, 2),\n        (0, 30),\n        (0, 457),\n        (0, 634),\n        (0, 365),\n        (0, 10),\n        (0, 68),\n        (0, 63),\n        (0, 850),\n        (0, 28),\n        (0, 57),\n        (0, 638),\n        (0, 33),\n        (0, 250),\n        (0, 228),\n        (0, 2719),\n        (0, 21),\n        (0, 1),\n        (0, 71),\n        (0, 0),\n        (0, 132),\n        (0, 551),\n        (0, 23),\n        (0, 0),\n        (0, 831),\n        (0, 3),\n        (0, 2),\n        (0, 0),\n        (0, 7),\n        (0, 4873),\n        (0, 285),\n        (0, 21),\n        (0, 232),\n        (0, 1950),\n        (0, 164),\n        (0, 33),\n        (0, 237),\n        (0, 0),\n        (0, 1755),\n        (0, 0),\n        (0, 1922),\n        (0, 80),\n        (0, 4),\n        (0, 319),\n        (0, 6),\n        (0, 65),\n        (0, 1664),\n        (0, 319),\n        (0, 176),\n        (0, 784),\n        (0, 4),\n        (0, 15),\n        (0, 15),\n        (0, 4),\n        (0, 1),\n        (0, 8),\n        (0, 1009),\n        (0, 123),\n        (0, 83),\n        (0, 0),\n        (0, 25),\n        (0, 66),\n        (0, 11),\n        (0, 18),\n        (0, 7),\n        (0, 136),\n        (0, 0),\n        (0, 6),\n        (0, 648),\n        (0, 424),\n        (0, 0),\n        (0, 100),\n        (0, 579),\n        (0, 74),\n        (0, 6),\n        (0, 188),\n        (0, 3469),\n        (0, 293),\n        (0, 1),\n        (0, 145),\n        (0, 87),\n        (0, 46),\n        (0, 1088),\n        (0, 45),\n        (0, 131),\n        (0, 2375),\n        (0, 87),\n        (0, 2),\n        (0, 0),\n        (0, 1),\n        (0, 0),\n        (0, 167),\n        (0, 29),\n        (0, 121),\n        (0, 249),\n        (0, 9),\n        (0, 260),\n        (0, 24),\n        (0, 143),\n        (0, 59),\n        (0, 321),\n        (0, 273),\n        (0, 86),\n        (0, 457),\n        (0, 1028),\n        (0, 1327),\n        (0, 1093),\n        (0, 53),\n        (0, 324),\n        (0, 17),\n        (0, 7),\n        (0, 441),\n        (0, 312),\n        (0, 701),\n        (0, 10),\n        (0, 473),\n        (0, 2398),\n        (0, 460),\n        (0, 0),\n        (0, 364),\n        (0, 394),\n        (0, 334),\n        (0, 156),\n        (0, 560),\n        (0, 366),\n        (0, 456),\n        (0, 609),\n        (0, 224),\n        (0, 51),\n        (0, 972),\n        (0, 48),\n        (0, 964),\n        (0, 0),\n        (0, 0),\n        (0, 1371),\n        (0, 104),\n        (0, 73),\n        (0, 463),\n        (0, 1),\n        (0, 24),\n        (0, 40),\n        (0, 2),\n        (0, 162),\n        (0, 1),\n        (0, 49),\n        (0, 0),\n        (0, 0),\n        (0, 352),\n        (0, 243),\n        (0, 679),\n        (0, 64),\n        (0, 473),\n        (0, 95),\n        (0, 215),\n        (0, 312),\n        (0, 141),\n        (0, 4),\n        (0, 1024),\n        (0, 0),\n        (0, 1211),\n        (0, 11),\n        (0, 8),\n        (0, 25),\n        (0, 194),\n        (0, 261),\n        (0, 25),\n        (0, 145),\n        (0, 69),\n        (0, 125),\n        (0, 1),\n        (0, 2),\n        (0, 198),\n        (0, 180),\n        (0, 350),\n        (0, 1),\n        (0, 36),\n        (0, 340),\n        (0, 29),\n        (0, 99),\n        (0, 868),\n        (0, 0),\n        (0, 542),\n        (0, 255),\n        (0, 273),\n        (0, 12),\n        (0, 975),\n        (0, 3664),\n        (0, 206),\n        (0, 240),\n        (0, 2),\n        (0, 838),\n        (0, 316),\n        (0, 107),\n        (0, 1),\n        (0, 53),\n        (0, 62),\n        (0, 3),\n        (0, 1500),\n        (0, 1009),\n        (0, 145),\n        (0, 243),\n        (0, 1418),\n        (0, 6),\n        (0, 51),\n        (0, 225),\n        (0, 85),\n        (0, 10),\n        (0, 1),\n        (0, 69),\n        (0, 36),\n        (0, 22),\n        (0, 3),\n        (0, 69),\n        (0, 8),\n        (0, 47),\n        (0, 1351),\n        (0, 283),\n        (0, 12),\n        (0, 226),\n        (0, 603),\n        (0, 62),\n        (0, 2070),\n        (0, 8),\n        (0, 2),\n        (0, 631),\n        (0, 276),\n        (0, 449),\n        (0, 115),\n        (0, 240),\n        (0, 27),\n        (0, 1106),\n        (0, 7),\n        (0, 1),\n        (0, 85),\n        (0, 0),\n        (0, 42),\n        (0, 7),\n        (0, 1),\n        (0, 1611),\n        (0, 17),\n        (0, 0),\n        (0, 1),\n        (0, 143),\n        (0, 257),\n        (0, 220),\n        (0, 397),\n        (0, 353),\n        (0, 1),\n        (0, 5),\n        (0, 935),\n        (0, 1),\n        (0, 9),\n        (0, 5),\n        (0, 53),\n        (0, 4),\n        (0, 2559),\n        (0, 37),\n        (0, 75),\n        (0, 540),\n        (0, 2488),\n        (0, 136),\n        (0, 236),\n        (0, 57),\n        (0, 12),\n        (0, 54),\n        (0, 14),\n        (0, 648),\n        (0, 4),\n        (0, 0),\n        (0, 9),\n        (0, 635),\n        (0, 0),\n        (0, 357),\n        (0, 115),\n        (0, 91),\n        (0, 7),\n        (0, 221),\n        (0, 892),\n        (0, 2383),\n        (0, 551),\n        (0, 29),\n        (0, 18),\n        (0, 1416),\n        (0, 2697),\n        (0, 69),\n        (0, 131),\n        (0, 97),\n        (0, 1671),\n        (0, 39),\n        (0, 0),\n        (0, 179),\n        (0, 0),\n        (0, 360),\n        (0, 144),\n        (0, 649),\n        (0, 1516),\n        (0, 163),\n        (0, 52),\n        (0, 5),\n        (0, 531),\n        (0, 1028),\n        (0, 121),\n        (0, 204),\n        (0, 364),\n        (0, 867),\n        (0, 123),\n        (0, 38),\n        (0, 8),\n        (0, 2334),\n        (0, 9),\n        (0, 34),\n        (0, 351),\n        (0, 166),\n        (0, 1),\n        (0, 902),\n        (0, 832),\n        (0, 117),\n        (0, 256),\n        (0, 41),\n        (0, 4846),\n        (0, 444),\n        (0, 225),\n        (0, 25),\n        (0, 0),\n        (0, 1963),\n        (0, 0),\n        (0, 1834),\n        (0, 90),\n        (0, 30),\n        (0, 1786),\n        (0, 6),\n        (0, 42),\n        (0, 284),\n        (0, 281),\n        (0, 192),\n        (0, 11),\n        (0, 187),\n        (0, 2),\n        (0, 7),\n        (0, 4),\n        (0, 33),\n        (0, 847),\n        (0, 1),\n        (0, 0),\n        (0, 223),\n        (0, 52),\n        (0, 979),\n        (0, 11),\n        (0, 6),\n        (0, 121),\n        (0, 337),\n        (0, 92),\n        (0, 49),\n        (0, 87),\n        (0, 596),\n        (0, 58),\n        (0, 0),\n        (0, 0),\n        (0, 30),\n        (0, 19),\n        (0, 4),\n        (0, 849),\n        (0, 0),\n        (0, 12),\n        (0, 145),\n        (0, 857),\n        (0, 1),\n        (0, 177),\n        (0, 45),\n        (0, 3),\n        (0, 18),\n        (0, 5),\n        (0, 59),\n        (0, 1254),\n        (0, 335),\n        (0, 16),\n        (0, 26),\n        (0, 15),\n        (0, 1733),\n        (0, 1),\n        (0, 0),\n        (0, 1006),\n        (0, 1001),\n        (0, 219),\n        (0, 12),\n        (0, 271),\n        (0, 5),\n        (0, 34),\n        (0, 7),\n        (0, 11),\n        (0, 1),\n        (0, 12),\n        (0, 102),\n        (0, 31),\n        (0, 65),\n        (0, 408),\n        (0, 12),\n        (0, 2),\n        (0, 88),\n        (0, 3280),\n        (0, 93),\n        (0, 4546),\n        (0, 1530),\n        (0, 14),\n        (0, 26),\n        (0, 34),\n        (0, 4),\n        (0, 1),\n        (0, 279),\n        (0, 696),\n        (0, 64),\n        (0, 221),\n        (0, 39),\n        (0, 71),\n        (0, 81),\n        (0, 0),\n        (0, 15),\n        (0, 210),\n        (0, 72),\n        (0, 696),\n        (0, 2337),\n        (0, 954),\n        (0, 170),\n        (0, 1415),\n        (0, 180),\n        (0, 2104),\n        (0, 4),\n        (0, 38),\n        (0, 2),\n        (0, 5),\n        (0, 14),\n        (0, 98),\n        (0, 1),\n        (0, 193),\n        (0, 188),\n        (0, 61),\n        (0, 91),\n        (0, 1085),\n        (0, 586),\n        (0, 20),\n        (0, 611),\n        (0, 33),\n        (0, 5063),\n        (0, 0),\n        (0, 3200),\n        (0, 22),\n        (0, 757),\n        (0, 51),\n        (0, 1),\n        (0, 6),\n        (0, 150),\n        (0, 7),\n        (0, 1),\n        (0, 51),\n        (0, 526),\n        (0, 30),\n        (0, 0),\n        (0, 193),\n        (0, 482),\n        (0, 38),\n        (0, 2391),\n        (0, 2),\n        (0, 27),\n        (0, 30),\n        (0, 35),\n        (0, 0),\n        (0, 0),\n        (0, 1),\n        (0, 131),\n        (0, 2952),\n        (0, 38),\n        (0, 215),\n        (0, 5),\n        (0, 0),\n        (0, 1659),\n        (0, 181),\n        (0, 39),\n        (0, 23),\n        (0, 14),\n        (0, 3862),\n        (0, 197),\n        (0, 1),\n        (0, 0),\n        (0, 2428),\n        (0, 239),\n        (0, 1),\n        (0, 0),\n        (0, 106),\n        (0, 0),\n        (0, 9),\n        (0, 0),\n        (0, 85),\n        (0, 867),\n        (0, 205),\n        (0, 138),\n        (0, 1413),\n        (0, 70),\n        (0, 498),\n        (0, 1),\n        (0, 2269),\n        (0, 16),\n        (0, 6),\n        (0, 0),\n        (0, 2),\n        (0, 30),\n        (0, 282),\n        (0, 566),\n        (0, 54),\n        (0, 54),\n        (0, 182),\n        (0, 131),\n        (0, 1240),\n        (0, 89),\n        (0, 15),\n        (0, 36),\n        (0, 450),\n        (0, 9),\n        (0, 79),\n        (0, 2435),\n        (0, 5),\n        (0, 1589),\n        (0, 2),\n        (0, 97),\n        (0, 962),\n        (0, 21),\n        (0, 36),\n        (0, 409),\n        (0, 537),\n        (0, 1068),\n        (0, 9),\n        (0, 126),\n        (0, 830),\n        (0, 1),\n        (0, 1392),\n        (0, 1),\n        (0, 55),\n        (0, 2),\n        (0, 1),\n        (0, 305),\n        (0, 3260),\n        (0, 427),\n        (0, 262),\n        (0, 5),\n        (0, 253),\n        (0, 879),\n        (0, 52),\n        (0, 160),\n        (0, 4056),\n        (0, 3806),\n        (0, 6),\n        (0, 1539),\n        (0, 9),\n        (0, 580),\n        (0, 198),\n        (0, 617),\n        (0, 65),\n        (0, 14),\n        (0, 2),\n        (0, 50),\n        (0, 0),\n        (0, 50),\n        (0, 32),\n        (0, 6),\n        (0, 1402),\n        (0, 1074),\n        (0, 4601),\n        (0, 230),\n        (0, 23),\n        (0, 40),\n        (0, 789),\n        (0, 938),\n        (0, 1555),\n        (0, 2),\n        (0, 594),\n        (0, 2),\n        (0, 14),\n        (0, 223),\n        (0, 8),\n        (0, 75),\n        (0, 1198),\n        (0, 136),\n        (0, 0),\n        (0, 3),\n        (0, 864),\n        (0, 137),\n        (0, 9290),\n        (0, 0),\n        (0, 209),\n        (0, 165),\n        (0, 836),\n        (0, 103),\n        (0, 720),\n        (0, 708),\n        (0, 2),\n        (0, 0),\n        (0, 150),\n        (0, 1021),\n        (0, 41),\n        (0, 3329),\n        (0, 1),\n        (0, 191),\n        (0, 1),\n        (0, 148),\n        (0, 27),\n        (0, 154),\n        (0, 1498),\n        (0, 733),\n        (0, 154),\n        (0, 1),\n        (0, 3982),\n        (0, 8095),\n        (0, 3),\n        (0, 67),\n        (0, 1001),\n        (0, 703),\n        (0, 756),\n        (0, 76),\n        (0, 34),\n        (0, 963),\n        (0, 1197),\n        (0, 0),\n        (0, 2),\n        (0, 121),\n        (0, 1062),\n        (0, 776),\n        (0, 145),\n        (0, 276),\n        (0, 0),\n        (0, 20),\n        (0, 5030),\n        (0, 100),\n        (0, 3104),\n        (0, 1),\n        (0, 1),\n        (0, 15),\n        (0, 0),\n        (0, 2313),\n        (0, 31),\n        (0, 5277),\n        (0, 11),\n        (0, 434),\n        (0, 112),\n        (0, 2),\n        (0, 635),\n        (0, 339),\n        (0, 1103),\n        (0, 23),\n        (0, 86),\n        (0, 1),\n        (0, 145),\n        (0, 61),\n        (0, 1242),\n        (0, 0),\n        (0, 0),\n        (0, 2),\n        (0, 4),\n        (0, 28),\n        (0, 7),\n        (0, 5580),\n        (0, 22),\n        (0, 1125),\n        (0, 20),\n        (0, 137),\n        (0, 3609),\n        (0, 131),\n        (0, 6),\n        (0, 0),\n        (0, 1289),\n        (0, 2),\n        (0, 1559),\n        (0, 598),\n        (0, 11),\n        (0, 1909),\n        (0, 1591),\n        (0, 22),\n        (0, 0),\n        (0, 23),\n        (0, 296),\n        (0, 19),\n        (0, 8441),\n        (0, 0),\n        (0, 9),\n        (0, 8),\n        (0, 2),\n        (0, 1993),\n        (0, 69),\n        (0, 19),\n        (0, 19),\n        (0, 5),\n        (0, 331),\n        (0, 16),\n        (0, 6),\n        (0, 3347),\n        (0, 49),\n        (0, 17),\n        (0, 1),\n        (0, 516),\n        (0, 156),\n        (0, 26),\n        (0, 501),\n        (0, 72),\n        (0, 106),\n        (0, 2),\n        (0, 336),\n        (0, 22),\n        (0, 0),\n        (0, 107),\n        (0, 939),\n        (0, 341),\n        (0, 19),\n        (0, 2877),\n        (0, 6),\n        (0, 177),\n        (0, 821),\n        (0, 1100),\n        (0, 194),\n        (0, 24),\n        (0, 599),\n        (0, 18),\n        (0, 21),\n        (0, 17),\n        (0, 42),\n        (0, 7),\n        (0, 86),\n        (0, 0),\n        (0, 238),\n        (0, 8),\n        (0, 5),\n        (0, 1),\n        (0, 68),\n        (0, 9193),\n        (0, 11),\n        (0, 6763),\n        (0, 158),\n        (0, 386),\n        (0, 4041),\n        (0, 63),\n        (0, 1819),\n        (0, 18),\n        (0, 0),\n        (0, 2036),\n        (0, 345),\n        (0, 2203),\n        (0, 113),\n        (0, 6),\n        (0, 371),\n        (0, 7),\n        (0, 194),\n        (0, 26),\n        (0, 3184),\n        (0, 185),\n        (0, 136),\n        (0, 35),\n        (0, 1883),\n        (0, 981),\n        (0, 1497),\n        (0, 140),\n        (0, 6),\n        (0, 0),\n        (0, 5),\n        (0, 4246),\n        (0, 121),\n        (0, 404),\n        (0, 398),\n        (0, 260),\n        (0, 368),\n        (0, 212),\n        (0, 2),\n        (0, 30),\n        (0, 45),\n        (0, 988),\n        (0, 82),\n        (0, 79),\n        (0, 1556),\n        (0, 5),\n        (0, 168),\n        (0, 0),\n        (0, 336),\n        (0, 1699),\n        (0, 141),\n        (0, 13),\n        (0, 0),\n        (0, 242),\n        (0, 40),\n        (0, 263),\n        (0, 6464),\n        (0, 1332),\n        (0, 4),\n        (0, 459),\n        (0, 7),\n        (0, 20),\n        (0, 1),\n        (0, 3523),\n        (0, 19),\n        (0, 0),\n        (0, 11),\n        (0, 8),\n        (0, 24),\n        (0, 608),\n        (0, 8),\n        (0, 50),\n        (0, 1),\n        (0, 2),\n        (0, 1723),\n        (0, 157),\n        (1, 108),\n        (0, 3),\n        (0, 0),\n        (0, 7122),\n        (0, 151),\n        (0, 4),\n        (0, 0),\n        (0, 1),\n        (0, 30),\n        (0, 5289),\n        (0, 2),\n        (0, 122),\n        (0, 66),\n        (0, 3),\n        (0, 7),\n        (0, 8258),\n        (0, 227),\n        (0, 3),\n        (0, 652),\n        (0, 574),\n        (0, 376),\n        (0, 522),\n        (0, 110),\n        (0, 1),\n        (0, 920),\n        (0, 2012),\n        (0, 4754),\n        (0, 412),\n        (0, 2774),\n        (0, 12),\n        (0, 1262),\n        (0, 144),\n        (0, 181),\n        (0, 94),\n        (0, 1903),\n        (0, 249),\n        (0, 8),\n        (0, 9),\n        (0, 96),\n        (0, 1323),\n        (0, 65),\n        (0, 20),\n        (0, 1270),\n        (0, 0),\n        (0, 1551),\n        (0, 13),\n        (0, 0),\n        (0, 5090),\n        (0, 2007),\n        (0, 6405),\n        (1, 891),\n        (0, 2327),\n        (0, 2029),\n        (0, 1078),\n        (0, 2),\n        (0, 3),\n        (0, 1),\n        (0, 661),\n        (0, 71),\n        (0, 43),\n        (0, 73),\n        (0, 12),\n        (0, 223),\n        (0, 90),\n        (0, 1360),\n        (0, 5),\n        (0, 329),\n        (0, 29),\n        (0, 398),\n        (0, 25),\n        (0, 14),\n        (0, 980),\n        (0, 271),\n        (0, 0),\n        (0, 466),\n        (0, 6142),\n        (0, 247),\n        (0, 172),\n        (0, 47),\n        (0, 38),\n        (0, 1576),\n        (0, 364),\n        (0, 4167),\n        (0, 3656),\n        (0, 3934),\n        (0, 721),\n        (0, 1329),\n        (0, 96),\n        (0, 625),\n        (0, 82),\n        (0, 72),\n        (0, 1763),\n        (0, 20),\n        (0, 947),\n        (0, 62),\n        (0, 478),\n        (0, 0),\n        (0, 1),\n        (0, 5),\n        (0, 1),\n        (0, 272),\n        (0, 1522),\n        (0, 857),\n        (0, 10),\n        (0, 4),\n        (0, 51),\n        (0, 252),\n        (0, 4),\n        (0, 90),\n        (0, 65),\n        (0, 1148),\n        (0, 990),\n        (0, 39),\n        (0, 6),\n        (0, 3926),\n        (0, 49),\n        (0, 1362),\n        (0, 9),\n        (0, 35),\n        (0, 0),\n        (0, 3880),\n        (0, 330),\n        (0, 32),\n        (0, 16),\n        (0, 5919),\n        (0, 22),\n        (0, 122),\n        (0, 3527),\n        (0, 16),\n        (0, 1085),\n        (0, 308),\n        (0, 134),\n        (0, 185),\n        (0, 138),\n        (0, 2443),\n        (0, 754),\n        (0, 506),\n        (0, 184),\n        (0, 6121),\n        (0, 1),\n        (0, 162),\n        (0, 17),\n        (0, 28),\n        (0, 17),\n        (0, 3843),\n        (0, 5),\n        (0, 158),\n        (0, 29),\n        (0, 42),\n        (0, 664),\n        (0, 388),\n        (0, 1209),\n        (0, 0),\n        (0, 1640),\n        (0, 58),\n        (0, 1),\n        (0, 18),\n        (0, 41),\n        (0, 7498),\n        (0, 7138),\n        (0, 5),\n        (0, 134),\n        (0, 9),\n        (0, 1),\n        (0, 207),\n        (0, 82),\n        (0, 7984),\n        (0, 42),\n        (0, 903),\n        (0, 258),\n        (0, 9392),\n        (0, 36),\n        (0, 46),\n        (0, 0),\n        (0, 228),\n        (0, 1633),\n        (0, 2445),\n        (0, 163),\n        (0, 885),\n        (0, 2340),\n        (0, 1173),\n        (0, 137),\n        (0, 5859),\n        (0, 202),\n        (0, 12),\n        (0, 1147),\n        (0, 3825),\n        (0, 525),\n        (0, 198),\n        (0, 182),\n        (0, 326),\n        (0, 210),\n        (0, 3107),\n        (0, 50),\n        (0, 257),\n        (0, 47),\n        (0, 832),\n        (0, 4166),\n        (0, 1592),\n        (0, 16),\n        (0, 10),\n        (1, 6970),\n        (0, 36),\n        (0, 16),\n        (0, 1),\n        (0, 9),\n        (0, 31),\n        (0, 4294),\n        (0, 4069),\n        (0, 28),\n        (0, 476),\n        (0, 2810),\n        (0, 403),\n        (0, 225),\n        (0, 583),\n        (0, 29),\n        (0, 261),\n        (0, 705),\n        (0, 5),\n        (0, 1938),\n        (0, 948),\n        (0, 7),\n        (0, 3653),\n        (0, 612),\n        (0, 7244),\n        (0, 29),\n        (0, 154),\n        (0, 111),\n        (0, 164),\n        (0, 61),\n        (0, 36),\n        (0, 226),\n        (0, 7905),\n        (0, 767),\n        (0, 0),\n        (0, 32),\n        (0, 6),\n        (0, 949),\n        (0, 2011),\n        (0, 25),\n        (0, 0),\n        (0, 27),\n        (0, 993),\n        (0, 108),\n        (0, 496),\n        (0, 2591),\n        (0, 2225),\n        (1, 1620),\n        (0, 182),\n        (0, 369),\n        (0, 2765),\n        (0, 165),\n        (0, 78),\n        (0, 313),\n        (0, 163),\n        (0, 26),\n        (0, 5609),\n        (0, 123),\n        (0, 8),\n        (0, 750),\n        (0, 3621),\n        (0, 272),\n        (0, 1),\n        (0, 0),\n        (0, 2785),\n        (0, 1),\n        (0, 9118),\n        (0, 1166),\n        (0, 1564),\n        (0, 0),\n        (0, 2468),\n        (0, 20),\n        (0, 4),\n        (0, 1506),\n        (1, 371),\n        (0, 533),\n        (0, 7),\n        (0, 38),\n        (0, 1051),\n        (0, 4),\n        (0, 7),\n        (0, 5),\n        (0, 1),\n        (0, 1177),\n        (0, 6404),\n        (0, 64),\n        (0, 51),\n        (0, 17),\n        (0, 4),\n        (0, 3),\n        (0, 0),\n        (0, 31),\n        (0, 367),\n        (0, 211),\n        (0, 1066),\n        (0, 693),\n        (0, 74),\n        (0, 1175),\n        (0, 25),\n        (0, 900),\n        (0, 1848),\n        (0, 19),\n        (0, 64),\n        (0, 18),\n        (0, 28),\n        (1, 4212),\n        (0, 1909),\n        (0, 1480),\n        (0, 176),\n        (0, 33),\n        (0, 0),\n        (0, 223),\n        (0, 2),\n        (0, 34),\n        (0, 444),\n        (0, 1564),\n        (0, 25),\n        (0, 1085),\n        (0, 808),\n        (0, 5),\n        (0, 0),\n        (0, 27),\n        (0, 6328),\n        (0, 9),\n        (0, 69),\n        (0, 282),\n        (0, 1832),\n        (1, 8685),\n        (0, 299),\n        (0, 6813),\n        (0, 4),\n        (0, 167),\n        (0, 348),\n        (0, 4403),\n        (1, 3801),\n        (0, 66),\n        (0, 6324),\n        (0, 1879),\n        (0, 33),\n        (0, 145),\n        (0, 180),\n        (0, 4675),\n        (0, 11),\n        (0, 0),\n        (0, 38),\n        (0, 1119),\n        (0, 100),\n        (0, 430),\n        (0, 843),\n        (0, 77),\n        (0, 8663),\n        (0, 7),\n        (0, 6805),\n        (1, 2379),\n        (0, 1556),\n        (0, 6029),\n        (0, 6596),\n        (0, 99),\n        (0, 6554),\n        (0, 1025),\n        (0, 1223),\n        (0, 58),\n        (0, 7),\n        (0, 737),\n        (0, 443),\n        (0, 407),\n        (0, 219),\n        (0, 2227),\n        (0, 2286),\n        (0, 4165),\n        (0, 54),\n        (0, 298),\n        (2, 3184),\n        (0, 185),\n        (0, 8251),\n        (0, 0),\n        (0, 33),\n        (0, 30),\n        (0, 2),\n        (0, 310),\n        (0, 802),\n        (0, 5196),\n        (0, 2985),\n        (0, 211),\n        (0, 66),\n        (0, 74),\n        (0, 97),\n        (0, 40),\n        (0, 1),\n        (0, 521),\n        (0, 8),\n        (0, 813),\n        (0, 974),\n        (0, 3396),\n        (1, 5828),\n        (0, 40),\n        (0, 277),\n        (0, 17),\n        (0, 597),\n        (0, 718),\n        (0, 280),\n        (0, 9),\n        (0, 4),\n        (0, 340),\n        (0, 0),\n        (0, 552),\n        (0, 1),\n        (0, 275),\n        (1, 5278),\n        (0, 58),\n        (0, 3),\n        (0, 5371),\n        (0, 1),\n        (0, 16),\n        (0, 162),\n        (1, 8009),\n        (0, 835),\n        (0, 4572),\n        (0, 242),\n        (0, 510),\n        (0, 1),\n        (0, 52),\n        (0, 57),\n        (0, 517),\n        (0, 4415),\n        (0, 16),\n        (0, 3225),\n        (0, 31),\n        (0, 99),\n        (0, 0),\n        (0, 146),\n        (0, 0),\n        (0, 161),\n        (0, 4),\n        (0, 4),\n        (0, 216),\n        (0, 0),\n        (0, 1160),\n        (0, 5675),\n        (0, 154),\n        (0, 112),\n        (0, 132),\n        (0, 2),\n        (0, 66),\n        (0, 53),\n        (0, 51),\n        (0, 0),\n        (0, 325),\n        (0, 2296),\n        (0, 109),\n        (0, 7514),\n        (0, 2850),\n        (0, 44),\n        (0, 1530),\n        (0, 248),\n        (0, 654),\n        (0, 44),\n        (0, 2282),\n        (0, 299),\n        (0, 2151),\n        (0, 2886),\n        (0, 114),\n        (0, 5823),\n        (0, 182),\n        (0, 872),\n        (0, 0),\n        (0, 3170),\n        (0, 0),\n        (0, 50),\n        (0, 71),\n        (0, 33),\n        (0, 11),\n        (0, 1),\n        (0, 1258),\n        (0, 14),\n        (0, 3255),\n        (0, 216),\n        (0, 6127),\n        (0, 2144),\n        (0, 0),\n        (0, 2588),\n        (0, 1169),\n        (0, 1311),\n        (0, 588),\n        (0, 5),\n        (0, 174),\n        (0, 1393),\n        (0, 63),\n        (0, 50),\n        (0, 3955),\n        (0, 473),\n        (0, 1519),\n        (0, 0),\n        (0, 327),\n        (0, 2475),\n        (0, 15),\n        (0, 0),\n        (2, 2826),\n        (0, 2896),\n        (0, 0),\n        (0, 7005),\n        (1, 2910),\n        (0, 217),\n        (0, 2121),\n        (0, 75),\n        (0, 336),\n        (0, 9830),\n        (1, 1127),\n        (0, 26),\n        (0, 250),\n        (0, 1550),\n        (0, 31),\n        (0, 170),\n        (0, 21),\n        (0, 3383),\n        (0, 3241),\n        (0, 8864),\n        (0, 426),\n        (0, 45),\n        (0, 5113),\n        (0, 622),\n        (0, 288),\n        (0, 3),\n        (0, 3236),\n        (0, 23),\n        (0, 3996),\n        (0, 2),\n        (0, 2),\n        (0, 584),\n        (0, 0),\n        (0, 4),\n        (0, 0),\n        (0, 6088),\n        (0, 5672),\n        (0, 3725),\n        (0, 1803),\n        (0, 230),\n        (0, 251),\n        (0, 725),\n        (0, 2059),\n        (0, 421),\n        (0, 86),\n        (0, 5),\n        (0, 6924),\n        (0, 28),\n        (0, 1440),\n        (0, 1976),\n        (0, 1836),\n        (0, 2),\n        (1, 1615),\n        (0, 4462),\n        (0, 4846),\n        (0, 5436),\n        (0, 123),\n        (1, 519),\n        (0, 87),\n        (0, 1595),\n        (0, 2401),\n        (0, 5),\n        (0, 0),\n        (1, 341),\n        (0, 4),\n        (0, 899),\n        (0, 1939),\n        (0, 2),\n        (0, 1105),\n        (0, 1273),\n        (0, 74),\n        (0, 56),\n        (0, 1685),\n        (0, 1154),\n        (0, 1130),\n        (0, 19),\n        (0, 5971),\n        (0, 2940),\n        (0, 8020),\n        (0, 0),\n        (0, 116),\n        (2, 5930),\n        (0, 41),\n        (0, 162),\n        (0, 57),\n        (0, 1375),\n        (0, 398),\n        (0, 4008),\n        (0, 9287),\n        (0, 817),\n        (0, 0),\n        (0, 2793),\n        (0, 556),\n        (0, 997),\n        (0, 282),\n        (0, 0),\n        (0, 553),\n        (0, 5742),\n        (0, 382),\n        (0, 6670),\n        (0, 5301),\n        (0, 0),\n        (2, 9658),\n        (0, 463),\n        (1, 2981),\n        (0, 3716),\n        (0, 4894),\n        (0, 35),\n        (1, 75),\n        (0, 86),\n        (0, 3384),\n        (0, 0),\n        (0, 73),\n        (0, 635),\n        (0, 2),\n        (0, 7793),\n        (1, 126),\n        (0, 21),\n        (0, 173),\n        (0, 505),\n        (0, 1558),\n        (0, 45),\n        (0, 3137),\n        (2, 9424),\n        (0, 4030),\n        (0, 1749),\n        (0, 172),\n        (0, 1309),\n        (0, 240),\n        (0, 735),\n        (0, 400),\n        (0, 4),\n        (0, 160),\n        (0, 0),\n        (0, 1),\n        (0, 105),\n        (0, 1),\n        (0, 5051),\n        (0, 365),\n        (0, 146),\n        (0, 30),\n        (0, 3),\n        (0, 470),\n        (0, 452),\n        (0, 1824),\n        (0, 1716),\n        (0, 15),\n        (0, 1028),\n        (0, 332),\n        (0, 3606),\n        (0, 19),\n        (0, 6),\n        (0, 405),\n        (0, 7770),\n        (0, 4300),\n        (0, 247),\n        (0, 7550),\n        (0, 6643),\n        (2, 1261),\n        (0, 7147),\n        (0, 30),\n        (0, 9),\n        (0, 223),\n        (0, 403),\n        (0, 372),\n        (3, 4276),\n        (0, 9288),\n        (0, 6212),\n        (0, 714),\n        (4, 6377),\n        (0, 4),\n        (0, 46),\n        (1, 8403),\n        (0, 142),\n        (0, 4462),\n        (0, 7581),\n        (0, 12),\n        (0, 0),\n        (0, 4864),\n        (0, 2961),\n        (0, 265),\n        (0, 19),\n        (0, 119),\n        (0, 5454),\n        (2, 2981),\n        (0, 3230),\n        (0, 3),\n        (0, 0),\n        (0, 6000),\n        (1, 9805),\n        (0, 354),\n        (0, 61),\n        (0, 8529),\n        (0, 0),\n        (0, 2076),\n        (0, 629),\n        (1, 1194),\n        (0, 3377),\n        (0, 0),\n        (0, 1956),\n        (0, 1749),\n        (3, 3998),\n        (0, 109),\n        (0, 16),\n        (0, 1467),\n        (0, 5195),\n        (0, 35),\n        (0, 9700),\n        (0, 4738),\n    ],\n    entries: \u0026[\n        (\"blacktrianglel\", (0, 0)),\n        (\"sharp\", (0, 0)),\n        (\"bowtie\", (0, 0)),\n        (\"NotPrecedesSlantEqual;\", (8928, 0)),\n        (\"Aci\", (0, 0)),\n        (\"Atilde;\", (195, 0)),\n        (\"Zacute;\", (377, 0)),\n        (\"gvertn\", (0, 0)),\n        (\"ordm\", (186, 0)),\n        (\"LeftV\", (0, 0)),\n        (\"circlearrowl\", (0, 0)),\n        (\"updo\", (0, 0)),\n        (\"wcirc\", (0, 0)),\n        (\"gtlPar;\", (10645, 0)),\n        (\"leftharpoondow\", (0, 0)),\n        (\"NotGreaterLess\", (0, 0)),\n        (\"curlyeqpr\", (0, 0)),\n        (\"Downarrow\", (0, 0)),\n        (\"mdas\", (0, 0)),\n        (\"timesd;\", (10800, 0)),\n        (\"smash\", (0, 0)),\n        (\"VerticalL\", (0, 0)),\n        (\"LessSlantE\", (0, 0)),\n        (\"Lamb\", (0, 0)),\n        (\"prap;\", (10935, 0)),\n        (\"Updownarro\", (0, 0)),\n        (\"right\", (0, 0)),\n        (\"bull\", (0, 0)),\n        (\"plusdo\", (0, 0)),\n        (\"Iuk\", (0, 0)),\n        (\"xmap;\", (10236, 0)),\n        (\"We\", (0, 0)),\n        (\"iiiin\", (0, 0)),\n        (\"Rsh;\", (8625, 0)),\n        (\"sac\", (0, 0)),\n        (\"nVDash;\", (8879, 0)),\n        (\"ns\", (0, 0)),\n        (\"NotNestedGr\", (0, 0)),\n        (\"RightCe\", (0, 0)),\n        (\"lce\", (0, 0)),\n        (\"lb\", (0, 0)),\n        (\"dArr;\", (8659, 0)),\n        (\"Hfr;\", (8460, 0)),\n        (\"lnE\", (0, 0)),\n        (\"emsp14\", (0, 0)),\n        (\"Ubre\", (0, 0)),\n        (\"bumpE\", (0, 0)),\n        (\"DoubleDo\", (0, 0)),\n        (\"g\", (0, 0)),\n        (\"grave\", (0, 0)),\n        (\"DoubleDownAr\", (0, 0)),\n        (\"bigt\", (0, 0)),\n        (\"nbu\", (0, 0)),\n        (\"Becau\", (0, 0)),\n        (\"curvearrowright;\", (8631, 0)),\n        (\"RightDownVector\", (0, 0)),\n        (\"xwedge;\", (8896, 0)),\n        (\"CircleTi\", (0, 0)),\n        (\"dashv\", (0, 0)),\n        (\"CupCa\", (0, 0)),\n        (\"vpro\", (0, 0)),\n        (\"scsim\", (0, 0)),\n        (\"kgr\", (0, 0)),\n        (\"fpartint\", (0, 0)),\n        (\"ShortDo\", (0, 0)),\n        (\"iiot\", (0, 0)),\n        (\"escr\", (0, 0)),\n        (\"lmidot\", (0, 0)),\n        (\"na\", (0, 0)),\n        (\"bigcup;\", (8899, 0)),\n        (\"bn\", (0, 0)),\n        (\"gneq\", (0, 0)),\n        (\"rBar\", (0, 0)),\n        (\"preceq;\", (10927, 0)),\n        (\"MediumSp\", (0, 0)),\n        (\"Ha\", (0, 0)),\n        (\"xve\", (0, 0)),\n        (\"tce\", (0, 0)),\n        (\"bsim\", (0, 0)),\n        (\"NotGreaterSlantEq\", (0, 0)),\n        (\"LeftAngleBra\", (0, 0)),\n        (\"nat\", (0, 0)),\n        (\"Acirc\", (194, 0)),\n        (\"Kappa\", (0, 0)),\n        (\"Uscr\", (0, 0)),\n        (\"intca\", (0, 0)),\n        (\"cylct\", (0, 0)),\n        (\"blk14\", (0, 0)),\n        (\"vdash\", (0, 0)),\n        (\"Laplacetr\", (0, 0)),\n        (\"Imaginar\", (0, 0)),\n        (\"Uma\", (0, 0)),\n        (\"DoubleLongRightArrow\", (0, 0)),\n        (\"lurd\", (0, 0)),\n        (\"icirc\", (238, 0)),\n        (\"lsquor;\", (8218, 0)),\n        (\"Idot\", (0, 0)),\n        (\"LessFull\", (0, 0)),\n        (\"ShortRightAr\", (0, 0)),\n        (\"DownLeftTeeVe\", (0, 0)),\n        (\"iiiint;\", (10764, 0)),\n        (\"ods\", (0, 0)),\n        (\"cwcon\", (0, 0)),\n        (\"ruluha\", (0, 0)),\n        (\"leftrightsquiga\", (0, 0)),\n        (\"odash\", (0, 0)),\n        (\"gel\", (0, 0)),\n        (\"Bu\", (0, 0)),\n        (\"xscr;\", (120013, 0)),\n        (\"succn\", (0, 0)),\n        (\"capdot;\", (10816, 0)),\n        (\"rat\", (0, 0)),\n        (\"topfor\", (0, 0)),\n        (\"NestedG\", (0, 0)),\n        (\"ContourIn\", (0, 0)),\n        (\"EqualT\", (0, 0)),\n        (\"Gscr;\", (119970, 0)),\n        (\"UpperLeftAr\", (0, 0)),\n        (\"pc\", (0, 0)),\n        (\"drcro\", (0, 0)),\n        (\"Vsc\", (0, 0)),\n        (\"thetasy\", (0, 0)),\n        (\"Clockwise\", (0, 0)),\n        (\"bigvee;\", (8897, 0)),\n        (\"jopf;\", (120155, 0)),\n        (\"Hcir\", (0, 0)),\n        (\"sw\", (0, 0)),\n        (\"Upsilon\", (0, 0)),\n        (\"CounterClockwiseContourIntegral;\", (8755, 0)),\n        (\"plusdu\", (0, 0)),\n        (\"searr;\", (8600, 0)),\n        (\"mnplus;\", (8723, 0)),\n        (\"shchc\", (0, 0)),\n        (\"clubsuit\", (0, 0)),\n        (\"epars\", (0, 0)),\n        (\"SquareUni\", (0, 0)),\n        (\"NotSubs\", (0, 0)),\n        (\"nltr\", (0, 0)),\n        (\"curly\", (0, 0)),\n        (\"NotGreater\", (0, 0)),\n        (\"DoubleLe\", (0, 0)),\n        (\"DoubleLongLeftRigh\", (0, 0)),\n        (\"ori\", (0, 0)),\n        (\"LeftAngl\", (0, 0)),\n        (\"jma\", (0, 0)),\n        (\"SquareSubs\", (0, 0)),\n        (\"Or\", (0, 0)),\n        (\"gna\", (0, 0)),\n        (\"circledast\", (0, 0)),\n        (\"RightUpVe\", (0, 0)),\n        (\"leftt\", (0, 0)),\n        (\"EmptySmallS\", (0, 0)),\n        (\"natu\", (0, 0)),\n        (\"succe\", (0, 0)),\n        (\"downdownar\", (0, 0)),\n        (\"Ogr\", (0, 0)),\n        (\"GT\", (62, 0)),\n        (\"YAcy;\", (1071, 0)),\n        (\"lcedil\", (0, 0)),\n        (\"clu\", (0, 0)),\n        (\"sd\", (0, 0)),\n        (\"nprec;\", (8832, 0)),\n        (\"NotSucceedsEq\", (0, 0)),\n        (\"slar\", (0, 0)),\n        (\"LongLeftRightA\", (0, 0)),\n        (\"smt;\", (10922, 0)),\n        (\"UnionPlus\", (0, 0)),\n        (\"col\", (0, 0)),\n        (\"clubsu\", (0, 0)),\n        (\"ruluh\", (0, 0)),\n        (\"vprop;\", (8733, 0)),\n        (\"gtreqles\", (0, 0)),\n        (\"succcurl\", (0, 0)),\n        (\"dotminus;\", (8760, 0)),\n        (\"DoubleLeftTee\", (0, 0)),\n        (\"duhar;\", (10607, 0)),\n        (\"Suc\", (0, 0)),\n        (\"DiacriticalDoubleAc\", (0, 0)),\n        (\"eqcolon;\", (8789, 0)),\n        (\"upharpoo\", (0, 0)),\n        (\"looparrow\", (0, 0)),\n        (\"ycirc;\", (375, 0)),\n        (\"gtra\", (0, 0)),\n        (\"succnsim;\", (8937, 0)),\n        (\"LeftRightV\", (0, 0)),\n        (\"dag\", (0, 0)),\n        (\"NotLessSlantEqual\", (0, 0)),\n        (\"varsigm\", (0, 0)),\n        (\"m\", (0, 0)),\n        (\"ouml\", (246, 0)),\n        (\"hkse\", (0, 0)),\n        (\"NotEqualTilde\", (0, 0)),\n        (\"NotGreaterTi\", (0, 0)),\n        (\"approxe\", (0, 0)),\n        (\"LeftTeeVe\", (0, 0)),\n        (\"sem\", (0, 0)),\n        (\"ou\", (0, 0)),\n        (\"straight\", (0, 0)),\n        (\"scc\", (0, 0)),\n        (\"ReverseElem\", (0, 0)),\n        (\"curlyeqprec;\", (8926, 0)),\n        (\"efr;\", (120098, 0)),\n        (\"ropl\", (0, 0)),\n        (\"downarro\", (0, 0)),\n        (\"Tild\", (0, 0)),\n        (\"SquareSubsetEqual;\", (8849, 0)),\n        (\"NotV\", (0, 0)),\n        (\"Ea\", (0, 0)),\n        (\"Lopf\", (0, 0)),\n        (\"swarr;\", (8601, 0)),\n        (\"rtimes;\", (8906, 0)),\n        (\"h\", (0, 0)),\n        (\"ntlg;\", (8824, 0)),\n        (\"Omicron;\", (927, 0)),\n        (\"Map;\", (10501, 0)),\n        (\"Gce\", (0, 0)),\n        (\"ZeroWidthSpac\", (0, 0)),\n        (\"Topf;\", (120139, 0)),\n        (\"ic\", (0, 0)),\n        (\"uarr;\", (8593, 0)),\n        (\"util\", (0, 0)),\n        (\"frac13\", (0, 0)),\n        (\"Longleftrightarro\", (0, 0)),\n        (\"Ufr\", (0, 0)),\n        (\"infin\", (0, 0)),\n        (\"Eq\", (0, 0)),\n        (\"cudarrl;\", (10552, 0)),\n        (\"Beta\", (0, 0)),\n        (\"NotEl\", (0, 0)),\n        (\"KHcy;\", (1061, 0)),\n        (\"diamonds\", (0, 0)),\n        (\"cca\", (0, 0)),\n        (\"LessF\", (0, 0)),\n        (\"nshortparallel;\", (8742, 0)),\n        (\"vsc\", (0, 0)),\n        (\"OverParenthe\", (0, 0)),\n        (\"Diamond\", (0, 0)),\n        (\"RightTri\", (0, 0)),\n        (\"iscr\", (0, 0)),\n        (\"HumpEqu\", (0, 0)),\n        (\"centerdot;\", (183, 0)),\n        (\"DownArrowUpA\", (0, 0)),\n        (\"lagran;\", (8466, 0)),\n        (\"dotpl\", (0, 0)),\n        (\"ulcorne\", (0, 0)),\n        (\"UpperLeftArr\", (0, 0)),\n        (\"lAarr\", (0, 0)),\n        (\"lhb\", (0, 0)),\n        (\"supnE\", (0, 0)),\n        (\"Brev\", (0, 0)),\n        (\"ulco\", (0, 0)),\n        (\"ccap\", (0, 0)),\n        (\"OverBracket\", (0, 0)),\n        (\"lArr\", (0, 0)),\n        (\"supplus\", (0, 0)),\n        (\"expe\", (0, 0)),\n        (\"expecta\", (0, 0)),\n        (\"om\", (0, 0)),\n        (\"eg;\", (10906, 0)),\n        (\"Ici\", (0, 0)),\n        (\"leftthreetime\", (0, 0)),\n        (\"iprod\", (0, 0)),\n        (\"ssetmn;\", (8726, 0)),\n        (\"A\", (0, 0)),\n        (\"ntrianglelefteq;\", (8940, 0)),\n        (\"Laplac\", (0, 0)),\n        (\"smeparsl;\", (10724, 0)),\n        (\"RightT\", (0, 0)),\n        (\"rsq\", (0, 0)),\n        (\"LeftUpDownVector;\", (10577, 0)),\n        (\"Rcedil;\", (342, 0)),\n        (\"Iot\", (0, 0)),\n        (\"NotSucceeds;\", (8833, 0)),\n        (\"uum\", (0, 0)),\n        (\"Llef\", (0, 0)),\n        (\"NegativeThinS\", (0, 0)),\n        (\"fj\", (0, 0)),\n        (\"breve\", (0, 0)),\n        (\"tbr\", (0, 0)),\n        (\"bkarow;\", (10509, 0)),\n        (\"NotSquare\", (0, 0)),\n        (\"RightArrowBar;\", (8677, 0)),\n        (\"RightDownVecto\", (0, 0)),\n        (\"Fi\", (0, 0)),\n        (\"Kfr\", (0, 0)),\n        (\"rightarrow;\", (8594, 0)),\n        (\"UpEquilib\", (0, 0)),\n        (\"leftrightsqu\", (0, 0)),\n        (\"succcurlye\", (0, 0)),\n        (\"blacktrianglele\", (0, 0)),\n        (\"Lcedi\", (0, 0)),\n        (\"djcy\", (0, 0)),\n        (\"ndash\", (0, 0)),\n        (\"LeftUpDownV\", (0, 0)),\n        (\"LessSlantEqu\", (0, 0)),\n        (\"RightDownTe\", (0, 0)),\n        (\"Ycy\", (0, 0)),\n        (\"exc\", (0, 0)),\n        (\"lef\", (0, 0)),\n        (\"ratai\", (0, 0)),\n        (\"LessFullEqual\", (0, 0)),\n        (\"icirc;\", (238, 0)),\n        (\"Nf\", (0, 0)),\n        (\"NotLessGr\", (0, 0)),\n        (\"gtreq\", (0, 0)),\n        (\"nvDa\", (0, 0)),\n        (\"Gcirc\", (0, 0)),\n        (\"otil\", (0, 0)),\n        (\"Hf\", (0, 0)),\n        (\"LeftUpTe\", (0, 0)),\n        (\"ThinSpace;\", (8201, 0)),\n        (\"el;\", (10905, 0)),\n        (\"Qf\", (0, 0)),\n        (\"backprime\", (0, 0)),\n        (\"LeftTr\", (0, 0)),\n        (\"DownRig\", (0, 0)),\n        (\"xhArr;\", (10234, 0)),\n        (\"Rop\", (0, 0)),\n        (\"DownTeeArrow\", (0, 0)),\n        (\"lozeng\", (0, 0)),\n        (\"CloseCurlyDoubleQu\", (0, 0)),\n        (\"Kcy\", (0, 0)),\n        (\"gsc\", (0, 0)),\n        (\"ReverseEquilibriu\", (0, 0)),\n        (\"GreaterSla\", (0, 0)),\n        (\"larrsim\", (0, 0)),\n        (\"vangrt;\", (10652, 0)),\n        (\"Rcaro\", (0, 0)),\n        (\"nco\", (0, 0)),\n        (\"LessEqual\", (0, 0)),\n        (\"uHar;\", (10595, 0)),\n        (\"andd\", (0, 0)),\n        (\"hstrok;\", (295, 0)),\n        (\"hyb\", (0, 0)),\n        (\"PrecedesTild\", (0, 0)),\n        (\"rangle;\", (10217, 0)),\n        (\"ContourIntegr\", (0, 0)),\n        (\"RBarr\", (0, 0)),\n        (\"Vscr\", (0, 0)),\n        (\"Negativ\", (0, 0)),\n        (\"Yo\", (0, 0)),\n        (\"cula\", (0, 0)),\n        (\"nGt\", (0, 0)),\n        (\"lesseqqg\", (0, 0)),\n        (\"rscr;\", (120007, 0)),\n        (\"nesim\", (0, 0)),\n        (\"LeftDownTeeVector;\", (10593, 0)),\n        (\"barv\", (0, 0)),\n        (\"succnapprox;\", (10938, 0)),\n        (\"lbrksld;\", (10639, 0)),\n        (\"triangl\", (0, 0)),\n        (\"CircleDo\", (0, 0)),\n        (\"xlarr\", (0, 0)),\n        (\"larrbf\", (0, 0)),\n        (\"larr\", (0, 0)),\n        (\"fal\", (0, 0)),\n        (\"Triple\", (0, 0)),\n        (\"opar\", (0, 0)),\n        (\"Uci\", (0, 0)),\n        (\"Roun\", (0, 0)),\n        (\"DoubleRightAr\", (0, 0)),\n        (\"planckh\", (0, 0)),\n        (\"EmptyVer\", (0, 0)),\n        (\"Prim\", (0, 0)),\n        (\"apo\", (0, 0)),\n        (\"RightTriangleEqua\", (0, 0)),\n        (\"blackt\", (0, 0)),\n        (\"Diac\", (0, 0)),\n        (\"UnderBracket\", (0, 0)),\n        (\"larrlp\", (0, 0)),\n        (\"Dot;\", (168, 0)),\n        (\"asympeq\", (0, 0)),\n        (\"mDDo\", (0, 0)),\n        (\"Uuml;\", (220, 0)),\n        (\"Tce\", (0, 0)),\n        (\"Integral\", (0, 0)),\n        (\"llcor\", (0, 0)),\n        (\"Prece\", (0, 0)),\n        (\"Part\", (0, 0)),\n        (\"herco\", (0, 0)),\n        (\"cacute\", (0, 0)),\n        (\"profli\", (0, 0)),\n        (\"of\", (0, 0)),\n        (\"uopf\", (0, 0)),\n        (\"Ti\", (0, 0)),\n        (\"edot;\", (279, 0)),\n        (\"drcor\", (0, 0)),\n        (\"RightArrowLeftArro\", (0, 0)),\n        (\"rightsquigarrow;\", (8605, 0)),\n        (\"upuparr\", (0, 0)),\n        (\"queste\", (0, 0)),\n        (\"Longleft\", (0, 0)),\n        (\"laemptyv\", (0, 0)),\n        (\"trie\", (0, 0)),\n        (\"hAr\", (0, 0)),\n        (\"xutr\", (0, 0)),\n        (\"siml;\", (10909, 0)),\n        (\"sup1\", (185, 0)),\n        (\"PrecedesSlan\", (0, 0)),\n        (\"Ntilde\", (209, 0)),\n        (\"uwa\", (0, 0)),\n        (\"frac34\", (190, 0)),\n        (\"boxVR;\", (9568, 0)),\n        (\"zig\", (0, 0)),\n        (\"dotsqua\", (0, 0)),\n        (\"dtr\", (0, 0)),\n        (\"Diacritic\", (0, 0)),\n        (\"gjcy;\", (1107, 0)),\n        (\"epsiv;\", (1013, 0)),\n        (\"IE\", (0, 0)),\n        (\"boxDR\", (0, 0)),\n        (\"fa\", (0, 0)),\n        (\"npara\", (0, 0)),\n        (\"frac45\", (0, 0)),\n        (\"pi;\", (960, 0)),\n        (\"cirmi\", (0, 0)),\n        (\"leftthreeti\", (0, 0)),\n        (\"bigotimes\", (0, 0)),\n        (\"bigsqc\", (0, 0)),\n        (\"xlarr;\", (10229, 0)),\n        (\"lhbl\", (0, 0)),\n        (\"ldc\", (0, 0)),\n        (\"ugrave;\", (249, 0)),\n        (\"NotHumpDownHump;\", (8782, 824)),\n        (\"Rho;\", (929, 0)),\n        (\"rarrs\", (0, 0)),\n        (\"NotLessS\", (0, 0)),\n        (\"inca\", (0, 0)),\n        (\"RoundImplies\", (0, 0)),\n        (\"FilledVerySmallS\", (0, 0)),\n        (\"esi\", (0, 0)),\n        (\"orslo\", (0, 0)),\n        (\"ddag\", (0, 0)),\n        (\"curre\", (0, 0)),\n        (\"uuarr;\", (8648, 0)),\n        (\"up\", (0, 0)),\n        (\"ccar\", (0, 0)),\n        (\"ri\", (0, 0)),\n        (\"lhard\", (0, 0)),\n        (\"nles\", (0, 0)),\n        (\"Utild\", (0, 0)),\n        (\"eqcirc;\", (8790, 0)),\n        (\"ltime\", (0, 0)),\n        (\"yacy;\", (1103, 0)),\n        (\"malt;\", (10016, 0)),\n        (\"aac\", (0, 0)),\n        (\"RoundImp\", (0, 0)),\n        (\"phmmat\", (0, 0)),\n        (\"RightDownTeeVect\", (0, 0)),\n        (\"cap;\", (8745, 0)),\n        (\"jm\", (0, 0)),\n        (\"looparrowle\", (0, 0)),\n        (\"profline;\", (8978, 0)),\n        (\"plus\", (0, 0)),\n        (\"straightepsi\", (0, 0)),\n        (\"RightCeili\", (0, 0)),\n        (\"awconin\", (0, 0)),\n        (\"mapstodown\", (0, 0)),\n        (\"triangleleft\", (0, 0)),\n        (\"gc\", (0, 0)),\n        (\"oo\", (0, 0)),\n        (\"zet\", (0, 0)),\n        (\"setmin\", (0, 0)),\n        (\"twix\", (0, 0)),\n        (\"mapstoleft\", (0, 0)),\n        (\"LowerLeftArrow\", (0, 0)),\n        (\"sqsub\", (0, 0)),\n        (\"iocy\", (0, 0)),\n        (\"imagpar\", (0, 0)),\n        (\"softcy\", (0, 0)),\n        (\"acd;\", (8767, 0)),\n        (\"Ium\", (0, 0)),\n        (\"DoubleLongRightArrow;\", (10233, 0)),\n        (\"Pri\", (0, 0)),\n        (\"tfr\", (0, 0)),\n        (\"DoubleLo\", (0, 0)),\n        (\"Tilde;\", (8764, 0)),\n        (\"Equal\", (0, 0)),\n        (\"Iu\", (0, 0)),\n        (\"Hs\", (0, 0)),\n        (\"nvl\", (0, 0)),\n        (\"ClockwiseContourIntegra\", (0, 0)),\n        (\"RightTriangleBar\", (0, 0)),\n        (\"downharpoonle\", (0, 0)),\n        (\"expec\", (0, 0)),\n        (\"bigotim\", (0, 0)),\n        (\"AMP;\", (38, 0)),\n        (\"boxH;\", (9552, 0)),\n        (\"Intersectio\", (0, 0)),\n        (\"aum\", (0, 0)),\n        (\"niv\", (0, 0)),\n        (\"nlefta\", (0, 0)),\n        (\"lesseq\", (0, 0)),\n        (\"mar\", (0, 0)),\n        (\"male\", (0, 0)),\n        (\"curlyeqpre\", (0, 0)),\n        (\"LowerRight\", (0, 0)),\n        (\"lon\", (0, 0)),\n        (\"Exponenti\", (0, 0)),\n        (\"nexist\", (0, 0)),\n        (\"siml\", (0, 0)),\n        (\"NotGreaterT\", (0, 0)),\n        (\"rfloor;\", (8971, 0)),\n        (\"Bsc\", (0, 0)),\n        (\"Otim\", (0, 0)),\n        (\"capbrcup\", (0, 0)),\n        (\"varkappa;\", (1008, 0)),\n        (\"circ\", (0, 0)),\n        (\"plan\", (0, 0)),\n        (\"Sacu\", (0, 0)),\n        (\"varsig\", (0, 0)),\n        (\"RoundImpli\", (0, 0)),\n        (\"jsercy;\", (1112, 0)),\n        (\"di\", (0, 0)),\n        (\"bepsi\", (0, 0)),\n        (\"hearts\", (0, 0)),\n        (\"nleqsla\", (0, 0)),\n        (\"RuleDel\", (0, 0)),\n        (\"boxhd\", (0, 0)),\n        (\"profl\", (0, 0)),\n        (\"downharpo\", (0, 0)),\n        (\"raemptyv;\", (10675, 0)),\n        (\"ominus\", (0, 0)),\n        (\"bsolb;\", (10693, 0)),\n        (\"straightepsilon;\", (1013, 0)),\n        (\"nsub\", (0, 0)),\n        (\"DoubleLongLeftArro\", (0, 0)),\n        (\"ensp\", (0, 0)),\n        (\"Aopf\", (0, 0)),\n        (\"gacute\", (0, 0)),\n        (\"Colone;\", (10868, 0)),\n        (\"zw\", (0, 0)),\n        (\"leftharpoo\", (0, 0)),\n        (\"UpArrowDownAr\", (0, 0)),\n        (\"IEcy\", (0, 0)),\n        (\"shortpar\", (0, 0)),\n        (\"nGtv;\", (8811, 824)),\n        (\"downh\", (0, 0)),\n        (\"commat;\", (64, 0)),\n        (\"ContourIntegral;\", (8750, 0)),\n        (\"eacut\", (0, 0)),\n        (\"gnapprox;\", (10890, 0)),\n        (\"breve;\", (728, 0)),\n        (\"iinf\", (0, 0)),\n        (\"hom\", (0, 0)),\n        (\"nlA\", (0, 0)),\n        (\"cupdo\", (0, 0)),\n        (\"ee\", (0, 0)),\n        (\"TScy;\", (1062, 0)),\n        (\"LeftDoubl\", (0, 0)),\n        (\"Succee\", (0, 0)),\n        (\"curlyv\", (0, 0)),\n        (\"rightarro\", (0, 0)),\n        (\"rbrace\", (0, 0)),\n        (\"NotGreaterFullE\", (0, 0)),\n        (\"quest;\", (63, 0)),\n        (\"cuvee\", (0, 0)),\n        (\"Cou\", (0, 0)),\n        (\"ReverseE\", (0, 0)),\n        (\"barwedg\", (0, 0)),\n        (\"succc\", (0, 0)),\n        (\"B\", (0, 0)),\n        (\"Uring\", (0, 0)),\n        (\"supne;\", (8843, 0)),\n        (\"capca\", (0, 0)),\n        (\"ohba\", (0, 0)),\n        (\"CloseCurlyQuote\", (0, 0)),\n        (\"nleqs\", (0, 0)),\n        (\"thksi\", (0, 0)),\n        (\"dol\", (0, 0)),\n        (\"ro\", (0, 0)),\n        (\"NotSucceedsSlantEqu\", (0, 0)),\n        (\"VerticalTi\", (0, 0)),\n        (\"LessGrea\", (0, 0)),\n        (\"copro\", (0, 0)),\n        (\"LessSlantEqual\", (0, 0)),\n        (\"upsilo\", (0, 0)),\n        (\"osol\", (0, 0)),\n        (\"peri\", (0, 0)),\n        (\"NotTildeE\", (0, 0)),\n        (\"varsupse\", (0, 0)),\n        (\"Eogon;\", (280, 0)),\n        (\"Ys\", (0, 0)),\n        (\"NotGreaterSlant\", (0, 0)),\n        (\"PrecedesEqual;\", (10927, 0)),\n        (\"FilledSmall\", (0, 0)),\n        (\"updownarrow;\", (8597, 0)),\n        (\"cupdot;\", (8845, 0)),\n        (\"Verb\", (0, 0)),\n        (\"subse\", (0, 0)),\n        (\"swar\", (0, 0)),\n        (\"pop\", (0, 0)),\n        (\"YAcy\", (0, 0)),\n        (\"PrecedesEqual\", (0, 0)),\n        (\"rHa\", (0, 0)),\n        (\"Bernoullis;\", (8492, 0)),\n        (\"DownRigh\", (0, 0)),\n        (\"circlearrowlef\", (0, 0)),\n        (\"hair\", (0, 0)),\n        (\"odi\", (0, 0)),\n        (\"NotTildeFullEqu\", (0, 0)),\n        (\"ntrianglele\", (0, 0)),\n        (\"Verbar;\", (8214, 0)),\n        (\"llcorner;\", (8990, 0)),\n        (\"AMP\", (38, 0)),\n        (\"hardc\", (0, 0)),\n        (\"LessFullEqu\", (0, 0)),\n        (\"ucy\", (0, 0)),\n        (\"rtri\", (0, 0)),\n        (\"Longleftarrow;\", (10232, 0)),\n        (\"SquareSupersetE\", (0, 0)),\n        (\"gesles;\", (10900, 0)),\n        (\"gg\", (0, 0)),\n        (\"Nscr;\", (119977, 0)),\n        (\"sqsubsete\", (0, 0)),\n        (\"twoheadrig\", (0, 0)),\n        (\"curvear\", (0, 0)),\n        (\"eqcirc\", (0, 0)),\n        (\"ClockwiseContourInt\", (0, 0)),\n        (\"Mop\", (0, 0)),\n        (\"pointint\", (0, 0)),\n        (\"NotTild\", (0, 0)),\n        (\"empt\", (0, 0)),\n        (\"Sma\", (0, 0)),\n        (\"aleph;\", (8501, 0)),\n        (\"copysr;\", (8471, 0)),\n        (\"la\", (0, 0)),\n        (\"lAa\", (0, 0)),\n        (\"Iop\", (0, 0)),\n        (\"CloseCurlyDoubleQuot\", (0, 0)),\n        (\"ltrie;\", (8884, 0)),\n        (\"rul\", (0, 0)),\n        (\"Umacr;\", (362, 0)),\n        (\"NJcy;\", (1034, 0)),\n        (\"NotSupersetEqual;\", (8841, 0)),\n        (\"rlar\", (0, 0)),\n        (\"NotPrecedesEqual\", (0, 0)),\n        (\"sopf;\", (120164, 0)),\n        (\"fork;\", (8916, 0)),\n        (\"Jopf;\", (120129, 0)),\n        (\"nsccue\", (0, 0)),\n        (\"leftrightarrow;\", (8596, 0)),\n        (\"ForAll\", (0, 0)),\n        (\"urin\", (0, 0)),\n        (\"nvap\", (0, 0)),\n        (\"squf;\", (9642, 0)),\n        (\"Gbreve\", (0, 0)),\n        (\"lmidot;\", (320, 0)),\n        (\"mapstoleft;\", (8612, 0)),\n        (\"er\", (0, 0)),\n        (\"LeftDownTeeVe\", (0, 0)),\n        (\"ominu\", (0, 0)),\n        (\"sharp;\", (9839, 0)),\n        (\"ccaps;\", (10829, 0)),\n        (\"Thet\", (0, 0)),\n        (\"Upsilo\", (0, 0)),\n        (\"rightharpoonup;\", (8640, 0)),\n        (\"spades;\", (9824, 0)),\n        (\"rightharpoond\", (0, 0)),\n        (\"SquareSubset;\", (8847, 0)),\n        (\"yscr;\", (120014, 0)),\n        (\"iac\", (0, 0)),\n        (\"permil\", (0, 0)),\n        (\"Rsh\", (0, 0)),\n        (\"rangd\", (0, 0)),\n        (\"els\", (0, 0)),\n        (\"cuepr\", (0, 0)),\n        (\"Ama\", (0, 0)),\n        (\"TripleDot;\", (8411, 0)),\n        (\"OpenCurlyDoubleQuote;\", (8220, 0)),\n        (\"gesl;\", (8923, 65024)),\n        (\"yci\", (0, 0)),\n        (\"nlAr\", (0, 0)),\n        (\"notnivc\", (0, 0)),\n        (\"gscr;\", (8458, 0)),\n        (\"NegativeMe\", (0, 0)),\n        (\"twi\", (0, 0)),\n        (\"lvertneqq\", (0, 0)),\n        (\"eth\", (240, 0)),\n        (\"Pi\", (0, 0)),\n        (\"MediumSpac\", (0, 0)),\n        (\"ultri\", (0, 0)),\n        (\"LongLeftA\", (0, 0)),\n        (\"SquareSupers\", (0, 0)),\n        (\"TildeT\", (0, 0)),\n        (\"FilledSmallSquare;\", (9724, 0)),\n        (\"nvrAr\", (0, 0)),\n        (\"nsho\", (0, 0)),\n        (\"RightAngl\", (0, 0)),\n        (\"dcy;\", (1076, 0)),\n        (\"RightVecto\", (0, 0)),\n        (\"szlig\", (223, 0)),\n        (\"NotSucce\", (0, 0)),\n        (\"lna\", (0, 0)),\n        (\"Not;\", (10988, 0)),\n        (\"InvisibleTimes\", (0, 0)),\n        (\"acir\", (0, 0)),\n        (\"uharr\", (0, 0)),\n        (\"RightFloor\", (0, 0)),\n        (\"npars\", (0, 0)),\n        (\"DownArro\", (0, 0)),\n        (\"squ\", (0, 0)),\n        (\"numer\", (0, 0)),\n        (\"Cc\", (0, 0)),\n        (\"succappr\", (0, 0)),\n        (\"cwco\", (0, 0)),\n        (\"dso\", (0, 0)),\n        (\"bu\", (0, 0)),\n        (\"Alph\", (0, 0)),\n        (\"UpTeeArrow;\", (8613, 0)),\n        (\"upharpoonrig\", (0, 0)),\n        (\"rarrt\", (0, 0)),\n        (\"expectati\", (0, 0)),\n        (\"easter\", (0, 0)),\n        (\"nsime\", (0, 0)),\n        (\"OpenC\", (0, 0)),\n        (\"lparl\", (0, 0)),\n        (\"LongRightA\", (0, 0)),\n        (\"NotGreate\", (0, 0)),\n        (\"LeftTria\", (0, 0)),\n        (\"sscr\", (0, 0)),\n        (\"drbkarow;\", (10512, 0)),\n        (\"Fscr;\", (8497, 0)),\n        (\"scap\", (0, 0)),\n        (\"minusdu\", (0, 0)),\n        (\"ycy\", (0, 0)),\n        (\"curlyve\", (0, 0)),\n        (\"trpezium\", (0, 0)),\n        (\"smtes\", (0, 0)),\n        (\"subr\", (0, 0)),\n        (\"For\", (0, 0)),\n        (\"dzcy;\", (1119, 0)),\n        (\"UpEquilibriu\", (0, 0)),\n        (\"order\", (0, 0)),\n        (\"iogon;\", (303, 0)),\n        (\"racute;\", (341, 0)),\n        (\"shortparallel\", (0, 0)),\n        (\"TildeFul\", (0, 0)),\n        (\"Ro\", (0, 0)),\n        (\"proflin\", (0, 0)),\n        (\"iukc\", (0, 0)),\n        (\"VeryThi\", (0, 0)),\n        (\"blo\", (0, 0)),\n        (\"Lmidot;\", (319, 0)),\n        (\"IJlig\", (0, 0)),\n        (\"LeftAng\", (0, 0)),\n        (\"circe\", (0, 0)),\n        (\"Ts\", (0, 0)),\n        (\"exponentiale;\", (8519, 0)),\n        (\"TildeFullE\", (0, 0)),\n        (\"angmsdab;\", (10665, 0)),\n        (\"Jo\", (0, 0)),\n        (\"Lscr;\", (8466, 0)),\n        (\"dis\", (0, 0)),\n        (\"Ut\", (0, 0)),\n        (\"odo\", (0, 0)),\n        (\"uwangle;\", (10663, 0)),\n        (\"apaci\", (0, 0)),\n        (\"comm\", (0, 0)),\n        (\"cirs\", (0, 0)),\n        (\"risin\", (0, 0)),\n        (\"NotSquareSupe\", (0, 0)),\n        (\"uparrow\", (0, 0)),\n        (\"UnderBracke\", (0, 0)),\n        (\"xlar\", (0, 0)),\n        (\"NotPrecedesEqual;\", (10927, 824)),\n        (\"Zscr;\", (119989, 0)),\n        (\"barwedge\", (0, 0)),\n        (\"Oop\", (0, 0)),\n        (\"bigsq\", (0, 0)),\n        (\"llcorn\", (0, 0)),\n        (\"backepsil\", (0, 0)),\n        (\"LJc\", (0, 0)),\n        (\"kh\", (0, 0)),\n        (\"varsupsetneq;\", (8843, 65024)),\n        (\"ve\", (0, 0)),\n        (\"omicron;\", (959, 0)),\n        (\"leftrightarro\", (0, 0)),\n        (\"leftrightarr\", (0, 0)),\n        (\"caret\", (0, 0)),\n        (\"topf\", (0, 0)),\n        (\"sdot\", (0, 0)),\n        (\"thickappr\", (0, 0)),\n        (\"radi\", (0, 0)),\n        (\"dopf;\", (120149, 0)),\n        (\"nex\", (0, 0)),\n        (\"copy\", (169, 0)),\n        (\"NotLessE\", (0, 0)),\n        (\"vltri\", (0, 0)),\n        (\"comma;\", (44, 0)),\n        (\"hoar\", (0, 0)),\n        (\"orig\", (0, 0)),\n        (\"nshortparal\", (0, 0)),\n        (\"rightsquiga\", (0, 0)),\n        (\"RightDown\", (0, 0)),\n        (\"ap\", (0, 0)),\n        (\"nltrie\", (0, 0)),\n        (\"HumpDow\", (0, 0)),\n        (\"straightph\", (0, 0)),\n        (\"circlearrowleft;\", (8634, 0)),\n        (\"tw\", (0, 0)),\n        (\"olci\", (0, 0)),\n        (\"phmm\", (0, 0)),\n        (\"SOFT\", (0, 0)),\n        (\"gopf\", (0, 0)),\n        (\"dotsquare\", (0, 0)),\n        (\"Bumpeq\", (0, 0)),\n        (\"erar\", (0, 0)),\n        (\"boxbo\", (0, 0)),\n        (\"nVDas\", (0, 0)),\n        (\"shch\", (0, 0)),\n        (\"OverBra\", (0, 0)),\n        (\"angmsdac\", (0, 0)),\n        (\"RightArrowLef\", (0, 0)),\n        (\"bigca\", (0, 0)),\n        (\"NotReverseElemen\", (0, 0)),\n        (\"perp\", (0, 0)),\n        (\"appr\", (0, 0)),\n        (\"js\", (0, 0)),\n        (\"profline\", (0, 0)),\n        (\"Wedge\", (0, 0)),\n        (\"LeftArrow;\", (8592, 0)),\n        (\"nwnear;\", (10535, 0)),\n        (\"eqvparsl\", (0, 0)),\n        (\"Vbar;\", (10987, 0)),\n        (\"lpa\", (0, 0)),\n        (\"searrow\", (0, 0)),\n        (\"DJ\", (0, 0)),\n        (\"nlarr;\", (8602, 0)),\n        (\"bigci\", (0, 0)),\n        (\"Clockwi\", (0, 0)),\n        (\"Sups\", (0, 0)),\n        (\"loarr\", (0, 0)),\n        (\"Cro\", (0, 0)),\n        (\"Beca\", (0, 0)),\n        (\"cirf\", (0, 0)),\n        (\"NotLeftTriangleEqu\", (0, 0)),\n        (\"vartriangl\", (0, 0)),\n        (\"real\", (0, 0)),\n        (\"ZeroWidthSp\", (0, 0)),\n        (\"lba\", (0, 0)),\n        (\"NotRightTriangleBar\", (0, 0)),\n        (\"oplus;\", (8853, 0)),\n        (\"times\", (215, 0)),\n        (\"rightr\", (0, 0)),\n        (\"leftri\", (0, 0)),\n        (\"Dcaron\", (0, 0)),\n        (\"rarrbfs;\", (10528, 0)),\n        (\"nLeftrightarr\", (0, 0)),\n        (\"ReverseUpE\", (0, 0)),\n        (\"DownLeftRightVector;\", (10576, 0)),\n        (\"pert\", (0, 0)),\n        (\"DoubleLongRightArro\", (0, 0)),\n        (\"iukcy;\", (1110, 0)),\n        (\"lowa\", (0, 0)),\n        (\"og\", (0, 0)),\n        (\"Cente\", (0, 0)),\n        (\"kcedil;\", (311, 0)),\n        (\"DoubleLongLeftRightArro\", (0, 0)),\n        (\"bnot\", (0, 0)),\n        (\"nrarrw;\", (8605, 824)),\n        (\"rfr;\", (120111, 0)),\n        (\"oti\", (0, 0)),\n        (\"Left\", (0, 0)),\n        (\"OverParenthesis;\", (9180, 0)),\n        (\"measuredangle\", (0, 0)),\n        (\"fpart\", (0, 0)),\n        (\"dotsquar\", (0, 0)),\n        (\"NotSquareSubsetEq\", (0, 0)),\n        (\"DiacriticalAcute\", (0, 0)),\n        (\"DS\", (0, 0)),\n        (\"downharpoonleft;\", (8643, 0)),\n        (\"harrcir\", (0, 0)),\n        (\"DownLeftRightVec\", (0, 0)),\n        (\"Egr\", (0, 0)),\n        (\"Jserc\", (0, 0)),\n        (\"ShortL\", (0, 0)),\n        (\"lessd\", (0, 0)),\n        (\"succcu\", (0, 0)),\n        (\"dotplu\", (0, 0)),\n        (\"PlusM\", (0, 0)),\n        (\"hyph\", (0, 0)),\n        (\"rightleftarrows;\", (8644, 0)),\n        (\"LeftTe\", (0, 0)),\n        (\"EmptySmallSqua\", (0, 0)),\n        (\"NotGreaterFullEq\", (0, 0)),\n        (\"cl\", (0, 0)),\n        (\"rppo\", (0, 0)),\n        (\"ldqu\", (0, 0)),\n        (\"DiacriticalDot\", (0, 0)),\n        (\"nvdas\", (0, 0)),\n        (\"LessTil\", (0, 0)),\n        (\"LowerRightArrow\", (0, 0)),\n        (\"dalet\", (0, 0)),\n        (\"Otilde\", (213, 0)),\n        (\"sh\", (0, 0)),\n        (\"lbrke;\", (10635, 0)),\n        (\"seArr;\", (8664, 0)),\n        (\"oma\", (0, 0)),\n        (\"gEl\", (0, 0)),\n        (\"NonBreakingSpace\", (0, 0)),\n        (\"LessEqualGreat\", (0, 0)),\n        (\"uhblk;\", (9600, 0)),\n        (\"timesba\", (0, 0)),\n        (\"bopf\", (0, 0)),\n        (\"CloseCu\", (0, 0)),\n        (\"curlyvee\", (0, 0)),\n        (\"thksim;\", (8764, 0)),\n        (\"boxvH;\", (9578, 0)),\n        (\"luruha\", (0, 0)),\n        (\"vns\", (0, 0)),\n        (\"Hopf;\", (8461, 0)),\n        (\"CloseCurlyDoub\", (0, 0)),\n        (\"Square;\", (9633, 0)),\n        (\"subs\", (0, 0)),\n        (\"fltn\", (0, 0)),\n        (\"diga\", (0, 0)),\n        (\"rfloo\", (0, 0)),\n        (\"nspar;\", (8742, 0)),\n        (\"rightleftar\", (0, 0)),\n        (\"precnapprox;\", (10937, 0)),\n        (\"leftharpo\", (0, 0)),\n        (\"nleq;\", (8816, 0)),\n        (\"boxVR\", (0, 0)),\n        (\"range\", (0, 0)),\n        (\"robrk\", (0, 0)),\n        (\"xup\", (0, 0)),\n        (\"vangrt\", (0, 0)),\n        (\"nLeftrightarro\", (0, 0)),\n        (\"var\", (0, 0)),\n        (\"nRi\", (0, 0)),\n        (\"gnE\", (0, 0)),\n        (\"cros\", (0, 0)),\n        (\"pla\", (0, 0)),\n        (\"RightF\", (0, 0)),\n        (\"DoubleUpDownArrow;\", (8661, 0)),\n        (\"trianglerighte\", (0, 0)),\n        (\"Sfr\", (0, 0)),\n        (\"copys\", (0, 0)),\n        (\"xcir\", (0, 0)),\n        (\"odbla\", (0, 0)),\n        (\"rHar\", (0, 0)),\n        (\"yuc\", (0, 0)),\n        (\"alefsy\", (0, 0)),\n        (\"bigwedge;\", (8896, 0)),\n        (\"olar\", (0, 0)),\n        (\"Igrave\", (204, 0)),\n        (\"EmptyVerySmallSquar\", (0, 0)),\n        (\"ContourInte\", (0, 0)),\n        (\"vartrianglerigh\", (0, 0)),\n        (\"NegativeThinSpac\", (0, 0)),\n        (\"twoheadrightarrow;\", (8608, 0)),\n        (\"subne\", (0, 0)),\n        (\"NegativeTh\", (0, 0)),\n        (\"lBarr\", (0, 0)),\n        (\"oeli\", (0, 0)),\n        (\"Iota\", (0, 0)),\n        (\"intcal;\", (8890, 0)),\n        (\"equals\", (0, 0)),\n        (\"frac2\", (0, 0)),\n        (\"abreve;\", (259, 0)),\n        (\"upharpoonri\", (0, 0)),\n        (\"DiacriticalDoub\", (0, 0)),\n        (\"pe\", (0, 0)),\n        (\"SquareSubsetEqua\", (0, 0)),\n        (\"Lambda;\", (923, 0)),\n        (\"Dashv;\", (10980, 0)),\n        (\"Za\", (0, 0)),\n        (\"NonBreak\", (0, 0)),\n        (\"LeftUpDownVe\", (0, 0)),\n        (\"setm\", (0, 0)),\n        (\"spadesu\", (0, 0)),\n        (\"Nacut\", (0, 0)),\n        (\"approx;\", (8776, 0)),\n        (\"parsl;\", (11005, 0)),\n        (\"leftrightharpoons\", (0, 0)),\n        (\"rarrap\", (0, 0)),\n        (\"NestedGreaterGreat\", (0, 0)),\n        (\"plusacir;\", (10787, 0)),\n        (\"CircleTimes\", (0, 0)),\n        (\"dwa\", (0, 0)),\n        (\"cul\", (0, 0)),\n        (\"SupersetEqua\", (0, 0)),\n        (\"downha\", (0, 0)),\n        (\"sqcaps;\", (8851, 65024)),\n        (\"Therefo\", (0, 0)),\n        (\"hookrightarrow;\", (8618, 0)),\n        (\"boxDL;\", (9559, 0)),\n        (\"complexes;\", (8450, 0)),\n        (\"dopf\", (0, 0)),\n        (\"nLeftrightarrow;\", (8654, 0)),\n        (\"leftthr\", (0, 0)),\n        (\"rulu\", (0, 0)),\n        (\"NotElemen\", (0, 0)),\n        (\"LessFullE\", (0, 0)),\n        (\"EmptySmallSq\", (0, 0)),\n        (\"rAtail;\", (10524, 0)),\n        (\"zigrar\", (0, 0)),\n        (\"DownArr\", (0, 0)),\n        (\"Yopf\", (0, 0)),\n        (\"boxtimes\", (0, 0)),\n        (\"Upsil\", (0, 0)),\n        (\"nrarrc;\", (10547, 824)),\n        (\"DownLe\", (0, 0)),\n        (\"Bopf\", (0, 0)),\n        (\"minusdu;\", (10794, 0)),\n        (\"TSHc\", (0, 0)),\n        (\"Gdot;\", (288, 0)),\n        (\"LessEqua\", (0, 0)),\n        (\"Re\", (0, 0)),\n        (\"icy;\", (1080, 0)),\n        (\"im\", (0, 0)),\n        (\"bumpE;\", (10926, 0)),\n        (\"Ema\", (0, 0)),\n        (\"or\", (0, 0)),\n        (\"djc\", (0, 0)),\n        (\"phmma\", (0, 0)),\n        (\"ocir\", (0, 0)),\n        (\"profsurf;\", (8979, 0)),\n        (\"looparrowleft;\", (8619, 0)),\n        (\"lefth\", (0, 0)),\n        (\"nabl\", (0, 0)),\n        (\"iq\", (0, 0)),\n        (\"emac\", (0, 0)),\n        (\"odot\", (0, 0)),\n        (\"RightAngleBracke\", (0, 0)),\n        (\"wcir\", (0, 0)),\n        (\"LeftTeeArro\", (0, 0)),\n        (\"oelig;\", (339, 0)),\n        (\"nlef\", (0, 0)),\n        (\"imagline;\", (8464, 0)),\n        (\"ssm\", (0, 0)),\n        (\"NotGrea\", (0, 0)),\n        (\"LowerLef\", (0, 0)),\n        (\"Lfr;\", (120079, 0)),\n        (\"DownRightVecto\", (0, 0)),\n        (\"longmaps\", (0, 0)),\n        (\"sol\", (0, 0)),\n        (\"exponential\", (0, 0)),\n        (\"barwedge;\", (8965, 0)),\n        (\"ltq\", (0, 0)),\n        (\"LongRightArr\", (0, 0)),\n        (\"aa\", (0, 0)),\n        (\"ofr;\", (120108, 0)),\n        (\"numsp;\", (8199, 0)),\n        (\"oscr\", (0, 0)),\n        (\"Iacut\", (0, 0)),\n        (\"lvertneq\", (0, 0)),\n        (\"udar\", (0, 0)),\n        (\"to\", (0, 0)),\n        (\"varsupsetn\", (0, 0)),\n        (\"racute\", (0, 0)),\n        (\"kfr;\", (120104, 0)),\n        (\"mid;\", (8739, 0)),\n        (\"npolint\", (0, 0)),\n        (\"ContourIntegra\", (0, 0)),\n        (\"rightthree\", (0, 0)),\n        (\"velli\", (0, 0)),\n        (\"ngeq\", (0, 0)),\n        (\"nums\", (0, 0)),\n        (\"upd\", (0, 0)),\n        (\"thor\", (0, 0)),\n        (\"rthree;\", (8908, 0)),\n        (\"Pf\", (0, 0)),\n        (\"mapstoup\", (0, 0)),\n        (\"NotGreaterSlantE\", (0, 0)),\n        (\"Poin\", (0, 0)),\n        (\"Laplacetrf\", (0, 0)),\n        (\"roa\", (0, 0)),\n        (\"precn\", (0, 0)),\n        (\"imaglin\", (0, 0)),\n        (\"hookl\", (0, 0)),\n        (\"Ccedil;\", (199, 0)),\n        (\"searhk;\", (10533, 0)),\n        (\"downharpoon\", (0, 0)),\n        (\"RightUpDownVe\", (0, 0)),\n        (\"cf\", (0, 0)),\n        (\"Efr\", (0, 0)),\n        (\"Rrightarrow;\", (8667, 0)),\n        (\"bigodo\", (0, 0)),\n        (\"Wcir\", (0, 0)),\n        (\"loang;\", (10220, 0)),\n        (\"rightsquig\", (0, 0)),\n        (\"langd\", (0, 0)),\n        (\"laem\", (0, 0)),\n        (\"nsqsu\", (0, 0)),\n        (\"smallsetminu\", (0, 0)),\n        (\"dl\", (0, 0)),\n        (\"DiacriticalD\", (0, 0)),\n        (\"DownLeftVe\", (0, 0)),\n        (\"DownLeftVectorBar;\", (10582, 0)),\n        (\"vzig\", (0, 0)),\n        (\"varnothing;\", (8709, 0)),\n        (\"Rri\", (0, 0)),\n        (\"NonBre\", (0, 0)),\n        (\"andv;\", (10842, 0)),\n        (\"NotLessSlantEqual;\", (10877, 824)),\n        (\"isindot\", (0, 0)),\n        (\"nspa\", (0, 0)),\n        (\"complemen\", (0, 0)),\n        (\"frac56;\", (8538, 0)),\n        (\"ReverseUpEqui\", (0, 0)),\n        (\"varsubs\", (0, 0)),\n        (\"sacut\", (0, 0)),\n        (\"bnequi\", (0, 0)),\n        (\"DownArrow\", (0, 0)),\n        (\"UpperRight\", (0, 0)),\n        (\"Jsercy\", (0, 0)),\n        (\"ac\", (0, 0)),\n        (\"lfi\", (0, 0)),\n        (\"natura\", (0, 0)),\n        (\"TildeEqua\", (0, 0)),\n        (\"UpArrowBar;\", (10514, 0)),\n        (\"uparr\", (0, 0)),\n        (\"Uogon;\", (370, 0)),\n        (\"pcy\", (0, 0)),\n        (\"Dcaron;\", (270, 0)),\n        (\"Cconint;\", (8752, 0)),\n        (\"LessFul\", (0, 0)),\n        (\"ReverseUpEq\", (0, 0)),\n        (\"cylc\", (0, 0)),\n        (\"DoubleLeftTee;\", (10980, 0)),\n        (\"oopf;\", (120160, 0)),\n        (\"nR\", (0, 0)),\n        (\"hami\", (0, 0)),\n        (\"nesea\", (0, 0)),\n        (\"mcy\", (0, 0)),\n        (\"boxm\", (0, 0)),\n        (\"RightTeeArro\", (0, 0)),\n        (\"varsubsetneqq\", (0, 0)),\n        (\"lthr\", (0, 0)),\n        (\"dharl\", (0, 0)),\n        (\"mD\", (0, 0)),\n        (\"OpenCurly\", (0, 0)),\n        (\"UpperLeftA\", (0, 0)),\n        (\"DownLeftRightVector\", (0, 0)),\n        (\"lneqq;\", (8808, 0)),\n        (\"rightsq\", (0, 0)),\n        (\"DotE\", (0, 0)),\n        (\"SquareIntersect\", (0, 0)),\n        (\"Succeeds;\", (8827, 0)),\n        (\"ReverseElemen\", (0, 0)),\n        (\"RightArrowLeftArr\", (0, 0)),\n        (\"gla\", (0, 0)),\n        (\"CircleM\", (0, 0)),\n        (\"VeryThinSpac\", (0, 0)),\n        (\"elin\", (0, 0)),\n        (\"xu\", (0, 0)),\n        (\"UpEquil\", (0, 0)),\n        (\"big\", (0, 0)),\n        (\"Bfr;\", (120069, 0)),\n        (\"Cross;\", (10799, 0)),\n        (\"gdo\", (0, 0)),\n        (\"ctdot\", (0, 0)),\n        (\"larrfs\", (0, 0)),\n        (\"vnsub;\", (8834, 8402)),\n        (\"leftharpoonu\", (0, 0)),\n        (\"cdot;\", (267, 0)),\n        (\"NotExist\", (0, 0)),\n        (\"NotCongru\", (0, 0)),\n        (\"lB\", (0, 0)),\n        (\"curlyvee;\", (8910, 0)),\n        (\"ShortLe\", (0, 0)),\n        (\"prece\", (0, 0)),\n        (\"Aring;\", (197, 0)),\n        (\"tar\", (0, 0)),\n        (\"Zdo\", (0, 0)),\n        (\"Bscr\", (0, 0)),\n        (\"upupar\", (0, 0)),\n        (\"NotSquareSuperset;\", (8848, 824)),\n        (\"origof\", (0, 0)),\n        (\"sset\", (0, 0)),\n        (\"Differential\", (0, 0)),\n        (\"NegativeThickSpace\", (0, 0)),\n        (\"CloseCurlyQuote;\", (8217, 0)),\n        (\"SquareIntersection\", (0, 0)),\n        (\"su\", (0, 0)),\n        (\"downarr\", (0, 0)),\n        (\"GreaterEq\", (0, 0)),\n        (\"leftrightharpo\", (0, 0)),\n        (\"LessFu\", (0, 0)),\n        (\"ecolon;\", (8789, 0)),\n        (\"LeftVe\", (0, 0)),\n        (\"ks\", (0, 0)),\n        (\"Theref\", (0, 0)),\n        (\"Sci\", (0, 0)),\n        (\"lrhar\", (0, 0)),\n        (\"ntilde;\", (241, 0)),\n        (\"iop\", (0, 0)),\n        (\"suphso\", (0, 0)),\n        (\"DoubleLongLeftRightArr\", (0, 0)),\n        (\"hyp\", (0, 0)),\n        (\"Ntild\", (0, 0)),\n        (\"rdldh\", (0, 0)),\n        (\"notni\", (0, 0)),\n        (\"rdca;\", (10551, 0)),\n        (\"Ccedi\", (0, 0)),\n        (\"leftarrow\", (0, 0)),\n        (\"Leftarrow\", (0, 0)),\n        (\"Dia\", (0, 0)),\n        (\"IOcy\", (0, 0)),\n        (\"Vcy;\", (1042, 0)),\n        (\"zd\", (0, 0)),\n        (\"QUOT;\", (34, 0)),\n        (\"YAc\", (0, 0)),\n        (\"angz\", (0, 0)),\n        (\"co\", (0, 0)),\n        (\"Lleftarro\", (0, 0)),\n        (\"odiv;\", (10808, 0)),\n        (\"Leftri\", (0, 0)),\n        (\"Horizo\", (0, 0)),\n        (\"Longlefta\", (0, 0)),\n        (\"LeftVecto\", (0, 0)),\n        (\"Nscr\", (0, 0)),\n        (\"Aa\", (0, 0)),\n        (\"RightUpVectorBar;\", (10580, 0)),\n        (\"Con\", (0, 0)),\n        (\"ldrdhar\", (0, 0)),\n        (\"Iuml\", (207, 0)),\n        (\"sacu\", (0, 0)),\n        (\"nLt\", (0, 0)),\n        (\"circlearr\", (0, 0)),\n        (\"AEli\", (0, 0)),\n        (\"Lacute\", (0, 0)),\n        (\"NotSuc\", (0, 0)),\n        (\"llarr\", (0, 0)),\n        (\"Negat\", (0, 0)),\n        (\"intercal\", (0, 0)),\n        (\"twoheadrighta\", (0, 0)),\n        (\"lefthar\", (0, 0)),\n        (\"middot\", (183, 0)),\n        (\"prc\", (0, 0)),\n        (\"Minu\", (0, 0)),\n        (\"tau\", (0, 0)),\n        (\"yacy\", (0, 0)),\n        (\"andand;\", (10837, 0)),\n        (\"LeftDownTeeVecto\", (0, 0)),\n        (\"ntriangl\", (0, 0)),\n        (\"scpolin\", (0, 0)),\n        (\"DownArrowUpArr\", (0, 0)),\n        (\"jmath;\", (567, 0)),\n        (\"ique\", (0, 0)),\n        (\"Ho\", (0, 0)),\n        (\"Ari\", (0, 0)),\n        (\"nscr;\", (120003, 0)),\n        (\"utilde;\", (361, 0)),\n        (\"succnsim\", (0, 0)),\n        (\"Bopf;\", (120121, 0)),\n        (\"InvisibleCo\", (0, 0)),\n        (\"barwe\", (0, 0)),\n        (\"lam\", (0, 0)),\n        (\"capcu\", (0, 0)),\n        (\"NotCu\", (0, 0)),\n        (\"rarrhk;\", (8618, 0)),\n        (\"bf\", (0, 0)),\n        (\"wfr;\", (120116, 0)),\n        (\"GreaterSl\", (0, 0)),\n        (\"wreat\", (0, 0)),\n        (\"leftthreetimes;\", (8907, 0)),\n        (\"a\", (0, 0)),\n        (\"mapsto\", (0, 0)),\n        (\"acute\", (180, 0)),\n        (\"mldr\", (0, 0)),\n        (\"VerticalLi\", (0, 0)),\n        (\"rnmid\", (0, 0)),\n        (\"Succ\", (0, 0)),\n        (\"LeftTriangle\", (0, 0)),\n        (\"dz\", (0, 0)),\n        (\"hy\", (0, 0)),\n        (\"LongLeftRig\", (0, 0)),\n        (\"LeftDoubleBrac\", (0, 0)),\n        (\"NonB\", (0, 0)),\n        (\"DownLeftTe\", (0, 0)),\n        (\"frac18;\", (8539, 0)),\n        (\"disi\", (0, 0)),\n        (\"Longleftrightarrow;\", (10234, 0)),\n        (\"lambda;\", (955, 0)),\n        (\"rBarr;\", (10511, 0)),\n        (\"boxt\", (0, 0)),\n        (\"nvle\", (0, 0)),\n        (\"ograv\", (0, 0)),\n        (\"poin\", (0, 0)),\n        (\"xlArr;\", (10232, 0)),\n        (\"rdquor;\", (8221, 0)),\n        (\"Iukcy\", (0, 0)),\n        (\"tp\", (0, 0)),\n        (\"ge;\", (8805, 0)),\n        (\"rceil;\", (8969, 0)),\n        (\"Lt;\", (8810, 0)),\n        (\"acirc;\", (226, 0)),\n        (\"bullet;\", (8226, 0)),\n        (\"sm\", (0, 0)),\n        (\"LJ\", (0, 0)),\n        (\"rightha\", (0, 0)),\n        (\"NotGreaterSlantEqual\", (0, 0)),\n        (\"hookleftarrow;\", (8617, 0)),\n        (\"qopf\", (0, 0)),\n        (\"ShortRightArrow\", (0, 0)),\n        (\"rppol\", (0, 0)),\n        (\"caps\", (0, 0)),\n        (\"quo\", (0, 0)),\n        (\"ycirc\", (0, 0)),\n        (\"digamm\", (0, 0)),\n        (\"LT\", (60, 0)),\n        (\"rlarr\", (0, 0)),\n        (\"Udblac\", (0, 0)),\n        (\"yen;\", (165, 0)),\n        (\"luruhar\", (0, 0)),\n        (\"ddarr\", (0, 0)),\n        (\"nexist;\", (8708, 0)),\n        (\"RoundImplie\", (0, 0)),\n        (\"rightharpoondo\", (0, 0)),\n        (\"nsqsupe;\", (8931, 0)),\n        (\"Minus\", (0, 0)),\n        (\"bigv\", (0, 0)),\n        (\"Backs\", (0, 0)),\n        (\"nleftrigh\", (0, 0)),\n        (\"plusa\", (0, 0)),\n        (\"rtr\", (0, 0)),\n        (\"NotLessG\", (0, 0)),\n        (\"Barw\", (0, 0)),\n        (\"ShortRightA\", (0, 0)),\n        (\"vrt\", (0, 0)),\n        (\"epl\", (0, 0)),\n        (\"lbra\", (0, 0)),\n        (\"nh\", (0, 0)),\n        (\"bigtriangledown\", (0, 0)),\n        (\"longmapst\", (0, 0)),\n        (\"LeftTriangleEqu\", (0, 0)),\n        (\"zac\", (0, 0)),\n        (\"bigtriangleup\", (0, 0)),\n        (\"lesdot;\", (10879, 0)),\n        (\"hai\", (0, 0)),\n        (\"llar\", (0, 0)),\n        (\"sma\", (0, 0)),\n        (\"fltns\", (0, 0)),\n        (\"Icirc\", (206, 0)),\n        (\"MediumSpa\", (0, 0)),\n        (\"cwconint;\", (8754, 0)),\n        (\"blacklo\", (0, 0)),\n        (\"Cl\", (0, 0)),\n        (\"ncedil;\", (326, 0)),\n        (\"lopf\", (0, 0)),\n        (\"Is\", (0, 0)),\n        (\"eqslan\", (0, 0)),\n        (\"ohbar\", (0, 0)),\n        (\"xodot;\", (10752, 0)),\n        (\"rarrb\", (0, 0)),\n        (\"supds\", (0, 0)),\n        (\"down\", (0, 0)),\n        (\"Differentia\", (0, 0)),\n        (\"nhA\", (0, 0)),\n        (\"LeftCeiling\", (0, 0)),\n        (\"measure\", (0, 0)),\n        (\"NotLessSlantE\", (0, 0)),\n        (\"supseteq\", (0, 0)),\n        (\"Ecir\", (0, 0)),\n        (\"Afr;\", (120068, 0)),\n        (\"barve\", (0, 0)),\n        (\"LeftDoubleBracket\", (0, 0)),\n        (\"downdowna\", (0, 0)),\n        (\"planckh;\", (8462, 0)),\n        (\"Aogon\", (0, 0)),\n        (\"plusb;\", (8862, 0)),\n        (\"center\", (0, 0)),\n        (\"PrecedesEqu\", (0, 0)),\n        (\"rsh;\", (8625, 0)),\n        (\"Mellin\", (0, 0)),\n        (\"SubsetEqu\", (0, 0)),\n        (\"gve\", (0, 0)),\n        (\"LeftArrowRightArrow\", (0, 0)),\n        (\"Ar\", (0, 0)),\n        (\"loang\", (0, 0)),\n        (\"supmul\", (0, 0)),\n        (\"Horizontal\", (0, 0)),\n        (\"Cac\", (0, 0)),\n        (\"supe;\", (8839, 0)),\n        (\"LeftRightArrow\", (0, 0)),\n        (\"gbreve;\", (287, 0)),\n        (\"LeftVect\", (0, 0)),\n        (\"micro;\", (181, 0)),\n        (\"fl\", (0, 0)),\n        (\"RightCeiling\", (0, 0)),\n        (\"em\", (0, 0)),\n        (\"Rca\", (0, 0)),\n        (\"OpenCurlyDoubl\", (0, 0)),\n        (\"bcong;\", (8780, 0)),\n        (\"HorizontalLin\", (0, 0)),\n        (\"nvHa\", (0, 0)),\n        (\"CloseCurlyDoubleQuo\", (0, 0)),\n        (\"rAr\", (0, 0)),\n        (\"RightDownVectorB\", (0, 0)),\n        (\"NotNestedGreaterGr\", (0, 0)),\n        (\"rightthreetime\", (0, 0)),\n        (\"nlArr;\", (8653, 0)),\n        (\"DownArrowUpAr\", (0, 0)),\n        (\"Iti\", (0, 0)),\n        (\"nsupseteqq\", (0, 0)),\n        (\"nrarr;\", (8603, 0)),\n        (\"lesdoto;\", (10881, 0)),\n        (\"angmsdah;\", (10671, 0)),\n        (\"OverPare\", (0, 0)),\n        (\"kfr\", (0, 0)),\n        (\"lsi\", (0, 0)),\n        (\"Be\", (0, 0)),\n        (\"ReverseU\", (0, 0)),\n        (\"low\", (0, 0)),\n        (\"asympeq;\", (8781, 0)),\n        (\"leftarrowtail\", (0, 0)),\n        (\"andv\", (0, 0)),\n        (\"iquest;\", (191, 0)),\n        (\"heartsuit\", (0, 0)),\n        (\"blacktrian\", (0, 0)),\n        (\"UnderBrack\", (0, 0)),\n        (\"vert\", (0, 0)),\n        (\"quat\", (0, 0)),\n        (\"cir\", (0, 0)),\n        (\"wf\", (0, 0)),\n        (\"downdownarrows\", (0, 0)),\n        (\"smallset\", (0, 0)),\n        (\"sccue\", (0, 0)),\n        (\"RightTriangleEqual;\", (8885, 0)),\n        (\"quaternio\", (0, 0)),\n        (\"DownRightTeeVecto\", (0, 0)),\n        (\"eqv\", (0, 0)),\n        (\"npreceq\", (0, 0)),\n        (\"Zac\", (0, 0)),\n        (\"oli\", (0, 0)),\n        (\"parsim\", (0, 0)),\n        (\"supdsub\", (0, 0)),\n        (\"equiv;\", (8801, 0)),\n        (\"ola\", (0, 0)),\n        (\"dtdot;\", (8945, 0)),\n        (\"raempt\", (0, 0)),\n        (\"LeftAngle\", (0, 0)),\n        (\"nshort\", (0, 0)),\n        (\"Rarrtl\", (0, 0)),\n        (\"frac4\", (0, 0)),\n        (\"ltrP\", (0, 0)),\n        (\"curvearrow\", (0, 0)),\n        (\"mdash\", (0, 0)),\n        (\"nearhk\", (0, 0)),\n        (\"suplar\", (0, 0)),\n        (\"GreaterEqualLes\", (0, 0)),\n        (\"kjcy\", (0, 0)),\n        (\"vartheta;\", (977, 0)),\n        (\"llco\", (0, 0)),\n        (\"boxHU;\", (9577, 0)),\n        (\"rightthr\", (0, 0)),\n        (\"nharr\", (0, 0)),\n        (\"para\", (182, 0)),\n        (\"W\", (0, 0)),\n        (\"andslope\", (0, 0)),\n        (\"sqsupsete\", (0, 0)),\n        (\"CircleMinus;\", (8854, 0)),\n        (\"nexi\", (0, 0)),\n        (\"Hilber\", (0, 0)),\n        (\"iex\", (0, 0)),\n        (\"UnionPlu\", (0, 0)),\n        (\"Bumpe\", (0, 0)),\n        (\"acu\", (0, 0)),\n        (\"cw\", (0, 0)),\n        (\"Eop\", (0, 0)),\n        (\"bigupl\", (0, 0)),\n        (\"mapstodown;\", (8615, 0)),\n        (\"hslash\", (0, 0)),\n        (\"Congruent\", (0, 0)),\n        (\"nGg\", (0, 0)),\n        (\"supE;\", (10950, 0)),\n        (\"parsl\", (0, 0)),\n        (\"lsa\", (0, 0)),\n        (\"spadesuit;\", (9824, 0)),\n        (\"ju\", (0, 0)),\n        (\"Juk\", (0, 0)),\n        (\"cwint;\", (8753, 0)),\n        (\"Equilibrium;\", (8652, 0)),\n        (\"Lon\", (0, 0)),\n        (\"NotNestedLe\", (0, 0)),\n        (\"succsim\", (0, 0)),\n        (\"varr\", (0, 0)),\n        (\"rbrke\", (0, 0)),\n        (\"Precedes\", (0, 0)),\n        (\"angmsd;\", (8737, 0)),\n        (\"lth\", (0, 0)),\n        (\"dal\", (0, 0)),\n        (\"GJc\", (0, 0)),\n        (\"ldrushar\", (0, 0)),\n        (\"Upsi;\", (978, 0)),\n        (\"nLtv\", (0, 0)),\n        (\"rationa\", (0, 0)),\n        (\"downharpoonr\", (0, 0)),\n        (\"DoubleDownArrow\", (0, 0)),\n        (\"urcorner\", (0, 0)),\n        (\"tscy;\", (1094, 0)),\n        (\"upharpoonleft;\", (8639, 0)),\n        (\"vBarv\", (0, 0)),\n        (\"square;\", (9633, 0)),\n        (\"HumpEqua\", (0, 0)),\n        (\"jcy;\", (1081, 0)),\n        (\"gtlPar\", (0, 0)),\n        (\"nsucceq\", (0, 0)),\n        (\"sacute;\", (347, 0)),\n        (\"eta;\", (951, 0)),\n        (\"bop\", (0, 0)),\n        (\"PrecedesSlantEqual;\", (8828, 0)),\n        (\"VerticalB\", (0, 0)),\n        (\"NotSucceedsSlantEq\", (0, 0)),\n        (\"vsupnE;\", (10956, 65024)),\n        (\"hoa\", (0, 0)),\n        (\"ea\", (0, 0)),\n        (\"leftrighth\", (0, 0)),\n        (\"LT;\", (60, 0)),\n        (\"divo\", (0, 0)),\n        (\"sra\", (0, 0)),\n        (\"DownLeftR\", (0, 0)),\n        (\"lopa\", (0, 0)),\n        (\"Esim;\", (10867, 0)),\n        (\"rhov\", (0, 0)),\n        (\"xha\", (0, 0)),\n        (\"NotNestedLessLess\", (0, 0)),\n        (\"DoubleLongLeftRightAr\", (0, 0)),\n        (\"kcy\", (0, 0)),\n        (\"Zop\", (0, 0)),\n        (\"nvdash;\", (8876, 0)),\n        (\"NonBreakin\", (0, 0)),\n        (\"NotLeftTriangleE\", (0, 0)),\n        (\"subedot\", (0, 0)),\n        (\"LeftDouble\", (0, 0)),\n        (\"hba\", (0, 0)),\n        (\"DoubleUpArr\", (0, 0)),\n        (\"D\", (0, 0)),\n        (\"bull;\", (8226, 0)),\n        (\"EmptySmallSqu\", (0, 0)),\n        (\"Rule\", (0, 0)),\n        (\"RightTeeV\", (0, 0)),\n        (\"Imag\", (0, 0)),\n        (\"Sh\", (0, 0)),\n        (\"lesdo\", (0, 0)),\n        (\"EmptyVery\", (0, 0)),\n        (\"nla\", (0, 0)),\n        (\"nv\", (0, 0)),\n        (\"botto\", (0, 0)),\n        (\"NotEle\", (0, 0)),\n        (\"InvisibleComm\", (0, 0)),\n        (\"cen\", (0, 0)),\n        (\"QU\", (0, 0)),\n        (\"llt\", (0, 0)),\n        (\"boxhu\", (0, 0)),\n        (\"psi\", (0, 0)),\n        (\"LongLeftArr\", (0, 0)),\n        (\"NotSucceedsEqual;\", (10928, 824)),\n        (\"bempt\", (0, 0)),\n        (\"mcom\", (0, 0)),\n        (\"p\", (0, 0)),\n        (\"Abrev\", (0, 0)),\n        (\"Longl\", (0, 0)),\n        (\"ClockwiseContour\", (0, 0)),\n        (\"NotSucceedsTi\", (0, 0)),\n        (\"curlyeqsuc\", (0, 0)),\n        (\"rpargt\", (0, 0)),\n        (\"lacut\", (0, 0)),\n        (\"TildeFullEqual;\", (8773, 0)),\n        (\"NotRightTri\", (0, 0)),\n        (\"rsaqu\", (0, 0)),\n        (\"shortparall\", (0, 0)),\n        (\"homt\", (0, 0)),\n        (\"nvg\", (0, 0)),\n        (\"rlhar\", (0, 0)),\n        (\"nr\", (0, 0)),\n        (\"bprime;\", (8245, 0)),\n        (\"zeta;\", (950, 0)),\n        (\"LeftTriangleBa\", (0, 0)),\n        (\"supsetn\", (0, 0)),\n        (\"kgreen;\", (312, 0)),\n        (\"uua\", (0, 0)),\n        (\"exi\", (0, 0)),\n        (\"LongLeftRightArro\", (0, 0)),\n        (\"dzc\", (0, 0)),\n        (\"Pcy;\", (1055, 0)),\n        (\"SquareSupersetEq\", (0, 0)),\n        (\"rba\", (0, 0)),\n        (\"Clockwis\", (0, 0)),\n        (\"DJc\", (0, 0)),\n        (\"fpartint;\", (10765, 0)),\n        (\"gesles\", (0, 0)),\n        (\"CloseCurly\", (0, 0)),\n        (\"lowbar;\", (95, 0)),\n        (\"toea\", (0, 0)),\n        (\"OverParenthesis\", (0, 0)),\n        (\"measu\", (0, 0)),\n        (\"inodo\", (0, 0)),\n        (\"jop\", (0, 0)),\n        (\"Psi\", (0, 0)),\n        (\"Yscr\", (0, 0)),\n        (\"RightUpVect\", (0, 0)),\n        (\"NotGreaterGreat\", (0, 0)),\n        (\"acy;\", (1072, 0)),\n        (\"ulcor\", (0, 0)),\n        (\"gla;\", (10917, 0)),\n        (\"emacr\", (0, 0)),\n        (\"nsupe\", (0, 0)),\n        (\"lltri;\", (9722, 0)),\n        (\"COPY;\", (169, 0)),\n        (\"NotSucceedsSl\", (0, 0)),\n        (\"lagran\", (0, 0)),\n        (\"thetav\", (0, 0)),\n        (\"boxVL\", (0, 0)),\n        (\"risingdo\", (0, 0)),\n        (\"NotSucceedsTil\", (0, 0)),\n        (\"blan\", (0, 0)),\n        (\"NotTildeFullEqual\", (0, 0)),\n        (\"DoubleLongLef\", (0, 0)),\n        (\"top\", (0, 0)),\n        (\"tin\", (0, 0)),\n        (\"olcross\", (0, 0)),\n        (\"intege\", (0, 0)),\n        (\"YIcy\", (0, 0)),\n        (\"dw\", (0, 0)),\n        (\"nleftrightar\", (0, 0)),\n        (\"doteq\", (0, 0)),\n        (\"S\", (0, 0)),\n        (\"egs\", (0, 0)),\n        (\"jmat\", (0, 0)),\n        (\"vdas\", (0, 0)),\n        (\"vsup\", (0, 0)),\n        (\"DZcy;\", (1039, 0)),\n        (\"rational\", (0, 0)),\n        (\"rthr\", (0, 0)),\n        (\"imagpart\", (0, 0)),\n        (\"RightUpDownVect\", (0, 0)),\n        (\"GreaterGrea\", (0, 0)),\n        (\"Uri\", (0, 0)),\n        (\"blacktriang\", (0, 0)),\n        (\"GreaterSlantE\", (0, 0)),\n        (\"ncy\", (0, 0)),\n        (\"colone;\", (8788, 0)),\n        (\"rpargt;\", (10644, 0)),\n        (\"lH\", (0, 0)),\n        (\"lgE\", (0, 0)),\n        (\"ari\", (0, 0)),\n        (\"Vf\", (0, 0)),\n        (\"Oma\", (0, 0)),\n        (\"lAtail;\", (10523, 0)),\n        (\"escr;\", (8495, 0)),\n        (\"cylcty\", (0, 0)),\n        (\"Updownarr\", (0, 0)),\n        (\"spades\", (0, 0)),\n        (\"DDotrahd;\", (10513, 0)),\n        (\"AEl\", (0, 0)),\n        (\"fem\", (0, 0)),\n        (\"image;\", (8465, 0)),\n        (\"CapitalDifferential\", (0, 0)),\n        (\"leftrightsquig\", (0, 0)),\n        (\"prurel\", (0, 0)),\n        (\"fallin\", (0, 0)),\n        (\"agr\", (0, 0)),\n        (\"DoubleUpA\", (0, 0)),\n        (\"uhar\", (0, 0)),\n        (\"DownLeftVectorB\", (0, 0)),\n        (\"RightAngleBrac\", (0, 0)),\n        (\"dsol;\", (10742, 0)),\n        (\"vcy;\", (1074, 0)),\n        (\"NestedGr\", (0, 0)),\n        (\"lopar\", (0, 0)),\n        (\"Lmid\", (0, 0)),\n        (\"aeli\", (0, 0)),\n        (\"nsubset;\", (8834, 8402)),\n        (\"LeftRightArr\", (0, 0)),\n        (\"longlef\", (0, 0)),\n        (\"leftleft\", (0, 0)),\n        (\"NewLin\", (0, 0)),\n        (\"dash;\", (8208, 0)),\n        (\"Udbl\", (0, 0)),\n        (\"thickappro\", (0, 0)),\n        (\"LeftUpV\", (0, 0)),\n        (\"awconint\", (0, 0)),\n        (\"DoubleLeftArr\", (0, 0)),\n        (\"qfr\", (0, 0)),\n        (\"DoubleVert\", (0, 0)),\n        (\"rob\", (0, 0)),\n        (\"hArr;\", (8660, 0)),\n        (\"backepsilo\", (0, 0)),\n        (\"DSc\", (0, 0)),\n        (\"RightVe\", (0, 0)),\n        (\"ba\", (0, 0)),\n        (\"bigcup\", (0, 0)),\n        (\"lv\", (0, 0)),\n        (\"Rev\", (0, 0)),\n        (\"fltns;\", (9649, 0)),\n        (\"lAtail\", (0, 0)),\n        (\"OElig\", (0, 0)),\n        (\"looparrowlef\", (0, 0)),\n        (\"swarr\", (0, 0)),\n        (\"olt;\", (10688, 0)),\n        (\"Zc\", (0, 0)),\n        (\"rightlefta\", (0, 0)),\n        (\"OEl\", (0, 0)),\n        (\"triangleright;\", (9657, 0)),\n        (\"cupbrca\", (0, 0)),\n        (\"square\", (0, 0)),\n        (\"Cr\", (0, 0)),\n        (\"longleftrig\", (0, 0)),\n        (\"lced\", (0, 0)),\n        (\"As\", (0, 0)),\n        (\"eacute\", (233, 0)),\n        (\"backsimeq;\", (8909, 0)),\n        (\"rightharp\", (0, 0)),\n        (\"not;\", (172, 0)),\n        (\"ord\", (0, 0)),\n        (\"Gbreve;\", (286, 0)),\n        (\"lve\", (0, 0)),\n        (\"rarrb;\", (8677, 0)),\n        (\"hairsp\", (0, 0)),\n        (\"Pi;\", (928, 0)),\n        (\"ltc\", (0, 0)),\n        (\"Dcar\", (0, 0)),\n        (\"nvlA\", (0, 0)),\n        (\"Dag\", (0, 0)),\n        (\"Imacr;\", (298, 0)),\n        (\"fi\", (0, 0)),\n        (\"leftarrowtai\", (0, 0)),\n        (\"Ascr\", (0, 0)),\n        (\"midast;\", (42, 0)),\n        (\"aogo\", (0, 0)),\n        (\"AElig\", (198, 0)),\n        (\"RightArrowL\", (0, 0)),\n        (\"oh\", (0, 0)),\n        (\"I\", (0, 0)),\n        (\"DiacriticalG\", (0, 0)),\n        (\"NestedLessLess;\", (8810, 0)),\n        (\"Int;\", (8748, 0)),\n        (\"capdo\", (0, 0)),\n        (\"straighte\", (0, 0)),\n        (\"NotExis\", (0, 0)),\n        (\"CupC\", (0, 0)),\n        (\"napprox\", (0, 0)),\n        (\"NotSquareSubsetEqual;\", (8930, 0)),\n        (\"ssmi\", (0, 0)),\n        (\"loti\", (0, 0)),\n        (\"SucceedsEqu\", (0, 0)),\n        (\"hf\", (0, 0)),\n        (\"Dash\", (0, 0)),\n        (\"lceil;\", (8968, 0)),\n        (\"sim\", (0, 0)),\n        (\"tcar\", (0, 0)),\n        (\"ccaps\", (0, 0)),\n        (\"frac12;\", (189, 0)),\n        (\"ufr\", (0, 0)),\n        (\"iff\", (0, 0)),\n        (\"noti\", (0, 0)),\n        (\"Das\", (0, 0)),\n        (\"Tfr\", (0, 0)),\n        (\"apE;\", (10864, 0)),\n        (\"equa\", (0, 0)),\n        (\"leftleftarr\", (0, 0)),\n        (\"NewL\", (0, 0)),\n        (\"ShortRi\", (0, 0)),\n        (\"ddagge\", (0, 0)),\n        (\"diamondsu\", (0, 0)),\n        (\"Ya\", (0, 0)),\n        (\"ul\", (0, 0)),\n        (\"LongRightArrow\", (0, 0)),\n        (\"Hilbe\", (0, 0)),\n        (\"ntgl;\", (8825, 0)),\n        (\"DoubleLeftRigh\", (0, 0)),\n        (\"sstarf\", (0, 0)),\n        (\"blank\", (0, 0)),\n        (\"vopf;\", (120167, 0)),\n        (\"uhbl\", (0, 0)),\n        (\"NotLessEqual\", (0, 0)),\n        (\"NotElem\", (0, 0)),\n        (\"NotLeftTria\", (0, 0)),\n        (\"DoubleContou\", (0, 0)),\n        (\"vopf\", (0, 0)),\n        (\"Xo\", (0, 0)),\n        (\"lmoust\", (0, 0)),\n        (\"NestedGreaterGrea\", (0, 0)),\n        (\"nt\", (0, 0)),\n        (\"NegativeV\", (0, 0)),\n        (\"ShortUpArr\", (0, 0)),\n        (\"alep\", (0, 0)),\n        (\"uopf;\", (120166, 0)),\n        (\"LeftDoubleBrack\", (0, 0)),\n        (\"ngE\", (0, 0)),\n        (\"NJc\", (0, 0)),\n        (\"Precede\", (0, 0)),\n        (\"hybull\", (0, 0)),\n        (\"hybu\", (0, 0)),\n        (\"vartrianglele\", (0, 0)),\n        (\"DoubleLeftRightArr\", (0, 0)),\n        (\"Ccaron;\", (268, 0)),\n        (\"range;\", (10661, 0)),\n        (\"angle\", (0, 0)),\n        (\"Cco\", (0, 0)),\n        (\"SucceedsEqua\", (0, 0)),\n        (\"nisd;\", (8954, 0)),\n        (\"NotSubset\", (0, 0)),\n        (\"rcedi\", (0, 0)),\n        (\"kjcy;\", (1116, 0)),\n        (\"Wedge;\", (8896, 0)),\n        (\"nleftarrow;\", (8602, 0)),\n        (\"there4\", (0, 0)),\n        (\"Iogon;\", (302, 0)),\n        (\"minusb\", (0, 0)),\n        (\"longl\", (0, 0)),\n        (\"NotSupersetEqua\", (0, 0)),\n        (\"trianglele\", (0, 0)),\n        (\"hel\", (0, 0)),\n        (\"ltrPar;\", (10646, 0)),\n        (\"NotGreaterFullEqua\", (0, 0)),\n        (\"CloseCur\", (0, 0)),\n        (\"aelig\", (230, 0)),\n        (\"ltrie\", (0, 0)),\n        (\"tstrok;\", (359, 0)),\n        (\"fopf\", (0, 0)),\n        (\"upharpoonl\", (0, 0)),\n        (\"tshc\", (0, 0)),\n        (\"imo\", (0, 0)),\n        (\"rthree\", (0, 0)),\n        (\"iinfin\", (0, 0)),\n        (\"Longleftri\", (0, 0)),\n        (\"oda\", (0, 0)),\n        (\"EmptyVerySma\", (0, 0)),\n        (\"lang;\", (10216, 0)),\n        (\"rbbrk;\", (10099, 0)),\n        (\"nbump\", (0, 0)),\n        (\"Wscr\", (0, 0)),\n        (\"LeftRightA\", (0, 0)),\n        (\"sesw\", (0, 0)),\n        (\"oint\", (0, 0)),\n        (\"pm;\", (177, 0)),\n        (\"nparal\", (0, 0)),\n        (\"subsup;\", (10963, 0)),\n        (\"Tced\", (0, 0)),\n        (\"xnis\", (0, 0)),\n        (\"lst\", (0, 0)),\n        (\"utdot;\", (8944, 0)),\n        (\"Yfr\", (0, 0)),\n        (\"NegativeThin\", (0, 0)),\n        (\"orv\", (0, 0)),\n        (\"Mu;\", (924, 0)),\n        (\"agrave\", (224, 0)),\n        (\"del\", (0, 0)),\n        (\"GreaterEqualL\", (0, 0)),\n        (\"dwangl\", (0, 0)),\n        (\"approx\", (0, 0)),\n        (\"ClockwiseC\", (0, 0)),\n        (\"Dsc\", (0, 0)),\n        (\"doublebarwedg\", (0, 0)),\n        (\"DownArrowU\", (0, 0)),\n        (\"lrtri\", (0, 0)),\n        (\"NegativeVeryThinSpace;\", (8203, 0)),\n        (\"bump;\", (8782, 0)),\n        (\"bigcirc\", (0, 0)),\n        (\"divideontime\", (0, 0)),\n        (\"uph\", (0, 0)),\n        (\"upharpoonleft\", (0, 0)),\n        (\"bigwed\", (0, 0)),\n        (\"GreaterLess\", (0, 0)),\n        (\"Invisible\", (0, 0)),\n        (\"RightTee\", (0, 0)),\n        (\"measuredan\", (0, 0)),\n        (\"DoubleLef\", (0, 0)),\n        (\"NestedGre\", (0, 0)),\n        (\"eDDot;\", (10871, 0)),\n        (\"Ccirc;\", (264, 0)),\n        (\"RightUpD\", (0, 0)),\n        (\"Sig\", (0, 0)),\n        (\"Scedi\", (0, 0)),\n        (\"NotNestedGrea\", (0, 0)),\n        (\"cwconi\", (0, 0)),\n        (\"DoubleContourInteg\", (0, 0)),\n        (\"curvearrowri\", (0, 0)),\n        (\"lfr;\", (120105, 0)),\n        (\"olin\", (0, 0)),\n        (\"vlt\", (0, 0)),\n        (\"RuleDela\", (0, 0)),\n        (\"imof;\", (8887, 0)),\n        (\"RightTeeVect\", (0, 0)),\n        (\"Mu\", (0, 0)),\n        (\"gescc\", (0, 0)),\n        (\"NotSuperset;\", (8835, 8402)),\n        (\"curlyeqsu\", (0, 0)),\n        (\"Element\", (0, 0)),\n        (\"ut\", (0, 0)),\n        (\"boxminu\", (0, 0)),\n        (\"DoubleUpDownA\", (0, 0)),\n        (\"xoplus\", (0, 0)),\n        (\"varkapp\", (0, 0)),\n        (\"Clock\", (0, 0)),\n        (\"Superset\", (0, 0)),\n        (\"sha\", (0, 0)),\n        (\"cap\", (0, 0)),\n        (\"Ucy\", (0, 0)),\n        (\"neAr\", (0, 0)),\n        (\"isind\", (0, 0)),\n        (\"npolint;\", (10772, 0)),\n        (\"bemptyv\", (0, 0)),\n        (\"cuw\", (0, 0)),\n        (\"Leftarro\", (0, 0)),\n        (\"EmptyVerySmallSqu\", (0, 0)),\n        (\"Cu\", (0, 0)),\n        (\"squar\", (0, 0)),\n        (\"Bec\", (0, 0)),\n        (\"Longleftarrow\", (0, 0)),\n        (\"LeftTriangl\", (0, 0)),\n        (\"nva\", (0, 0)),\n        (\"odsold\", (0, 0)),\n        (\"straightepsil\", (0, 0)),\n        (\"circlearrowleft\", (0, 0)),\n        (\"Cros\", (0, 0)),\n        (\"OEli\", (0, 0)),\n        (\"boxUL\", (0, 0)),\n        (\"DoubleLongR\", (0, 0)),\n        (\"NotTildeT\", (0, 0)),\n        (\"boxVl;\", (9570, 0)),\n        (\"gE;\", (8807, 0)),\n        (\"ThickSpac\", (0, 0)),\n        (\"NotL\", (0, 0)),\n        (\"longri\", (0, 0)),\n        (\"eas\", (0, 0)),\n        (\"ThickSpace\", (0, 0)),\n        (\"Rfr\", (0, 0)),\n        (\"Prod\", (0, 0)),\n        (\"pr;\", (8826, 0)),\n        (\"dot;\", (729, 0)),\n        (\"duarr;\", (8693, 0)),\n        (\"T\", (0, 0)),\n        (\"hbar\", (0, 0)),\n        (\"ange\", (0, 0)),\n        (\"duarr\", (0, 0)),\n        (\"ufish\", (0, 0)),\n        (\"Del;\", (8711, 0)),\n        (\"xv\", (0, 0)),\n        (\"SucceedsSlant\", (0, 0)),\n        (\"ofcir;\", (10687, 0)),\n        (\"forall;\", (8704, 0)),\n        (\"reals;\", (8477, 0)),\n        (\"afr;\", (120094, 0)),\n        (\"rightrigh\", (0, 0)),\n        (\"cirfni\", (0, 0)),\n        (\"rfisht;\", (10621, 0)),\n        (\"nacut\", (0, 0)),\n        (\"Sa\", (0, 0)),\n        (\"VeryThin\", (0, 0)),\n        (\"emp\", (0, 0)),\n        (\"angrtvbd\", (0, 0)),\n        (\"iot\", (0, 0)),\n        (\"cup;\", (8746, 0)),\n        (\"ngsim;\", (8821, 0)),\n        (\"latail\", (0, 0)),\n        (\"dtd\", (0, 0)),\n        (\"neA\", (0, 0)),\n        (\"NotSupersetEqual\", (0, 0)),\n        (\"Lang\", (0, 0)),\n        (\"Exp\", (0, 0)),\n        (\"supedot;\", (10948, 0)),\n        (\"SquareSupe\", (0, 0)),\n        (\"eta\", (0, 0)),\n        (\"slarr;\", (8592, 0)),\n        (\"xdtr\", (0, 0)),\n        (\"euro;\", (8364, 0)),\n        (\"nvrA\", (0, 0)),\n        (\"NotSuccee\", (0, 0)),\n        (\"mnplus\", (0, 0)),\n        (\"emptyset\", (0, 0)),\n        (\"gopf;\", (120152, 0)),\n        (\"profsu\", (0, 0)),\n        (\"RightDoubleBra\", (0, 0)),\n        (\"angmsdab\", (0, 0)),\n        (\"Leftrightar\", (0, 0)),\n        (\"zcaron;\", (382, 0)),\n        (\"timesb;\", (8864, 0)),\n        (\"curlywedg\", (0, 0)),\n        (\"QUO\", (0, 0)),\n        (\"NotReverse\", (0, 0)),\n        (\"ogra\", (0, 0)),\n        (\"hstr\", (0, 0)),\n        (\"NotNe\", (0, 0)),\n        (\"l\", (0, 0)),\n        (\"nab\", (0, 0)),\n        (\"bepsi;\", (1014, 0)),\n        (\"upar\", (0, 0)),\n        (\"Subse\", (0, 0)),\n        (\"rs\", (0, 0)),\n        (\"Congruent;\", (8801, 0)),\n        (\"NotGreaterLes\", (0, 0)),\n        (\"juk\", (0, 0)),\n        (\"Cfr;\", (8493, 0)),\n        (\"nleftrightarrow;\", (8622, 0)),\n        (\"gel;\", (8923, 0)),\n        (\"Leftrig\", (0, 0)),\n        (\"Uarroci\", (0, 0)),\n        (\"fnof\", (0, 0)),\n        (\"angmsdaf;\", (10669, 0)),\n        (\"YUc\", (0, 0)),\n        (\"Tcedi\", (0, 0)),\n        (\"les\", (0, 0)),\n        (\"loze\", (0, 0)),\n        (\"lesseqqgtr\", (0, 0)),\n        (\"percnt;\", (37, 0)),\n        (\"bne;\", (61, 8421)),\n        (\"nrightarrow\", (0, 0)),\n        (\"piv;\", (982, 0)),\n        (\"lsim;\", (8818, 0)),\n        (\"COP\", (0, 0)),\n        (\"blacksquar\", (0, 0)),\n        (\"DoubleVertica\", (0, 0)),\n        (\"Reverse\", (0, 0)),\n        (\"vsupne\", (0, 0)),\n        (\"It\", (0, 0)),\n        (\"Popf;\", (8473, 0)),\n        (\"GreaterGr\", (0, 0)),\n        (\"bbrk;\", (9141, 0)),\n        (\"Pl\", (0, 0)),\n        (\"NotCupCa\", (0, 0)),\n        (\"simd\", (0, 0)),\n        (\"boxtim\", (0, 0)),\n        (\"GreaterSlantEqu\", (0, 0)),\n        (\"GreaterLes\", (0, 0)),\n        (\"LessEqualG\", (0, 0)),\n        (\"ntrianglerighteq\", (0, 0)),\n        (\"ho\", (0, 0)),\n        (\"HumpEqual\", (0, 0)),\n        (\"hookleftarro\", (0, 0)),\n        (\"smid\", (0, 0)),\n        (\"shchcy;\", (1097, 0)),\n        (\"rbra\", (0, 0)),\n        (\"LeftArrowRig\", (0, 0)),\n        (\"Doub\", (0, 0)),\n        (\"bernou;\", (8492, 0)),\n        (\"Vdas\", (0, 0)),\n        (\"dote\", (0, 0)),\n        (\"eac\", (0, 0)),\n        (\"gneqq\", (0, 0)),\n        (\"ApplyFunc\", (0, 0)),\n        (\"rationals;\", (8474, 0)),\n        (\"kapp\", (0, 0)),\n        (\"NotG\", (0, 0)),\n        (\"ag\", (0, 0)),\n        (\"supplu\", (0, 0)),\n        (\"sec\", (0, 0)),\n        (\"Expone\", (0, 0)),\n        (\"ctdo\", (0, 0)),\n        (\"pound\", (163, 0)),\n        (\"NotGreaterGreater;\", (8811, 824)),\n        (\"simplu\", (0, 0)),\n        (\"Exi\", (0, 0)),\n        (\"st\", (0, 0)),\n        (\"kopf;\", (120156, 0)),\n        (\"zwnj;\", (8204, 0)),\n        (\"UnionPlus;\", (8846, 0)),\n        (\"ntriangleri\", (0, 0)),\n        (\"xdtri\", (0, 0)),\n        (\"supmult\", (0, 0)),\n        (\"The\", (0, 0)),\n        (\"blacklozenge\", (0, 0)),\n        (\"ngeqsl\", (0, 0)),\n        (\"iio\", (0, 0)),\n        (\"fallingdotseq;\", (8786, 0)),\n        (\"Co\", (0, 0)),\n        (\"bcong\", (0, 0)),\n        (\"lvertneqq;\", (8808, 65024)),\n        (\"LeftUpTeeVec\", (0, 0)),\n        (\"triangledow\", (0, 0)),\n        (\"Uparrow;\", (8657, 0)),\n        (\"varep\", (0, 0)),\n        (\"R\", (0, 0)),\n        (\"alefsym\", (0, 0)),\n        (\"RBar\", (0, 0)),\n        (\"lceil\", (0, 0)),\n        (\"DownRightVector\", (0, 0)),\n        (\"suph\", (0, 0)),\n        (\"DownAr\", (0, 0)),\n        (\"ZeroWidth\", (0, 0)),\n        (\"NotRi\", (0, 0)),\n        (\"precsim\", (0, 0)),\n        (\"xop\", (0, 0)),\n        (\"Mfr\", (0, 0)),\n        (\"pluss\", (0, 0)),\n        (\"ogt;\", (10689, 0)),\n        (\"gtlP\", (0, 0)),\n        (\"nwArr;\", (8662, 0)),\n        (\"rarrl\", (0, 0)),\n        (\"larrp\", (0, 0)),\n        (\"ShortRigh\", (0, 0)),\n        (\"lneqq\", (0, 0)),\n        (\"Cconint\", (0, 0)),\n        (\"CounterClockwi\", (0, 0)),\n        (\"inodot;\", (305, 0)),\n        (\"planc\", (0, 0)),\n        (\"nsupseteqq;\", (10950, 824)),\n        (\"Updownarrow;\", (8661, 0)),\n        (\"DD;\", (8517, 0)),\n        (\"black\", (0, 0)),\n        (\"gtcir;\", (10874, 0)),\n        (\"righta\", (0, 0)),\n        (\"Uum\", (0, 0)),\n        (\"NotLess;\", (8814, 0)),\n        (\"pu\", (0, 0)),\n        (\"SquareIntersecti\", (0, 0)),\n        (\"rarr;\", (8594, 0)),\n        (\"capand\", (0, 0)),\n        (\"nrtri;\", (8939, 0)),\n        (\"LeftUpDownVect\", (0, 0)),\n        (\"trade;\", (8482, 0)),\n        (\"Eacut\", (0, 0)),\n        (\"sqsups\", (0, 0)),\n        (\"CircleD\", (0, 0)),\n        (\"rsaquo;\", (8250, 0)),\n        (\"sum\", (0, 0)),\n        (\"vell\", (0, 0)),\n        (\"ZeroWid\", (0, 0)),\n        (\"hscr\", (0, 0)),\n        (\"Subset\", (0, 0)),\n        (\"Gcirc;\", (284, 0)),\n        (\"awconi\", (0, 0)),\n        (\"VDas\", (0, 0)),\n        (\"Ouml\", (214, 0)),\n        (\"Im\", (0, 0)),\n        (\"sdo\", (0, 0)),\n        (\"Ecirc\", (202, 0)),\n        (\"supsetneqq;\", (10956, 0)),\n        (\"Scar\", (0, 0)),\n        (\"kgreen\", (0, 0)),\n        (\"ncaron;\", (328, 0)),\n        (\"doublebarwedge\", (0, 0)),\n        (\"femal\", (0, 0)),\n        (\"gammad;\", (989, 0)),\n        (\"dlcorn\", (0, 0)),\n        (\"twoh\", (0, 0)),\n        (\"RuleDelay\", (0, 0)),\n        (\"submul\", (0, 0)),\n        (\"mapsto;\", (8614, 0)),\n        (\"rtime\", (0, 0)),\n        (\"scar\", (0, 0)),\n        (\"Ecaron;\", (282, 0)),\n        (\"late;\", (10925, 0)),\n        (\"QUOT\", (34, 0)),\n        (\"aring\", (229, 0)),\n        (\"Rscr;\", (8475, 0)),\n        (\"Hstro\", (0, 0)),\n        (\"ZHcy\", (0, 0)),\n        (\"anda\", (0, 0)),\n        (\"Elem\", (0, 0)),\n        (\"nsucc\", (0, 0)),\n        (\"prna\", (0, 0)),\n        (\"NotHumpDownHum\", (0, 0)),\n        (\"succapp\", (0, 0)),\n        (\"DoubleVerticalBar\", (0, 0)),\n        (\"sigmav;\", (962, 0)),\n        (\"TRA\", (0, 0)),\n        (\"ofci\", (0, 0)),\n        (\"UpTee;\", (8869, 0)),\n        (\"zdo\", (0, 0)),\n        (\"NotDoubleVer\", (0, 0)),\n        (\"delta\", (0, 0)),\n        (\"rbrke;\", (10636, 0)),\n        (\"zopf\", (0, 0)),\n        (\"lesdotor;\", (10883, 0)),\n        (\"sig\", (0, 0)),\n        (\"epa\", (0, 0)),\n        (\"divideontimes;\", (8903, 0)),\n        (\"NotTilde;\", (8769, 0)),\n        (\"NotPrecedesSlantEq\", (0, 0)),\n        (\"Eo\", (0, 0)),\n        (\"UpDownA\", (0, 0)),\n        (\"frown;\", (8994, 0)),\n        (\"DotEqual\", (0, 0)),\n        (\"IO\", (0, 0)),\n        (\"iuml\", (239, 0)),\n        (\"lharul\", (0, 0)),\n        (\"falli\", (0, 0)),\n        (\"udhar;\", (10606, 0)),\n        (\"dfr;\", (120097, 0)),\n        (\"Qopf;\", (8474, 0)),\n        (\"frac14;\", (188, 0)),\n        (\"raemptyv\", (0, 0)),\n        (\"nprece\", (0, 0)),\n        (\"rdquor\", (0, 0)),\n        (\"vnsup;\", (8835, 8402)),\n        (\"iacu\", (0, 0)),\n        (\"longrightarrow\", (0, 0)),\n        (\"leftrightarrows\", (0, 0)),\n        (\"prop\", (0, 0)),\n        (\"orde\", (0, 0)),\n        (\"otimesa\", (0, 0)),\n        (\"suplarr;\", (10619, 0)),\n        (\"macr;\", (175, 0)),\n        (\"grav\", (0, 0)),\n        (\"napos\", (0, 0)),\n        (\"weierp;\", (8472, 0)),\n        (\"leftharpoon\", (0, 0)),\n        (\"RightTeeVec\", (0, 0)),\n        (\"GreaterEqualLe\", (0, 0)),\n        (\"SO\", (0, 0)),\n        (\"bdquo;\", (8222, 0)),\n        (\"NegativeMediumSpac\", (0, 0)),\n        (\"vscr\", (0, 0)),\n        (\"nop\", (0, 0)),\n        (\"nsups\", (0, 0)),\n        (\"boxhd;\", (9516, 0)),\n        (\"nea\", (0, 0)),\n        (\"Ne\", (0, 0)),\n        (\"EmptyVerySm\", (0, 0)),\n        (\"zh\", (0, 0)),\n        (\"Smal\", (0, 0)),\n        (\"oopf\", (0, 0)),\n        (\"hA\", (0, 0)),\n        (\"Au\", (0, 0)),\n        (\"apE\", (0, 0)),\n        (\"Eogo\", (0, 0)),\n        (\"int;\", (8747, 0)),\n        (\"Urin\", (0, 0)),\n        (\"fras\", (0, 0)),\n        (\"leftrightha\", (0, 0)),\n        (\"rtrie;\", (8885, 0)),\n        (\"nvsi\", (0, 0)),\n        (\"eogon;\", (281, 0)),\n        (\"OpenCurlyQuot\", (0, 0)),\n        (\"lscr\", (0, 0)),\n        (\"ufisht;\", (10622, 0)),\n        (\"Gbr\", (0, 0)),\n        (\"NotSquareSupersetEq\", (0, 0)),\n        (\"capcup;\", (10823, 0)),\n        (\"DoubleLeft\", (0, 0)),\n        (\"oplus\", (0, 0)),\n        (\"equivDD\", (0, 0)),\n        (\"LeftRightVec\", (0, 0)),\n        (\"dj\", (0, 0)),\n        (\"DownArrowUp\", (0, 0)),\n        (\"Epsilon;\", (917, 0)),\n        (\"Ubrev\", (0, 0)),\n        (\"RightDownVect\", (0, 0)),\n        (\"Lang;\", (10218, 0)),\n        (\"laq\", (0, 0)),\n        (\"Poincarep\", (0, 0)),\n        (\"vpr\", (0, 0)),\n        (\"straighteps\", (0, 0)),\n        (\"phi\", (0, 0)),\n        (\"quaternions;\", (8461, 0)),\n        (\"nsqsupe\", (0, 0)),\n        (\"RB\", (0, 0)),\n        (\"varnoth\", (0, 0)),\n        (\"realine\", (0, 0)),\n        (\"rB\", (0, 0)),\n        (\"curvea\", (0, 0)),\n        (\"UpperL\", (0, 0)),\n        (\"Io\", (0, 0)),\n        (\"RightUpTeeVector\", (0, 0)),\n        (\"NotRightTriangle\", (0, 0)),\n        (\"ltdo\", (0, 0)),\n        (\"nVd\", (0, 0)),\n        (\"bc\", (0, 0)),\n        (\"nshortpa\", (0, 0)),\n        (\"nu\", (0, 0)),\n        (\"midas\", (0, 0)),\n        (\"angmsd\", (0, 0)),\n        (\"cup\", (0, 0)),\n        (\"heartsu\", (0, 0)),\n        (\"Tstro\", (0, 0)),\n        (\"dfis\", (0, 0)),\n        (\"lesseqgtr;\", (8922, 0)),\n        (\"bnequiv;\", (8801, 8421)),\n        (\"rcub\", (0, 0)),\n        (\"orsl\", (0, 0)),\n        (\"Lstr\", (0, 0)),\n        (\"ForAl\", (0, 0)),\n        (\"downdo\", (0, 0)),\n        (\"npar;\", (8742, 0)),\n        (\"rx;\", (8478, 0)),\n        (\"curarr;\", (8631, 0)),\n        (\"Emacr\", (0, 0)),\n        (\"sigma\", (0, 0)),\n        (\"topc\", (0, 0)),\n        (\"Gcy;\", (1043, 0)),\n        (\"nLef\", (0, 0)),\n        (\"spad\", (0, 0)),\n        (\"NotRightTriangleEqu\", (0, 0)),\n        (\"gi\", (0, 0)),\n        (\"vfr\", (0, 0)),\n        (\"CounterClockwiseContou\", (0, 0)),\n        (\"lsc\", (0, 0)),\n        (\"downd\", (0, 0)),\n        (\"ap;\", (8776, 0)),\n        (\"ubrcy\", (0, 0)),\n        (\"piv\", (0, 0)),\n        (\"backpr\", (0, 0)),\n        (\"DiacriticalTil\", (0, 0)),\n        (\"Hori\", (0, 0)),\n        (\"supdsub;\", (10968, 0)),\n        (\"scns\", (0, 0)),\n        (\"precnsi\", (0, 0)),\n        (\"Horizonta\", (0, 0)),\n        (\"VerticalSeparat\", (0, 0)),\n        (\"angst\", (0, 0)),\n        (\"VeryThinS\", (0, 0)),\n        (\"uring\", (0, 0)),\n        (\"Itild\", (0, 0)),\n        (\"ShortDownArr\", (0, 0)),\n        (\"nd\", (0, 0)),\n        (\"Preced\", (0, 0)),\n        (\"glE\", (0, 0)),\n        (\"G\", (0, 0)),\n        (\"plustwo;\", (10791, 0)),\n        (\"notindo\", (0, 0)),\n        (\"CounterC\", (0, 0)),\n        (\"Iacute;\", (205, 0)),\n        (\"looparrowrigh\", (0, 0)),\n        (\"Hfr\", (0, 0)),\n        (\"isinE;\", (8953, 0)),\n        (\"gtques\", (0, 0)),\n        (\"Oscr\", (0, 0)),\n        (\"Ps\", (0, 0)),\n        (\"DoubleLeftArro\", (0, 0)),\n        (\"Ot\", (0, 0)),\n        (\"Qs\", (0, 0)),\n        (\"curarr\", (0, 0)),\n        (\"RightUpT\", (0, 0)),\n        (\"check;\", (10003, 0)),\n        (\"trpezi\", (0, 0)),\n        (\"bla\", (0, 0)),\n        (\"intcal\", (0, 0)),\n        (\"LeftUpVe\", (0, 0)),\n        (\"Fscr\", (0, 0)),\n        (\"uplu\", (0, 0)),\n        (\"npoli\", (0, 0)),\n        (\"lfisht;\", (10620, 0)),\n        (\"precc\", (0, 0)),\n        (\"lotime\", (0, 0)),\n        (\"nleftar\", (0, 0)),\n        (\"Tr\", (0, 0)),\n        (\"quot;\", (34, 0)),\n        (\"gimel;\", (8503, 0)),\n        (\"twoheadlefta\", (0, 0)),\n        (\"jcir\", (0, 0)),\n        (\"Dstr\", (0, 0)),\n        (\"Backslash;\", (8726, 0)),\n        (\"hookleftarrow\", (0, 0)),\n        (\"Oslash\", (216, 0)),\n        (\"orslop\", (0, 0)),\n        (\"Wfr;\", (120090, 0)),\n        (\"NestedLe\", (0, 0)),\n        (\"nvap;\", (8781, 8402)),\n        (\"Vopf\", (0, 0)),\n        (\"strns;\", (175, 0)),\n        (\"nLl;\", (8920, 824)),\n        (\"varkap\", (0, 0)),\n        (\"backp\", (0, 0)),\n        (\"ffilig\", (0, 0)),\n        (\"image\", (0, 0)),\n        (\"Zcaron;\", (381, 0)),\n        (\"OE\", (0, 0)),\n        (\"frown\", (0, 0)),\n        (\"Implies;\", (8658, 0)),\n        (\"dca\", (0, 0)),\n        (\"ApplyFunction\", (0, 0)),\n        (\"DoubleLongRig\", (0, 0)),\n        (\"oas\", (0, 0)),\n        (\"prs\", (0, 0)),\n        (\"HAR\", (0, 0)),\n        (\"SmallCirc\", (0, 0)),\n        (\"succnappro\", (0, 0)),\n        (\"Unde\", (0, 0)),\n        (\"RightDownTeeV\", (0, 0)),\n        (\"star;\", (9734, 0)),\n        (\"notinvb;\", (8951, 0)),\n        (\"nvlAr\", (0, 0)),\n        (\"NotRightTriangl\", (0, 0)),\n        (\"prure\", (0, 0)),\n        (\"DownRightT\", (0, 0)),\n        (\"P\", (0, 0)),\n        (\"subpl\", (0, 0)),\n        (\"Thic\", (0, 0)),\n        (\"TRADE\", (0, 0)),\n        (\"rH\", (0, 0)),\n        (\"elinter\", (0, 0)),\n        (\"M\", (0, 0)),\n        (\"boxvL\", (0, 0)),\n        (\"NotSubsetEq\", (0, 0)),\n        (\"lagr\", (0, 0)),\n        (\"vDa\", (0, 0)),\n        (\"itilde;\", (297, 0)),\n        (\"blacktrianglerig\", (0, 0)),\n        (\"agrave;\", (224, 0)),\n        (\"Lcy;\", (1051, 0)),\n        (\"apacir;\", (10863, 0)),\n        (\"sqsube;\", (8849, 0)),\n        (\"roan\", (0, 0)),\n        (\"ts\", (0, 0)),\n        (\"lesge\", (0, 0)),\n        (\"vartrianglerig\", (0, 0)),\n        (\"cemptyv;\", (10674, 0)),\n        (\"nscc\", (0, 0)),\n        (\"verb\", (0, 0)),\n        (\"ubrcy;\", (1118, 0)),\n        (\"dotminu\", (0, 0)),\n        (\"dstr\", (0, 0)),\n        (\"auml;\", (228, 0)),\n        (\"rtrif\", (0, 0)),\n        (\"NotGreaterG\", (0, 0)),\n        (\"nvltrie\", (0, 0)),\n        (\"Leftrightarrow;\", (8660, 0)),\n        (\"CHcy;\", (1063, 0)),\n        (\"curvearrowr\", (0, 0)),\n        (\"NotLessGreater;\", (8824, 0)),\n        (\"suppl\", (0, 0)),\n        (\"FilledSmallSquar\", (0, 0)),\n        (\"Horiz\", (0, 0)),\n        (\"CloseC\", (0, 0)),\n        (\"precappr\", (0, 0)),\n        (\"Atil\", (0, 0)),\n        (\"opl\", (0, 0)),\n        (\"nLeft\", (0, 0)),\n        (\"Ba\", (0, 0)),\n        (\"LeftVector\", (0, 0)),\n        (\"UpArrowB\", (0, 0)),\n        (\"InvisibleC\", (0, 0)),\n        (\"kgree\", (0, 0)),\n        (\"Dfr;\", (120071, 0)),\n        (\"bigcirc;\", (9711, 0)),\n        (\"NotCong\", (0, 0)),\n        (\"gesdotol\", (0, 0)),\n        (\"DownLeftRight\", (0, 0)),\n        (\"hcir\", (0, 0)),\n        (\"sqsubseteq;\", (8849, 0)),\n        (\"succnappr\", (0, 0)),\n        (\"rang;\", (10217, 0)),\n        (\"leg\", (0, 0)),\n        (\"Utilde\", (0, 0)),\n        (\"eqvparsl;\", (10725, 0)),\n        (\"LeftAngleBracket;\", (10216, 0)),\n        (\"pcy;\", (1087, 0)),\n        (\"RightDownVector;\", (8642, 0)),\n        (\"vartrianglel\", (0, 0)),\n        (\"HorizontalLine;\", (9472, 0)),\n        (\"downar\", (0, 0)),\n        (\"backepsilon;\", (1014, 0)),\n        (\"t\", (0, 0)),\n        (\"spadesuit\", (0, 0)),\n        (\"nsubE\", (0, 0)),\n        (\"rightt\", (0, 0)),\n        (\"LessTild\", (0, 0)),\n        (\"rightharpoondow\", (0, 0)),\n        (\"Umac\", (0, 0)),\n        (\"ange;\", (10660, 0)),\n        (\"circlearrowri\", (0, 0)),\n        (\"lrhar;\", (8651, 0)),\n        (\"NotEqualT\", (0, 0)),\n        (\"squ;\", (9633, 0)),\n        (\"tstrok\", (0, 0)),\n        (\"lmoustac\", (0, 0)),\n        (\"dcaron\", (0, 0)),\n        (\"succappro\", (0, 0)),\n        (\"gcirc;\", (285, 0)),\n        (\"RBarr;\", (10512, 0)),\n        (\"multimap;\", (8888, 0)),\n        (\"cempt\", (0, 0)),\n        (\"Right\", (0, 0)),\n        (\"Atilde\", (195, 0)),\n        (\"nvltr\", (0, 0)),\n        (\"NotLeftTrian\", (0, 0)),\n        (\"nV\", (0, 0)),\n        (\"Rarrtl;\", (10518, 0)),\n        (\"drco\", (0, 0)),\n        (\"GT;\", (62, 0)),\n        (\"Al\", (0, 0)),\n        (\"shortparal\", (0, 0)),\n        (\"ljc\", (0, 0)),\n        (\"sse\", (0, 0)),\n        (\"MinusP\", (0, 0)),\n        (\"Cayle\", (0, 0)),\n        (\"bigtriangledo\", (0, 0)),\n        (\"erDo\", (0, 0)),\n        (\"mcomm\", (0, 0)),\n        (\"intpr\", (0, 0)),\n        (\"Scirc\", (0, 0)),\n        (\"Kf\", (0, 0)),\n        (\"Coni\", (0, 0)),\n        (\"llha\", (0, 0)),\n        (\"xuplus\", (0, 0)),\n        (\"leftrightharpoons;\", (8651, 0)),\n        (\"dzigra\", (0, 0)),\n        (\"Lcedil;\", (315, 0)),\n        (\"diam;\", (8900, 0)),\n        (\"CircleTim\", (0, 0)),\n        (\"nwArr\", (0, 0)),\n        (\"pa\", (0, 0)),\n        (\"ordf;\", (170, 0)),\n        (\"tra\", (0, 0)),\n        (\"kce\", (0, 0)),\n        (\"ocirc;\", (244, 0)),\n        (\"Itil\", (0, 0)),\n        (\"Nfr;\", (120081, 0)),\n        (\"RightUpDownVector;\", (10575, 0)),\n        (\"cupcap;\", (10822, 0)),\n        (\"intpro\", (0, 0)),\n        (\"SubsetEqual;\", (8838, 0)),\n        (\"nleftri\", (0, 0)),\n        (\"easter;\", (10862, 0)),\n        (\"erDot\", (0, 0)),\n        (\"NotLeftTriangleEqua\", (0, 0)),\n        (\"betwe\", (0, 0)),\n        (\"cirmid;\", (10991, 0)),\n        (\"gtrar\", (0, 0)),\n        (\"SquareI\", (0, 0)),\n        (\"boxmi\", (0, 0)),\n        (\"realpart;\", (8476, 0)),\n        (\"varsups\", (0, 0)),\n        (\"hArr\", (0, 0)),\n        (\"NotNestedGreaterG\", (0, 0)),\n        (\"par;\", (8741, 0)),\n        (\"DoubleUpDo\", (0, 0)),\n        (\"zhc\", (0, 0)),\n        (\"DoubleContourInte\", (0, 0)),\n        (\"cop\", (0, 0)),\n        (\"xscr\", (0, 0)),\n        (\"nvgt;\", (62, 8402)),\n        (\"rightarr\", (0, 0)),\n        (\"xcap\", (0, 0)),\n        (\"blacktriangleleft;\", (9666, 0)),\n        (\"Ascr;\", (119964, 0)),\n        (\"pscr;\", (120005, 0)),\n        (\"straightepsilo\", (0, 0)),\n        (\"Upd\", (0, 0)),\n        (\"rnm\", (0, 0)),\n        (\"nright\", (0, 0)),\n        (\"NotNestedLessLe\", (0, 0)),\n        (\"cupc\", (0, 0)),\n        (\"rightthreet\", (0, 0)),\n        (\"ordf\", (170, 0)),\n        (\"notind\", (0, 0)),\n        (\"lBa\", (0, 0)),\n        (\"varsubsetne\", (0, 0)),\n        (\"Pr;\", (10939, 0)),\n        (\"Scaro\", (0, 0)),\n        (\"odot;\", (8857, 0)),\n        (\"OverPa\", (0, 0)),\n        (\"TSHcy\", (0, 0)),\n        (\"drcrop\", (0, 0)),\n        (\"Clos\", (0, 0)),\n        (\"UnderPar\", (0, 0)),\n        (\"dagge\", (0, 0)),\n        (\"nvsim\", (0, 0)),\n        (\"lowast;\", (8727, 0)),\n        (\"succa\", (0, 0)),\n        (\"ncup;\", (10818, 0)),\n        (\"v\", (0, 0)),\n        (\"backsime\", (0, 0)),\n        (\"frac25\", (0, 0)),\n        (\"backcong;\", (8780, 0)),\n        (\"DownRightTeeVe\", (0, 0)),\n        (\"Sc\", (0, 0)),\n        (\"odblac;\", (337, 0)),\n        (\"oslash\", (248, 0)),\n        (\"HumpDownHump;\", (8782, 0)),\n        (\"dHar;\", (10597, 0)),\n        (\"Circle\", (0, 0)),\n        (\"xcup\", (0, 0)),\n        (\"centerdo\", (0, 0)),\n        (\"yc\", (0, 0)),\n        (\"searhk\", (0, 0)),\n        (\"aw\", (0, 0)),\n        (\"Ograve;\", (210, 0)),\n        (\"HumpDo\", (0, 0)),\n        (\"nLe\", (0, 0)),\n        (\"DoubleUpArrow\", (0, 0)),\n        (\"DownRightVec\", (0, 0)),\n        (\"Nfr\", (0, 0)),\n        (\"lambd\", (0, 0)),\n        (\"Exis\", (0, 0)),\n        (\"CupCap;\", (8781, 0)),\n        (\"angl\", (0, 0)),\n        (\"trade\", (0, 0)),\n        (\"straightp\", (0, 0)),\n        (\"swarhk\", (0, 0)),\n        (\"llhard;\", (10603, 0)),\n        (\"fallingdotseq\", (0, 0)),\n        (\"roti\", (0, 0)),\n        (\"excl\", (0, 0)),\n        (\"NegativeMediumS\", (0, 0)),\n        (\"Righ\", (0, 0)),\n        (\"Uparro\", (0, 0)),\n        (\"Barwed;\", (8966, 0)),\n        (\"LeftDownTeeV\", (0, 0)),\n        (\"demptyv;\", (10673, 0)),\n        (\"udblac;\", (369, 0)),\n        (\"sub;\", (8834, 0)),\n        (\"urtr\", (0, 0)),\n        (\"vartriang\", (0, 0)),\n        (\"race;\", (8765, 817)),\n        (\"LeftRight\", (0, 0)),\n        (\"doubleb\", (0, 0)),\n        (\"Delt\", (0, 0)),\n        (\"DoubleRightA\", (0, 0)),\n        (\"RightDownVectorBar;\", (10581, 0)),\n        (\"DD\", (0, 0)),\n        (\"boxUL;\", (9565, 0)),\n        (\"uacut\", (0, 0)),\n        (\"NonBreaking\", (0, 0)),\n        (\"aacute\", (225, 0)),\n        (\"rarrfs;\", (10526, 0)),\n        (\"Prime;\", (8243, 0)),\n        (\"blk34\", (0, 0)),\n        (\"capcap;\", (10827, 0)),\n        (\"sext\", (0, 0)),\n        (\"cups;\", (8746, 65024)),\n        (\"LeftArrowBa\", (0, 0)),\n        (\"upharpoon\", (0, 0)),\n        (\"gl\", (0, 0)),\n        (\"ngs\", (0, 0)),\n        (\"lsh\", (0, 0)),\n        (\"NegativeThi\", (0, 0)),\n        (\"circledast;\", (8859, 0)),\n        (\"GreaterEqual\", (0, 0)),\n        (\"paral\", (0, 0)),\n        (\"Bernoul\", (0, 0)),\n        (\"Vert;\", (8214, 0)),\n        (\"swarh\", (0, 0)),\n        (\"spade\", (0, 0)),\n        (\"Aacute;\", (193, 0)),\n        (\"boxhU\", (0, 0)),\n        (\"LowerLeftAr\", (0, 0)),\n        (\"NotGreaterEq\", (0, 0)),\n        (\"csup;\", (10960, 0)),\n        (\"vee;\", (8744, 0)),\n        (\"DownTeeAr\", (0, 0)),\n        (\"Pr\", (0, 0)),\n        (\"gvertneqq;\", (8809, 65024)),\n        (\"NotPrecedesS\", (0, 0)),\n        (\"boxV\", (0, 0)),\n        (\"ngsim\", (0, 0)),\n        (\"NotGreaterF\", (0, 0)),\n        (\"vArr\", (0, 0)),\n        (\"origof;\", (8886, 0)),\n        (\"RightUpDown\", (0, 0)),\n        (\"DoubleCont\", (0, 0)),\n        (\"pitchfork;\", (8916, 0)),\n        (\"Iacu\", (0, 0)),\n        (\"rl\", (0, 0)),\n        (\"precneqq\", (0, 0)),\n        (\"larrlp;\", (8619, 0)),\n        (\"geqq\", (0, 0)),\n        (\"nb\", (0, 0)),\n        (\"simne;\", (8774, 0)),\n        (\"ldrdhar;\", (10599, 0)),\n        (\"nshortp\", (0, 0)),\n        (\"DownLeftVector\", (0, 0)),\n        (\"wp;\", (8472, 0)),\n        (\"LeftDownVectorBa\", (0, 0)),\n        (\"Cacute\", (0, 0)),\n        (\"swarhk;\", (10534, 0)),\n        (\"Rrightarr\", (0, 0)),\n        (\"NegativeMediumSp\", (0, 0)),\n        (\"Qscr\", (0, 0)),\n        (\"GJcy\", (0, 0)),\n        (\"imagpart;\", (8465, 0)),\n        (\"rmous\", (0, 0)),\n        (\"there4;\", (8756, 0)),\n        (\"larrb\", (0, 0)),\n        (\"angzar\", (0, 0)),\n        (\"me\", (0, 0)),\n        (\"Nacute\", (0, 0)),\n        (\"rbrkslu;\", (10640, 0)),\n        (\"RightUpTeeVec\", (0, 0)),\n        (\"EmptySmal\", (0, 0)),\n        (\"NotGreat\", (0, 0)),\n        (\"VerticalTild\", (0, 0)),\n        (\"pitchf\", (0, 0)),\n        (\"nexists\", (0, 0)),\n        (\"notinva;\", (8713, 0)),\n        (\"Conto\", (0, 0)),\n        (\"clubs\", (0, 0)),\n        (\"bigtriangleu\", (0, 0)),\n        (\"harrc\", (0, 0)),\n        (\"nwarr\", (0, 0)),\n        (\"wopf;\", (120168, 0)),\n        (\"downarrow;\", (8595, 0)),\n        (\"Partia\", (0, 0)),\n        (\"nvrArr\", (0, 0)),\n        (\"supse\", (0, 0)),\n        (\"And;\", (10835, 0)),\n        (\"thks\", (0, 0)),\n        (\"triangleq\", (0, 0)),\n        (\"Pc\", (0, 0)),\n        (\"GreaterTild\", (0, 0)),\n        (\"CounterClockwiseConto\", (0, 0)),\n        (\"szl\", (0, 0)),\n        (\"preccurlyeq\", (0, 0)),\n        (\"NotPrecedesSla\", (0, 0)),\n        (\"ac;\", (8766, 0)),\n        (\"lfloor\", (0, 0)),\n        (\"eplus\", (0, 0)),\n        (\"rbrace;\", (125, 0)),\n        (\"rarrap;\", (10613, 0)),\n        (\"awin\", (0, 0)),\n        (\"eqc\", (0, 0)),\n        (\"fscr;\", (119995, 0)),\n        (\"hairsp;\", (8202, 0)),\n        (\"searro\", (0, 0)),\n        (\"DoubleContourIntegra\", (0, 0)),\n        (\"VerticalSeparator\", (0, 0)),\n        (\"Cedil\", (0, 0)),\n        (\"smepars\", (0, 0)),\n        (\"LowerRig\", (0, 0)),\n        (\"NotPr\", (0, 0)),\n        (\"rha\", (0, 0)),\n        (\"boxhD;\", (9573, 0)),\n        (\"ems\", (0, 0)),\n        (\"efDot\", (0, 0)),\n        (\"shortmi\", (0, 0)),\n        (\"lmoustache\", (0, 0)),\n        (\"backs\", (0, 0)),\n        (\"rdldha\", (0, 0)),\n        (\"bsolhsub\", (0, 0)),\n        (\"mapstoup;\", (8613, 0)),\n        (\"fla\", (0, 0)),\n        (\"circledcir\", (0, 0)),\n        (\"uscr\", (0, 0)),\n        (\"bigopl\", (0, 0)),\n        (\"niv;\", (8715, 0)),\n        (\"RoundI\", (0, 0)),\n        (\"boxplus\", (0, 0)),\n        (\"dha\", (0, 0)),\n        (\"smtes;\", (10924, 65024)),\n        (\"vB\", (0, 0)),\n        (\"imagli\", (0, 0)),\n        (\"bfr;\", (120095, 0)),\n        (\"HilbertS\", (0, 0)),\n        (\"GreaterFullEqu\", (0, 0)),\n        (\"uri\", (0, 0)),\n        (\"circlearrow\", (0, 0)),\n        (\"Me\", (0, 0)),\n        (\"RightUpVector\", (0, 0)),\n        (\"njcy\", (0, 0)),\n        (\"Lcaron\", (0, 0)),\n        (\"ncaron\", (0, 0)),\n        (\"bigtri\", (0, 0)),\n        (\"nlsi\", (0, 0)),\n        (\"reg\", (174, 0)),\n        (\"lescc;\", (10920, 0)),\n        (\"gbrev\", (0, 0)),\n        (\"prnE;\", (10933, 0)),\n        (\"leq;\", (8804, 0)),\n        (\"Reve\", (0, 0)),\n        (\"cwconin\", (0, 0)),\n        (\"RightV\", (0, 0)),\n        (\"becaus;\", (8757, 0)),\n        (\"Racu\", (0, 0)),\n        (\"Ncedil;\", (325, 0)),\n        (\"SquareInte\", (0, 0)),\n        (\"hookrightarrow\", (0, 0)),\n        (\"qprim\", (0, 0)),\n        (\"Kced\", (0, 0)),\n        (\"nrtrie\", (0, 0)),\n        (\"lowast\", (0, 0)),\n        (\"ltquest;\", (10875, 0)),\n        (\"SucceedsTil\", (0, 0)),\n        (\"Amacr\", (0, 0)),\n        (\"Hilb\", (0, 0)),\n        (\"NotHumpDownH\", (0, 0)),\n        (\"sqsupse\", (0, 0)),\n        (\"bep\", (0, 0)),\n        (\"boxu\", (0, 0)),\n        (\"Ma\", (0, 0)),\n        (\"bem\", (0, 0)),\n        (\"ApplyFunctio\", (0, 0)),\n        (\"dagger;\", (8224, 0)),\n        (\"Colone\", (0, 0)),\n        (\"lesd\", (0, 0)),\n        (\"SubsetEq\", (0, 0)),\n        (\"khcy;\", (1093, 0)),\n        (\"nvrtr\", (0, 0)),\n        (\"Oopf;\", (120134, 0)),\n        (\"otimes;\", (8855, 0)),\n        (\"trianglelefteq;\", (8884, 0)),\n        (\"nVdash\", (0, 0)),\n        (\"profala\", (0, 0)),\n        (\"risingdotseq;\", (8787, 0)),\n        (\"NotReverseElement\", (0, 0)),\n        (\"nRighta\", (0, 0)),\n        (\"langle;\", (10216, 0)),\n        (\"Kc\", (0, 0)),\n        (\"numero;\", (8470, 0)),\n        (\"UpEquilibrium;\", (10606, 0)),\n        (\"DiacriticalDoubleA\", (0, 0)),\n        (\"Xs\", (0, 0)),\n        (\"lrc\", (0, 0)),\n        (\"Abre\", (0, 0)),\n        (\"iota;\", (953, 0)),\n        (\"Rcy\", (0, 0)),\n        (\"simlE;\", (10911, 0)),\n        (\"Os\", (0, 0)),\n        (\"ugr\", (0, 0)),\n        (\"PrecedesEqua\", (0, 0)),\n        (\"eo\", (0, 0)),\n        (\"kjc\", (0, 0)),\n        (\"SquareUnio\", (0, 0)),\n        (\"lacute\", (0, 0)),\n        (\"GreaterEqualLess\", (0, 0)),\n        (\"bec\", (0, 0)),\n        (\"backsim;\", (8765, 0)),\n        (\"DoubleLongLeftA\", (0, 0)),\n        (\"longmap\", (0, 0)),\n        (\"tho\", (0, 0)),\n        (\"ApplyFu\", (0, 0)),\n        (\"equ\", (0, 0)),\n        (\"Kopf\", (0, 0)),\n        (\"Agr\", (0, 0)),\n        (\"LongLeftArro\", (0, 0)),\n        (\"Scaron;\", (352, 0)),\n        (\"SquareSubsetEqual\", (0, 0)),\n        (\"frac18\", (0, 0)),\n        (\"succns\", (0, 0)),\n        (\"bigcap;\", (8898, 0)),\n        (\"plusdu;\", (10789, 0)),\n        (\"nsm\", (0, 0)),\n        (\"real;\", (8476, 0)),\n        (\"NJcy\", (0, 0)),\n        (\"blacklozen\", (0, 0)),\n        (\"ncaro\", (0, 0)),\n        (\"bkar\", (0, 0)),\n        (\"gtrap\", (0, 0)),\n        (\"rdq\", (0, 0)),\n        (\"SquareInt\", (0, 0)),\n        (\"rpar\", (0, 0)),\n        (\"VD\", (0, 0)),\n        (\"CapitalDiffere\", (0, 0)),\n        (\"Gam\", (0, 0)),\n        (\"geqslant\", (0, 0)),\n        (\"leq\", (0, 0)),\n        (\"dia\", (0, 0)),\n        (\"straightepsilon\", (0, 0)),\n        (\"ncap\", (0, 0)),\n        (\"vDash\", (0, 0)),\n        (\"ugrave\", (249, 0)),\n        (\"rightleftharpoons;\", (8652, 0)),\n        (\"approxeq\", (0, 0)),\n        (\"RightTriang\", (0, 0)),\n        (\"odiv\", (0, 0)),\n        (\"egsdo\", (0, 0)),\n        (\"Exist\", (0, 0)),\n        (\"RightTeeArr\", (0, 0)),\n        (\"Equilibriu\", (0, 0)),\n        (\"Qsc\", (0, 0)),\n        (\"rightleftharp\", (0, 0)),\n        (\"srar\", (0, 0)),\n        (\"gl;\", (8823, 0)),\n        (\"rmoust;\", (9137, 0)),\n        (\"Bern\", (0, 0)),\n        (\"hksearow\", (0, 0)),\n        (\"oacute\", (243, 0)),\n        (\"Xscr\", (0, 0)),\n        (\"gfr;\", (120100, 0)),\n        (\"bsime\", (0, 0)),\n        (\"ordero\", (0, 0)),\n        (\"uAr\", (0, 0)),\n        (\"UnderBrace\", (0, 0)),\n        (\"NotLes\", (0, 0)),\n        (\"lscr;\", (120001, 0)),\n        (\"ntrianglerigh\", (0, 0)),\n        (\"nleftright\", (0, 0)),\n        (\"rh\", (0, 0)),\n        (\"pra\", (0, 0)),\n        (\"SucceedsE\", (0, 0)),\n        (\"RightTriangleB\", (0, 0)),\n        (\"per\", (0, 0)),\n        (\"eqvpar\", (0, 0)),\n        (\"mlcp\", (0, 0)),\n        (\"NegativeVeryThi\", (0, 0)),\n        (\"TildeEqual\", (0, 0)),\n        (\"api\", (0, 0)),\n        (\"therefore;\", (8756, 0)),\n        (\"gdot;\", (289, 0)),\n        (\"ntrianglelefte\", (0, 0)),\n        (\"scpo\", (0, 0)),\n        (\"Ifr;\", (8465, 0)),\n        (\"Tst\", (0, 0)),\n        (\"Invisib\", (0, 0)),\n        (\"csu\", (0, 0)),\n        (\"RightD\", (0, 0)),\n        (\"Differe\", (0, 0)),\n        (\"nra\", (0, 0)),\n        (\"lesges;\", (10899, 0)),\n        (\"Psc\", (0, 0)),\n        (\"io\", (0, 0)),\n        (\"iprod;\", (10812, 0)),\n        (\"Int\", (0, 0)),\n        (\"DownLeftTeeVector;\", (10590, 0)),\n        (\"LeftDownVec\", (0, 0)),\n        (\"ml\", (0, 0)),\n        (\"DownLeftT\", (0, 0)),\n        (\"ReverseElement;\", (8715, 0)),\n        (\"lsim\", (0, 0)),\n        (\"nlar\", (0, 0)),\n        (\"CapitalDifferenti\", (0, 0)),\n        (\"Ua\", (0, 0)),\n        (\"uml\", (168, 0)),\n        (\"nmi\", (0, 0)),\n        (\"sce\", (0, 0)),\n        (\"Hacek;\", (711, 0)),\n        (\"Coun\", (0, 0)),\n        (\"poun\", (0, 0)),\n        (\"rhov;\", (1009, 0)),\n        (\"NotDoubleVe\", (0, 0)),\n        (\"UpTeeAr\", (0, 0)),\n        (\"larrf\", (0, 0)),\n        (\"Bump\", (0, 0)),\n        (\"nLeftarro\", (0, 0)),\n        (\"ddo\", (0, 0)),\n        (\"lflo\", (0, 0)),\n        (\"Wc\", (0, 0)),\n        (\"ovbar;\", (9021, 0)),\n        (\"starf\", (0, 0)),\n        (\"Wci\", (0, 0)),\n        (\"Longrightarr\", (0, 0)),\n        (\"looparr\", (0, 0)),\n        (\"Appl\", (0, 0)),\n        (\"ascr;\", (119990, 0)),\n        (\"NotNestedGreaterGreat\", (0, 0)),\n        (\"NotVertica\", (0, 0)),\n        (\"subset\", (0, 0)),\n        (\"npol\", (0, 0)),\n        (\"Ou\", (0, 0)),\n        (\"nsupseteq\", (0, 0)),\n        (\"Iscr;\", (8464, 0)),\n        (\"nscr\", (0, 0)),\n        (\"Q\", (0, 0)),\n        (\"lnap\", (0, 0)),\n        (\"sla\", (0, 0)),\n        (\"DiacriticalDoubleAcute\", (0, 0)),\n        (\"RightUpVectorB\", (0, 0)),\n        (\"NotPrecedesSlant\", (0, 0)),\n        (\"DoubleLongRightArr\", (0, 0)),\n        (\"LeftDownV\", (0, 0)),\n        (\"Ecirc;\", (202, 0)),\n        (\"lbrksld\", (0, 0)),\n        (\"NotGreaterLe\", (0, 0)),\n        (\"LongLeftRi\", (0, 0)),\n        (\"cyl\", (0, 0)),\n        (\"Longrightarro\", (0, 0)),\n        (\"DDotrahd\", (0, 0)),\n        (\"tscy\", (0, 0)),\n        (\"If\", (0, 0)),\n        (\"plustwo\", (0, 0)),\n        (\"rcu\", (0, 0)),\n        (\"ch\", (0, 0)),\n        (\"Diacritica\", (0, 0)),\n        (\"Hace\", (0, 0)),\n        (\"InvisibleT\", (0, 0)),\n        (\"Dfr\", (0, 0)),\n        (\"Yuml;\", (376, 0)),\n        (\"bcy\", (0, 0)),\n        (\"udhar\", (0, 0)),\n        (\"Propo\", (0, 0)),\n        (\"dashv;\", (8867, 0)),\n        (\"nprcue;\", (8928, 0)),\n        (\"Asc\", (0, 0)),\n        (\"commat\", (0, 0)),\n        (\"Grea\", (0, 0)),\n        (\"xvee;\", (8897, 0)),\n        (\"rbrksl\", (0, 0)),\n        (\"Tsc\", (0, 0)),\n        (\"ccupss\", (0, 0)),\n        (\"nesear\", (0, 0)),\n        (\"rightlefthar\", (0, 0)),\n        (\"DoubleLongRightAr\", (0, 0)),\n        (\"min\", (0, 0)),\n        (\"meas\", (0, 0)),\n        (\"npolin\", (0, 0)),\n        (\"swn\", (0, 0)),\n        (\"bd\", (0, 0)),\n        (\"nsuc\", (0, 0)),\n        (\"fra\", (0, 0)),\n        (\"dzigr\", (0, 0)),\n        (\"usc\", (0, 0)),\n        (\"risingdotse\", (0, 0)),\n        (\"ocirc\", (244, 0)),\n        (\"csup\", (0, 0)),\n        (\"tscr;\", (120009, 0)),\n        (\"hor\", (0, 0)),\n        (\"cuesc\", (0, 0)),\n        (\"cudarrr\", (0, 0)),\n        (\"boxDL\", (0, 0)),\n        (\"ncongdo\", (0, 0)),\n        (\"Mscr\", (0, 0)),\n        (\"DownLeftVec\", (0, 0)),\n        (\"Cay\", (0, 0)),\n        (\"cupb\", (0, 0)),\n        (\"checkma\", (0, 0)),\n        (\"gjc\", (0, 0)),\n        (\"lm\", (0, 0)),\n        (\"Gced\", (0, 0)),\n        (\"vee\", (0, 0)),\n        (\"xi\", (0, 0)),\n        (\"preccu\", (0, 0)),\n        (\"EmptyVerySmallS\", (0, 0)),\n        (\"Rightarrow\", (0, 0)),\n        (\"longleftr\", (0, 0)),\n        (\"ipro\", (0, 0)),\n        (\"frac23;\", (8532, 0)),\n        (\"lA\", (0, 0)),\n        (\"Cconin\", (0, 0)),\n        (\"Vba\", (0, 0)),\n        (\"ddar\", (0, 0)),\n        (\"mstpos;\", (8766, 0)),\n        (\"angsph;\", (8738, 0)),\n        (\"HARD\", (0, 0)),\n        (\"sup;\", (8835, 0)),\n        (\"HumpDown\", (0, 0)),\n        (\"Edot;\", (278, 0)),\n        (\"NotSucceedsTilde;\", (8831, 824)),\n        (\"Uog\", (0, 0)),\n        (\"NestedLessLe\", (0, 0)),\n        (\"Ocir\", (0, 0)),\n        (\"heart\", (0, 0)),\n        (\"Agrave;\", (192, 0)),\n        (\"SquareIntersection;\", (8851, 0)),\n        (\"uparro\", (0, 0)),\n        (\"strn\", (0, 0)),\n        (\"rsh\", (0, 0)),\n        (\"lHa\", (0, 0)),\n        (\"hci\", (0, 0)),\n        (\"bigotime\", (0, 0)),\n        (\"LessLe\", (0, 0)),\n        (\"Capit\", (0, 0)),\n        (\"Equ\", (0, 0)),\n        (\"nrt\", (0, 0)),\n        (\"Lam\", (0, 0)),\n        (\"centerdot\", (0, 0)),\n        (\"realpa\", (0, 0)),\n        (\"gammad\", (0, 0)),\n        (\"NotLessTi\", (0, 0)),\n        (\"OverBrace\", (0, 0)),\n        (\"vda\", (0, 0)),\n        (\"twoheadrightarr\", (0, 0)),\n        (\"ClockwiseContourInteg\", (0, 0)),\n        (\"dot\", (0, 0)),\n        (\"ii\", (0, 0)),\n        (\"curvearrowrigh\", (0, 0)),\n        (\"PrecedesSl\", (0, 0)),\n        (\"zi\", (0, 0)),\n        (\"tsh\", (0, 0)),\n        (\"vnsub\", (0, 0)),\n        (\"rb\", (0, 0)),\n        (\"lcub;\", (123, 0)),\n        (\"betwee\", (0, 0)),\n        (\"Super\", (0, 0)),\n        (\"NotGreaterTilde;\", (8821, 0)),\n        (\"dua\", (0, 0)),\n        (\"Great\", (0, 0)),\n        (\"NotS\", (0, 0)),\n        (\"nle\", (0, 0)),\n        (\"lharu\", (0, 0)),\n        (\"rin\", (0, 0)),\n        (\"Sacute;\", (346, 0)),\n        (\"rbrack;\", (93, 0)),\n        (\"DoubleDot;\", (168, 0)),\n        (\"Jcy;\", (1049, 0)),\n        (\"xsqcup;\", (10758, 0)),\n        (\"UpArrowDownArrow\", (0, 0)),\n        (\"Laplacet\", (0, 0)),\n        (\"Map\", (0, 0)),\n        (\"HARDc\", (0, 0)),\n        (\"bfr\", (0, 0)),\n        (\"preceq\", (0, 0)),\n        (\"rdsh\", (0, 0)),\n        (\"Mellintrf;\", (8499, 0)),\n        (\"LeftRightVector\", (0, 0)),\n        (\"Poinca\", (0, 0)),\n        (\"imp\", (0, 0)),\n        (\"varsubsetneqq;\", (10955, 65024)),\n        (\"nsupset;\", (8835, 8402)),\n        (\"exp\", (0, 0)),\n        (\"rmoust\", (0, 0)),\n        (\"NegativeVeryThinS\", (0, 0)),\n        (\"NotHumpEqual\", (0, 0)),\n        (\"rdquo;\", (8221, 0)),\n        (\"TildeEqu\", (0, 0)),\n        (\"sccue;\", (8829, 0)),\n        (\"ThinSpa\", (0, 0)),\n        (\"hairs\", (0, 0)),\n        (\"nes\", (0, 0)),\n        (\"Hat\", (0, 0)),\n        (\"Rcaron\", (0, 0)),\n        (\"TildeE\", (0, 0)),\n        (\"hslas\", (0, 0)),\n        (\"bcy;\", (1073, 0)),\n        (\"amalg\", (0, 0)),\n        (\"SquareSubse\", (0, 0)),\n        (\"NotGreater;\", (8815, 0)),\n        (\"bullet\", (0, 0)),\n        (\"otimesas;\", (10806, 0)),\n        (\"ed\", (0, 0)),\n        (\"NegativeVeryThinSpac\", (0, 0)),\n        (\"jukc\", (0, 0)),\n        (\"planck;\", (8463, 0)),\n        (\"VerticalLine\", (0, 0)),\n        (\"nvD\", (0, 0)),\n        (\"oel\", (0, 0)),\n        (\"nparall\", (0, 0)),\n        (\"qpr\", (0, 0)),\n        (\"capa\", (0, 0)),\n        (\"gtrd\", (0, 0)),\n        (\"nsupseteq;\", (8841, 0)),\n        (\"Conint;\", (8751, 0)),\n        (\"NonBr\", (0, 0)),\n        (\"twoheadrightar\", (0, 0)),\n        (\"Iuml;\", (207, 0)),\n        (\"rlarr;\", (8644, 0)),\n        (\"epar;\", (8917, 0)),\n        (\"LeftUpVectorBar;\", (10584, 0)),\n        (\"To\", (0, 0)),\n        (\"LessEqualGrea\", (0, 0)),\n        (\"jc\", (0, 0)),\n        (\"yacute\", (253, 0)),\n        (\"leftrightsquigar\", (0, 0)),\n        (\"targe\", (0, 0)),\n        (\"uArr\", (0, 0)),\n        (\"EmptyVerySmallSquare;\", (9643, 0)),\n        (\"Rang\", (0, 0)),\n        (\"uwangle\", (0, 0)),\n        (\"iopf\", (0, 0)),\n        (\"gtrappr\", (0, 0)),\n        (\"smte\", (0, 0)),\n        (\"hslash;\", (8463, 0)),\n        (\"Impli\", (0, 0)),\n        (\"nrig\", (0, 0)),\n        (\"imag\", (0, 0)),\n        (\"od\", (0, 0)),\n        (\"Thi\", (0, 0)),\n        (\"O\", (0, 0)),\n        (\"RightUpDownVector\", (0, 0)),\n        (\"vltri;\", (8882, 0)),\n        (\"ShortRight\", (0, 0)),\n        (\"ntr\", (0, 0)),\n        (\"ddotseq;\", (10871, 0)),\n        (\"LessLess\", (0, 0)),\n        (\"toea;\", (10536, 0)),\n        (\"macr\", (175, 0)),\n        (\"LeftUpVectorBa\", (0, 0)),\n        (\"tsc\", (0, 0)),\n        (\"ldru\", (0, 0)),\n        (\"simpl\", (0, 0)),\n        (\"bigtriangled\", (0, 0)),\n        (\"DownRightVect\", (0, 0)),\n        (\"zfr\", (0, 0)),\n        (\"CloseCurlyQu\", (0, 0)),\n        (\"bdqu\", (0, 0)),\n        (\"lessap\", (0, 0)),\n        (\"NegativeThinSpa\", (0, 0)),\n        (\"verba\", (0, 0)),\n        (\"gsi\", (0, 0)),\n        (\"ClockwiseContou\", (0, 0)),\n        (\"phone\", (0, 0)),\n        (\"Zopf;\", (8484, 0)),\n        (\"lbrke\", (0, 0)),\n        (\"wopf\", (0, 0)),\n        (\"clubs;\", (9827, 0)),\n        (\"parallel;\", (8741, 0)),\n        (\"mapstole\", (0, 0)),\n        (\"sfrown;\", (8994, 0)),\n        (\"rAar\", (0, 0)),\n        (\"lrhard;\", (10605, 0)),\n        (\"Nopf;\", (8469, 0)),\n        (\"rppolint\", (0, 0)),\n        (\"notniv\", (0, 0)),\n        (\"gtr\", (0, 0)),\n        (\"NotGre\", (0, 0)),\n        (\"ENG;\", (330, 0)),\n        (\"inter\", (0, 0)),\n        (\"Jcirc\", (0, 0)),\n        (\"Intersecti\", (0, 0)),\n        (\"bscr\", (0, 0)),\n        (\"order;\", (8500, 0)),\n        (\"fll\", (0, 0)),\n        (\"xc\", (0, 0)),\n        (\"supdo\", (0, 0)),\n        (\"DDotra\", (0, 0)),\n        (\"cylcty;\", (9005, 0)),\n        (\"DownRightTee\", (0, 0)),\n        (\"supseteq;\", (8839, 0)),\n        (\"gim\", (0, 0)),\n        (\"ctdot;\", (8943, 0)),\n        (\"mu;\", (956, 0)),\n        (\"part;\", (8706, 0)),\n        (\"Bc\", (0, 0)),\n        (\"npreceq;\", (10927, 824)),\n        (\"cupor;\", (10821, 0)),\n        (\"looparrowl\", (0, 0)),\n        (\"boxvR;\", (9566, 0)),\n        (\"doubl\", (0, 0)),\n        (\"ldquo;\", (8220, 0)),\n        (\"Ecy\", (0, 0)),\n        (\"minusb;\", (8863, 0)),\n        (\"RightUpDow\", (0, 0)),\n        (\"oin\", (0, 0)),\n        (\"lneq;\", (10887, 0)),\n        (\"DoubleLongLeftRi\", (0, 0)),\n        (\"awc\", (0, 0)),\n        (\"latail;\", (10521, 0)),\n        (\"blacktriangle\", (0, 0)),\n        (\"sfro\", (0, 0)),\n        (\"questeq;\", (8799, 0)),\n        (\"bigtria\", (0, 0)),\n        (\"ZeroWidthSpace\", (0, 0)),\n        (\"NotCupCap;\", (8813, 0)),\n        (\"urc\", (0, 0)),\n        (\"Hsc\", (0, 0)),\n        (\"llcorne\", (0, 0)),\n        (\"rscr\", (0, 0)),\n        (\"DoubleLeftT\", (0, 0)),\n        (\"LongRightArro\", (0, 0)),\n        (\"PlusMinus;\", (177, 0)),\n        (\"Lacu\", (0, 0)),\n        (\"SquareUnion\", (0, 0)),\n        (\"bne\", (0, 0)),\n        (\"Ccirc\", (0, 0)),\n        (\"FilledVerySmallSquare;\", (9642, 0)),\n        (\"rightrightarro\", (0, 0)),\n        (\"HARDcy;\", (1066, 0)),\n        (\"Barwe\", (0, 0)),\n        (\"Very\", (0, 0)),\n        (\"CircleDot;\", (8857, 0)),\n        (\"jo\", (0, 0)),\n        (\"lata\", (0, 0)),\n        (\"nge;\", (8817, 0)),\n        (\"imat\", (0, 0)),\n        (\"boxUR;\", (9562, 0)),\n        (\"DoubleContourIntegral\", (0, 0)),\n        (\"notin\", (0, 0)),\n        (\"curlyeqp\", (0, 0)),\n        (\"equi\", (0, 0)),\n        (\"npre;\", (10927, 824)),\n        (\"diamo\", (0, 0)),\n        (\"LeftDoub\", (0, 0)),\n        (\"Yu\", (0, 0)),\n        (\"leftarrowtail;\", (8610, 0)),\n        (\"CounterClockwiseContourInte\", (0, 0)),\n        (\"Ri\", (0, 0)),\n        (\"ThickSpace;\", (8287, 8202)),\n        (\"hscr;\", (119997, 0)),\n        (\"fcy;\", (1092, 0)),\n        (\"rang\", (0, 0)),\n        (\"longrigh\", (0, 0)),\n        (\"Ncaro\", (0, 0)),\n        (\"ses\", (0, 0)),\n        (\"LeftArrowRightArr\", (0, 0)),\n        (\"DoubleDown\", (0, 0)),\n        (\"lessgt\", (0, 0)),\n        (\"ReverseEquilibri\", (0, 0)),\n        (\"RightCei\", (0, 0)),\n        (\"fall\", (0, 0)),\n        (\"de\", (0, 0)),\n        (\"precnappr\", (0, 0)),\n        (\"NonBreaki\", (0, 0)),\n        (\"xoplus;\", (10753, 0)),\n        (\"jserc\", (0, 0)),\n        (\"updownar\", (0, 0)),\n        (\"N\", (0, 0)),\n        (\"frac38;\", (8540, 0)),\n        (\"Nes\", (0, 0)),\n        (\"subseteqq\", (0, 0)),\n        (\"NotLessTilde\", (0, 0)),\n        (\"NotHumpE\", (0, 0)),\n        (\"OverBa\", (0, 0)),\n        (\"Prop\", (0, 0)),\n        (\"bbrk\", (0, 0)),\n        (\"bno\", (0, 0)),\n        (\"nLt;\", (8810, 8402)),\n        (\"ltqu\", (0, 0)),\n        (\"looparrowrig\", (0, 0)),\n        (\"lsqb;\", (91, 0)),\n        (\"efDot;\", (8786, 0)),\n        (\"gamma\", (0, 0)),\n        (\"Rrightarro\", (0, 0)),\n        (\"longleft\", (0, 0)),\n        (\"TildeEq\", (0, 0)),\n        (\"mho;\", (8487, 0)),\n        (\"longrig\", (0, 0)),\n        (\"Kce\", (0, 0)),\n        (\"scnap\", (0, 0)),\n        (\"Scedil;\", (350, 0)),\n        (\"nVdas\", (0, 0)),\n        (\"Om\", (0, 0)),\n        (\"xwedg\", (0, 0)),\n        (\"vzigzag;\", (10650, 0)),\n        (\"Exists\", (0, 0)),\n        (\"rightleftharpo\", (0, 0)),\n        (\"gsiml;\", (10896, 0)),\n        (\"rsquor;\", (8217, 0)),\n        (\"LongLef\", (0, 0)),\n        (\"Capi\", (0, 0)),\n        (\"isinE\", (0, 0)),\n        (\"triangle;\", (9653, 0)),\n        (\"SucceedsSlantEqual\", (0, 0)),\n        (\"twoheadright\", (0, 0)),\n        (\"jcy\", (0, 0)),\n        (\"OverPar\", (0, 0)),\n        (\"Of\", (0, 0)),\n        (\"frac13;\", (8531, 0)),\n        (\"toe\", (0, 0)),\n        (\"lamb\", (0, 0)),\n        (\"nLeftri\", (0, 0)),\n        (\"stra\", (0, 0)),\n        (\"RightTe\", (0, 0)),\n        (\"rp\", (0, 0)),\n        (\"DownB\", (0, 0)),\n        (\"els;\", (10901, 0)),\n        (\"larrbfs\", (0, 0)),\n        (\"CH\", (0, 0)),\n        (\"bco\", (0, 0)),\n        (\"naturals\", (0, 0)),\n        (\"odsol\", (0, 0)),\n        (\"nsu\", (0, 0)),\n        (\"DiacriticalAcu\", (0, 0)),\n        (\"phi;\", (966, 0)),\n        (\"RuleDelaye\", (0, 0)),\n        (\"frac56\", (0, 0)),\n        (\"rtrilt\", (0, 0)),\n        (\"nsupE;\", (10950, 824)),\n        (\"doubleba\", (0, 0)),\n        (\"yac\", (0, 0)),\n        (\"curlywed\", (0, 0)),\n        (\"Hstrok;\", (294, 0)),\n        (\"cuda\", (0, 0)),\n        (\"capc\", (0, 0)),\n        (\"Kscr;\", (119974, 0)),\n        (\"seArr\", (0, 0)),\n        (\"LongRigh\", (0, 0)),\n        (\"larrl\", (0, 0)),\n        (\"ThinSp\", (0, 0)),\n        (\"scpol\", (0, 0)),\n        (\"raq\", (0, 0)),\n        (\"Tscr;\", (119983, 0)),\n        (\"rlm;\", (8207, 0)),\n        (\"xsqcup\", (0, 0)),\n        (\"varepsilo\", (0, 0)),\n        (\"RightUpDownVec\", (0, 0)),\n        (\"prn\", (0, 0)),\n        (\"NotRightTrian\", (0, 0)),\n        (\"Racute;\", (340, 0)),\n        (\"lacu\", (0, 0)),\n        (\"eg\", (0, 0)),\n        (\"scpolint;\", (10771, 0)),\n        (\"gbre\", (0, 0)),\n        (\"TScy\", (0, 0)),\n        (\"curvearrowleft;\", (8630, 0)),\n        (\"nedot\", (0, 0)),\n        (\"angzarr\", (0, 0)),\n        (\"Top\", (0, 0)),\n        (\"dolla\", (0, 0)),\n        (\"CapitalDifferent\", (0, 0)),\n        (\"amacr\", (0, 0)),\n        (\"ldquor;\", (8222, 0)),\n        (\"ecolo\", (0, 0)),\n        (\"notinE\", (0, 0)),\n        (\"Clo\", (0, 0)),\n        (\"nvinfi\", (0, 0)),\n        (\"succapprox\", (0, 0)),\n        (\"lesssim\", (0, 0)),\n        (\"para;\", (182, 0)),\n        (\"plankv;\", (8463, 0)),\n        (\"ClockwiseContourIn\", (0, 0)),\n        (\"nrarr\", (0, 0)),\n        (\"searh\", (0, 0)),\n        (\"precneq\", (0, 0)),\n        (\"ensp;\", (8194, 0)),\n        (\"RightC\", (0, 0)),\n        (\"Ce\", (0, 0)),\n        (\"rtriltri\", (0, 0)),\n        (\"LeftFlo\", (0, 0)),\n        (\"RightAngleBracket;\", (10217, 0)),\n        (\"boxdR\", (0, 0)),\n        (\"Contou\", (0, 0)),\n        (\"boxUR\", (0, 0)),\n        (\"Rarrt\", (0, 0)),\n        (\"FilledVerySmallSquar\", (0, 0)),\n        (\"Diacrit\", (0, 0)),\n        (\"NotLeftTriangleEq\", (0, 0)),\n        (\"dots\", (0, 0)),\n        (\"ijli\", (0, 0)),\n        (\"Od\", (0, 0)),\n        (\"ReverseUp\", (0, 0)),\n        (\"Colon\", (0, 0)),\n        (\"zc\", (0, 0)),\n        (\"DownLeftTeeVect\", (0, 0)),\n        (\"ecy;\", (1101, 0)),\n        (\"afr\", (0, 0)),\n        (\"emsp13\", (0, 0)),\n        (\"ulcrop;\", (8975, 0)),\n        (\"rarrw\", (0, 0)),\n        (\"nvsim;\", (8764, 8402)),\n        (\"rc\", (0, 0)),\n        (\"vartrian\", (0, 0)),\n        (\"dfish\", (0, 0)),\n        (\"acute;\", (180, 0)),\n        (\"edot\", (0, 0)),\n        (\"Vvda\", (0, 0)),\n        (\"RightUpVectorBa\", (0, 0)),\n        (\"LeftTee\", (0, 0)),\n        (\"notniva\", (0, 0)),\n        (\"Iota;\", (921, 0)),\n        (\"iocy;\", (1105, 0)),\n        (\"NotTildeTi\", (0, 0)),\n        (\"scnsim;\", (8937, 0)),\n        (\"PrecedesTilde;\", (8830, 0)),\n        (\"nsupe;\", (8841, 0)),\n        (\"bsim;\", (8765, 0)),\n        (\"se\", (0, 0)),\n        (\"asymp\", (0, 0)),\n        (\"EmptyVerySmallSq\", (0, 0)),\n        (\"omid;\", (10678, 0)),\n        (\"circledR\", (0, 0)),\n        (\"NotGreaterFull\", (0, 0)),\n        (\"acE\", (0, 0)),\n        (\"Congr\", (0, 0)),\n        (\"olarr;\", (8634, 0)),\n        (\"bigtrian\", (0, 0)),\n        (\"X\", (0, 0)),\n        (\"nl\", (0, 0)),\n        (\"lAarr;\", (8666, 0)),\n        (\"isinsv\", (0, 0)),\n        (\"SquareIntersec\", (0, 0)),\n        (\"udblac\", (0, 0)),\n        (\"Xfr\", (0, 0)),\n        (\"vBarv;\", (10985, 0)),\n        (\"capbrc\", (0, 0)),\n        (\"simrarr;\", (10610, 0)),\n        (\"prsim\", (0, 0)),\n        (\"CirclePlus\", (0, 0)),\n        (\"spadesui\", (0, 0)),\n        (\"varsigma;\", (962, 0)),\n        (\"TR\", (0, 0)),\n        (\"oper\", (0, 0)),\n        (\"diamondsuit;\", (9830, 0)),\n        (\"sqcap\", (0, 0)),\n        (\"ltl\", (0, 0)),\n        (\"NotRightTriang\", (0, 0)),\n        (\"ici\", (0, 0)),\n        (\"gtrappro\", (0, 0)),\n        (\"HorizontalL\", (0, 0)),\n        (\"boxHU\", (0, 0)),\n        (\"Imacr\", (0, 0)),\n        (\"rect;\", (9645, 0)),\n        (\"GJ\", (0, 0)),\n        (\"boxplu\", (0, 0)),\n        (\"circledd\", (0, 0)),\n        (\"gnsim\", (0, 0)),\n        (\"eque\", (0, 0)),\n        (\"boxHd\", (0, 0)),\n        (\"swAr\", (0, 0)),\n        (\"boxb\", (0, 0)),\n        (\"LessSlant\", (0, 0)),\n        (\"Ll;\", (8920, 0)),\n        (\"larr;\", (8592, 0)),\n        (\"Lowe\", (0, 0)),\n        (\"ma\", (0, 0)),\n        (\"vop\", (0, 0)),\n        (\"eog\", (0, 0)),\n        (\"Sac\", (0, 0)),\n        (\"nvrt\", (0, 0)),\n        (\"precnsim\", (0, 0)),\n        (\"fopf;\", (120151, 0)),\n        (\"loarr;\", (8701, 0)),\n        (\"lg;\", (8822, 0)),\n        (\"iiiint\", (0, 0)),\n        (\"approxeq;\", (8778, 0)),\n        (\"hookright\", (0, 0)),\n        (\"NotDoubl\", (0, 0)),\n        (\"nsc\", (0, 0)),\n        (\"Sscr;\", (119982, 0)),\n        (\"Diacriti\", (0, 0)),\n        (\"gtreqqless\", (0, 0)),\n        (\"NotGreaterSlan\", (0, 0)),\n        (\"icir\", (0, 0)),\n        (\"Sub\", (0, 0)),\n        (\"twoheadrightarrow\", (0, 0)),\n        (\"DoubleUpDown\", (0, 0)),\n        (\"NotSucceedsSlantE\", (0, 0)),\n        (\"subseteq\", (0, 0)),\n        (\"nsubE;\", (10949, 824)),\n        (\"rtri;\", (9657, 0)),\n        (\"LongLeft\", (0, 0)),\n        (\"Tca\", (0, 0)),\n        (\"vsupne;\", (8843, 65024)),\n        (\"Updow\", (0, 0)),\n        (\"xrArr;\", (10233, 0)),\n        (\"prec;\", (8826, 0)),\n        (\"efr\", (0, 0)),\n        (\"VerticalSeparator;\", (10072, 0)),\n        (\"OpenCurlyDoub\", (0, 0)),\n        (\"Qop\", (0, 0)),\n        (\"homtht\", (0, 0)),\n        (\"Ido\", (0, 0)),\n        (\"rightrig\", (0, 0)),\n        (\"andslo\", (0, 0)),\n        (\"lesc\", (0, 0)),\n        (\"Scy;\", (1057, 0)),\n        (\"LeftTriangleEq\", (0, 0)),\n        (\"simdot;\", (10858, 0)),\n        (\"ffllig\", (0, 0)),\n        (\"trim\", (0, 0)),\n        (\"larrtl\", (0, 0)),\n        (\"nri\", (0, 0)),\n        (\"GreaterSlantEqua\", (0, 0)),\n        (\"rightarrowta\", (0, 0)),\n        (\"nshortpar\", (0, 0)),\n        (\"ncedi\", (0, 0)),\n        (\"RightArrowLe\", (0, 0)),\n        (\"simdot\", (0, 0)),\n        (\"GreaterFu\", (0, 0)),\n        (\"RightUpTeeVector;\", (10588, 0)),\n        (\"gtrsim;\", (8819, 0)),\n        (\"lates;\", (10925, 65024)),\n        (\"NotTildeF\", (0, 0)),\n        (\"simra\", (0, 0)),\n        (\"zcaro\", (0, 0)),\n        (\"LeftTriangleE\", (0, 0)),\n        (\"DoubleVertical\", (0, 0)),\n        (\"awi\", (0, 0)),\n        (\"Ucir\", (0, 0)),\n        (\"qua\", (0, 0)),\n        (\"LessTilde;\", (8818, 0)),\n        (\"propto\", (0, 0)),\n        (\"precsi\", (0, 0)),\n        (\"compf\", (0, 0)),\n        (\"lsq\", (0, 0)),\n        (\"Wo\", (0, 0)),\n        (\"ltlarr\", (0, 0)),\n        (\"andand\", (0, 0)),\n        (\"LongRight\", (0, 0)),\n        (\"cire\", (0, 0)),\n        (\"DownTee\", (0, 0)),\n        (\"Jukcy\", (0, 0)),\n        (\"simr\", (0, 0)),\n        (\"infinti\", (0, 0)),\n        (\"upuparrow\", (0, 0)),\n        (\"SquareSubset\", (0, 0)),\n        (\"expon\", (0, 0)),\n        (\"DiacriticalT\", (0, 0)),\n        (\"apac\", (0, 0)),\n        (\"Superset;\", (8835, 0)),\n        (\"Iogon\", (0, 0)),\n        (\"NoBrea\", (0, 0)),\n        (\"circledc\", (0, 0)),\n        (\"LeftArrowRi\", (0, 0)),\n        (\"LongLeftRight\", (0, 0)),\n        (\"LeftUpDownVec\", (0, 0)),\n        (\"FilledSmallS\", (0, 0)),\n        (\"Vvdash\", (0, 0)),\n        (\"fflli\", (0, 0)),\n        (\"thkap;\", (8776, 0)),\n        (\"frac16;\", (8537, 0)),\n        (\"RightAr\", (0, 0)),\n        (\"DoubleRightArro\", (0, 0)),\n        (\"ur\", (0, 0)),\n        (\"DownLeftRig\", (0, 0)),\n        (\"DoubleLeftAr\", (0, 0)),\n        (\"rsaquo\", (0, 0)),\n        (\"succ;\", (8827, 0)),\n        (\"NotHumpDownHu\", (0, 0)),\n        (\"rightrightarrow\", (0, 0)),\n        (\"lrha\", (0, 0)),\n        (\"gap;\", (10886, 0)),\n        (\"Xf\", (0, 0)),\n        (\"bul\", (0, 0)),\n        (\"RuleDelayed;\", (10740, 0)),\n        (\"eparsl;\", (10723, 0)),\n        (\"gimel\", (0, 0)),\n        (\"telrec;\", (8981, 0)),\n        (\"lowas\", (0, 0)),\n        (\"PlusMinus\", (0, 0)),\n        (\"nleqq;\", (8806, 824)),\n        (\"precapprox;\", (10935, 0)),\n        (\"vartriangleright;\", (8883, 0)),\n        (\"uu\", (0, 0)),\n        (\"NegativeVeryThin\", (0, 0)),\n        (\"frac78;\", (8542, 0)),\n        (\"Iopf\", (0, 0)),\n        (\"LowerRightA\", (0, 0)),\n        (\"NotExi\", (0, 0)),\n        (\"xot\", (0, 0)),\n        (\"CapitalDifferentialD;\", (8517, 0)),\n        (\"lacute;\", (314, 0)),\n        (\"Cap;\", (8914, 0)),\n        (\"zeetrf\", (0, 0)),\n        (\"NotRevers\", (0, 0)),\n        (\"Ao\", (0, 0)),\n        (\"ulc\", (0, 0)),\n        (\"blacktrianglelef\", (0, 0)),\n        (\"eum\", (0, 0)),\n        (\"ltquest\", (0, 0)),\n        (\"mida\", (0, 0)),\n        (\"uda\", (0, 0)),\n        (\"DiacriticalDoubl\", (0, 0)),\n        (\"ltrif\", (0, 0)),\n        (\"rightharpoonu\", (0, 0)),\n        (\"OpenCurlyQu\", (0, 0)),\n        (\"Pcy\", (0, 0)),\n        (\"sdote\", (0, 0)),\n        (\"SubsetE\", (0, 0)),\n        (\"mst\", (0, 0)),\n        (\"NestedGreaterGreate\", (0, 0)),\n        (\"Ntil\", (0, 0)),\n        (\"Amac\", (0, 0)),\n        (\"nbumpe\", (0, 0)),\n        (\"Equa\", (0, 0)),\n        (\"eqsim\", (0, 0)),\n        (\"Cent\", (0, 0)),\n        (\"Aum\", (0, 0)),\n        (\"gnsim;\", (8935, 0)),\n        (\"Because\", (0, 0)),\n        (\"xotim\", (0, 0)),\n        (\"supset;\", (8835, 0)),\n        (\"simn\", (0, 0)),\n        (\"sqsubs\", (0, 0)),\n        (\"Equili\", (0, 0)),\n        (\"LeftArrowBar\", (0, 0)),\n        (\"nless\", (0, 0)),\n        (\"NotGreaterGreater\", (0, 0)),\n        (\"gvnE;\", (8809, 65024)),\n        (\"varth\", (0, 0)),\n        (\"veeeq;\", (8794, 0)),\n        (\"Dagge\", (0, 0)),\n        (\"bigtriangl\", (0, 0)),\n        (\"SuchThat\", (0, 0)),\n        (\"OverParenthesi\", (0, 0)),\n        (\"DoubleUp\", (0, 0)),\n        (\"cups\", (0, 0)),\n        (\"DScy;\", (1029, 0)),\n        (\"dAr\", (0, 0)),\n        (\"emsp13;\", (8196, 0)),\n        (\"Yacute\", (221, 0)),\n        (\"lsimg\", (0, 0)),\n        (\"mfr;\", (120106, 0)),\n        (\"nvin\", (0, 0)),\n        (\"osl\", (0, 0)),\n        (\"vnsup\", (0, 0)),\n        (\"RightArrowLeftAr\", (0, 0)),\n        (\"weier\", (0, 0)),\n        (\"zop\", (0, 0)),\n        (\"lessgtr\", (0, 0)),\n        (\"leftleftarro\", (0, 0)),\n        (\"lessa\", (0, 0)),\n        (\"varpi;\", (982, 0)),\n        (\"Gopf;\", (120126, 0)),\n        (\"OverBracket;\", (9140, 0)),\n        (\"isins;\", (8948, 0)),\n        (\"wedgeq;\", (8793, 0)),\n        (\"simplus\", (0, 0)),\n        (\"ufisht\", (0, 0)),\n        (\"lurds\", (0, 0)),\n        (\"verbar;\", (124, 0)),\n        (\"urco\", (0, 0)),\n        (\"Uuml\", (220, 0)),\n        (\"Cacut\", (0, 0)),\n        (\"NotSucceedsSlant\", (0, 0)),\n        (\"ReverseUpEquili\", (0, 0)),\n        (\"NotDoubleVert\", (0, 0)),\n        (\"sst\", (0, 0)),\n        (\"pertenk;\", (8241, 0)),\n        (\"blacksq\", (0, 0)),\n        (\"hal\", (0, 0)),\n        (\"NotNested\", (0, 0)),\n        (\"DiacriticalGrav\", (0, 0)),\n        (\"rharul;\", (10604, 0)),\n        (\"Cca\", (0, 0)),\n        (\"yuml\", (255, 0)),\n        (\"incare;\", (8453, 0)),\n        (\"varsubse\", (0, 0)),\n        (\"ru\", (0, 0)),\n        (\"vDas\", (0, 0)),\n        (\"ifr;\", (120102, 0)),\n        (\"LeftDoubleBracke\", (0, 0)),\n        (\"ThinSpace\", (0, 0)),\n        (\"supsetne\", (0, 0)),\n        (\"sqsupset\", (0, 0)),\n        (\"Uarrocir\", (0, 0)),\n        (\"nacute;\", (324, 0)),\n        (\"xsq\", (0, 0)),\n        (\"succnapp\", (0, 0)),\n        (\"topfork\", (0, 0)),\n        (\"tritim\", (0, 0)),\n        (\"nrtr\", (0, 0)),\n        (\"quot\", (34, 0)),\n        (\"ep\", (0, 0)),\n        (\"mho\", (0, 0)),\n        (\"Proportiona\", (0, 0)),\n        (\"NestedGreaterGre\", (0, 0)),\n        (\"DoubleCon\", (0, 0)),\n        (\"cire;\", (8791, 0)),\n        (\"RightTeeArrow\", (0, 0)),\n        (\"nedot;\", (8784, 824)),\n        (\"OpenCurlyDouble\", (0, 0)),\n        (\"NotGr\", (0, 0)),\n        (\"sea\", (0, 0)),\n        (\"geqq;\", (8807, 0)),\n        (\"um\", (0, 0)),\n        (\"rlh\", (0, 0)),\n        (\"jf\", (0, 0)),\n        (\"lc\", (0, 0)),\n        (\"das\", (0, 0)),\n        (\"swArr;\", (8665, 0)),\n        (\"DownLeftVectorBa\", (0, 0)),\n        (\"ssetmn\", (0, 0)),\n        (\"Eleme\", (0, 0)),\n        (\"upa\", (0, 0)),\n        (\"angsph\", (0, 0)),\n        (\"com\", (0, 0)),\n        (\"cirE;\", (10691, 0)),\n        (\"loan\", (0, 0)),\n        (\"Yacute;\", (221, 0)),\n        (\"dollar;\", (36, 0)),\n        (\"Contour\", (0, 0)),\n        (\"gvert\", (0, 0)),\n        (\"rceil\", (0, 0)),\n        (\"cuepr;\", (8926, 0)),\n        (\"La\", (0, 0)),\n        (\"CircleMi\", (0, 0)),\n        (\"DoubleLongLeftRight\", (0, 0)),\n        (\"nm\", (0, 0)),\n        (\"ltimes;\", (8905, 0)),\n        (\"UpperRigh\", (0, 0)),\n        (\"rae\", (0, 0)),\n        (\"Ocirc\", (212, 0)),\n        (\"gesl\", (0, 0)),\n        (\"pointi\", (0, 0)),\n        (\"rsqb;\", (93, 0)),\n        (\"ko\", (0, 0)),\n        (\"nhpar\", (0, 0)),\n        (\"scy\", (0, 0)),\n        (\"urcorner;\", (8989, 0)),\n        (\"ImaginaryI;\", (8520, 0)),\n        (\"Equil\", (0, 0)),\n        (\"vert;\", (124, 0)),\n        (\"leftlef\", (0, 0)),\n        (\"boxVH;\", (9580, 0)),\n        (\"yscr\", (0, 0)),\n        (\"uacute\", (250, 0)),\n        (\"RightArrowLeftArrow;\", (8644, 0)),\n        (\"Negative\", (0, 0)),\n        (\"Diamond;\", (8900, 0)),\n        (\"punc\", (0, 0)),\n        (\"Aogon;\", (260, 0)),\n        (\"LeftCe\", (0, 0)),\n        (\"NegativeMed\", (0, 0)),\n        (\"iques\", (0, 0)),\n        (\"forall\", (0, 0)),\n        (\"Supse\", (0, 0)),\n        (\"boxVH\", (0, 0)),\n        (\"NotRightTriangleBar;\", (10704, 824)),\n        (\"NotNestedLessLess;\", (10913, 824)),\n        (\"Diamo\", (0, 0)),\n        (\"NotRever\", (0, 0)),\n        (\"profsur\", (0, 0)),\n        (\"LeftTeeArrow\", (0, 0)),\n        (\"rarrlp;\", (8620, 0)),\n        (\"filig;\", (64257, 0)),\n        (\"Ex\", (0, 0)),\n        (\"nearh\", (0, 0)),\n        (\"ssc\", (0, 0)),\n        (\"Qfr\", (0, 0)),\n        (\"ecolon\", (0, 0)),\n        (\"Product\", (0, 0)),\n        (\"triangleright\", (0, 0)),\n        (\"mapstod\", (0, 0)),\n        (\"igrave;\", (236, 0)),\n        (\"bigstar;\", (9733, 0)),\n        (\"Uni\", (0, 0)),\n        (\"rightthreetim\", (0, 0)),\n        (\"Poincarepl\", (0, 0)),\n        (\"Gammad\", (0, 0)),\n        (\"bigoplu\", (0, 0)),\n        (\"varnothi\", (0, 0)),\n        (\"DownLeftVectorBar\", (0, 0)),\n        (\"fscr\", (0, 0)),\n        (\"Jscr\", (0, 0)),\n        (\"nsup\", (0, 0)),\n        (\"smil\", (0, 0)),\n        (\"Updowna\", (0, 0)),\n        (\"NotDoubleVertica\", (0, 0)),\n        (\"ropf\", (0, 0)),\n        (\"uH\", (0, 0)),\n        (\"hks\", (0, 0)),\n        (\"sce;\", (10928, 0)),\n        (\"xmap\", (0, 0)),\n        (\"loopar\", (0, 0)),\n        (\"SquareSupersetEqual;\", (8850, 0)),\n        (\"iota\", (0, 0)),\n        (\"delta;\", (948, 0)),\n        (\"xopf;\", (120169, 0)),\n        (\"wp\", (0, 0)),\n        (\"amal\", (0, 0)),\n        (\"nlt;\", (8814, 0)),\n        (\"NoB\", (0, 0)),\n        (\"yuml;\", (255, 0)),\n        (\"neArr;\", (8663, 0)),\n        (\"Cf\", (0, 0)),\n        (\"Gbrev\", (0, 0)),\n        (\"doll\", (0, 0)),\n        (\"oc\", (0, 0)),\n        (\"ulcorn\", (0, 0)),\n        (\"UnderP\", (0, 0)),\n        (\"nabla\", (0, 0)),\n        (\"leftleftarrows\", (0, 0)),\n        (\"Coproduct;\", (8720, 0)),\n        (\"nsqsube\", (0, 0)),\n        (\"angmsdaa\", (0, 0)),\n        (\"Dst\", (0, 0)),\n        (\"CapitalDifferentialD\", (0, 0)),\n        (\"shortm\", (0, 0)),\n        (\"doteqdot;\", (8785, 0)),\n        (\"SHcy\", (0, 0)),\n        (\"SOFTc\", (0, 0)),\n        (\"Gbre\", (0, 0)),\n        (\"quate\", (0, 0)),\n        (\"subnE;\", (10955, 0)),\n        (\"LessTilde\", (0, 0)),\n        (\"supd\", (0, 0)),\n        (\"doublebarwedge;\", (8966, 0)),\n        (\"iff;\", (8660, 0)),\n        (\"awcon\", (0, 0)),\n        (\"lfl\", (0, 0)),\n        (\"FilledSmallSqua\", (0, 0)),\n        (\"VeryThinSpace;\", (8202, 0)),\n        (\"subrarr;\", (10617, 0)),\n        (\"alpha\", (0, 0)),\n        (\"Csc\", (0, 0)),\n        (\"ovbar\", (0, 0)),\n        (\"lra\", (0, 0)),\n        (\"ubreve;\", (365, 0)),\n        (\"NotLessSla\", (0, 0)),\n        (\"Rce\", (0, 0)),\n        (\"nLeftrighta\", (0, 0)),\n        (\"NegativeVeryT\", (0, 0)),\n        (\"lrtr\", (0, 0)),\n        (\"Yuml\", (0, 0)),\n        (\"CloseCurlyDou\", (0, 0)),\n        (\"fork\", (0, 0)),\n        (\"ruluhar;\", (10600, 0)),\n        (\"rBa\", (0, 0)),\n        (\"varr;\", (8597, 0)),\n        (\"smallsetminus;\", (8726, 0)),\n        (\"lsqb\", (0, 0)),\n        (\"yu\", (0, 0)),\n        (\"olcr\", (0, 0)),\n        (\"bigcap\", (0, 0)),\n        (\"NotSubsetEqua\", (0, 0)),\n        (\"NotSucceedsSlantEqua\", (0, 0)),\n        (\"DoubleLongRightA\", (0, 0)),\n        (\"interca\", (0, 0)),\n        (\"larrbfs;\", (10527, 0)),\n        (\"apa\", (0, 0)),\n        (\"NotSquareSuperset\", (0, 0)),\n        (\"nvdash\", (0, 0)),\n        (\"DownTee;\", (8868, 0)),\n        (\"xuplus;\", (10756, 0)),\n        (\"OverBrace;\", (9182, 0)),\n        (\"tridot\", (0, 0)),\n        (\"bigtr\", (0, 0)),\n        (\"Osl\", (0, 0)),\n        (\"lmo\", (0, 0)),\n        (\"Sscr\", (0, 0)),\n        (\"OverBrac\", (0, 0)),\n        (\"rightleftarr\", (0, 0)),\n        (\"nsime;\", (8772, 0)),\n        (\"sqcups;\", (8852, 65024)),\n        (\"NotTildeFullEq\", (0, 0)),\n        (\"nsc;\", (8833, 0)),\n        (\"notinvc\", (0, 0)),\n        (\"erD\", (0, 0)),\n        (\"lcar\", (0, 0)),\n        (\"CounterClockwiseContourInt\", (0, 0)),\n        (\"Fouriertrf;\", (8497, 0)),\n        (\"Rh\", (0, 0)),\n        (\"near\", (0, 0)),\n        (\"Mo\", (0, 0)),\n        (\"DotD\", (0, 0)),\n        (\"sof\", (0, 0)),\n        (\"ngt;\", (8815, 0)),\n        (\"ccups\", (0, 0)),\n        (\"appro\", (0, 0)),\n        (\"LeftDownVector;\", (8643, 0)),\n        (\"beca\", (0, 0)),\n        (\"trpez\", (0, 0)),\n        (\"blacktriangleri\", (0, 0)),\n        (\"congd\", (0, 0)),\n        (\"sacute\", (0, 0)),\n        (\"b\", (0, 0)),\n        (\"Sop\", (0, 0)),\n        (\"fllig\", (0, 0)),\n        (\"doteqdot\", (0, 0)),\n        (\"rpp\", (0, 0)),\n        (\"cente\", (0, 0)),\n        (\"bse\", (0, 0)),\n        (\"NotDoubleVerticalBar\", (0, 0)),\n        (\"brvbar\", (166, 0)),\n        (\"backprim\", (0, 0)),\n        (\"ReverseUpEquil\", (0, 0)),\n        (\"crarr\", (0, 0)),\n        (\"Zd\", (0, 0)),\n        (\"Afr\", (0, 0)),\n        (\"nvinfin;\", (10718, 0)),\n        (\"csub\", (0, 0)),\n        (\"lEg;\", (10891, 0)),\n        (\"eopf\", (0, 0)),\n        (\"scaro\", (0, 0)),\n        (\"rra\", (0, 0)),\n        (\"ncongd\", (0, 0)),\n        (\"abrev\", (0, 0)),\n        (\"Ther\", (0, 0)),\n        (\"DiacriticalDoubleAcute;\", (733, 0)),\n        (\"NotElement\", (0, 0)),\n        (\"updownarrow\", (0, 0)),\n        (\"ShortDownArro\", (0, 0)),\n        (\"ig\", (0, 0)),\n        (\"vangr\", (0, 0)),\n        (\"cuesc;\", (8927, 0)),\n        (\"Yac\", (0, 0)),\n        (\"ljcy\", (0, 0)),\n        (\"sqsubseteq\", (0, 0)),\n        (\"map;\", (8614, 0)),\n        (\"ljcy;\", (1113, 0)),\n        (\"Under\", (0, 0)),\n        (\"LeftTeeVector\", (0, 0)),\n        (\"TildeTil\", (0, 0)),\n        (\"quati\", (0, 0)),\n        (\"DoubleVerticalBa\", (0, 0)),\n        (\"longleftar\", (0, 0)),\n        (\"Auml;\", (196, 0)),\n        (\"tcaro\", (0, 0)),\n        (\"equal\", (0, 0)),\n        (\"NotGreaterFullEqual;\", (8807, 824)),\n        (\"nsupE\", (0, 0)),\n        (\"Proportio\", (0, 0)),\n        (\"epsilon\", (0, 0)),\n        (\"dbkar\", (0, 0)),\n        (\"upharpoonright\", (0, 0)),\n        (\"rata\", (0, 0)),\n        (\"NotNestedGreaterGreate\", (0, 0)),\n        (\"lrm;\", (8206, 0)),\n        (\"ael\", (0, 0)),\n        (\"frac23\", (0, 0)),\n        (\"Emac\", (0, 0)),\n        (\"Counter\", (0, 0)),\n        (\"capcup\", (0, 0)),\n        (\"Wfr\", (0, 0)),\n        (\"VerticalSe\", (0, 0)),\n        (\"rAta\", (0, 0)),\n        (\"NotSupersetEqu\", (0, 0)),\n        (\"angmsda\", (0, 0)),\n        (\"subm\", (0, 0)),\n        (\"LowerLeftArro\", (0, 0)),\n        (\"scnap;\", (10938, 0)),\n        (\"rotimes;\", (10805, 0)),\n        (\"Lacut\", (0, 0)),\n        (\"bigodot\", (0, 0)),\n        (\"veebar;\", (8891, 0)),\n        (\"leg;\", (8922, 0)),\n        (\"du\", (0, 0)),\n        (\"aopf\", (0, 0)),\n        (\"hbar;\", (8463, 0)),\n        (\"ouml;\", (246, 0)),\n        (\"tbrk;\", (9140, 0)),\n        (\"lnapprox\", (0, 0)),\n        (\"lharu;\", (8636, 0)),\n        (\"upsih\", (0, 0)),\n        (\"nsi\", (0, 0)),\n        (\"nwne\", (0, 0)),\n        (\"Nest\", (0, 0)),\n        (\"plusacir\", (0, 0)),\n        (\"LeftTriangleBar;\", (10703, 0)),\n        (\"bsolhsub;\", (10184, 0)),\n        (\"Egra\", (0, 0)),\n        (\"ccaron;\", (269, 0)),\n        (\"vcy\", (0, 0)),\n        (\"Proportional\", (0, 0)),\n        (\"ShortLeftArrow\", (0, 0)),\n        (\"SubsetEqua\", (0, 0)),\n        (\"hearts;\", (9829, 0)),\n        (\"because;\", (8757, 0)),\n        (\"mcy;\", (1084, 0)),\n        (\"shortpa\", (0, 0)),\n        (\"NotGreaterS\", (0, 0)),\n        (\"lAr\", (0, 0)),\n        (\"realp\", (0, 0)),\n        (\"Cayley\", (0, 0)),\n        (\"RightTriangleBar;\", (10704, 0)),\n        (\"aop\", (0, 0)),\n        (\"NotLess\", (0, 0)),\n        (\"RightA\", (0, 0)),\n        (\"looparro\", (0, 0)),\n        (\"NotVe\", (0, 0)),\n        (\"equivD\", (0, 0)),\n        (\"Circl\", (0, 0)),\n        (\"leftthreetim\", (0, 0)),\n        (\"popf;\", (120161, 0)),\n        (\"DoubleVer\", (0, 0)),\n        (\"raqu\", (0, 0)),\n        (\"nbum\", (0, 0)),\n        (\"Larr\", (0, 0)),\n        (\"NotReverseElement;\", (8716, 0)),\n        (\"NotPrecedesSl\", (0, 0)),\n        (\"downharpoonl\", (0, 0)),\n        (\"nVDash\", (0, 0)),\n        (\"loopa\", (0, 0)),\n        (\"plusci\", (0, 0)),\n        (\"Eopf;\", (120124, 0)),\n        (\"larrhk;\", (8617, 0)),\n        (\"orarr\", (0, 0)),\n        (\"subnE\", (0, 0)),\n        (\"leftthreet\", (0, 0)),\n        (\"prop;\", (8733, 0)),\n        (\"nlsim\", (0, 0)),\n        (\"care\", (0, 0)),\n        (\"Inter\", (0, 0)),\n        (\"cc\", (0, 0)),\n        (\"CounterClo\", (0, 0)),\n        (\"nrar\", (0, 0)),\n        (\"DoubleLeftRightArro\", (0, 0)),\n        (\"permil;\", (8240, 0)),\n        (\"ps\", (0, 0)),\n        (\"Back\", (0, 0)),\n        (\"hookle\", (0, 0)),\n        (\"cs\", (0, 0)),\n        (\"ddagger\", (0, 0)),\n        (\"Succeeds\", (0, 0)),\n        (\"eqslantl\", (0, 0)),\n        (\"rbr\", (0, 0)),\n        (\"LeftArrowBar;\", (8676, 0)),\n        (\"Amacr;\", (256, 0)),\n        (\"angmsdaf\", (0, 0)),\n        (\"ImaginaryI\", (0, 0)),\n        (\"Ed\", (0, 0)),\n        (\"becau\", (0, 0)),\n        (\"Backslash\", (0, 0)),\n        (\"NotPrec\", (0, 0)),\n        (\"Rs\", (0, 0)),\n        (\"Rcedil\", (0, 0)),\n        (\"succcur\", (0, 0)),\n        (\"NotHumpEqual;\", (8783, 824)),\n        (\"Ssc\", (0, 0)),\n        (\"nsubsete\", (0, 0)),\n        (\"con\", (0, 0)),\n        (\"cdo\", (0, 0)),\n        (\"Fopf\", (0, 0)),\n        (\"Rrightarrow\", (0, 0)),\n        (\"scp\", (0, 0)),\n        (\"NotTildeEqua\", (0, 0)),\n        (\"napi\", (0, 0)),\n        (\"ab\", (0, 0)),\n        (\"Cap\", (0, 0)),\n        (\"lrh\", (0, 0)),\n        (\"NotHu\", (0, 0)),\n        (\"osla\", (0, 0)),\n        (\"rightsquigarro\", (0, 0)),\n        (\"exist\", (0, 0)),\n        (\"veeeq\", (0, 0)),\n        (\"DoubleLongLeftArr\", (0, 0)),\n        (\"Leftar\", (0, 0)),\n        (\"twoheadri\", (0, 0)),\n        (\"for\", (0, 0)),\n        (\"NotGreaterFullEqual\", (0, 0)),\n        (\"RightTr\", (0, 0)),\n        (\"Mellintrf\", (0, 0)),\n        (\"YIc\", (0, 0)),\n        (\"it;\", (8290, 0)),\n        (\"Uac\", (0, 0)),\n        (\"herc\", (0, 0)),\n        (\"mlcp;\", (10971, 0)),\n        (\"sqsupset;\", (8848, 0)),\n        (\"mp\", (0, 0)),\n        (\"rightthreetimes;\", (8908, 0)),\n        (\"MediumS\", (0, 0)),\n        (\"dharl;\", (8643, 0)),\n        (\"leftrightharp\", (0, 0)),\n        (\"cular\", (0, 0)),\n        (\"Sho\", (0, 0)),\n        (\"iexcl\", (161, 0)),\n        (\"pitc\", (0, 0)),\n        (\"L\", (0, 0)),\n        (\"LeftRightArro\", (0, 0)),\n        (\"Uring;\", (366, 0)),\n        (\"pars\", (0, 0)),\n        (\"asymp;\", (8776, 0)),\n        (\"Ati\", (0, 0)),\n        (\"angmsdad\", (0, 0)),\n        (\"malt\", (0, 0)),\n        (\"realin\", (0, 0)),\n        (\"RightVectorBar;\", (10579, 0)),\n        (\"Sc;\", (10940, 0)),\n        (\"NotTildeFull\", (0, 0)),\n        (\"Oci\", (0, 0)),\n        (\"rightharpoondown;\", (8641, 0)),\n        (\"trido\", (0, 0)),\n        (\"submult\", (0, 0)),\n        (\"elinters;\", (9191, 0)),\n        (\"cedil\", (184, 0)),\n        (\"eq\", (0, 0)),\n        (\"varepsi\", (0, 0)),\n        (\"circleddash;\", (8861, 0)),\n        (\"hoarr;\", (8703, 0)),\n        (\"ucirc\", (251, 0)),\n        (\"measureda\", (0, 0)),\n        (\"ContourInt\", (0, 0)),\n        (\"LowerLe\", (0, 0)),\n        (\"dzigrar\", (0, 0)),\n        (\"boxtimes;\", (8864, 0)),\n        (\"percnt\", (0, 0)),\n        (\"ogt\", (0, 0)),\n        (\"Iukc\", (0, 0)),\n        (\"DownTeeArrow;\", (8615, 0)),\n        (\"Agrav\", (0, 0)),\n        (\"gtrles\", (0, 0)),\n        (\"erDot;\", (8787, 0)),\n        (\"Mellint\", (0, 0)),\n        (\"PrecedesE\", (0, 0)),\n        (\"as\", (0, 0)),\n        (\"NotEx\", (0, 0)),\n        (\"sqsube\", (0, 0)),\n        (\"precsim;\", (8830, 0)),\n        (\"fs\", (0, 0)),\n        (\"realpart\", (0, 0)),\n        (\"Ropf\", (0, 0)),\n        (\"barvee;\", (8893, 0)),\n        (\"leftthre\", (0, 0)),\n        (\"NotSucceedsE\", (0, 0)),\n        (\"frac25;\", (8534, 0)),\n        (\"backe\", (0, 0)),\n        (\"Colo\", (0, 0)),\n        (\"vd\", (0, 0)),\n        (\"OverBar;\", (8254, 0)),\n        (\"exist;\", (8707, 0)),\n        (\"Cup;\", (8915, 0)),\n        (\"paralle\", (0, 0)),\n        (\"OverB\", (0, 0)),\n        (\"LessSlantEqual;\", (10877, 0)),\n        (\"zscr;\", (120015, 0)),\n        (\"DownL\", (0, 0)),\n        (\"mDD\", (0, 0)),\n        (\"boxH\", (0, 0)),\n        (\"fjl\", (0, 0)),\n        (\"Bre\", (0, 0)),\n        (\"NotLessEq\", (0, 0)),\n        (\"bso\", (0, 0)),\n        (\"blacklozenge;\", (10731, 0)),\n        (\"Rig\", (0, 0)),\n        (\"rparg\", (0, 0)),\n        (\"EmptyVerySmallSquare\", (0, 0)),\n        (\"smid;\", (8739, 0)),\n        (\"nis;\", (8956, 0)),\n        (\"DZcy\", (0, 0)),\n        (\"bigtriang\", (0, 0)),\n        (\"khc\", (0, 0)),\n        (\"lltr\", (0, 0)),\n        (\"OpenCurlyDo\", (0, 0)),\n        (\"NotRightTr\", (0, 0)),\n        (\"DiacriticalDoubleAcu\", (0, 0)),\n        (\"backepsi\", (0, 0)),\n        (\"OpenCurlyQ\", (0, 0)),\n        (\"trianglerigh\", (0, 0)),\n        (\"supe\", (0, 0)),\n        (\"Equi\", (0, 0)),\n        (\"NotHumpEqu\", (0, 0)),\n        (\"Usc\", (0, 0)),\n        (\"Msc\", (0, 0)),\n        (\"upsilon;\", (965, 0)),\n        (\"sex\", (0, 0)),\n        (\"FilledVerySmallSqu\", (0, 0)),\n        (\"RightUpDownV\", (0, 0)),\n        (\"copysr\", (0, 0)),\n        (\"ShortLeft\", (0, 0)),\n        (\"ultri;\", (9720, 0)),\n        (\"lsaquo\", (0, 0)),\n        (\"LeftUpT\", (0, 0)),\n        (\"De\", (0, 0)),\n        (\"twoheadleftarrow\", (0, 0)),\n        (\"nesear;\", (10536, 0)),\n        (\"NonBreakingS\", (0, 0)),\n        (\"thicksim;\", (8764, 0)),\n        (\"alefs\", (0, 0)),\n        (\"cupcap\", (0, 0)),\n        (\"hcirc\", (0, 0)),\n        (\"Kcedi\", (0, 0)),\n        (\"angrtvbd;\", (10653, 0)),\n        (\"capbr\", (0, 0)),\n        (\"UnderParen\", (0, 0)),\n        (\"GreaterS\", (0, 0)),\n        (\"solbar;\", (9023, 0)),\n        (\"fn\", (0, 0)),\n        (\"cularr;\", (8630, 0)),\n        (\"zee\", (0, 0)),\n        (\"laquo;\", (171, 0)),\n        (\"poi\", (0, 0)),\n        (\"roang;\", (10221, 0)),\n        (\"rHar;\", (10596, 0)),\n        (\"natur;\", (9838, 0)),\n        (\"Fill\", (0, 0)),\n        (\"y\", (0, 0)),\n        (\"NotSquareSubsetEqu\", (0, 0)),\n        (\"deg\", (176, 0)),\n        (\"ecy\", (0, 0)),\n        (\"aogon;\", (261, 0)),\n        (\"raemp\", (0, 0)),\n        (\"xlA\", (0, 0)),\n        (\"cupbrc\", (0, 0)),\n        (\"Imp\", (0, 0)),\n        (\"nang;\", (8736, 8402)),\n        (\"gtq\", (0, 0)),\n        (\"leftha\", (0, 0)),\n        (\"KHcy\", (0, 0)),\n        (\"xotime;\", (10754, 0)),\n        (\"nce\", (0, 0)),\n        (\"SquareIntersectio\", (0, 0)),\n        (\"varepsilon;\", (1013, 0)),\n        (\"DownBreve;\", (785, 0)),\n        (\"ulcr\", (0, 0)),\n        (\"vrtr\", (0, 0)),\n        (\"Js\", (0, 0)),\n        (\"gtrs\", (0, 0)),\n        (\"gtrl\", (0, 0)),\n        (\"VerticalSepara\", (0, 0)),\n        (\"blacktriangle;\", (9652, 0)),\n        (\"circlearrowright\", (0, 0)),\n        (\"bneq\", (0, 0)),\n        (\"frac\", (0, 0)),\n        (\"NotLessEqual;\", (8816, 0)),\n        (\"nrarrw\", (0, 0)),\n        (\"dzigrarr\", (0, 0)),\n        (\"cr\", (0, 0)),\n        (\"Xscr;\", (119987, 0)),\n        (\"rbbr\", (0, 0)),\n        (\"gb\", (0, 0)),\n        (\"hell\", (0, 0)),\n        (\"ntriangleleft;\", (8938, 0)),\n        (\"OverParent\", (0, 0)),\n        (\"longleftrightarr\", (0, 0)),\n        (\"rightar\", (0, 0)),\n        (\"pointint;\", (10773, 0)),\n        (\"ther\", (0, 0)),\n        (\"angsp\", (0, 0)),\n        (\"gime\", (0, 0)),\n        (\"Us\", (0, 0)),\n        (\"ropf;\", (120163, 0)),\n        (\"Df\", (0, 0)),\n        (\"dempty\", (0, 0)),\n        (\"complexe\", (0, 0)),\n        (\"Star;\", (8902, 0)),\n        (\"Idot;\", (304, 0)),\n        (\"soft\", (0, 0)),\n        (\"ccedil\", (231, 0)),\n        (\"nwarr;\", (8598, 0)),\n        (\"dfisht\", (0, 0)),\n        (\"Vert\", (0, 0)),\n        (\"dbk\", (0, 0)),\n        (\"gne\", (0, 0)),\n        (\"neq\", (0, 0)),\n        (\"boxHd;\", (9572, 0)),\n        (\"rfl\", (0, 0)),\n        (\"bigwedge\", (0, 0)),\n        (\"operp;\", (10681, 0)),\n        (\"lnapprox;\", (10889, 0)),\n        (\"times;\", (215, 0)),\n        (\"NestedGreaterGr\", (0, 0)),\n        (\"Ms\", (0, 0)),\n        (\"Vscr;\", (119985, 0)),\n        (\"UpEquilibr\", (0, 0)),\n        (\"inc\", (0, 0)),\n        (\"downdow\", (0, 0)),\n        (\"ApplyFuncti\", (0, 0)),\n        (\"lbrack\", (0, 0)),\n        (\"rce\", (0, 0)),\n        (\"ldrush\", (0, 0)),\n        (\"backsim\", (0, 0)),\n        (\"ph\", (0, 0)),\n        (\"LeftVector;\", (8636, 0)),\n        (\"umac\", (0, 0)),\n        (\"hsc\", (0, 0)),\n        (\"kscr\", (0, 0)),\n        (\"lrhard\", (0, 0)),\n        (\"NotEqual\", (0, 0)),\n        (\"map\", (0, 0)),\n        (\"fjlig\", (0, 0)),\n        (\"lsquo;\", (8216, 0)),\n        (\"sect\", (167, 0)),\n        (\"lbrkslu\", (0, 0)),\n        (\"Isc\", (0, 0)),\n        (\"K\", (0, 0)),\n        (\"ddagg\", (0, 0)),\n        (\"ReverseEquilibr\", (0, 0)),\n        (\"leftharpoonup\", (0, 0)),\n        (\"seswar;\", (10537, 0)),\n        (\"complement\", (0, 0)),\n        (\"Lleftarr\", (0, 0)),\n        (\"iuml;\", (239, 0)),\n        (\"simg\", (0, 0)),\n        (\"boxbox\", (0, 0)),\n        (\"Gg\", (0, 0)),\n        (\"cwc\", (0, 0)),\n        (\"NotSquareSupersetEqual\", (0, 0)),\n        (\"weie\", (0, 0)),\n        (\"agrav\", (0, 0)),\n        (\"UpEquilibrium\", (0, 0)),\n        (\"RightCeil\", (0, 0)),\n        (\"op\", (0, 0)),\n        (\"boxvl\", (0, 0)),\n        (\"dtri;\", (9663, 0)),\n        (\"nhp\", (0, 0)),\n        (\"rbrac\", (0, 0)),\n        (\"Leftrightarro\", (0, 0)),\n        (\"ccedil;\", (231, 0)),\n        (\"UnderBar;\", (95, 0)),\n        (\"UpperLe\", (0, 0)),\n        (\"pre\", (0, 0)),\n        (\"middot;\", (183, 0)),\n        (\"Hst\", (0, 0)),\n        (\"Downarro\", (0, 0)),\n        (\"Four\", (0, 0)),\n        (\"nshortmid\", (0, 0)),\n        (\"lesdoto\", (0, 0)),\n        (\"rnmid;\", (10990, 0)),\n        (\"leftlefta\", (0, 0)),\n        (\"rightleft\", (0, 0)),\n        (\"Bernoulli\", (0, 0)),\n        (\"qint;\", (10764, 0)),\n        (\"quatint\", (0, 0)),\n        (\"nsubseteqq;\", (10949, 824)),\n        (\"rot\", (0, 0)),\n        (\"Mscr;\", (8499, 0)),\n        (\"quatern\", (0, 0)),\n        (\"boxD\", (0, 0)),\n        (\"supmult;\", (10946, 0)),\n        (\"NotLeftTriangle\", (0, 0)),\n        (\"Gcedil\", (0, 0)),\n        (\"LeftUpDownVector\", (0, 0)),\n        (\"NotRightTria\", (0, 0)),\n        (\"wedbar;\", (10847, 0)),\n        (\"horbar\", (0, 0)),\n        (\"RightDownTee\", (0, 0)),\n        (\"Eog\", (0, 0)),\n        (\"boxVr\", (0, 0)),\n        (\"lesseqqgt\", (0, 0)),\n        (\"OverP\", (0, 0)),\n        (\"Eopf\", (0, 0)),\n        (\"Ograv\", (0, 0)),\n        (\"nearrow;\", (8599, 0)),\n        (\"ima\", (0, 0)),\n        (\"ffll\", (0, 0)),\n        (\"DownRightVector;\", (8641, 0)),\n        (\"dscy;\", (1109, 0)),\n        (\"Expon\", (0, 0)),\n        (\"DownRightTeeV\", (0, 0)),\n        (\"Darr\", (0, 0)),\n        (\"Tstrok;\", (358, 0)),\n        (\"boxHu\", (0, 0)),\n        (\"nearro\", (0, 0)),\n        (\"thkap\", (0, 0)),\n        (\"vartrianglelef\", (0, 0)),\n        (\"downdownarrow\", (0, 0)),\n        (\"sz\", (0, 0)),\n        (\"hookleftarr\", (0, 0)),\n        (\"Ll\", (0, 0)),\n        (\"vn\", (0, 0)),\n        (\"quaternion\", (0, 0)),\n        (\"omac\", (0, 0)),\n        (\"SquareSupersetEqua\", (0, 0)),\n        (\"thins\", (0, 0)),\n        (\"Lstrok;\", (321, 0)),\n        (\"dscr\", (0, 0)),\n        (\"longleftarrow;\", (10229, 0)),\n        (\"DoubleContourIn\", (0, 0)),\n        (\"LongLeftRightArrow;\", (10231, 0)),\n        (\"LongLeftArrow;\", (10229, 0)),\n        (\"trianglerighteq\", (0, 0)),\n        (\"lfloor;\", (8970, 0)),\n        (\"subseteqq;\", (10949, 0)),\n        (\"laquo\", (171, 0)),\n        (\"RightTeeA\", (0, 0)),\n        (\"brv\", (0, 0)),\n        (\"ltdot;\", (8918, 0)),\n        (\"brvba\", (0, 0)),\n        (\"fpartin\", (0, 0)),\n        (\"Downarr\", (0, 0)),\n        (\"swarrow\", (0, 0)),\n        (\"Assign\", (0, 0)),\n        (\"UpperRightArro\", (0, 0)),\n        (\"alefsym;\", (8501, 0)),\n        (\"DoubleLongLe\", (0, 0)),\n        (\"Lefta\", (0, 0)),\n        (\"khcy\", (0, 0)),\n        (\"NotSucceedsEqual\", (0, 0)),\n        (\"nsubseteq\", (0, 0)),\n        (\"drb\", (0, 0)),\n        (\"NonBreakingSp\", (0, 0)),\n        (\"Ta\", (0, 0)),\n        (\"succ\", (0, 0)),\n        (\"utd\", (0, 0)),\n        (\"exponentiale\", (0, 0)),\n        (\"gt;\", (62, 0)),\n        (\"eDDot\", (0, 0)),\n        (\"rlm\", (0, 0)),\n        (\"PrecedesSlantEq\", (0, 0)),\n        (\"DownArrowUpArrow\", (0, 0)),\n        (\"DDo\", (0, 0)),\n        (\"solb;\", (10692, 0)),\n        (\"laemptyv;\", (10676, 0)),\n        (\"bigve\", (0, 0)),\n        (\"Fourier\", (0, 0)),\n        (\"Epsilon\", (0, 0)),\n        (\"subd\", (0, 0)),\n        (\"CapitalDiffer\", (0, 0)),\n        (\"SHc\", (0, 0)),\n        (\"Gg;\", (8921, 0)),\n        (\"boxtime\", (0, 0)),\n        (\"OpenCurlyD\", (0, 0)),\n        (\"simrarr\", (0, 0)),\n        (\"Ksc\", (0, 0)),\n        (\"angrtvb;\", (8894, 0)),\n        (\"sbquo\", (0, 0)),\n        (\"precapp\", (0, 0)),\n        (\"Ef\", (0, 0)),\n        (\"OverBr\", (0, 0)),\n        (\"gns\", (0, 0)),\n        (\"Tstrok\", (0, 0)),\n        (\"setmi\", (0, 0)),\n        (\"LeftCeil\", (0, 0)),\n        (\"RightVectorBar\", (0, 0)),\n        (\"boxul\", (0, 0)),\n        (\"Lmidot\", (0, 0)),\n        (\"smepar\", (0, 0)),\n        (\"Zet\", (0, 0)),\n        (\"rising\", (0, 0)),\n        (\"ncedil\", (0, 0)),\n        (\"Longleftar\", (0, 0)),\n        (\"lsquo\", (0, 0)),\n        (\"Hop\", (0, 0)),\n        (\"elsdot;\", (10903, 0)),\n        (\"sigmaf\", (0, 0)),\n        (\"varsu\", (0, 0)),\n        (\"Ks\", (0, 0)),\n        (\"twoheadle\", (0, 0)),\n        (\"tri\", (0, 0)),\n        (\"blacks\", (0, 0)),\n        (\"wfr\", (0, 0)),\n        (\"ZeroWidthS\", (0, 0)),\n        (\"ZHc\", (0, 0)),\n        (\"ddotseq\", (0, 0)),\n        (\"DoubleLeftArrow\", (0, 0)),\n        (\"ijlig\", (0, 0)),\n        (\"straightep\", (0, 0)),\n        (\"Uarro\", (0, 0)),\n        (\"lj\", (0, 0)),\n        (\"LeftDownT\", (0, 0)),\n        (\"zeta\", (0, 0)),\n        (\"ssta\", (0, 0)),\n        (\"Un\", (0, 0)),\n        (\"mf\", (0, 0)),\n        (\"harrcir;\", (10568, 0)),\n        (\"UnderBar\", (0, 0)),\n        (\"midd\", (0, 0)),\n        (\"bsol\", (0, 0)),\n        (\"lrcorn\", (0, 0)),\n        (\"hooklefta\", (0, 0)),\n        (\"bsemi;\", (8271, 0)),\n        (\"searrow;\", (8600, 0)),\n        (\"thickapprox\", (0, 0)),\n        (\"scnE;\", (10934, 0)),\n        (\"elsdo\", (0, 0)),\n        (\"ao\", (0, 0)),\n        (\"Min\", (0, 0)),\n        (\"nlE\", (0, 0)),\n        (\"bigs\", (0, 0)),\n        (\"disin;\", (8946, 0)),\n        (\"NotTildeTil\", (0, 0)),\n        (\"Zacut\", (0, 0)),\n        (\"nwarrow\", (0, 0)),\n        (\"NotExists\", (0, 0)),\n        (\"oS\", (0, 0)),\n        (\"Ocy;\", (1054, 0)),\n        (\"scedil\", (0, 0)),\n        (\"there\", (0, 0)),\n        (\"notinv\", (0, 0)),\n        (\"Nacu\", (0, 0)),\n        (\"Lca\", (0, 0)),\n        (\"lha\", (0, 0)),\n        (\"vAr\", (0, 0)),\n        (\"Ugrave;\", (217, 0)),\n        (\"ntriangleleft\", (0, 0)),\n        (\"mid\", (0, 0)),\n        (\"DoubleC\", (0, 0)),\n        (\"GreaterSlantEqual;\", (10878, 0)),\n        (\"sc;\", (8827, 0)),\n        (\"NotTildeTild\", (0, 0)),\n        (\"LessEqualGreater\", (0, 0)),\n        (\"swA\", (0, 0)),\n        (\"ordm;\", (186, 0)),\n        (\"ominus;\", (8854, 0)),\n        (\"DotDot;\", (8412, 0)),\n        (\"LowerL\", (0, 0)),\n        (\"lbbr\", (0, 0)),\n        (\"lcu\", (0, 0)),\n        (\"vsub\", (0, 0)),\n        (\"Util\", (0, 0)),\n        (\"iog\", (0, 0)),\n        (\"ex\", (0, 0)),\n        (\"DotEq\", (0, 0)),\n        (\"scnsi\", (0, 0)),\n        (\"rmo\", (0, 0)),\n        (\"Sopf\", (0, 0)),\n        (\"empty;\", (8709, 0)),\n        (\"nang\", (0, 0)),\n        (\"upsilon\", (0, 0)),\n        (\"rightharpo\", (0, 0)),\n        (\"ee;\", (8519, 0)),\n        (\"vltr\", (0, 0)),\n        (\"yacute;\", (253, 0)),\n        (\"pscr\", (0, 0)),\n        (\"supla\", (0, 0)),\n        (\"sopf\", (0, 0)),\n        (\"varnothing\", (0, 0)),\n        (\"supdot;\", (10942, 0)),\n        (\"RightDoubl\", (0, 0)),\n        (\"RBa\", (0, 0)),\n        (\"precnap\", (0, 0)),\n        (\"hookrighta\", (0, 0)),\n        (\"setmn;\", (8726, 0)),\n        (\"angmsdah\", (0, 0)),\n        (\"Imaginary\", (0, 0)),\n        (\"ccedi\", (0, 0)),\n        (\"Union\", (0, 0)),\n        (\"xuplu\", (0, 0)),\n        (\"sum;\", (8721, 0)),\n        (\"trisb\", (0, 0)),\n        (\"amp;\", (38, 0)),\n        (\"rightle\", (0, 0)),\n        (\"theta\", (0, 0)),\n        (\"nleqq\", (0, 0)),\n        (\"preccur\", (0, 0)),\n        (\"lob\", (0, 0)),\n        (\"erarr\", (0, 0)),\n        (\"Icir\", (0, 0)),\n        (\"bum\", (0, 0)),\n        (\"amp\", (38, 0)),\n        (\"EmptySmallSquar\", (0, 0)),\n        (\"sp\", (0, 0)),\n        (\"Longleftrightarrow\", (0, 0)),\n        (\"hybul\", (0, 0)),\n        (\"Tcedil\", (0, 0)),\n        (\"tosa\", (0, 0)),\n        (\"SucceedsSl\", (0, 0)),\n        (\"Berno\", (0, 0)),\n        (\"RightDownVectorBar\", (0, 0)),\n        (\"half\", (0, 0)),\n        (\"emptys\", (0, 0)),\n        (\"rhard;\", (8641, 0)),\n        (\"nsim;\", (8769, 0)),\n        (\"solb\", (0, 0)),\n        (\"between\", (0, 0)),\n        (\"nwar\", (0, 0)),\n        (\"larrsim;\", (10611, 0)),\n        (\"UpEqui\", (0, 0)),\n        (\"ngtr;\", (8815, 0)),\n        (\"FilledSmallSquare\", (0, 0)),\n        (\"uogon\", (0, 0)),\n        (\"mi\", (0, 0)),\n        (\"cwin\", (0, 0)),\n        (\"varsupsetneq\", (0, 0)),\n        (\"LeftUpVec\", (0, 0)),\n        (\"nprcu\", (0, 0)),\n        (\"nan\", (0, 0)),\n        (\"blacksquare;\", (9642, 0)),\n        (\"rcedil\", (0, 0)),\n        (\"ShortDownArrow;\", (8595, 0)),\n        (\"rarrsim;\", (10612, 0)),\n        (\"Xopf;\", (120143, 0)),\n        (\"cross\", (0, 0)),\n        (\"DownTeeArr\", (0, 0)),\n        (\"Otild\", (0, 0)),\n        (\"Jop\", (0, 0)),\n        (\"NotGreaterFullEqu\", (0, 0)),\n        (\"bbr\", (0, 0)),\n        (\"biguplu\", (0, 0)),\n        (\"uop\", (0, 0)),\n        (\"Thin\", (0, 0)),\n        (\"ov\", (0, 0)),\n        (\"boxuR;\", (9560, 0)),\n        (\"nRightarrow;\", (8655, 0)),\n        (\"Iacute\", (205, 0)),\n        (\"reali\", (0, 0)),\n        (\"cupcup\", (0, 0)),\n        (\"LongRightAr\", (0, 0)),\n        (\"nleftr\", (0, 0)),\n        (\"clubsui\", (0, 0)),\n        (\"andan\", (0, 0)),\n        (\"ycy;\", (1099, 0)),\n        (\"nvinfin\", (0, 0)),\n        (\"Ac\", (0, 0)),\n        (\"longmapsto;\", (10236, 0)),\n        (\"RightDoubleBracket;\", (10215, 0)),\n        (\"blacksqua\", (0, 0)),\n        (\"DoubleContour\", (0, 0)),\n        (\"isins\", (0, 0)),\n        (\"varsupsetne\", (0, 0)),\n        (\"LeftUpVect\", (0, 0)),\n        (\"nearr\", (0, 0)),\n        (\"Lle\", (0, 0)),\n        (\"Dscr;\", (119967, 0)),\n        (\"SucceedsSlan\", (0, 0)),\n        (\"Ass\", (0, 0)),\n        (\"sime\", (0, 0)),\n        (\"popf\", (0, 0)),\n        (\"LJcy;\", (1033, 0)),\n        (\"backeps\", (0, 0)),\n        (\"disin\", (0, 0)),\n        (\"ReverseEq\", (0, 0)),\n        (\"LeftAngleBr\", (0, 0)),\n        (\"UnderB\", (0, 0)),\n        (\"fallingdots\", (0, 0)),\n        (\"Verba\", (0, 0)),\n        (\"nrArr;\", (8655, 0)),\n        (\"Unio\", (0, 0)),\n        (\"Vc\", (0, 0)),\n        (\"female;\", (9792, 0)),\n        (\"topcir\", (0, 0)),\n        (\"NotSquareSubs\", (0, 0)),\n        (\"intl\", (0, 0)),\n        (\"her\", (0, 0)),\n        (\"prsi\", (0, 0)),\n        (\"downdownarr\", (0, 0)),\n        (\"Plus\", (0, 0)),\n        (\"elsd\", (0, 0)),\n        (\"lvertne\", (0, 0)),\n        (\"ccaron\", (0, 0)),\n        (\"lang\", (0, 0)),\n        (\"loar\", (0, 0)),\n        (\"LessS\", (0, 0)),\n        (\"LeftRigh\", (0, 0)),\n        (\"eqslantg\", (0, 0)),\n        (\"zwn\", (0, 0)),\n        (\"nsimeq\", (0, 0)),\n        (\"urcro\", (0, 0)),\n        (\"CHcy\", (0, 0)),\n        (\"Lapl\", (0, 0)),\n        (\"leqsl\", (0, 0)),\n        (\"LeftDownTeeVect\", (0, 0)),\n        (\"shortparalle\", (0, 0)),\n        (\"nvHar\", (0, 0)),\n        (\"Different\", (0, 0)),\n        (\"scE;\", (10932, 0)),\n        (\"Su\", (0, 0)),\n        (\"rcar\", (0, 0)),\n        (\"utri;\", (9653, 0)),\n        (\"UpTe\", (0, 0)),\n        (\"GreaterTilde;\", (8819, 0)),\n        (\"isin;\", (8712, 0)),\n        (\"eur\", (0, 0)),\n        (\"darr;\", (8595, 0)),\n        (\"longleftright\", (0, 0)),\n        (\"euro\", (0, 0)),\n        (\"NotDoubleVerticalBa\", (0, 0)),\n        (\"orslope\", (0, 0)),\n        (\"Icy;\", (1048, 0)),\n        (\"af;\", (8289, 0)),\n        (\"blacktriangleright;\", (9656, 0)),\n        (\"rsa\", (0, 0)),\n        (\"lE\", (0, 0)),\n        (\"Longleftrighta\", (0, 0)),\n        (\"esdot;\", (8784, 0)),\n        (\"lmi\", (0, 0)),\n        (\"backprime;\", (8245, 0)),\n        (\"NotSuperse\", (0, 0)),\n        (\"curlyeqsucc\", (0, 0)),\n        (\"dwangle;\", (10662, 0)),\n        (\"uacute;\", (250, 0)),\n        (\"Longleftr\", (0, 0)),\n        (\"DotDo\", (0, 0)),\n        (\"Hstrok\", (0, 0)),\n        (\"thick\", (0, 0)),\n        (\"Longright\", (0, 0)),\n        (\"NotHumpDown\", (0, 0)),\n        (\"TH\", (0, 0)),\n        (\"lbrkslu;\", (10637, 0)),\n        (\"gvn\", (0, 0)),\n        (\"imagl\", (0, 0)),\n        (\"Proporti\", (0, 0)),\n        (\"sup\", (0, 0)),\n        (\"EmptyVerySmal\", (0, 0)),\n        (\"npr;\", (8832, 0)),\n        (\"circeq;\", (8791, 0)),\n        (\"suphs\", (0, 0)),\n        (\"angle;\", (8736, 0)),\n        (\"rAtai\", (0, 0)),\n        (\"rop\", (0, 0)),\n        (\"NegativeM\", (0, 0)),\n        (\"Longle\", (0, 0)),\n        (\"Invisibl\", (0, 0)),\n        (\"angza\", (0, 0)),\n        (\"bigu\", (0, 0)),\n        (\"NotHumpEq\", (0, 0)),\n        (\"DoubleLongLeftRightArrow\", (0, 0)),\n        (\"VDash;\", (8875, 0)),\n        (\"nGg;\", (8921, 824)),\n        (\"Gre\", (0, 0)),\n        (\"cempty\", (0, 0)),\n        (\"NegativeThick\", (0, 0)),\n        (\"leftl\", (0, 0)),\n        (\"Ucirc\", (219, 0)),\n        (\"tr\", (0, 0)),\n        (\"easte\", (0, 0)),\n        (\"lo\", (0, 0)),\n        (\"COPY\", (169, 0)),\n        (\"Poi\", (0, 0)),\n        (\"Congruen\", (0, 0)),\n        (\"smepa\", (0, 0)),\n        (\"rfi\", (0, 0)),\n        (\"eplus;\", (10865, 0)),\n        (\"LeftArrowRightArro\", (0, 0)),\n        (\"CounterClockwiseCo\", (0, 0)),\n        (\"frac34;\", (190, 0)),\n        (\"bopf;\", (120147, 0)),\n        (\"rightleftha\", (0, 0)),\n        (\"blacktriangledow\", (0, 0)),\n        (\"xutri;\", (9651, 0)),\n        (\"eqvp\", (0, 0)),\n        (\"Rho\", (0, 0)),\n        (\"profa\", (0, 0)),\n        (\"circleda\", (0, 0)),\n        (\"frac58\", (0, 0)),\n        (\"prsim;\", (8830, 0)),\n        (\"scsim;\", (8831, 0)),\n        (\"leftarrowta\", (0, 0)),\n        (\"LeftUpDown\", (0, 0)),\n        (\"eqco\", (0, 0)),\n        (\"NestedGreaterGreater\", (0, 0)),\n        (\"nwarhk;\", (10531, 0)),\n        (\"epsilo\", (0, 0)),\n        (\"Eg\", (0, 0)),\n        (\"dtdo\", (0, 0)),\n        (\"es\", (0, 0)),\n        (\"uwangl\", (0, 0)),\n        (\"zwj;\", (8205, 0)),\n        (\"LeftVec\", (0, 0)),\n        (\"succnap\", (0, 0)),\n        (\"iec\", (0, 0)),\n        (\"softc\", (0, 0)),\n        (\"topfo\", (0, 0)),\n        (\"vf\", (0, 0)),\n        (\"Hilbert\", (0, 0)),\n        (\"pro\", (0, 0)),\n        (\"gs\", (0, 0)),\n        (\"ReverseEquili\", (0, 0)),\n        (\"Wscr;\", (119986, 0)),\n        (\"DownLeftRigh\", (0, 0)),\n        (\"LeftRightAr\", (0, 0)),\n        (\"rmoustac\", (0, 0)),\n        (\"nprec\", (0, 0)),\n        (\"Trip\", (0, 0)),\n        (\"circlearrowright;\", (8635, 0)),\n        (\"SucceedsS\", (0, 0)),\n        (\"NoBr\", (0, 0)),\n        (\"xod\", (0, 0)),\n        (\"DoubleDot\", (0, 0)),\n        (\"mapstou\", (0, 0)),\n        (\"ncap;\", (10819, 0)),\n        (\"Diacri\", (0, 0)),\n        (\"subset;\", (8834, 0)),\n        (\"YA\", (0, 0)),\n        (\"Sigm\", (0, 0)),\n        (\"gtrarr;\", (10616, 0)),\n        (\"DoubleLongRigh\", (0, 0)),\n        (\"Beta;\", (914, 0)),\n        (\"gtrarr\", (0, 0)),\n        (\"nsup;\", (8837, 0)),\n        (\"LeftTeeVect\", (0, 0)),\n        (\"plank\", (0, 0)),\n        (\"omid\", (0, 0)),\n        (\"DownRightVectorB\", (0, 0)),\n        (\"lmoustach\", (0, 0)),\n        (\"OpenCu\", (0, 0)),\n        (\"Lt\", (0, 0)),\n        (\"gtreqqless;\", (10892, 0)),\n        (\"twohea\", (0, 0)),\n        (\"ni\", (0, 0)),\n        (\"laemp\", (0, 0)),\n        (\"lhblk;\", (9604, 0)),\n        (\"Ud\", (0, 0)),\n        (\"PrecedesS\", (0, 0)),\n        (\"MediumSpace\", (0, 0)),\n        (\"varnot\", (0, 0)),\n        (\"divonx\", (0, 0)),\n        (\"bar\", (0, 0)),\n        (\"RightUpTeeV\", (0, 0)),\n        (\"bigst\", (0, 0)),\n        (\"ExponentialE\", (0, 0)),\n        (\"rightthre\", (0, 0)),\n        (\"prod\", (0, 0)),\n        (\"npa\", (0, 0)),\n        (\"ufr;\", (120114, 0)),\n        (\"preccurl\", (0, 0)),\n        (\"oi\", (0, 0)),\n        (\"sf\", (0, 0)),\n        (\"IOc\", (0, 0)),\n        (\"loplu\", (0, 0)),\n        (\"Uo\", (0, 0)),\n        (\"rharu;\", (8640, 0)),\n        (\"LessG\", (0, 0)),\n        (\"doteqd\", (0, 0)),\n        (\"chc\", (0, 0)),\n        (\"Ubreve;\", (364, 0)),\n        (\"ris\", (0, 0)),\n        (\"nGtv\", (0, 0)),\n        (\"boxdr\", (0, 0)),\n        (\"rarrp\", (0, 0)),\n        (\"eco\", (0, 0)),\n        (\"hamil\", (0, 0)),\n        (\"ord;\", (10845, 0)),\n        (\"wedb\", (0, 0)),\n        (\"nsucc;\", (8833, 0)),\n        (\"zcy;\", (1079, 0)),\n        (\"NotLef\", (0, 0)),\n        (\"Ocy\", (0, 0)),\n        (\"Intersection\", (0, 0)),\n        (\"Ntilde;\", (209, 0)),\n        (\"vartriangleri\", (0, 0)),\n        (\"uuar\", (0, 0)),\n        (\"suphsol;\", (10185, 0)),\n        (\"verbar\", (0, 0)),\n        (\"exponentia\", (0, 0)),\n        (\"eop\", (0, 0)),\n        (\"boxU\", (0, 0)),\n        (\"twoheadlef\", (0, 0)),\n        (\"dotmin\", (0, 0)),\n        (\"rho\", (0, 0)),\n        (\"Ubreve\", (0, 0)),\n        (\"Jfr;\", (120077, 0)),\n        (\"LessGreate\", (0, 0)),\n        (\"Rced\", (0, 0)),\n        (\"vBar;\", (10984, 0)),\n        (\"Longleftarro\", (0, 0)),\n        (\"wsc\", (0, 0)),\n        (\"yen\", (165, 0)),\n        (\"NotGreaterFul\", (0, 0)),\n        (\"gcirc\", (0, 0)),\n        (\"qpri\", (0, 0)),\n        (\"napo\", (0, 0)),\n        (\"Aacu\", (0, 0)),\n        (\"UpDow\", (0, 0)),\n        (\"Assign;\", (8788, 0)),\n        (\"Chi\", (0, 0)),\n        (\"blank;\", (9251, 0)),\n        (\"VerticalSep\", (0, 0)),\n        (\"vars\", (0, 0)),\n        (\"SuchTh\", (0, 0)),\n        (\"NotSucceedsS\", (0, 0)),\n        (\"Ced\", (0, 0)),\n        (\"NotSquareS\", (0, 0)),\n        (\"LowerR\", (0, 0)),\n        (\"DoubleRight\", (0, 0)),\n        (\"NotDoub\", (0, 0)),\n        (\"subrar\", (0, 0)),\n        (\"boxpl\", (0, 0)),\n        (\"ogon\", (0, 0)),\n        (\"lescc\", (0, 0)),\n        (\"capan\", (0, 0)),\n        (\"egrave\", (232, 0)),\n        (\"VerticalBa\", (0, 0)),\n        (\"ltr\", (0, 0)),\n        (\"Fourie\", (0, 0)),\n        (\"Precedes;\", (8826, 0)),\n        (\"rarr\", (0, 0)),\n        (\"cuv\", (0, 0)),\n        (\"ct\", (0, 0)),\n        (\"Longleftrig\", (0, 0)),\n        (\"VDash\", (0, 0)),\n        (\"nsimeq;\", (8772, 0)),\n        (\"natural\", (0, 0)),\n        (\"TildeFullEqua\", (0, 0)),\n        (\"Updo\", (0, 0)),\n        (\"hamilt\", (0, 0)),\n        (\"OpenCur\", (0, 0)),\n        (\"Ve\", (0, 0)),\n        (\"Cdot;\", (266, 0)),\n        (\"updow\", (0, 0)),\n        (\"nleftarrow\", (0, 0)),\n        (\"jsercy\", (0, 0)),\n        (\"upharpoonr\", (0, 0)),\n        (\"ang;\", (8736, 0)),\n        (\"blacktriangledown;\", (9662, 0)),\n        (\"Im;\", (8465, 0)),\n        (\"curlyeq\", (0, 0)),\n        (\"cularrp\", (0, 0)),\n        (\"lrcor\", (0, 0)),\n        (\"comp\", (0, 0)),\n        (\"sstarf;\", (8902, 0)),\n        (\"apid;\", (8779, 0)),\n        (\"curvearrowlef\", (0, 0)),\n        (\"GreaterFull\", (0, 0)),\n        (\"xr\", (0, 0)),\n        (\"SupersetEqual\", (0, 0)),\n        (\"Ph\", (0, 0)),\n        (\"rightsquigarrow\", (0, 0)),\n        (\"divideonti\", (0, 0)),\n        (\"euml\", (235, 0)),\n        (\"Kappa;\", (922, 0)),\n        (\"npre\", (0, 0)),\n        (\"njcy;\", (1114, 0)),\n        (\"xla\", (0, 0)),\n        (\"blacktriangl\", (0, 0)),\n        (\"RightDownT\", (0, 0)),\n        (\"ReverseEle\", (0, 0)),\n        (\"DoubleLongRi\", (0, 0)),\n        (\"wreath;\", (8768, 0)),\n        (\"race\", (0, 0)),\n        (\"NotSquareSu\", (0, 0)),\n        (\"nbsp\", (160, 0)),\n        (\"ZeroWidt\", (0, 0)),\n        (\"wedg\", (0, 0)),\n        (\"he\", (0, 0)),\n        (\"UpperRightAr\", (0, 0)),\n        (\"xcirc;\", (9711, 0)),\n        (\"ges;\", (10878, 0)),\n        (\"trian\", (0, 0)),\n        (\"nsucceq;\", (10928, 824)),\n        (\"j\", (0, 0)),\n        (\"Cayl\", (0, 0)),\n        (\"Xsc\", (0, 0)),\n        (\"circle\", (0, 0)),\n        (\"yo\", (0, 0)),\n        (\"rcedil;\", (343, 0)),\n        (\"notn\", (0, 0)),\n        (\"NotCup\", (0, 0)),\n        (\"cirmid\", (0, 0)),\n        (\"o\", (0, 0)),\n        (\"UpperR\", (0, 0)),\n        (\"smallsetmin\", (0, 0)),\n        (\"boxvh;\", (9532, 0)),\n        (\"boxhU;\", (9576, 0)),\n        (\"ForA\", (0, 0)),\n        (\"RightDoub\", (0, 0)),\n        (\"nvHarr;\", (10500, 0)),\n        (\"Kcedil;\", (310, 0)),\n        (\"mdash;\", (8212, 0)),\n        (\"LeftUpTee\", (0, 0)),\n        (\"prnsi\", (0, 0)),\n        (\"rarrbf\", (0, 0)),\n        (\"thickapp\", (0, 0)),\n        (\"simg;\", (10910, 0)),\n        (\"Low\", (0, 0)),\n        (\"oast\", (0, 0)),\n        (\"rppoli\", (0, 0)),\n        (\"CloseCurlyDoubleQuote\", (0, 0)),\n        (\"RE\", (0, 0)),\n        (\"rbrk\", (0, 0)),\n        (\"Gop\", (0, 0)),\n        (\"epsi\", (0, 0)),\n        (\"RightU\", (0, 0)),\n        (\"aring;\", (229, 0)),\n        (\"eps\", (0, 0)),\n        (\"amalg;\", (10815, 0)),\n        (\"SquareInterse\", (0, 0)),\n        (\"Omic\", (0, 0)),\n        (\"bigo\", (0, 0)),\n        (\"rightleftharpoons\", (0, 0)),\n        (\"uog\", (0, 0)),\n        (\"ShortUpAr\", (0, 0)),\n        (\"Ropf;\", (8477, 0)),\n        (\"UpperLeft\", (0, 0)),\n        (\"downarrow\", (0, 0)),\n        (\"succsi\", (0, 0)),\n        (\"otime\", (0, 0)),\n        (\"Til\", (0, 0)),\n        (\"suphsub;\", (10967, 0)),\n        (\"llhard\", (0, 0)),\n        (\"Lop\", (0, 0)),\n        (\"ShortLeftA\", (0, 0)),\n        (\"NotPrecede\", (0, 0)),\n        (\"Gscr\", (0, 0)),\n        (\"NotD\", (0, 0)),\n        (\"boxminus\", (0, 0)),\n        (\"qi\", (0, 0)),\n        (\"iiint;\", (8749, 0)),\n        (\"NotEqualTild\", (0, 0)),\n        (\"Phi;\", (934, 0)),\n        (\"Clockw\", (0, 0)),\n        (\"cudar\", (0, 0)),\n        (\"Inte\", (0, 0)),\n        (\"midcir;\", (10992, 0)),\n        (\"UpE\", (0, 0)),\n        (\"lbar\", (0, 0)),\n        (\"ZeroWidthSpa\", (0, 0)),\n        (\"Zdot\", (0, 0)),\n        (\"lbrk\", (0, 0)),\n        (\"ReverseUpEquilibri\", (0, 0)),\n        (\"Capital\", (0, 0)),\n        (\"nhpa\", (0, 0)),\n        (\"precns\", (0, 0)),\n        (\"NotSquareSubset;\", (8847, 824)),\n        (\"Hi\", (0, 0)),\n        (\"eacute;\", (233, 0)),\n        (\"smile\", (0, 0)),\n        (\"RightUpTeeVect\", (0, 0)),\n        (\"pfr;\", (120109, 0)),\n        (\"Ncy\", (0, 0)),\n        (\"opa\", (0, 0)),\n        (\"xo\", (0, 0)),\n        (\"ntriangler\", (0, 0)),\n        (\"lotim\", (0, 0)),\n        (\"Element;\", (8712, 0)),\n        (\"Mcy;\", (1052, 0)),\n        (\"vdash;\", (8866, 0)),\n        (\"ExponentialE;\", (8519, 0)),\n        (\"vA\", (0, 0)),\n        (\"precnappro\", (0, 0)),\n        (\"Cci\", (0, 0)),\n        (\"ome\", (0, 0)),\n        (\"blk12\", (0, 0)),\n        (\"yf\", (0, 0)),\n        (\"plust\", (0, 0)),\n        (\"LeftDoubleBr\", (0, 0)),\n        (\"angrtv\", (0, 0)),\n        (\"cupor\", (0, 0)),\n        (\"gvnE\", (0, 0)),\n        (\"LessSlan\", (0, 0)),\n        (\"triangle\", (0, 0)),\n        (\"Lsh;\", (8624, 0)),\n        (\"ecir;\", (8790, 0)),\n        (\"NotPrecedes;\", (8832, 0)),\n        (\"Y\", (0, 0)),\n        (\"edo\", (0, 0)),\n        (\"PlusMin\", (0, 0)),\n        (\"DoubleLongL\", (0, 0)),\n        (\"racu\", (0, 0)),\n        (\"SHCH\", (0, 0)),\n        (\"Rrightar\", (0, 0)),\n        (\"u\", (0, 0)),\n        (\"cur\", (0, 0)),\n        (\"Copr\", (0, 0)),\n        (\"llh\", (0, 0)),\n        (\"NotCupC\", (0, 0)),\n        (\"Vee\", (0, 0)),\n        (\"lsquor\", (0, 0)),\n        (\"sop\", (0, 0)),\n        (\"nese\", (0, 0)),\n        (\"shar\", (0, 0)),\n        (\"hc\", (0, 0)),\n        (\"har\", (0, 0)),\n        (\"RuleDe\", (0, 0)),\n        (\"RightVec\", (0, 0)),\n        (\"bbrktb\", (0, 0)),\n        (\"boxDR;\", (9556, 0)),\n        (\"Lfr\", (0, 0)),\n        (\"Zfr;\", (8488, 0)),\n        (\"it\", (0, 0)),\n        (\"expectation;\", (8496, 0)),\n        (\"Lstro\", (0, 0)),\n        (\"sol;\", (47, 0)),\n        (\"ShortLef\", (0, 0)),\n        (\"tel\", (0, 0)),\n        (\"mul\", (0, 0)),\n        (\"uac\", (0, 0)),\n        (\"dblac;\", (733, 0)),\n        (\"Esim\", (0, 0)),\n        (\"nappr\", (0, 0)),\n        (\"ulcorn;\", (8988, 0)),\n        (\"lotimes;\", (10804, 0)),\n        (\"SucceedsEq\", (0, 0)),\n        (\"nti\", (0, 0)),\n        (\"ffl\", (0, 0)),\n        (\"beth;\", (8502, 0)),\n        (\"circledas\", (0, 0)),\n        (\"nVda\", (0, 0)),\n        (\"udh\", (0, 0)),\n        (\"ET\", (0, 0)),\n        (\"luru\", (0, 0)),\n        (\"fp\", (0, 0)),\n        (\"simne\", (0, 0)),\n        (\"NotCongruent;\", (8802, 0)),\n        (\"less\", (0, 0)),\n        (\"thetav;\", (977, 0)),\n        (\"lopar;\", (10629, 0)),\n        (\"zeetrf;\", (8488, 0)),\n        (\"uwang\", (0, 0)),\n        (\"nearhk;\", (10532, 0)),\n        (\"rect\", (0, 0)),\n        (\"IJlig;\", (306, 0)),\n        (\"mscr\", (0, 0)),\n        (\"crarr;\", (8629, 0)),\n        (\"vartriangler\", (0, 0)),\n        (\"tcy\", (0, 0)),\n        (\"varpr\", (0, 0)),\n        (\"InvisibleTimes;\", (8290, 0)),\n        (\"urtri;\", (9721, 0)),\n        (\"Hci\", (0, 0)),\n        (\"UpEq\", (0, 0)),\n        (\"LeftVectorB\", (0, 0)),\n        (\"rmoustache;\", (9137, 0)),\n        (\"ngeqsla\", (0, 0)),\n        (\"NotEqual;\", (8800, 0)),\n        (\"imac\", (0, 0)),\n        (\"quater\", (0, 0)),\n        (\"Tf\", (0, 0)),\n        (\"nvge\", (0, 0)),\n        (\"LeftUpTeeV\", (0, 0)),\n        (\"fallingd\", (0, 0)),\n        (\"Zs\", (0, 0)),\n        (\"Fouriertr\", (0, 0)),\n        (\"lessdot\", (0, 0)),\n        (\"Ec\", (0, 0)),\n        (\"nsce;\", (10928, 824)),\n        (\"tcaron;\", (357, 0)),\n        (\"seAr\", (0, 0)),\n        (\"agra\", (0, 0)),\n        (\"GreaterGreater\", (0, 0)),\n        (\"ug\", (0, 0)),\n        (\"NotSucceedsTilde\", (0, 0)),\n        (\"UpAr\", (0, 0)),\n        (\"hopf;\", (120153, 0)),\n        (\"NotLessSl\", (0, 0)),\n        (\"iinfin;\", (10716, 0)),\n        (\"dlcro\", (0, 0)),\n        (\"bet\", (0, 0)),\n        (\"cir;\", (9675, 0)),\n        (\"iacute\", (237, 0)),\n        (\"gtl\", (0, 0)),\n        (\"olcross;\", (10683, 0)),\n        (\"Non\", (0, 0)),\n        (\"impe\", (0, 0)),\n        (\"Exponential\", (0, 0)),\n        (\"VeryThinSpace\", (0, 0)),\n        (\"CloseCurlyD\", (0, 0)),\n        (\"ef\", (0, 0)),\n        (\"Conin\", (0, 0)),\n        (\"za\", (0, 0)),\n        (\"DoubleLongLeftArrow;\", (10232, 0)),\n        (\"dsol\", (0, 0)),\n        (\"ra\", (0, 0)),\n        (\"hellip;\", (8230, 0)),\n        (\"loz;\", (9674, 0)),\n        (\"Cayleys\", (0, 0)),\n        (\"RightDownTeeVe\", (0, 0)),\n        (\"Si\", (0, 0)),\n        (\"ohbar;\", (10677, 0)),\n        (\"U\", (0, 0)),\n        (\"trit\", (0, 0)),\n        (\"pl\", (0, 0)),\n        (\"timesd\", (0, 0)),\n        (\"nless;\", (8814, 0)),\n        (\"sqsupseteq;\", (8850, 0)),\n        (\"Vda\", (0, 0)),\n        (\"SquareSupersetEqual\", (0, 0)),\n        (\"ShortDownArrow\", (0, 0)),\n        (\"Edo\", (0, 0)),\n        (\"DownRightTeeVector;\", (10591, 0)),\n        (\"CounterClockwiseContourInteg\", (0, 0)),\n        (\"lap;\", (10885, 0)),\n        (\"SquareSuperset\", (0, 0)),\n        (\"Lower\", (0, 0)),\n        (\"check\", (0, 0)),\n        (\"Ca\", (0, 0)),\n        (\"looparrowright;\", (8620, 0)),\n        (\"CapitalDif\", (0, 0)),\n        (\"ncongdot\", (0, 0)),\n        (\"ub\", (0, 0)),\n        (\"nwa\", (0, 0)),\n        (\"Mellintr\", (0, 0)),\n        (\"elinters\", (0, 0)),\n        (\"lessappr\", (0, 0)),\n        (\"perm\", (0, 0)),\n        (\"Succeed\", (0, 0)),\n        (\"odsold;\", (10684, 0)),\n        (\"Ep\", (0, 0)),\n        (\"DZc\", (0, 0)),\n        (\"wei\", (0, 0)),\n        (\"Cong\", (0, 0)),\n        (\"preccurlye\", (0, 0)),\n        (\"nparallel;\", (8742, 0)),\n        (\"NotLeftTriangleBar;\", (10703, 824)),\n        (\"Pfr;\", (120083, 0)),\n        (\"GreaterGreater;\", (10914, 0)),\n        (\"Odblac\", (0, 0)),\n        (\"xd\", (0, 0)),\n        (\"puncsp\", (0, 0)),\n        (\"ntrianglelef\", (0, 0)),\n        (\"gtcc;\", (10919, 0)),\n        (\"scnE\", (0, 0)),\n        (\"osc\", (0, 0)),\n        (\"rAarr\", (0, 0)),\n        (\"boxdr;\", (9484, 0)),\n        (\"rarrsi\", (0, 0)),\n        (\"Sacute\", (0, 0)),\n        (\"NegativeThinSpace\", (0, 0)),\n        (\"Nega\", (0, 0)),\n        (\"LeftArrowRightArrow;\", (8646, 0)),\n        (\"ecaron;\", (283, 0)),\n        (\"Les\", (0, 0)),\n        (\"sim;\", (8764, 0)),\n        (\"bot;\", (8869, 0)),\n        (\"ShortRightArr\", (0, 0)),\n        (\"blacktrianglerigh\", (0, 0)),\n        (\"zsc\", (0, 0)),\n        (\"expone\", (0, 0)),\n        (\"NotLessL\", (0, 0)),\n        (\"ors\", (0, 0)),\n        (\"bNot;\", (10989, 0)),\n        (\"Upper\", (0, 0)),\n        (\"Le\", (0, 0)),\n        (\"gtrapprox\", (0, 0)),\n        (\"tprime\", (0, 0)),\n        (\"veeb\", (0, 0)),\n        (\"nvinf\", (0, 0)),\n        (\"ffi\", (0, 0)),\n        (\"Dagger\", (0, 0)),\n        (\"Kscr\", (0, 0)),\n        (\"vartr\", (0, 0)),\n        (\"smeparsl\", (0, 0)),\n        (\"star\", (0, 0)),\n        (\"rightsqu\", (0, 0)),\n        (\"die;\", (168, 0)),\n        (\"Pop\", (0, 0)),\n        (\"divon\", (0, 0)),\n        (\"nle;\", (8816, 0)),\n        (\"larrsi\", (0, 0)),\n        (\"nequ\", (0, 0)),\n        (\"rightleftarrows\", (0, 0)),\n        (\"q\", (0, 0)),\n        (\"Abreve;\", (258, 0)),\n        (\"dop\", (0, 0)),\n        (\"longlefta\", (0, 0)),\n        (\"LeftRi\", (0, 0)),\n        (\"bulle\", (0, 0)),\n        (\"nvrtri\", (0, 0)),\n        (\"Mopf;\", (120132, 0)),\n        (\"hcirc;\", (293, 0)),\n        (\"incar\", (0, 0)),\n        (\"RightTrian\", (0, 0)),\n        (\"precne\", (0, 0)),\n        (\"target;\", (8982, 0)),\n        (\"Ocirc;\", (212, 0)),\n        (\"ama\", (0, 0)),\n        (\"prcue\", (0, 0)),\n        (\"uHar\", (0, 0)),\n        (\"IJ\", (0, 0)),\n        (\"lsimg;\", (10895, 0)),\n        (\"simeq;\", (8771, 0)),\n        (\"TS\", (0, 0)),\n        (\"solbar\", (0, 0)),\n        (\"rarrsim\", (0, 0)),\n        (\"asym\", (0, 0)),\n        (\"ggg;\", (8921, 0)),\n        (\"raempty\", (0, 0)),\n        (\"hookrightarr\", (0, 0)),\n        (\"bow\", (0, 0)),\n        (\"CircleMinu\", (0, 0)),\n        (\"nshortpara\", (0, 0)),\n        (\"nrightar\", (0, 0)),\n        (\"straigh\", (0, 0)),\n        (\"DoubleLeftRightArrow;\", (8660, 0)),\n        (\"gesdo\", (0, 0)),\n        (\"bbrkt\", (0, 0)),\n        (\"DoubleRightTee;\", (8872, 0)),\n        (\"rrar\", (0, 0)),\n        (\"SquareUnion;\", (8852, 0)),\n        (\"NotGreaterGre\", (0, 0)),\n        (\"sqcap;\", (8851, 0)),\n        (\"DotEqua\", (0, 0)),\n        (\"RightArr\", (0, 0)),\n        (\"Ju\", (0, 0)),\n        (\"sqsupseteq\", (0, 0)),\n        (\"ltrPa\", (0, 0)),\n        (\"NotSquareSuper\", (0, 0)),\n        (\"orv;\", (10843, 0)),\n        (\"varsigma\", (0, 0)),\n        (\"andslop\", (0, 0)),\n        (\"nwarrow;\", (8598, 0)),\n        (\"CloseCurl\", (0, 0)),\n        (\"copf\", (0, 0)),\n        (\"UpDown\", (0, 0)),\n        (\"bk\", (0, 0)),\n        (\"Pro\", (0, 0)),\n        (\"NegativeVeryThinSpace\", (0, 0)),\n        (\"tripl\", (0, 0)),\n        (\"frac14\", (188, 0)),\n        (\"Lambd\", (0, 0)),\n        (\"Jcirc;\", (308, 0)),\n        (\"npo\", (0, 0)),\n        (\"yfr\", (0, 0)),\n        (\"DoubleU\", (0, 0)),\n        (\"mstp\", (0, 0)),\n        (\"Rightarr\", (0, 0)),\n        (\"que\", (0, 0)),\n        (\"divide\", (247, 0)),\n        (\"Cced\", (0, 0)),\n        (\"bNo\", (0, 0)),\n        (\"swnwar\", (0, 0)),\n        (\"dlcor\", (0, 0)),\n        (\"time\", (0, 0)),\n        (\"thk\", (0, 0)),\n        (\"ltcir\", (0, 0)),\n        (\"sup3\", (179, 0)),\n        (\"Ncaron\", (0, 0)),\n        (\"Therefore;\", (8756, 0)),\n        (\"CloseCurlyQuo\", (0, 0)),\n        (\"NotSubset;\", (8834, 8402)),\n        (\"ruluhar\", (0, 0)),\n        (\"blk1\", (0, 0)),\n        (\"lcub\", (0, 0)),\n        (\"period;\", (46, 0)),\n        (\"vzigz\", (0, 0)),\n        (\"tos\", (0, 0)),\n        (\"nwn\", (0, 0)),\n        (\"Id\", (0, 0)),\n        (\"ddots\", (0, 0)),\n        (\"eqvpa\", (0, 0)),\n        (\"intprod\", (0, 0)),\n        (\"scna\", (0, 0)),\n        (\"Medium\", (0, 0)),\n        (\"ffr\", (0, 0)),\n        (\"ii;\", (8520, 0)),\n        (\"CounterClockwiseCont\", (0, 0)),\n        (\"boxur;\", (9492, 0)),\n        (\"colo\", (0, 0)),\n        (\"trianglerig\", (0, 0)),\n        (\"latai\", (0, 0)),\n        (\"IEc\", (0, 0)),\n        (\"awco\", (0, 0)),\n        (\"rightharpoondown\", (0, 0)),\n        (\"shortmid\", (0, 0)),\n        (\"LeftUpTeeVecto\", (0, 0)),\n        (\"Longleftrigh\", (0, 0)),\n        (\"Tcar\", (0, 0)),\n        (\"LeftUpDo\", (0, 0)),\n        (\"checkmark\", (0, 0)),\n        (\"Rarr;\", (8608, 0)),\n        (\"isindot;\", (8949, 0)),\n        (\"Rac\", (0, 0)),\n        (\"solba\", (0, 0)),\n        (\"dda\", (0, 0)),\n        (\"sc\", (0, 0)),\n        (\"infin;\", (8734, 0)),\n        (\"npr\", (0, 0)),\n        (\"prnE\", (0, 0)),\n        (\"NotRightT\", (0, 0)),\n        (\"NegativeMediumSpace;\", (8203, 0)),\n        (\"alpha;\", (945, 0)),\n        (\"Ccaro\", (0, 0)),\n        (\"NotTildeTilde;\", (8777, 0)),\n        (\"rca\", (0, 0)),\n        (\"geqslant;\", (10878, 0)),\n        (\"bsolh\", (0, 0)),\n        (\"mapstodo\", (0, 0)),\n        (\"NotLessGrea\", (0, 0)),\n        (\"RightAngleBr\", (0, 0)),\n        (\"middo\", (0, 0)),\n        (\"lcaron;\", (318, 0)),\n        (\"supedo\", (0, 0)),\n        (\"iogon\", (0, 0)),\n        (\"GreaterTilde\", (0, 0)),\n        (\"PrecedesSlant\", (0, 0)),\n        (\"HA\", (0, 0)),\n        (\"leftrighta\", (0, 0)),\n        (\"boxdl\", (0, 0)),\n        (\"NotN\", (0, 0)),\n        (\"LeftVectorBa\", (0, 0)),\n        (\"Cacute;\", (262, 0)),\n        (\"ae\", (0, 0)),\n        (\"suped\", (0, 0)),\n        (\"infi\", (0, 0)),\n        (\"Esi\", (0, 0)),\n        (\"gnapprox\", (0, 0)),\n        (\"uha\", (0, 0)),\n        (\"Br\", (0, 0)),\n        (\"divideontimes\", (0, 0)),\n        (\"heartsui\", (0, 0)),\n        (\"Dc\", (0, 0)),\n        (\"boxvr\", (0, 0)),\n        (\"EmptyS\", (0, 0)),\n        (\"cirscir;\", (10690, 0)),\n        (\"egsd\", (0, 0)),\n        (\"hookleft\", (0, 0)),\n        (\"nvr\", (0, 0)),\n        (\"lne\", (0, 0)),\n        (\"ati\", (0, 0)),\n        (\"NotTildeEqual\", (0, 0)),\n        (\"NotSucceeds\", (0, 0)),\n        (\"LeftDownVector\", (0, 0)),\n        (\"Ffr;\", (120073, 0)),\n        (\"Sfr;\", (120086, 0)),\n        (\"eng;\", (331, 0)),\n        (\"lurdshar;\", (10570, 0)),\n        (\"NotVer\", (0, 0)),\n        (\"frac78\", (0, 0)),\n        (\"LeftUpTeeVector\", (0, 0)),\n        (\"longleftrightarro\", (0, 0)),\n        (\"nleftarr\", (0, 0)),\n        (\"Thick\", (0, 0)),\n        (\"Llefta\", (0, 0)),\n        (\"VerticalSepa\", (0, 0)),\n        (\"Sq\", (0, 0)),\n        (\"TRADE;\", (8482, 0)),\n        (\"Diamon\", (0, 0)),\n        (\"ell;\", (8467, 0)),\n        (\"Cop\", (0, 0)),\n        (\"Zfr\", (0, 0)),\n        (\"succsim;\", (8831, 0)),\n        (\"NonBrea\", (0, 0)),\n        (\"Rcaron;\", (344, 0)),\n        (\"rth\", (0, 0)),\n        (\"nparalle\", (0, 0)),\n        (\"Wcirc;\", (372, 0)),\n        (\"jukcy\", (0, 0)),\n        (\"dwang\", (0, 0)),\n        (\"SuchTha\", (0, 0)),\n        (\"varsubset\", (0, 0)),\n        (\"Vfr;\", (120089, 0)),\n        (\"nsubse\", (0, 0)),\n        (\"hop\", (0, 0)),\n        (\"multimap\", (0, 0)),\n        (\"nvd\", (0, 0)),\n        (\"NotLeftTri\", (0, 0)),\n        (\"curvearrowl\", (0, 0)),\n        (\"tilde\", (0, 0)),\n        (\"zacu\", (0, 0)),\n        (\"zcy\", (0, 0)),\n        (\"PrecedesTilde\", (0, 0)),\n        (\"DoubleLeftR\", (0, 0)),\n        (\"Larr;\", (8606, 0)),\n        (\"Ss\", (0, 0)),\n        (\"zacut\", (0, 0)),\n        (\"Poincarepla\", (0, 0)),\n        (\"urcorn;\", (8989, 0)),\n        (\"boxUl\", (0, 0)),\n        (\"Rc\", (0, 0)),\n        (\"lbarr\", (0, 0)),\n        (\"vartriangleright\", (0, 0)),\n        (\"eqcolon\", (0, 0)),\n        (\"CapitalDiffe\", (0, 0)),\n        (\"subsetneqq;\", (10955, 0)),\n        (\"Dcaro\", (0, 0)),\n        (\"ldsh;\", (8626, 0)),\n        (\"ccup\", (0, 0)),\n        (\"CircleTimes;\", (8855, 0)),\n        (\"coprod;\", (8720, 0)),\n        (\"RightDownVec\", (0, 0)),\n        (\"SquareSup\", (0, 0)),\n        (\"nprc\", (0, 0)),\n        (\"sr\", (0, 0)),\n        (\"rea\", (0, 0)),\n        (\"LeftUpTeeVector;\", (10592, 0)),\n        (\"midci\", (0, 0)),\n        (\"upl\", (0, 0)),\n        (\"DoubleContourIntegral;\", (8751, 0)),\n        (\"RightDownVectorBa\", (0, 0)),\n        (\"Zcy\", (0, 0)),\n        (\"NotSquareSupersetE\", (0, 0)),\n        (\"UpA\", (0, 0)),\n        (\"circlearro\", (0, 0)),\n        (\"gescc;\", (10921, 0)),\n        (\"dtrif;\", (9662, 0)),\n        (\"Ig\", (0, 0)),\n        (\"NotGreaterSlantEqual;\", (10878, 824)),\n        (\"die\", (0, 0)),\n        (\"NotSupersetE\", (0, 0)),\n        (\"dollar\", (0, 0)),\n        (\"tritime;\", (10811, 0)),\n        (\"digamma\", (0, 0)),\n        (\"CapitalDifferen\", (0, 0)),\n        (\"ffili\", (0, 0)),\n        (\"scedil;\", (351, 0)),\n        (\"delt\", (0, 0)),\n        (\"sqsupe\", (0, 0)),\n        (\"nc\", (0, 0)),\n        (\"NotSucceedsEqu\", (0, 0)),\n        (\"NoBreak;\", (8288, 0)),\n        (\"NegativeVeryThinSp\", (0, 0)),\n        (\"ShortLeftArr\", (0, 0)),\n        (\"SOF\", (0, 0)),\n        (\"egr\", (0, 0)),\n        (\"CHc\", (0, 0)),\n        (\"NestedLessLess\", (0, 0)),\n        (\"leftr\", (0, 0)),\n        (\"SucceedsTilde\", (0, 0)),\n        (\"Square\", (0, 0)),\n        (\"Oo\", (0, 0)),\n        (\"d\", (0, 0)),\n        (\"varsupsetneqq\", (0, 0)),\n        (\"varsi\", (0, 0)),\n        (\"nlE;\", (8806, 824)),\n        (\"Lm\", (0, 0)),\n        (\"rtriltri;\", (10702, 0)),\n        (\"dfisht;\", (10623, 0)),\n        (\"DoubleRightTee\", (0, 0)),\n        (\"ltcc\", (0, 0)),\n        (\"triti\", (0, 0)),\n        (\"loa\", (0, 0)),\n        (\"Dscr\", (0, 0)),\n        (\"rtriltr\", (0, 0)),\n        (\"nRightarr\", (0, 0)),\n        (\"ngsi\", (0, 0)),\n        (\"curlyeqsucc;\", (8927, 0)),\n        (\"horbar;\", (8213, 0)),\n        (\"Kcy;\", (1050, 0)),\n        (\"LeftUpVectorBar\", (0, 0)),\n        (\"DoubleVerticalB\", (0, 0)),\n        (\"subdot\", (0, 0)),\n        (\"fro\", (0, 0)),\n        (\"ThinSpac\", (0, 0)),\n        (\"Ograve\", (210, 0)),\n        (\"lti\", (0, 0)),\n        (\"copy;\", (169, 0)),\n        (\"cro\", (0, 0)),\n        (\"DoubleVertic\", (0, 0)),\n        (\"prnsim;\", (8936, 0)),\n        (\"kj\", (0, 0)),\n        (\"lsqu\", (0, 0)),\n        (\"Igrave;\", (204, 0)),\n        (\"DoubleRightT\", (0, 0)),\n        (\"Alpha;\", (913, 0)),\n        (\"Lan\", (0, 0)),\n        (\"llcorner\", (0, 0)),\n        (\"risingdotseq\", (0, 0)),\n        (\"olcro\", (0, 0)),\n        (\"MinusPlu\", (0, 0)),\n        (\"gtdot\", (0, 0)),\n        (\"bsolhs\", (0, 0)),\n        (\"hb\", (0, 0)),\n        (\"hkswarow;\", (10534, 0)),\n        (\"dbkaro\", (0, 0)),\n        (\"SquareSubsetEqu\", (0, 0)),\n        (\"lmous\", (0, 0)),\n        (\"AM\", (0, 0)),\n        (\"tpri\", (0, 0)),\n        (\"ofr\", (0, 0)),\n        (\"ZHcy;\", (1046, 0)),\n        (\"equiv\", (0, 0)),\n        (\"EmptyVe\", (0, 0)),\n        (\"eqslantless;\", (10901, 0)),\n        (\"upharpoonrigh\", (0, 0)),\n        (\"eng\", (0, 0)),\n        (\"Lo\", (0, 0)),\n        (\"Invisi\", (0, 0)),\n        (\"larrhk\", (0, 0)),\n        (\"nbumpe;\", (8783, 824)),\n        (\"nshortparalle\", (0, 0)),\n        (\"lsaquo;\", (8249, 0)),\n        (\"nLeftrig\", (0, 0)),\n        (\"omi\", (0, 0)),\n        (\"lu\", (0, 0)),\n        (\"Cedi\", (0, 0)),\n        (\"bnot;\", (8976, 0)),\n        (\"Dca\", (0, 0)),\n        (\"xcap;\", (8898, 0)),\n        (\"ca\", (0, 0)),\n        (\"fpa\", (0, 0)),\n        (\"UpDownArro\", (0, 0)),\n        (\"NotTildeFullEqual;\", (8775, 0)),\n        (\"Pa\", (0, 0)),\n        (\"iiint\", (0, 0)),\n        (\"plankv\", (0, 0)),\n        (\"curr\", (0, 0)),\n        (\"shc\", (0, 0)),\n        (\"At\", (0, 0)),\n        (\"plusmn\", (177, 0)),\n        (\"lates\", (0, 0)),\n        (\"cent;\", (162, 0)),\n        (\"dbka\", (0, 0)),\n        (\"Sum\", (0, 0)),\n        (\"NotCo\", (0, 0)),\n        (\"lurdsh\", (0, 0)),\n        (\"nhAr\", (0, 0)),\n        (\"UnderBa\", (0, 0)),\n        (\"vsubn\", (0, 0)),\n        (\"rdsh;\", (8627, 0)),\n        (\"leftth\", (0, 0)),\n        (\"SubsetEqual\", (0, 0)),\n        (\"EqualTilde;\", (8770, 0)),\n        (\"lnE;\", (8808, 0)),\n        (\"dou\", (0, 0)),\n        (\"telre\", (0, 0)),\n        (\"DownArrowB\", (0, 0)),\n        (\"nsccu\", (0, 0)),\n        (\"Colon;\", (8759, 0)),\n        (\"bac\", (0, 0)),\n        (\"UpperRi\", (0, 0)),\n        (\"longleftrigh\", (0, 0)),\n        (\"Eta;\", (919, 0)),\n        (\"NotNestedGre\", (0, 0)),\n        (\"Nopf\", (0, 0)),\n        (\"Upar\", (0, 0)),\n        (\"circleddas\", (0, 0)),\n        (\"rcaron;\", (345, 0)),\n        (\"ApplyF\", (0, 0)),\n        (\"djcy;\", (1106, 0)),\n        (\"succnsi\", (0, 0)),\n        (\"xra\", (0, 0)),\n        (\"frac3\", (0, 0)),\n        (\"succneq\", (0, 0)),\n        (\"eqsla\", (0, 0)),\n        (\"NotNestedG\", (0, 0)),\n        (\"upsi;\", (965, 0)),\n        (\"CounterClockwiseContourIntegr\", (0, 0)),\n        (\"subdo\", (0, 0)),\n        (\"Leftright\", (0, 0)),\n        (\"GreaterEqua\", (0, 0)),\n        (\"Lsh\", (0, 0)),\n        (\"itilde\", (0, 0)),\n        (\"SmallCircle;\", (8728, 0)),\n        (\"diamond\", (0, 0)),\n        (\"ApplyFunction;\", (8289, 0)),\n        (\"iiota;\", (8489, 0)),\n        (\"upharpo\", (0, 0)),\n        (\"ContourIntegral\", (0, 0)),\n        (\"ffilig;\", (64259, 0)),\n        (\"NotEqualTi\", (0, 0)),\n        (\"gvertneq\", (0, 0)),\n        (\"NotPre\", (0, 0)),\n        (\"fflig\", (0, 0)),\n        (\"varsubsetneq;\", (8842, 65024)),\n        (\"NotSquareSup\", (0, 0)),\n        (\"models\", (0, 0)),\n        (\"nLefta\", (0, 0)),\n        (\"drbkarow\", (0, 0)),\n        (\"DoubleUpDownArr\", (0, 0)),\n        (\"xcirc\", (0, 0)),\n        (\"empty\", (0, 0)),\n        (\"CounterClockw\", (0, 0)),\n        (\"quatint;\", (10774, 0)),\n        (\"LeftDou\", (0, 0)),\n        (\"LeftTeeVecto\", (0, 0)),\n        (\"dotsquare;\", (8865, 0)),\n        (\"bernou\", (0, 0)),\n        (\"Omicro\", (0, 0)),\n        (\"colone\", (0, 0)),\n        (\"xh\", (0, 0)),\n        (\"varnothin\", (0, 0)),\n        (\"pound;\", (163, 0)),\n        (\"gtc\", (0, 0)),\n        (\"LowerLeftA\", (0, 0)),\n        (\"xoplu\", (0, 0)),\n        (\"geqsla\", (0, 0)),\n        (\"uogo\", (0, 0)),\n        (\"epar\", (0, 0)),\n        (\"cacut\", (0, 0)),\n        (\"apos\", (0, 0)),\n        (\"xdtri;\", (9661, 0)),\n        (\"CupCap\", (0, 0)),\n        (\"iti\", (0, 0)),\n        (\"Breve\", (0, 0)),\n        (\"utilde\", (0, 0)),\n        (\"Ycirc\", (0, 0)),\n        (\"Rcy;\", (1056, 0)),\n        (\"NotSubse\", (0, 0)),\n        (\"napE;\", (10864, 824)),\n        (\"lat\", (0, 0)),\n        (\"UpDownArrow;\", (8597, 0)),\n        (\"pluse\", (0, 0)),\n        (\"ShortDow\", (0, 0)),\n        (\"OverBracke\", (0, 0)),\n        (\"vprop\", (0, 0)),\n        (\"flt\", (0, 0)),\n        (\"Rf\", (0, 0)),\n        (\"lbr\", (0, 0)),\n        (\"DoubleRightTe\", (0, 0)),\n        (\"conint\", (0, 0)),\n        (\"SucceedsSlantEqual;\", (8829, 0)),\n        (\"DownArrow;\", (8595, 0)),\n        (\"LessGreat\", (0, 0)),\n        (\"Ru\", (0, 0)),\n        (\"exis\", (0, 0)),\n        (\"csub;\", (10959, 0)),\n        (\"lcaron\", (0, 0)),\n        (\"ntrianglel\", (0, 0)),\n        (\"ip\", (0, 0)),\n        (\"Aopf;\", (120120, 0)),\n        (\"Phi\", (0, 0)),\n        (\"TildeTild\", (0, 0)),\n        (\"rightright\", (0, 0)),\n        (\"ffr;\", (120099, 0)),\n        (\"ograve\", (242, 0)),\n        (\"cacute;\", (263, 0)),\n        (\"NotVert\", (0, 0)),\n        (\"scedi\", (0, 0)),\n        (\"succcurlyeq\", (0, 0)),\n        (\"Bs\", (0, 0)),\n        (\"weierp\", (0, 0)),\n        (\"lesss\", (0, 0)),\n        (\"backc\", (0, 0)),\n        (\"rpar;\", (41, 0)),\n        (\"LeftFloor\", (0, 0)),\n        (\"yic\", (0, 0)),\n        (\"Omacr;\", (332, 0)),\n        (\"nabla;\", (8711, 0)),\n        (\"gne;\", (10888, 0)),\n        (\"nvDas\", (0, 0)),\n        (\"reg;\", (174, 0)),\n        (\"CounterClockwiseContourI\", (0, 0)),\n        (\"geqsl\", (0, 0)),\n        (\"lobrk;\", (10214, 0)),\n        (\"oslas\", (0, 0)),\n        (\"Ds\", (0, 0)),\n        (\"Odbla\", (0, 0)),\n        (\"bigstar\", (0, 0)),\n        (\"olc\", (0, 0)),\n        (\"perte\", (0, 0)),\n        (\"dotp\", (0, 0)),\n        (\"DoubleUpArro\", (0, 0)),\n        (\"gtrdot;\", (8919, 0)),\n        (\"Jscr;\", (119973, 0)),\n        (\"tcedil\", (0, 0)),\n        (\"Mel\", (0, 0)),\n        (\"gtrapprox;\", (10886, 0)),\n        (\"dotmi\", (0, 0)),\n        (\"harrw\", (0, 0)),\n        (\"ntg\", (0, 0)),\n        (\"EmptySmall\", (0, 0)),\n        (\"CapitalD\", (0, 0)),\n        (\"cudarr\", (0, 0)),\n        (\"lvert\", (0, 0)),\n        (\"subdot;\", (10941, 0)),\n        (\"sup3;\", (179, 0)),\n        (\"minu\", (0, 0)),\n        (\"yicy\", (0, 0)),\n        (\"boxVr;\", (9567, 0)),\n        (\"Ncar\", (0, 0)),\n        (\"otild\", (0, 0)),\n        (\"RightTriangl\", (0, 0)),\n        (\"UpperRightArrow\", (0, 0)),\n        (\"subedo\", (0, 0)),\n        (\"dr\", (0, 0)),\n        (\"GreaterFullEqual;\", (8807, 0)),\n        (\"RightAngleBrack\", (0, 0)),\n        (\"we\", (0, 0)),\n        (\"DiacriticalGrave\", (0, 0)),\n        (\"Oscr;\", (119978, 0)),\n        (\"zigrarr;\", (8669, 0)),\n        (\"Eci\", (0, 0)),\n        (\"LeftTriangleBar\", (0, 0)),\n        (\"lozf\", (0, 0)),\n        (\"Ns\", (0, 0)),\n        (\"omeg\", (0, 0)),\n        (\"sime;\", (8771, 0)),\n        (\"gtrless;\", (8823, 0)),\n        (\"Cen\", (0, 0)),\n        (\"Ia\", (0, 0)),\n        (\"mnplu\", (0, 0)),\n        (\"lae\", (0, 0)),\n        (\"primes;\", (8473, 0)),\n        (\"acd\", (0, 0)),\n        (\"NotNeste\", (0, 0)),\n        (\"nhArr\", (0, 0)),\n        (\"ltcir;\", (10873, 0)),\n        (\"thinsp;\", (8201, 0)),\n        (\"lt\", (60, 0)),\n        (\"ApplyFunct\", (0, 0)),\n        (\"nsubseteq;\", (8840, 0)),\n        (\"lesssim;\", (8818, 0)),\n        (\"dstro\", (0, 0)),\n        (\"Tab\", (0, 0)),\n        (\"circlearrowle\", (0, 0)),\n        (\"LessLes\", (0, 0)),\n        (\"Squa\", (0, 0)),\n        (\"Topf\", (0, 0)),\n        (\"eqvpars\", (0, 0)),\n        (\"UnderBrac\", (0, 0)),\n        (\"quaterni\", (0, 0)),\n        (\"curlye\", (0, 0)),\n        (\"dagg\", (0, 0)),\n        (\"profalar;\", (9006, 0)),\n        (\"frac15;\", (8533, 0)),\n        (\"Longrightarrow\", (0, 0)),\n        (\"bigsqcup;\", (10758, 0)),\n        (\"Uppe\", (0, 0)),\n        (\"GreaterSlan\", (0, 0)),\n        (\"Lleftar\", (0, 0)),\n        (\"trpe\", (0, 0)),\n        (\"SucceedsEqual;\", (10928, 0)),\n        (\"NegativeMediumSpace\", (0, 0)),\n        (\"wedba\", (0, 0)),\n        (\"leftle\", (0, 0)),\n        (\"RightVector\", (0, 0)),\n        (\"bsol;\", (92, 0)),\n        (\"Acy\", (0, 0)),\n        (\"dzigrarr;\", (10239, 0)),\n        (\"double\", (0, 0)),\n        (\"SquareIn\", (0, 0)),\n        (\"emsp\", (0, 0)),\n        (\"thetasym;\", (977, 0)),\n        (\"Xop\", (0, 0)),\n        (\"cwi\", (0, 0)),\n        (\"Mcy\", (0, 0)),\n        (\"ltcc;\", (10918, 0)),\n        (\"vsubne;\", (8842, 65024)),\n        (\"cfr;\", (120096, 0)),\n        (\"thorn;\", (254, 0)),\n        (\"Lar\", (0, 0)),\n        (\"fllig;\", (64258, 0)),\n        (\"foral\", (0, 0)),\n        (\"boxvh\", (0, 0)),\n        (\"boxdl;\", (9488, 0)),\n        (\"DoubleContourInt\", (0, 0)),\n        (\"GJcy;\", (1027, 0)),\n        (\"shchcy\", (0, 0)),\n        (\"Uopf\", (0, 0)),\n        (\"ze\", (0, 0)),\n        (\"at\", (0, 0)),\n        (\"model\", (0, 0)),\n        (\"uharl\", (0, 0)),\n        (\"prec\", (0, 0)),\n        (\"UnderParenth\", (0, 0)),\n        (\"NotSucceedsSlantEqual\", (0, 0)),\n        (\"curve\", (0, 0)),\n        (\"rnmi\", (0, 0)),\n        (\"ClockwiseCon\", (0, 0)),\n        (\"Rar\", (0, 0)),\n        (\"nsubs\", (0, 0)),\n        (\"sccu\", (0, 0)),\n        (\"SucceedsSla\", (0, 0)),\n        (\"atild\", (0, 0)),\n        (\"ddotse\", (0, 0)),\n        (\"curarrm;\", (10556, 0)),\n        (\"LeftDoubleB\", (0, 0)),\n        (\"exponenti\", (0, 0)),\n        (\"apid\", (0, 0)),\n        (\"awconint;\", (8755, 0)),\n        (\"te\", (0, 0)),\n        (\"ult\", (0, 0)),\n        (\"LessT\", (0, 0)),\n        (\"uarr\", (0, 0)),\n        (\"Jfr\", (0, 0)),\n        (\"radic\", (0, 0)),\n        (\"NotLeftTriang\", (0, 0)),\n        (\"intprod;\", (10812, 0)),\n        (\"xf\", (0, 0)),\n        (\"GreaterSlantEq\", (0, 0)),\n        (\"ngeqq;\", (8807, 824)),\n        (\"prcue;\", (8828, 0)),\n        (\"bigwedg\", (0, 0)),\n        (\"dH\", (0, 0)),\n        (\"gesdotol;\", (10884, 0)),\n        (\"ShortDownA\", (0, 0)),\n        (\"div;\", (247, 0)),\n        (\"dfi\", (0, 0)),\n        (\"larrt\", (0, 0)),\n        (\"varrho\", (0, 0)),\n        (\"NotTildeFullE\", (0, 0)),\n        (\"intlarhk;\", (10775, 0)),\n        (\"upsi\", (0, 0)),\n        (\"dcaro\", (0, 0)),\n        (\"Gfr\", (0, 0)),\n        (\"nequiv\", (0, 0)),\n        (\"lobr\", (0, 0)),\n        (\"Euml;\", (203, 0)),\n        (\"NotCongrue\", (0, 0)),\n        (\"nG\", (0, 0)),\n        (\"vzi\", (0, 0)),\n        (\"NegativeMediumSpa\", (0, 0)),\n        (\"Plu\", (0, 0)),\n        (\"Ccaron\", (0, 0)),\n        (\"nj\", (0, 0)),\n        (\"roarr;\", (8702, 0)),\n        (\"rtril\", (0, 0)),\n        (\"nwnear\", (0, 0)),\n        (\"hksear\", (0, 0)),\n        (\"ssmile;\", (8995, 0)),\n        (\"numero\", (0, 0)),\n        (\"Kapp\", (0, 0)),\n        (\"parsim;\", (10995, 0)),\n        (\"ccupssm\", (0, 0)),\n        (\"AE\", (0, 0)),\n        (\"Nc\", (0, 0)),\n        (\"Supe\", (0, 0)),\n        (\"angrt\", (0, 0)),\n        (\"RightTriangleEq\", (0, 0)),\n        (\"DoubleLongLeftR\", (0, 0)),\n        (\"lcedi\", (0, 0)),\n        (\"in\", (0, 0)),\n        (\"rightri\", (0, 0)),\n        (\"RightFl\", (0, 0)),\n        (\"LessEqualGreater;\", (8922, 0)),\n        (\"upsih;\", (978, 0)),\n        (\"frac38\", (0, 0)),\n        (\"EmptyVeryS\", (0, 0)),\n        (\"hook\", (0, 0)),\n        (\"blk3\", (0, 0)),\n        (\"longrightarrow;\", (10230, 0)),\n        (\"NotLessGreat\", (0, 0)),\n        (\"RightArrow;\", (8594, 0)),\n        (\"EqualTilde\", (0, 0)),\n        (\"Par\", (0, 0)),\n        (\"rcaro\", (0, 0)),\n        (\"sqcups\", (0, 0)),\n        (\"comma\", (0, 0)),\n        (\"cirm\", (0, 0)),\n        (\"InvisibleCom\", (0, 0)),\n        (\"dblac\", (0, 0)),\n        (\"PrecedesSla\", (0, 0)),\n        (\"NotLe\", (0, 0)),\n        (\"xotime\", (0, 0)),\n        (\"Vdash;\", (8873, 0)),\n        (\"HumpDownHu\", (0, 0)),\n        (\"lf\", (0, 0)),\n        (\"sbq\", (0, 0)),\n        (\"succeq\", (0, 0)),\n        (\"DownLeftVector;\", (8637, 0)),\n        (\"gvertne\", (0, 0)),\n        (\"NegativeMedium\", (0, 0)),\n        (\"lesdot\", (0, 0)),\n        (\"expo\", (0, 0)),\n        (\"nldr;\", (8229, 0)),\n        (\"So\", (0, 0)),\n        (\"lobrk\", (0, 0)),\n        (\"chec\", (0, 0)),\n        (\"RightUpTe\", (0, 0)),\n        (\"xhA\", (0, 0)),\n        (\"ntrianglelefteq\", (0, 0)),\n        (\"GreaterFullE\", (0, 0)),\n        (\"SHC\", (0, 0)),\n        (\"Fouriert\", (0, 0)),\n        (\"str\", (0, 0)),\n        (\"IJli\", (0, 0)),\n        (\"imath;\", (305, 0)),\n        (\"lmoustache;\", (9136, 0)),\n        (\"minusd\", (0, 0)),\n        (\"uogon;\", (371, 0)),\n        (\"erarr;\", (10609, 0)),\n        (\"Cup\", (0, 0)),\n        (\"and\", (0, 0)),\n        (\"dbkarow;\", (10511, 0)),\n        (\"cularr\", (0, 0)),\n        (\"NJ\", (0, 0)),\n        (\"succcurlyeq;\", (8829, 0)),\n        (\"drcr\", (0, 0)),\n        (\"nlarr\", (0, 0)),\n        (\"PlusMinu\", (0, 0)),\n        (\"nacute\", (0, 0)),\n        (\"SHcy;\", (1064, 0)),\n        (\"SupersetEqual;\", (8839, 0)),\n        (\"Lleftarrow;\", (8666, 0)),\n        (\"DoubleL\", (0, 0)),\n        (\"Ecaro\", (0, 0)),\n        (\"uh\", (0, 0)),\n        (\"oast;\", (8859, 0)),\n        (\"IJl\", (0, 0)),\n        (\"sup2;\", (178, 0)),\n        (\"curvearrowleft\", (0, 0)),\n        (\"vscr;\", (120011, 0)),\n        (\"equest\", (0, 0)),\n        (\"RightVect\", (0, 0)),\n        (\"varsubsetneq\", (0, 0)),\n        (\"Yci\", (0, 0)),\n        (\"UnderPare\", (0, 0)),\n        (\"lot\", (0, 0)),\n        (\"triplu\", (0, 0)),\n        (\"Oslash;\", (216, 0)),\n        (\"Down\", (0, 0)),\n        (\"RightTeeVecto\", (0, 0)),\n        (\"dh\", (0, 0)),\n        (\"supl\", (0, 0)),\n        (\"nisd\", (0, 0)),\n        (\"nacu\", (0, 0)),\n        (\"xrArr\", (0, 0)),\n        (\"vart\", (0, 0)),\n        (\"ntri\", (0, 0)),\n        (\"frac1\", (0, 0)),\n        (\"bsi\", (0, 0)),\n        (\"ya\", (0, 0)),\n        (\"DoubleLongLeft\", (0, 0)),\n        (\"Icirc;\", (206, 0)),\n        (\"notindot;\", (8949, 824)),\n        (\"two\", (0, 0)),\n        (\"twohe\", (0, 0)),\n        (\"SupersetEqu\", (0, 0)),\n        (\"gacu\", (0, 0)),\n        (\"leftrightsquigarrow\", (0, 0)),\n        (\"ratail\", (0, 0)),\n        (\"UnionPl\", (0, 0)),\n        (\"bemp\", (0, 0)),\n        (\"notni;\", (8716, 0)),\n        (\"hellip\", (0, 0)),\n        (\"pun\", (0, 0)),\n        (\"DoubleLongLeftRightA\", (0, 0)),\n        (\"eqslantgtr\", (0, 0)),\n        (\"n\", (0, 0)),\n        (\"longmapsto\", (0, 0)),\n        (\"longrightarro\", (0, 0)),\n        (\"NotReve\", (0, 0)),\n        (\"brvbar;\", (166, 0)),\n        (\"Gt;\", (8811, 0)),\n        (\"tcedil;\", (355, 0)),\n        (\"RightFloo\", (0, 0)),\n        (\"Sup\", (0, 0)),\n        (\"Ugr\", (0, 0)),\n        (\"Esc\", (0, 0)),\n        (\"circledR;\", (174, 0)),\n        (\"hksw\", (0, 0)),\n        (\"Diacr\", (0, 0)),\n        (\"RightAngle\", (0, 0)),\n        (\"precap\", (0, 0)),\n        (\"topbot;\", (9014, 0)),\n        (\"oe\", (0, 0)),\n        (\"NotReverseEl\", (0, 0)),\n        (\"supset\", (0, 0)),\n        (\"lesg;\", (8922, 65024)),\n        (\"EmptySmallSquare\", (0, 0)),\n        (\"isc\", (0, 0)),\n        (\"tosa;\", (10537, 0)),\n        (\"EmptyV\", (0, 0)),\n        (\"yucy\", (0, 0)),\n        (\"NotRightTriangleEqual\", (0, 0)),\n        (\"InvisibleComma\", (0, 0)),\n        (\"OverParen\", (0, 0)),\n        (\"ltques\", (0, 0)),\n        (\"Otimes\", (0, 0)),\n        (\"inf\", (0, 0)),\n        (\"prime\", (0, 0)),\n        (\"dempt\", (0, 0)),\n        (\"Tau;\", (932, 0)),\n        (\"simrar\", (0, 0)),\n        (\"FilledSma\", (0, 0)),\n        (\"ia\", (0, 0)),\n        (\"qo\", (0, 0)),\n        (\"minus;\", (8722, 0)),\n        (\"NotSquareSuperse\", (0, 0)),\n        (\"gbreve\", (0, 0)),\n        (\"thickapprox;\", (8776, 0)),\n        (\"ultr\", (0, 0)),\n        (\"simeq\", (0, 0)),\n        (\"Exponen\", (0, 0)),\n        (\"nsp\", (0, 0)),\n        (\"Iopf;\", (120128, 0)),\n        (\"ocy;\", (1086, 0)),\n        (\"subed\", (0, 0)),\n        (\"drcrop;\", (8972, 0)),\n        (\"twoheadl\", (0, 0)),\n        (\"vo\", (0, 0)),\n        (\"LeftDownVe\", (0, 0)),\n        (\"Acy;\", (1040, 0)),\n        (\"Nested\", (0, 0)),\n        (\"Fc\", (0, 0)),\n        (\"Eac\", (0, 0)),\n        (\"nfr\", (0, 0)),\n        (\"subsetneq;\", (8842, 0)),\n        (\"nearr;\", (8599, 0)),\n        (\"DownLeftVecto\", (0, 0)),\n        (\"Gopf\", (0, 0)),\n        (\"thinsp\", (0, 0)),\n        (\"DownTeeA\", (0, 0)),\n        (\"Ofr;\", (120082, 0)),\n        (\"nvlt\", (0, 0)),\n        (\"circleddash\", (0, 0)),\n        (\"ldr\", (0, 0)),\n        (\"aleph\", (0, 0)),\n        (\"doub\", (0, 0)),\n        (\"nac\", (0, 0)),\n        (\"Zscr\", (0, 0)),\n        (\"LeftCei\", (0, 0)),\n        (\"LeftArrowR\", (0, 0)),\n        (\"NotGreaterGrea\", (0, 0)),\n        (\"rangl\", (0, 0)),\n        (\"NotReverseEleme\", (0, 0)),\n        (\"puncsp;\", (8200, 0)),\n        (\"lArr;\", (8656, 0)),\n        (\"hookrightarro\", (0, 0)),\n        (\"CenterDot\", (0, 0)),\n        (\"LowerLeftArrow;\", (8601, 0)),\n        (\"bsem\", (0, 0)),\n        (\"zigrarr\", (0, 0)),\n        (\"ecol\", (0, 0)),\n        (\"rA\", (0, 0)),\n        (\"xhar\", (0, 0)),\n        (\"PrecedesEq\", (0, 0)),\n        (\"Escr\", (0, 0)),\n        (\"uhblk\", (0, 0)),\n        (\"subsetn\", (0, 0)),\n        (\"ApplyFun\", (0, 0)),\n        (\"eacu\", (0, 0)),\n        (\"rightrightar\", (0, 0)),\n        (\"nda\", (0, 0)),\n        (\"GreaterTil\", (0, 0)),\n        (\"DownArrowBa\", (0, 0)),\n        (\"centerd\", (0, 0)),\n        (\"kc\", (0, 0)),\n        (\"lltri\", (0, 0)),\n        (\"DoubleUpArrow;\", (8657, 0)),\n        (\"Zcar\", (0, 0)),\n        (\"tau;\", (964, 0)),\n        (\"angmsdae\", (0, 0)),\n        (\"cupca\", (0, 0)),\n        (\"Invis\", (0, 0)),\n        (\"raquo\", (187, 0)),\n        (\"SucceedsTi\", (0, 0)),\n        (\"LessFullEqual;\", (8806, 0)),\n        (\"sqsu\", (0, 0)),\n        (\"equest;\", (8799, 0)),\n        (\"nleqsl\", (0, 0)),\n        (\"raem\", (0, 0)),\n        (\"Double\", (0, 0)),\n        (\"horba\", (0, 0)),\n        (\"NotCon\", (0, 0)),\n        (\"lE;\", (8806, 0)),\n        (\"Dcy\", (0, 0)),\n        (\"gra\", (0, 0)),\n        (\"simgE\", (0, 0)),\n        (\"semi\", (0, 0)),\n        (\"mic\", (0, 0)),\n        (\"CenterDot;\", (183, 0)),\n        (\"ha\", (0, 0)),\n        (\"setminus;\", (8726, 0)),\n        (\"dotplus\", (0, 0)),\n        (\"suc\", (0, 0)),\n        (\"varpro\", (0, 0)),\n        (\"gsime;\", (10894, 0)),\n        (\"Sum;\", (8721, 0)),\n        (\"iin\", (0, 0)),\n        (\"nbs\", (0, 0)),\n        (\"nvrArr;\", (10499, 0)),\n        (\"ldrdha\", (0, 0)),\n        (\"OpenCurlyDoubleQu\", (0, 0)),\n        (\"ncu\", (0, 0)),\n        (\"dHa\", (0, 0)),\n        (\"boxv\", (0, 0)),\n        (\"brev\", (0, 0)),\n        (\"Tcy;\", (1058, 0)),\n        (\"Oslas\", (0, 0)),\n        (\"PrecedesSlantEqua\", (0, 0)),\n        (\"DiacriticalTilde;\", (732, 0)),\n        (\"Zcaron\", (0, 0)),\n        (\"yucy;\", (1102, 0)),\n        (\"dd;\", (8518, 0)),\n        (\"harr;\", (8596, 0)),\n        (\"DoubleRigh\", (0, 0)),\n        (\"looparrowri\", (0, 0)),\n        (\"orslope;\", (10839, 0)),\n        (\"RuleDelayed\", (0, 0)),\n        (\"xrar\", (0, 0)),\n        (\"acy\", (0, 0)),\n        (\"FilledS\", (0, 0)),\n        (\"DoubleLeftRig\", (0, 0)),\n        (\"varepsil\", (0, 0)),\n        (\"RightDow\", (0, 0)),\n        (\"Updownarrow\", (0, 0)),\n        (\"nha\", (0, 0)),\n        (\"oslash;\", (248, 0)),\n        (\"Cayleys;\", (8493, 0)),\n        (\"iiii\", (0, 0)),\n        (\"subplus\", (0, 0)),\n        (\"cuwed;\", (8911, 0)),\n        (\"NotReverseElem\", (0, 0)),\n        (\"suphsu\", (0, 0)),\n        (\"vang\", (0, 0)),\n        (\"ClockwiseContourI\", (0, 0)),\n        (\"Vd\", (0, 0)),\n        (\"fe\", (0, 0)),\n        (\"Leftarrow;\", (8656, 0)),\n        (\"NotR\", (0, 0)),\n        (\"cra\", (0, 0)),\n        (\"NotNestedLessL\", (0, 0)),\n        (\"rsqb\", (0, 0)),\n        (\"TripleDo\", (0, 0)),\n        (\"gesd\", (0, 0)),\n        (\"Longri\", (0, 0)),\n        (\"block;\", (9608, 0)),\n        (\"NestedGreater\", (0, 0)),\n        (\"RightArrowBa\", (0, 0)),\n        (\"KJc\", (0, 0)),\n        (\"LeftTeeVector;\", (10586, 0)),\n        (\"NotVerticalBar;\", (8740, 0)),\n        (\"GreaterG\", (0, 0)),\n        (\"LeftDown\", (0, 0)),\n        (\"Eum\", (0, 0)),\n        (\"Wop\", (0, 0)),\n        (\"bpri\", (0, 0)),\n        (\"br\", (0, 0)),\n        (\"profsurf\", (0, 0)),\n        (\"rharu\", (0, 0)),\n        (\"SquareU\", (0, 0)),\n        (\"strns\", (0, 0)),\n        (\"boxdR;\", (9554, 0)),\n        (\"larrh\", (0, 0)),\n        (\"TripleDot\", (0, 0)),\n        (\"FilledVerySmallSq\", (0, 0)),\n        (\"scpoli\", (0, 0)),\n        (\"YUcy\", (0, 0)),\n        (\"xrAr\", (0, 0)),\n        (\"Qfr;\", (120084, 0)),\n        (\"NewLine;\", (10, 0)),\n        (\"angmsdac;\", (10666, 0)),\n        (\"nsucce\", (0, 0)),\n        (\"wcirc;\", (373, 0)),\n        (\"dem\", (0, 0)),\n        (\"van\", (0, 0)),\n        (\"NotSquareSupersetEqu\", (0, 0)),\n        (\"Bop\", (0, 0)),\n        (\"Exponent\", (0, 0)),\n        (\"mapstolef\", (0, 0)),\n        (\"prap\", (0, 0)),\n        (\"squf\", (0, 0)),\n        (\"DoubleRi\", (0, 0)),\n        (\"origo\", (0, 0)),\n        (\"plussi\", (0, 0)),\n        (\"Longrig\", (0, 0)),\n        (\"twoheadleftarro\", (0, 0)),\n        (\"Uar\", (0, 0)),\n        (\"Cce\", (0, 0)),\n        (\"Parti\", (0, 0)),\n        (\"drbkar\", (0, 0)),\n        (\"SH\", (0, 0)),\n        (\"nsubset\", (0, 0)),\n        (\"semi;\", (59, 0)),\n        (\"supsim\", (0, 0)),\n        (\"YU\", (0, 0)),\n        (\"igrave\", (236, 0)),\n        (\"Aogo\", (0, 0)),\n        (\"HumpDownH\", (0, 0)),\n        (\"DownRightVectorBar\", (0, 0)),\n        (\"ga\", (0, 0)),\n        (\"geq;\", (8805, 0)),\n        (\"Tau\", (0, 0)),\n        (\"ratio\", (0, 0)),\n        (\"DownRight\", (0, 0)),\n        (\"aci\", (0, 0)),\n        (\"NestedGreaterGreater;\", (8811, 0)),\n        (\"gv\", (0, 0)),\n        (\"Mi\", (0, 0)),\n        (\"Bcy;\", (1041, 0)),\n        (\"Tcaron\", (0, 0)),\n        (\"boxv;\", (9474, 0)),\n        (\"ua\", (0, 0)),\n        (\"LeftDownVecto\", (0, 0)),\n        (\"plusb\", (0, 0)),\n        (\"NotSucceedsT\", (0, 0)),\n        (\"LongLe\", (0, 0)),\n        (\"RightDou\", (0, 0)),\n        (\"bsolhsu\", (0, 0)),\n        (\"cong;\", (8773, 0)),\n        (\"rsqu\", (0, 0)),\n        (\"rfisht\", (0, 0)),\n        (\"app\", (0, 0)),\n        (\"ClockwiseContourIntegral\", (0, 0)),\n        (\"ale\", (0, 0)),\n        (\"eques\", (0, 0)),\n        (\"RightTeeVector\", (0, 0)),\n        (\"leftarro\", (0, 0)),\n        (\"ysc\", (0, 0)),\n        (\"ne\", (0, 0)),\n        (\"Backsla\", (0, 0)),\n        (\"hkswarow\", (0, 0)),\n        (\"excl;\", (33, 0)),\n        (\"nges\", (0, 0)),\n        (\"Dar\", (0, 0)),\n        (\"NotSucceedsSla\", (0, 0)),\n        (\"Ub\", (0, 0)),\n        (\"igra\", (0, 0)),\n        (\"VeryT\", (0, 0)),\n        (\"ntilde\", (241, 0)),\n        (\"copr\", (0, 0)),\n        (\"Lce\", (0, 0)),\n        (\"swnwar;\", (10538, 0)),\n        (\"ecaron\", (0, 0)),\n        (\"bumpeq;\", (8783, 0)),\n        (\"rightsqui\", (0, 0)),\n        (\"bnequiv\", (0, 0)),\n        (\"lhar\", (0, 0)),\n        (\"RightTee;\", (8866, 0)),\n        (\"FilledVer\", (0, 0)),\n        (\"ens\", (0, 0)),\n        (\"leftrightar\", (0, 0)),\n        (\"RightDownV\", (0, 0)),\n        (\"NotRe\", (0, 0)),\n        (\"bowti\", (0, 0)),\n        (\"falling\", (0, 0)),\n        (\"HilbertSp\", (0, 0)),\n        (\"LeftTri\", (0, 0)),\n        (\"gnsi\", (0, 0)),\n        (\"lgE;\", (10897, 0)),\n        (\"ThinS\", (0, 0)),\n        (\"gtdo\", (0, 0)),\n        (\"gacut\", (0, 0)),\n        (\"oro\", (0, 0)),\n        (\"Produc\", (0, 0)),\n        (\"emsp14;\", (8197, 0)),\n        (\"gcy\", (0, 0)),\n        (\"SuchThat;\", (8715, 0)),\n        (\"tstro\", (0, 0)),\n        (\"lesdotor\", (0, 0)),\n        (\"bbrktbrk\", (0, 0)),\n        (\"NotDoubleV\", (0, 0)),\n        (\"Kcedil\", (0, 0)),\n        (\"lessdot;\", (8918, 0)),\n        (\"cirE\", (0, 0)),\n        (\"DiacriticalGra\", (0, 0)),\n        (\"lAta\", (0, 0)),\n        (\"grave;\", (96, 0)),\n        (\"bigc\", (0, 0)),\n        (\"DoubleDownArro\", (0, 0)),\n        (\"elsdot\", (0, 0)),\n        (\"NotSub\", (0, 0)),\n        (\"DoubleVerti\", (0, 0)),\n        (\"VerticalBar\", (0, 0)),\n        (\"Sigma;\", (931, 0)),\n        (\"Ag\", (0, 0)),\n        (\"Fille\", (0, 0)),\n        (\"glE;\", (10898, 0)),\n        (\"lbrac\", (0, 0)),\n        (\"pitchfork\", (0, 0)),\n        (\"doublebarwed\", (0, 0)),\n        (\"num;\", (35, 0)),\n        (\"Uacute;\", (218, 0)),\n        (\"Zf\", (0, 0)),\n        (\"boxhu;\", (9524, 0)),\n        (\"ld\", (0, 0)),\n        (\"SuchT\", (0, 0)),\n        (\"LongRig\", (0, 0)),\n        (\"LowerLeft\", (0, 0)),\n        (\"veee\", (0, 0)),\n        (\"muma\", (0, 0)),\n        (\"thka\", (0, 0)),\n        (\"Ogra\", (0, 0)),\n        (\"SquareSu\", (0, 0)),\n        (\"compleme\", (0, 0)),\n        (\"Jukcy;\", (1028, 0)),\n        (\"Di\", (0, 0)),\n        (\"blk\", (0, 0)),\n        (\"zigra\", (0, 0)),\n        (\"lneq\", (0, 0)),\n        (\"gtquest;\", (10876, 0)),\n        (\"LeftArrowB\", (0, 0)),\n        (\"UpArro\", (0, 0)),\n        (\"succna\", (0, 0)),\n        (\"pluscir;\", (10786, 0)),\n        (\"sfr;\", (120112, 0)),\n        (\"vartriangle\", (0, 0)),\n        (\"Leftrightarrow\", (0, 0)),\n        (\"RightTria\", (0, 0)),\n        (\"upharpoonright;\", (8638, 0)),\n        (\"LeftUpVecto\", (0, 0)),\n        (\"TSc\", (0, 0)),\n        (\"colon;\", (58, 0)),\n        (\"DownLeftRightVe\", (0, 0)),\n        (\"Do\", (0, 0)),\n        (\"DoubleRightArrow;\", (8658, 0)),\n        (\"bump\", (0, 0)),\n        (\"cuvee;\", (8910, 0)),\n        (\"Ycirc;\", (374, 0)),\n        (\"lca\", (0, 0)),\n        (\"Revers\", (0, 0)),\n        (\"tdo\", (0, 0)),\n        (\"gtci\", (0, 0)),\n        (\"mDDot;\", (8762, 0)),\n        (\"nrightarrow;\", (8603, 0)),\n        (\"laqu\", (0, 0)),\n        (\"rpa\", (0, 0)),\n        (\"ned\", (0, 0)),\n        (\"NotCongr\", (0, 0)),\n        (\"Kap\", (0, 0)),\n        (\"eopf;\", (120150, 0)),\n        (\"num\", (0, 0)),\n        (\"plusdo;\", (8724, 0)),\n        (\"hookr\", (0, 0)),\n        (\"egs;\", (10902, 0)),\n        (\"varno\", (0, 0)),\n        (\"Downar\", (0, 0)),\n        (\"boxDr\", (0, 0)),\n        (\"lesseqqgtr;\", (10891, 0)),\n        (\"vl\", (0, 0)),\n        (\"uHa\", (0, 0)),\n        (\"osol;\", (8856, 0)),\n        (\"scaron\", (0, 0)),\n        (\"Ccedil\", (199, 0)),\n        (\"El\", (0, 0)),\n        (\"Coprod\", (0, 0)),\n        (\"divideontim\", (0, 0)),\n        (\"Nt\", (0, 0)),\n        (\"ss\", (0, 0)),\n        (\"lthree\", (0, 0)),\n        (\"utrif\", (0, 0)),\n        (\"RightTeeAr\", (0, 0)),\n        (\"SucceedsEqual\", (0, 0)),\n        (\"rotimes\", (0, 0)),\n        (\"gn\", (0, 0)),\n        (\"eogon\", (0, 0)),\n        (\"boxd\", (0, 0)),\n        (\"nLtv;\", (8810, 824)),\n        (\"nRigh\", (0, 0)),\n        (\"ShortRig\", (0, 0)),\n        (\"curlyeqs\", (0, 0)),\n        (\"Otime\", (0, 0)),\n        (\"UpD\", (0, 0)),\n        (\"theta;\", (952, 0)),\n        (\"Fouri\", (0, 0)),\n        (\"EmptySmallSquare;\", (9723, 0)),\n        (\"lpar;\", (40, 0)),\n        (\"lowb\", (0, 0)),\n        (\"SquareSuperse\", (0, 0)),\n        (\"Jf\", (0, 0)),\n        (\"gnappr\", (0, 0)),\n        (\"sear\", (0, 0)),\n        (\"NotLessEqua\", (0, 0)),\n        (\"DiacriticalDo\", (0, 0)),\n        (\"gtd\", (0, 0)),\n        (\"bowtie;\", (8904, 0)),\n        (\"precna\", (0, 0)),\n        (\"nprcue\", (0, 0)),\n        (\"Aring\", (197, 0)),\n        (\"Vb\", (0, 0)),\n        (\"ThickS\", (0, 0)),\n        (\"Lc\", (0, 0)),\n        (\"DiacriticalTild\", (0, 0)),\n        (\"TildeFullEqual\", (0, 0)),\n        (\"wc\", (0, 0)),\n        (\"Ff\", (0, 0)),\n        (\"dc\", (0, 0)),\n        (\"NotExists;\", (8708, 0)),\n        (\"atilde;\", (227, 0)),\n        (\"doteq;\", (8784, 0)),\n        (\"nvs\", (0, 0)),\n        (\"lbrack;\", (91, 0)),\n        (\"biguplus\", (0, 0)),\n        (\"hyphen\", (0, 0)),\n        (\"Scy\", (0, 0)),\n        (\"lsime\", (0, 0)),\n        (\"tb\", (0, 0)),\n        (\"intla\", (0, 0)),\n        (\"dst\", (0, 0)),\n        (\"back\", (0, 0)),\n        (\"DownBre\", (0, 0)),\n        (\"smile;\", (8995, 0)),\n        (\"ugra\", (0, 0)),\n        (\"Lced\", (0, 0)),\n        (\"H\", (0, 0)),\n        (\"urt\", (0, 0)),\n        (\"NotNest\", (0, 0)),\n        (\"precs\", (0, 0)),\n        (\"smallsetmi\", (0, 0)),\n        (\"DownRightTeeVec\", (0, 0)),\n        (\"Rrighta\", (0, 0)),\n        (\"Ycy;\", (1067, 0)),\n        (\"Oti\", (0, 0)),\n        (\"Xi;\", (926, 0)),\n        (\"leftarrow;\", (8592, 0)),\n        (\"ZH\", (0, 0)),\n        (\"permi\", (0, 0)),\n        (\"NotLessSlant\", (0, 0)),\n        (\"nopf\", (0, 0)),\n        (\"timesb\", (0, 0)),\n        (\"Zer\", (0, 0)),\n        (\"cupbrcap\", (0, 0)),\n        (\"LowerRi\", (0, 0)),\n        (\"late\", (0, 0)),\n        (\"InvisibleComma;\", (8291, 0)),\n        (\"eDD\", (0, 0)),\n        (\"softcy;\", (1100, 0)),\n        (\"nvrtrie;\", (8885, 8402)),\n        (\"xw\", (0, 0)),\n        (\"Tripl\", (0, 0)),\n        (\"rcub;\", (125, 0)),\n        (\"cudarrl\", (0, 0)),\n        (\"DoubleDownArrow;\", (8659, 0)),\n        (\"lag\", (0, 0)),\n        (\"ltlar\", (0, 0)),\n        (\"NoBre\", (0, 0)),\n        (\"Ecaron\", (0, 0)),\n        (\"lessapp\", (0, 0)),\n        (\"submu\", (0, 0)),\n        (\"wedbar\", (0, 0)),\n        (\"NestedGreaterG\", (0, 0)),\n        (\"RightDownVe\", (0, 0)),\n        (\"cu\", (0, 0)),\n        (\"hksearo\", (0, 0)),\n        (\"bigup\", (0, 0)),\n        (\"omic\", (0, 0)),\n        (\"aacut\", (0, 0)),\n        (\"notniva;\", (8716, 0)),\n        (\"dale\", (0, 0)),\n        (\"capbrcu\", (0, 0)),\n        (\"NotGreaterSlantEqu\", (0, 0)),\n        (\"atilde\", (227, 0)),\n        (\"wrea\", (0, 0)),\n        (\"imagp\", (0, 0)),\n        (\"Prec\", (0, 0)),\n        (\"otim\", (0, 0)),\n        (\"Nacute;\", (323, 0)),\n        (\"lesseqg\", (0, 0)),\n        (\"k\", (0, 0)),\n        (\"mod\", (0, 0)),\n        (\"Lleft\", (0, 0)),\n        (\"LessLess;\", (10913, 0)),\n        (\"pre;\", (10927, 0)),\n        (\"blk14;\", (9617, 0)),\n        (\"chcy;\", (1095, 0)),\n        (\"Integra\", (0, 0)),\n        (\"NotGreaterL\", (0, 0)),\n        (\"downa\", (0, 0)),\n        (\"gf\", (0, 0)),\n        (\"conint;\", (8750, 0)),\n        (\"thickap\", (0, 0)),\n        (\"vsubnE\", (0, 0)),\n        (\"boxuR\", (0, 0)),\n        (\"GreaterF\", (0, 0)),\n        (\"ETH\", (208, 0)),\n        (\"ced\", (0, 0)),\n        (\"gtcir\", (0, 0)),\n        (\"DoubleUpD\", (0, 0)),\n        (\"ulcorner\", (0, 0)),\n        (\"UpEqu\", (0, 0)),\n        (\"digamma;\", (989, 0)),\n        (\"rightsquigar\", (0, 0)),\n        (\"berno\", (0, 0)),\n        (\"divideo\", (0, 0)),\n        (\"digam\", (0, 0)),\n        (\"scir\", (0, 0)),\n        (\"exponent\", (0, 0)),\n        (\"apacir\", (0, 0)),\n        (\"i\", (0, 0)),\n        (\"LongLeftRightArrow\", (0, 0)),\n        (\"ngeqs\", (0, 0)),\n        (\"Cloc\", (0, 0)),\n        (\"pf\", (0, 0)),\n        (\"compfn\", (0, 0)),\n        (\"LeftTriangleEqual;\", (8884, 0)),\n        (\"wreath\", (0, 0)),\n        (\"boxVl\", (0, 0)),\n        (\"congdot\", (0, 0)),\n        (\"lstro\", (0, 0)),\n        (\"nopf;\", (120159, 0)),\n        (\"yacut\", (0, 0)),\n        (\"triplus\", (0, 0)),\n        (\"mapstol\", (0, 0)),\n        (\"Intersect\", (0, 0)),\n        (\"DiacriticalTi\", (0, 0)),\n        (\"utr\", (0, 0)),\n        (\"Omi\", (0, 0)),\n        (\"plussim;\", (10790, 0)),\n        (\"aopf;\", (120146, 0)),\n        (\"Oacute;\", (211, 0)),\n        (\"uplus\", (0, 0)),\n        (\"Tilde\", (0, 0)),\n        (\"ctd\", (0, 0)),\n        (\"div\", (0, 0)),\n        (\"gamm\", (0, 0)),\n        (\"NotHumpD\", (0, 0)),\n        (\"SquareS\", (0, 0)),\n        (\"ulcorner;\", (8988, 0)),\n        (\"succnapprox\", (0, 0)),\n        (\"shcy;\", (1096, 0)),\n        (\"MediumSpace;\", (8287, 0)),\n        (\"LeftTriangleEqual\", (0, 0)),\n        (\"iukcy\", (0, 0)),\n        (\"RightUpVector;\", (8638, 0)),\n        (\"bigodot;\", (10752, 0)),\n        (\"c\", (0, 0)),\n        (\"UpArrowDownArr\", (0, 0)),\n        (\"NotGreaterEqua\", (0, 0)),\n        (\"itild\", (0, 0)),\n        (\"Vopf;\", (120141, 0)),\n        (\"lvnE\", (0, 0)),\n        (\"lmoust;\", (9136, 0)),\n        (\"lotimes\", (0, 0)),\n        (\"numsp\", (0, 0)),\n        (\"sfr\", (0, 0)),\n        (\"subsetne\", (0, 0)),\n        (\"chi\", (0, 0)),\n        (\"boxVL;\", (9571, 0)),\n        (\"NotHump\", (0, 0)),\n        (\"ShortRightArro\", (0, 0)),\n        (\"xs\", (0, 0)),\n        (\"squa\", (0, 0)),\n        (\"Rarr\", (0, 0)),\n        (\"cirscir\", (0, 0)),\n        (\"intercal;\", (8890, 0)),\n        (\"UpTeeArr\", (0, 0)),\n        (\"Barwed\", (0, 0)),\n        (\"nsupset\", (0, 0)),\n        (\"Omeg\", (0, 0)),\n        (\"NewLine\", (0, 0)),\n        (\"LeftUpVector;\", (8639, 0)),\n        (\"Xfr;\", (120091, 0)),\n        (\"Tstr\", (0, 0)),\n        (\"nparallel\", (0, 0)),\n        (\"succapprox;\", (10936, 0)),\n        (\"subsub;\", (10965, 0)),\n        (\"lvertn\", (0, 0)),\n        (\"simgE;\", (10912, 0)),\n        (\"qsc\", (0, 0)),\n        (\"emacr;\", (275, 0)),\n        (\"LongL\", (0, 0)),\n        (\"longleftrightarrow\", (0, 0)),\n        (\"boxp\", (0, 0)),\n        (\"nesi\", (0, 0)),\n        (\"zf\", (0, 0)),\n        (\"Long\", (0, 0)),\n        (\"downharpoonlef\", (0, 0)),\n        (\"icy\", (0, 0)),\n        (\"LeftC\", (0, 0)),\n        (\"upupa\", (0, 0)),\n        (\"NotRigh\", (0, 0)),\n        (\"LeftFloor;\", (8970, 0)),\n        (\"Succe\", (0, 0)),\n        (\"box\", (0, 0)),\n        (\"cedi\", (0, 0)),\n        (\"PartialD;\", (8706, 0)),\n        (\"ora\", (0, 0)),\n        (\"UpArrowDownA\", (0, 0)),\n        (\"rmoustach\", (0, 0)),\n        (\"bNot\", (0, 0)),\n        (\"varp\", (0, 0)),\n        (\"lmido\", (0, 0)),\n        (\"Oacut\", (0, 0)),\n        (\"rig\", (0, 0)),\n        (\"vartri\", (0, 0)),\n        (\"odb\", (0, 0)),\n        (\"searr\", (0, 0)),\n        (\"xsqcu\", (0, 0)),\n        (\"SucceedsTild\", (0, 0)),\n        (\"sect;\", (167, 0)),\n        (\"tpr\", (0, 0)),\n        (\"gtreqq\", (0, 0)),\n        (\"Ab\", (0, 0)),\n        (\"isin\", (0, 0)),\n        (\"ntriang\", (0, 0)),\n        (\"leftharpoond\", (0, 0)),\n        (\"shy;\", (173, 0)),\n        (\"par\", (0, 0)),\n        (\"NotSubsetEqu\", (0, 0)),\n        (\"prcu\", (0, 0)),\n        (\"thet\", (0, 0)),\n        (\"UpTeeArro\", (0, 0)),\n        (\"kopf\", (0, 0)),\n        (\"LeftUpDow\", (0, 0)),\n        (\"cupbrcap;\", (10824, 0)),\n        (\"xlArr\", (0, 0)),\n        (\"Darr;\", (8609, 0)),\n        (\"DoubleVerticalBar;\", (8741, 0)),\n        (\"eqcir\", (0, 0)),\n        (\"qscr;\", (120006, 0)),\n        (\"looparrowleft\", (0, 0)),\n        (\"ltlarr;\", (10614, 0)),\n        (\"robr\", (0, 0)),\n        (\"cdot\", (0, 0)),\n        (\"integers\", (0, 0)),\n        (\"Iac\", (0, 0)),\n        (\"micr\", (0, 0)),\n        (\"LeftArrowRightAr\", (0, 0)),\n        (\"supn\", (0, 0)),\n        (\"RightDoubleBracket\", (0, 0)),\n        (\"olarr\", (0, 0)),\n        (\"larrs\", (0, 0)),\n        (\"utri\", (0, 0)),\n        (\"imped;\", (437, 0)),\n        (\"FilledVerySmal\", (0, 0)),\n        (\"leftrightharpoo\", (0, 0)),\n        (\"xrarr;\", (10230, 0)),\n        (\"olcros\", (0, 0)),\n        (\"sqcup\", (0, 0)),\n        (\"hercon;\", (8889, 0)),\n        (\"Em\", (0, 0)),\n        (\"prnsim\", (0, 0)),\n        (\"Nac\", (0, 0)),\n        (\"varrh\", (0, 0)),\n        (\"sfrown\", (0, 0)),\n        (\"dArr\", (0, 0)),\n        (\"longleftrightarrow;\", (10231, 0)),\n        (\"DownLeftTeeVector\", (0, 0)),\n        (\"NotSquareSub\", (0, 0)),\n        (\"NegativeVer\", (0, 0)),\n        (\"egsdot\", (0, 0)),\n        (\"rightrightarrows;\", (8649, 0)),\n        (\"sups\", (0, 0)),\n        (\"DownArrowBar;\", (10515, 0)),\n        (\"drc\", (0, 0)),\n        (\"nsube;\", (8840, 0)),\n        (\"fparti\", (0, 0)),\n        (\"mumap;\", (8888, 0)),\n        (\"Gdo\", (0, 0)),\n        (\"car\", (0, 0)),\n        (\"rotim\", (0, 0)),\n        (\"tilde;\", (732, 0)),\n        (\"sqc\", (0, 0)),\n        (\"yicy;\", (1111, 0)),\n        (\"nvHarr\", (0, 0)),\n        (\"Diam\", (0, 0)),\n        (\"ncar\", (0, 0)),\n        (\"lpar\", (0, 0)),\n        (\"Hc\", (0, 0)),\n        (\"Expo\", (0, 0)),\n        (\"Dagg\", (0, 0)),\n        (\"varsub\", (0, 0)),\n        (\"Sced\", (0, 0)),\n        (\"frac12\", (189, 0)),\n        (\"no\", (0, 0)),\n        (\"npart;\", (8706, 824)),\n        (\"lAar\", (0, 0)),\n        (\"bpr\", (0, 0)),\n        (\"oS;\", (9416, 0)),\n        (\"pru\", (0, 0)),\n        (\"harr\", (0, 0)),\n        (\"Gr\", (0, 0)),\n        (\"Cir\", (0, 0)),\n        (\"DJcy;\", (1026, 0)),\n        (\"zhcy;\", (1078, 0)),\n        (\"rightarrow\", (0, 0)),\n        (\"VerticalS\", (0, 0)),\n        (\"qop\", (0, 0)),\n        (\"ReverseEquilibrium\", (0, 0)),\n        (\"Vo\", (0, 0)),\n        (\"urcrop;\", (8974, 0)),\n        (\"TildeEqual;\", (8771, 0)),\n        (\"kcedil\", (0, 0)),\n        (\"Et\", (0, 0)),\n        (\"nLeftright\", (0, 0)),\n        (\"ReverseUpEquilib\", (0, 0)),\n        (\"tshcy\", (0, 0)),\n        (\"Uparr\", (0, 0)),\n        (\"angmsdae;\", (10668, 0)),\n        (\"Sqr\", (0, 0)),\n        (\"DownRi\", (0, 0)),\n        (\"Eta\", (0, 0)),\n        (\"succap\", (0, 0)),\n        (\"hyphe\", (0, 0)),\n        (\"Jsercy;\", (1032, 0)),\n        (\"GreaterEqualLess;\", (8923, 0)),\n        (\"ij\", (0, 0)),\n        (\"squarf;\", (9642, 0)),\n        (\"GreaterGre\", (0, 0)),\n        (\"OElig;\", (338, 0)),\n        (\"urcorne\", (0, 0)),\n        (\"LeftArr\", (0, 0)),\n        (\"Ecar\", (0, 0)),\n        (\"nles;\", (10877, 824)),\n        (\"pri\", (0, 0)),\n        (\"lessg\", (0, 0)),\n        (\"rbar\", (0, 0)),\n        (\"LessSl\", (0, 0)),\n        (\"md\", (0, 0)),\n        (\"DownBreve\", (0, 0)),\n        (\"succcurly\", (0, 0)),\n        (\"ncup\", (0, 0)),\n        (\"UnionP\", (0, 0)),\n        (\"HumpDownHump\", (0, 0)),\n        (\"sqcaps\", (0, 0)),\n        (\"NotNestedGreaterGre\", (0, 0)),\n        (\"triang\", (0, 0)),\n        (\"eqcol\", (0, 0)),\n        (\"oum\", (0, 0)),\n        (\"lbbrk;\", (10098, 0)),\n        (\"nsupsete\", (0, 0)),\n        (\"Icy\", (0, 0)),\n        (\"EN\", (0, 0)),\n        (\"nvltri\", (0, 0)),\n        (\"Uop\", (0, 0)),\n        (\"inte\", (0, 0)),\n        (\"darr\", (0, 0)),\n        (\"LeftArro\", (0, 0)),\n        (\"Diff\", (0, 0)),\n        (\"Empty\", (0, 0)),\n        (\"rangd;\", (10642, 0)),\n        (\"ln\", (0, 0)),\n        (\"Acir\", (0, 0)),\n        (\"Theta\", (0, 0)),\n        (\"Bscr;\", (8492, 0)),\n        (\"vfr;\", (120115, 0)),\n        (\"shortpara\", (0, 0)),\n        (\"curlywe\", (0, 0)),\n        (\"rarra\", (0, 0)),\n        (\"bigtriangledow\", (0, 0)),\n        (\"triminus;\", (10810, 0)),\n        (\"utdo\", (0, 0)),\n        (\"sme\", (0, 0)),\n        (\"LeftCeili\", (0, 0)),\n        (\"xcu\", (0, 0)),\n        (\"ge\", (0, 0)),\n        (\"smashp;\", (10803, 0)),\n        (\"dsc\", (0, 0)),\n        (\"twoheadleft\", (0, 0)),\n        (\"urtri\", (0, 0)),\n        (\"horb\", (0, 0)),\n        (\"upharpoonlef\", (0, 0)),\n        (\"lessdo\", (0, 0)),\n        (\"curvearrowrig\", (0, 0)),\n        (\"Ap\", (0, 0)),\n        (\"trad\", (0, 0)),\n        (\"LeftDownTeeVec\", (0, 0)),\n        (\"np\", (0, 0)),\n        (\"cirsci\", (0, 0)),\n        (\"prur\", (0, 0)),\n        (\"cirfnint\", (0, 0)),\n        (\"nbump;\", (8782, 824)),\n        (\"UpArrowD\", (0, 0)),\n        (\"GreaterFul\", (0, 0)),\n        (\"ntil\", (0, 0)),\n        (\"DoubleDow\", (0, 0)),\n        (\"Lst\", (0, 0)),\n        (\"GreaterEqual;\", (8805, 0)),\n        (\"mld\", (0, 0)),\n        (\"gtreql\", (0, 0)),\n        (\"thetas\", (0, 0)),\n        (\"Hopf\", (0, 0)),\n        (\"rrarr;\", (8649, 0)),\n        (\"napid\", (0, 0)),\n        (\"glj;\", (10916, 0)),\n        (\"nLeftarrow;\", (8653, 0)),\n        (\"emptyset;\", (8709, 0)),\n        (\"NotEqualTilde;\", (8770, 824)),\n        (\"angmsdad;\", (10667, 0)),\n        (\"njc\", (0, 0)),\n        (\"NotPrecedesSlantE\", (0, 0)),\n        (\"vrtri;\", (8883, 0)),\n        (\"Ws\", (0, 0)),\n        (\"prnap;\", (10937, 0)),\n        (\"nhArr;\", (8654, 0)),\n        (\"cuep\", (0, 0)),\n        (\"Cedill\", (0, 0)),\n        (\"Wopf;\", (120142, 0)),\n        (\"sigm\", (0, 0)),\n        (\"leftrightsq\", (0, 0)),\n        (\"nvlArr;\", (10498, 0)),\n        (\"jukcy;\", (1108, 0)),\n        (\"Gc\", (0, 0)),\n        (\"leftharpoondo\", (0, 0)),\n        (\"DoubleLeftA\", (0, 0)),\n        (\"Bum\", (0, 0)),\n        (\"Omicr\", (0, 0)),\n        (\"Uf\", (0, 0)),\n        (\"rdc\", (0, 0)),\n        (\"DownT\", (0, 0)),\n        (\"ropa\", (0, 0)),\n        (\"DoubleLong\", (0, 0)),\n        (\"Lmido\", (0, 0)),\n        (\"Bernoull\", (0, 0)),\n        (\"NotLeftTriangl\", (0, 0)),\n        (\"NotRightTriangleEqua\", (0, 0)),\n        (\"lparlt;\", (10643, 0)),\n        (\"HumpE\", (0, 0)),\n        (\"Becaus\", (0, 0)),\n        (\"female\", (0, 0)),\n        (\"Wed\", (0, 0)),\n        (\"LessGreater\", (0, 0)),\n        (\"LessE\", (0, 0)),\n        (\"phiv\", (0, 0)),\n        (\"LongLeftRightAr\", (0, 0)),\n        (\"\", (0, 0)),\n        (\"Gt\", (0, 0)),\n        (\"nsqsup\", (0, 0)),\n        (\"gr\", (0, 0)),\n        (\"ape\", (0, 0)),\n        (\"dagger\", (0, 0)),\n        (\"lrarr;\", (8646, 0)),\n        (\"Otimes;\", (10807, 0)),\n        (\"topbot\", (0, 0)),\n        (\"RightAngleB\", (0, 0)),\n        (\"precapprox\", (0, 0)),\n        (\"TSHcy;\", (1035, 0)),\n        (\"HorizontalLine\", (0, 0)),\n        (\"KJ\", (0, 0)),\n        (\"rightrightarr\", (0, 0)),\n        (\"rightrightarrows\", (0, 0)),\n        (\"bigcu\", (0, 0)),\n        (\"nVDa\", (0, 0)),\n        (\"RightVectorB\", (0, 0)),\n        (\"Rever\", (0, 0)),\n        (\"curvearrowle\", (0, 0)),\n        (\"vsubne\", (0, 0)),\n        (\"RightArro\", (0, 0)),\n        (\"gesle\", (0, 0)),\n        (\"Rcedi\", (0, 0)),\n        (\"gdot\", (0, 0)),\n        (\"GreaterL\", (0, 0)),\n        (\"Odblac;\", (336, 0)),\n        (\"NegativeVeryThinSpa\", (0, 0)),\n        (\"abre\", (0, 0)),\n        (\"backcong\", (0, 0)),\n        (\"Vbar\", (0, 0)),\n        (\"dotsq\", (0, 0)),\n        (\"mcomma\", (0, 0)),\n        (\"NotTil\", (0, 0)),\n        (\"NotVerticalBar\", (0, 0)),\n        (\"opar;\", (10679, 0)),\n        (\"rarrbfs\", (0, 0)),\n        (\"Lstrok\", (0, 0)),\n        (\"zfr;\", (120119, 0)),\n        (\"nrtrie;\", (8941, 0)),\n        (\"prof\", (0, 0)),\n        (\"odbl\", (0, 0)),\n        (\"UpArrowDo\", (0, 0)),\n        (\"UpEquili\", (0, 0)),\n        (\"uA\", (0, 0)),\n        (\"Mfr;\", (120080, 0)),\n        (\"lesseqq\", (0, 0)),\n        (\"Ur\", (0, 0)),\n        (\"supedot\", (0, 0)),\n        (\"mldr;\", (8230, 0)),\n        (\"succs\", (0, 0)),\n        (\"congdo\", (0, 0)),\n        (\"pr\", (0, 0)),\n        (\"LeftUpTeeVect\", (0, 0)),\n        (\"cularrp;\", (10557, 0)),\n        (\"lh\", (0, 0)),\n        (\"supplus;\", (10944, 0)),\n        (\"NotNestedGreater\", (0, 0)),\n        (\"leftrights\", (0, 0)),\n        (\"asc\", (0, 0)),\n        (\"Efr;\", (120072, 0)),\n        (\"utdot\", (0, 0)),\n        (\"omicron\", (0, 0)),\n        (\"YIcy;\", (1031, 0)),\n        (\"supsup;\", (10966, 0)),\n        (\"rfis\", (0, 0)),\n        (\"andd;\", (10844, 0)),\n        (\"nrAr\", (0, 0)),\n        (\"nwarro\", (0, 0)),\n        (\"eli\", (0, 0)),\n        (\"gacute;\", (501, 0)),\n        (\"NonBreakingSpace;\", (160, 0)),\n        (\"NotReverseEle\", (0, 0)),\n        (\"uf\", (0, 0)),\n        (\"nshortm\", (0, 0)),\n        (\"ltim\", (0, 0)),\n        (\"angr\", (0, 0)),\n        (\"uplus;\", (8846, 0)),\n        (\"part\", (0, 0)),\n        (\"RightArrowB\", (0, 0)),\n        (\"DoubleUpDownAr\", (0, 0)),\n        (\"LessL\", (0, 0)),\n        (\"Poincareplane;\", (8460, 0)),\n        (\"RightDoubleBrack\", (0, 0)),\n        (\"LeftA\", (0, 0)),\n        (\"ngeqslant;\", (10878, 824)),\n        (\"FilledSmallSq\", (0, 0)),\n        (\"uar\", (0, 0)),\n        (\"dharr\", (0, 0)),\n        (\"rf\", (0, 0)),\n        (\"MinusPlus;\", (8723, 0)),\n        (\"leftthree\", (0, 0)),\n        (\"NotGreaterSla\", (0, 0)),\n        (\"circlearrowrig\", (0, 0)),\n        (\"DoubleRig\", (0, 0)),\n        (\"cupcu\", (0, 0)),\n        (\"lparlt\", (0, 0)),\n        (\"bdq\", (0, 0)),\n        (\"Go\", (0, 0)),\n        (\"xi;\", (958, 0)),\n        (\"Lscr\", (0, 0)),\n        (\"ubreve\", (0, 0)),\n        (\"checkmar\", (0, 0)),\n        (\"LeftDoubleBra\", (0, 0)),\n        (\"NestedLes\", (0, 0)),\n        (\"rec\", (0, 0)),\n        (\"rlha\", (0, 0)),\n        (\"msc\", (0, 0)),\n        (\"CounterClockwiseCon\", (0, 0)),\n        (\"supsete\", (0, 0)),\n        (\"boxDl;\", (9558, 0)),\n        (\"hkswa\", (0, 0)),\n        (\"vDash;\", (8872, 0)),\n        (\"xca\", (0, 0)),\n        (\"DownLeftRi\", (0, 0)),\n        (\"seswa\", (0, 0)),\n        (\"mDDot\", (0, 0)),\n        (\"ubre\", (0, 0)),\n        (\"RightDownTeeVector\", (0, 0)),\n        (\"Gamma;\", (915, 0)),\n        (\"Wsc\", (0, 0)),\n        (\"Ofr\", (0, 0)),\n        (\"blacktriangledo\", (0, 0)),\n        (\"triangledo\", (0, 0)),\n        (\"lnapp\", (0, 0)),\n        (\"upuparrows;\", (8648, 0)),\n        (\"Kop\", (0, 0)),\n        (\"PrecedesTil\", (0, 0)),\n        (\"circledcirc\", (0, 0)),\n        (\"RightTriangle;\", (8883, 0)),\n        (\"copf;\", (120148, 0)),\n        (\"dar\", (0, 0)),\n        (\"sb\", (0, 0)),\n        (\"lvn\", (0, 0)),\n        (\"eqslantles\", (0, 0)),\n        (\"hkswaro\", (0, 0)),\n        (\"eDDo\", (0, 0)),\n        (\"CenterDo\", (0, 0)),\n        (\"LeftAngleB\", (0, 0)),\n        (\"in;\", (8712, 0)),\n        (\"LessEq\", (0, 0)),\n        (\"gnappro\", (0, 0)),\n        (\"LeftD\", (0, 0)),\n        (\"rad\", (0, 0)),\n        (\"Hscr;\", (8459, 0)),\n        (\"Circ\", (0, 0)),\n        (\"curlywedge\", (0, 0)),\n        (\"smalls\", (0, 0)),\n        (\"racut\", (0, 0)),\n        (\"loz\", (0, 0)),\n        (\"xhArr\", (0, 0)),\n        (\"DoubleUpDownArro\", (0, 0)),\n        (\"gtrless\", (0, 0)),\n        (\"DoubleLeftRightA\", (0, 0)),\n        (\"ZeroWi\", (0, 0)),\n        (\"Yfr;\", (120092, 0)),\n        (\"inodot\", (0, 0)),\n        (\"nshortparallel\", (0, 0)),\n        (\"curren\", (164, 0)),\n        (\"Uu\", (0, 0)),\n        (\"Lopf;\", (120131, 0)),\n        (\"Um\", (0, 0)),\n        (\"Del\", (0, 0)),\n        (\"langd;\", (10641, 0)),\n        (\"frac35;\", (8535, 0)),\n        (\"capdot\", (0, 0)),\n        (\"Dstro\", (0, 0)),\n        (\"smi\", (0, 0)),\n        (\"thetasym\", (0, 0)),\n        (\"szlig;\", (223, 0)),\n        (\"rtrif;\", (9656, 0)),\n        (\"NotLessSlan\", (0, 0)),\n        (\"ups\", (0, 0)),\n        (\"becaus\", (0, 0)),\n        (\"bbrktbrk;\", (9142, 0)),\n        (\"NegativeThickSpac\", (0, 0)),\n        (\"rarrh\", (0, 0)),\n        (\"Leftr\", (0, 0)),\n        (\"xoti\", (0, 0)),\n        (\"Union;\", (8899, 0)),\n        (\"ema\", (0, 0)),\n        (\"RightArrowBar\", (0, 0)),\n        (\"rced\", (0, 0)),\n        (\"hea\", (0, 0)),\n        (\"NotNestedLessLes\", (0, 0)),\n        (\"ltimes\", (0, 0)),\n        (\"itil\", (0, 0)),\n        (\"nsube\", (0, 0)),\n        (\"jsc\", (0, 0)),\n        (\"Cross\", (0, 0)),\n        (\"sdotb;\", (8865, 0)),\n        (\"NotDoubleVertical\", (0, 0)),\n        (\"NotVertic\", (0, 0)),\n        (\"drbkaro\", (0, 0)),\n        (\"sqsup\", (0, 0)),\n        (\"Zeta;\", (918, 0)),\n        (\"supsetneq\", (0, 0)),\n        (\"UpArrowDow\", (0, 0)),\n        (\"eqci\", (0, 0)),\n        (\"uti\", (0, 0)),\n        (\"UpTeeA\", (0, 0)),\n        (\"varpropto;\", (8733, 0)),\n        (\"NotTildeFullEqua\", (0, 0)),\n        (\"Dot\", (0, 0)),\n        (\"gver\", (0, 0)),\n        (\"cong\", (0, 0)),\n        (\"measuredangle;\", (8737, 0)),\n        (\"FilledSmal\", (0, 0)),\n        (\"zeet\", (0, 0)),\n        (\"rdquo\", (0, 0)),\n        (\"Proportion;\", (8759, 0)),\n        (\"ldquor\", (0, 0)),\n        (\"Lcaron;\", (317, 0)),\n        (\"ldsh\", (0, 0)),\n        (\"rarrfs\", (0, 0)),\n        (\"PlusMi\", (0, 0)),\n        (\"omicr\", (0, 0)),\n        (\"RoundImplies;\", (10608, 0)),\n        (\"UpDownAr\", (0, 0)),\n        (\"lrcorner\", (0, 0)),\n        (\"roplus\", (0, 0)),\n        (\"uma\", (0, 0)),\n        (\"bigod\", (0, 0)),\n        (\"gap\", (0, 0)),\n        (\"NotSup\", (0, 0)),\n        (\"LeftAn\", (0, 0)),\n        (\"Oc\", (0, 0)),\n        (\"sdotb\", (0, 0)),\n        (\"barwed\", (0, 0)),\n        (\"lnappr\", (0, 0)),\n        (\"fora\", (0, 0)),\n        (\"Kfr;\", (120078, 0)),\n        (\"rightharpoo\", (0, 0)),\n        (\"Therefor\", (0, 0)),\n        (\"au\", (0, 0)),\n        (\"daleth\", (0, 0)),\n        (\"leftrightsquigarr\", (0, 0)),\n        (\"subsetneq\", (0, 0)),\n        (\"iexcl;\", (161, 0)),\n        (\"NegativeVery\", (0, 0)),\n        (\"plusd\", (0, 0)),\n        (\"qprime;\", (8279, 0)),\n        (\"subra\", (0, 0)),\n        (\"hst\", (0, 0)),\n        (\"vr\", (0, 0)),\n        (\"parall\", (0, 0)),\n        (\"Eu\", (0, 0)),\n        (\"TSH\", (0, 0)),\n        (\"trip\", (0, 0)),\n        (\"ssmil\", (0, 0)),\n        (\"cue\", (0, 0)),\n        (\"tint\", (0, 0)),\n        (\"eqsim;\", (8770, 0)),\n        (\"Ucirc;\", (219, 0)),\n        (\"tdot\", (0, 0)),\n        (\"lnsim\", (0, 0)),\n        (\"Wopf\", (0, 0)),\n        (\"NotLeftTriangleB\", (0, 0)),\n        (\"Imagi\", (0, 0)),\n        (\"backpri\", (0, 0)),\n        (\"sube\", (0, 0)),\n        (\"bigcir\", (0, 0)),\n        (\"ngtr\", (0, 0)),\n        (\"mode\", (0, 0)),\n        (\"am\", (0, 0)),\n        (\"trisb;\", (10701, 0)),\n        (\"DoubleLongLeftAr\", (0, 0)),\n        (\"rationals\", (0, 0)),\n        (\"GreaterLe\", (0, 0)),\n        (\"capbrcup;\", (10825, 0)),\n        (\"NotLessSlantEq\", (0, 0)),\n        (\"Emp\", (0, 0)),\n        (\"InvisibleTime\", (0, 0)),\n        (\"ast;\", (42, 0)),\n        (\"therefore\", (0, 0)),\n        (\"Bac\", (0, 0)),\n        (\"LessGreater;\", (8822, 0)),\n        (\"Propor\", (0, 0)),\n        (\"Fopf;\", (120125, 0)),\n        (\"Eacute\", (201, 0)),\n        (\"rbrkslu\", (0, 0)),\n        (\"lowba\", (0, 0)),\n        (\"gg;\", (8811, 0)),\n        (\"Hac\", (0, 0)),\n        (\"ohb\", (0, 0)),\n        (\"lg\", (0, 0)),\n        (\"Longrigh\", (0, 0)),\n        (\"angmsdag\", (0, 0)),\n        (\"backsimeq\", (0, 0)),\n        (\"elinte\", (0, 0)),\n        (\"rdldhar\", (0, 0)),\n        (\"thicksim\", (0, 0)),\n        (\"udbla\", (0, 0)),\n        (\"malte\", (0, 0)),\n        (\"gbr\", (0, 0)),\n        (\"supp\", (0, 0)),\n        (\"Downa\", (0, 0)),\n        (\"NotTi\", (0, 0)),\n        (\"mo\", (0, 0)),\n        (\"ngeqslan\", (0, 0)),\n        (\"nshortparall\", (0, 0)),\n        (\"swArr\", (0, 0)),\n        (\"Ups\", (0, 0)),\n        (\"triangler\", (0, 0)),\n        (\"nRightarro\", (0, 0)),\n        (\"nu;\", (957, 0)),\n        (\"LessSla\", (0, 0)),\n        (\"cced\", (0, 0)),\n        (\"SucceedsTilde;\", (8831, 0)),\n        (\"gesdoto\", (0, 0)),\n        (\"Longlef\", (0, 0)),\n        (\"Egrave\", (200, 0)),\n        (\"ShortUpArro\", (0, 0)),\n        (\"duh\", (0, 0)),\n        (\"Therefore\", (0, 0)),\n        (\"blacktriangledown\", (0, 0)),\n        (\"nhar\", (0, 0)),\n        (\"Gsc\", (0, 0)),\n        (\"nleftrighta\", (0, 0)),\n        (\"csupe;\", (10962, 0)),\n        (\"nRig\", (0, 0)),\n        (\"ofc\", (0, 0)),\n        (\"gscr\", (0, 0)),\n        (\"set\", (0, 0)),\n        (\"RightUpVec\", (0, 0)),\n        (\"Vdashl\", (0, 0)),\n        (\"prod;\", (8719, 0)),\n        (\"Fil\", (0, 0)),\n        (\"jfr;\", (120103, 0)),\n        (\"sdote;\", (10854, 0)),\n        (\"nshortmi\", (0, 0)),\n        (\"naturals;\", (8469, 0)),\n        (\"Zo\", (0, 0)),\n        (\"rightarrowt\", (0, 0)),\n        (\"lozen\", (0, 0)),\n        (\"parsi\", (0, 0)),\n        (\"emptyv;\", (8709, 0)),\n        (\"Count\", (0, 0)),\n        (\"NotLessGreater\", (0, 0)),\n        (\"NotSquareSupersetEqua\", (0, 0)),\n        (\"angrt;\", (8735, 0)),\n        (\"epsil\", (0, 0)),\n        (\"crar\", (0, 0)),\n        (\"LeftCeilin\", (0, 0)),\n        (\"LeftArrowRight\", (0, 0)),\n        (\"Vdashl;\", (10982, 0)),\n        (\"iiota\", (0, 0)),\n        (\"LeftArrow\", (0, 0)),\n        (\"LowerRightArr\", (0, 0)),\n        (\"scirc\", (0, 0)),\n        (\"Hil\", (0, 0)),\n        (\"duar\", (0, 0)),\n        (\"Rightarrow;\", (8658, 0)),\n        (\"Mc\", (0, 0)),\n        (\"SucceedsSlantE\", (0, 0)),\n        (\"Af\", (0, 0)),\n        (\"ran\", (0, 0)),\n        (\"circlearrowr\", (0, 0)),\n        (\"natural;\", (9838, 0)),\n        (\"VerticalTilde\", (0, 0)),\n        (\"NotLessT\", (0, 0)),\n        (\"esim\", (0, 0)),\n        (\"td\", (0, 0)),\n        (\"boxminus;\", (8863, 0)),\n        (\"rightthreeti\", (0, 0)),\n        (\"tridot;\", (9708, 0)),\n        (\"gtreqle\", (0, 0)),\n        (\"LeftUpVector\", (0, 0)),\n        (\"boxvR\", (0, 0)),\n        (\"twoheadrigh\", (0, 0)),\n        (\"OverParenth\", (0, 0)),\n        (\"roarr\", (0, 0)),\n        (\"epsiv\", (0, 0)),\n        (\"There\", (0, 0)),\n        (\"rcy\", (0, 0)),\n        (\"tca\", (0, 0)),\n        (\"DoubleLongRight\", (0, 0)),\n        (\"Yacut\", (0, 0)),\n        (\"CirclePl\", (0, 0)),\n        (\"nLeftrigh\", (0, 0)),\n        (\"dscy\", (0, 0)),\n        (\"laempt\", (0, 0)),\n        (\"mnp\", (0, 0)),\n        (\"upup\", (0, 0)),\n        (\"isi\", (0, 0)),\n        (\"bbrktbr\", (0, 0)),\n        (\"NotPreced\", (0, 0)),\n        (\"NegativeThickS\", (0, 0)),\n        (\"supsetneqq\", (0, 0)),\n        (\"Lacute;\", (313, 0)),\n        (\"Euml\", (203, 0)),\n        (\"Egrave;\", (200, 0)),\n        (\"zwj\", (0, 0)),\n        (\"gnE;\", (8809, 0)),\n        (\"fcy\", (0, 0)),\n        (\"ape;\", (8778, 0)),\n        (\"demp\", (0, 0)),\n        (\"DownLeft\", (0, 0)),\n        (\"nbsp;\", (160, 0)),\n        (\"angs\", (0, 0)),\n        (\"ltri;\", (9667, 0)),\n        (\"natur\", (0, 0)),\n        (\"lessappro\", (0, 0)),\n        (\"frac5\", (0, 0)),\n        (\"FilledVerySmallSquare\", (0, 0)),\n        (\"qprime\", (0, 0)),\n        (\"aogon\", (0, 0)),\n        (\"wo\", (0, 0)),\n        (\"vArr;\", (8661, 0)),\n        (\"omicro\", (0, 0)),\n        (\"HilbertSpa\", (0, 0)),\n        (\"rightarrowtai\", (0, 0)),\n        (\"ifr\", (0, 0)),\n        (\"infintie\", (0, 0)),\n        (\"ti\", (0, 0)),\n        (\"Cscr\", (0, 0)),\n        (\"ot\", (0, 0)),\n        (\"dt\", (0, 0)),\n        (\"ecirc;\", (234, 0)),\n        (\"marker;\", (9646, 0)),\n        (\"NotPrecedesSlantEqua\", (0, 0)),\n        (\"oop\", (0, 0)),\n        (\"Or;\", (10836, 0)),\n        (\"le;\", (8804, 0)),\n        (\"puncs\", (0, 0)),\n        (\"timesbar;\", (10801, 0)),\n        (\"Cont\", (0, 0)),\n        (\"Ome\", (0, 0)),\n        (\"lvnE;\", (8808, 65024)),\n        (\"w\", (0, 0)),\n        (\"sigmav\", (0, 0)),\n        (\"colon\", (0, 0)),\n        (\"Zca\", (0, 0)),\n        (\"leftharpoondown;\", (8637, 0)),\n        (\"ic;\", (8291, 0)),\n        (\"Eca\", (0, 0)),\n        (\"Egrav\", (0, 0)),\n        (\"larrb;\", (8676, 0)),\n        (\"boxul;\", (9496, 0)),\n        (\"upuparro\", (0, 0)),\n        (\"Sopf;\", (120138, 0)),\n        (\"VerticalTil\", (0, 0)),\n        (\"eqs\", (0, 0)),\n        (\"DoubleDownArr\", (0, 0)),\n        (\"NotP\", (0, 0)),\n        (\"Fcy;\", (1060, 0)),\n        (\"bkaro\", (0, 0)),\n        (\"UnderBr\", (0, 0)),\n        (\"lt;\", (60, 0)),\n        (\"Nu;\", (925, 0)),\n        (\"ReverseElement\", (0, 0)),\n        (\"micro\", (181, 0)),\n        (\"Atild\", (0, 0)),\n        (\"exponen\", (0, 0)),\n        (\"egra\", (0, 0)),\n        (\"pluscir\", (0, 0)),\n        (\"perten\", (0, 0)),\n        (\"ShortLeftArro\", (0, 0)),\n        (\"LeftUpD\", (0, 0)),\n        (\"NotPrece\", (0, 0)),\n        (\"NotCongruent\", (0, 0)),\n        (\"NotLessTild\", (0, 0)),\n        (\"trianglelefteq\", (0, 0)),\n        (\"RightArrowLeftArrow\", (0, 0)),\n        (\"notinvb\", (0, 0)),\n        (\"DotEqu\", (0, 0)),\n        (\"NotRightTriangleEqual;\", (8941, 0)),\n        (\"Lf\", (0, 0)),\n        (\"Because;\", (8757, 0)),\n        (\"RightTeeArrow;\", (8614, 0)),\n        (\"NotLessTil\", (0, 0)),\n        (\"bumpe;\", (8783, 0)),\n        (\"ijlig;\", (307, 0)),\n        (\"Ysc\", (0, 0)),\n        (\"theref\", (0, 0)),\n        (\"supnE;\", (10956, 0)),\n        (\"DScy\", (0, 0)),\n        (\"Nop\", (0, 0)),\n        (\"Uogo\", (0, 0)),\n        (\"eqsi\", (0, 0)),\n        (\"CapitalDifferentia\", (0, 0)),\n        (\"laempty\", (0, 0)),\n        (\"Bernou\", (0, 0)),\n        (\"e\", (0, 0)),\n        (\"prE\", (0, 0)),\n        (\"zs\", (0, 0)),\n        (\"csupe\", (0, 0)),\n        (\"Ope\", (0, 0)),\n        (\"block\", (0, 0)),\n        (\"NotLeftTriangle;\", (8938, 0)),\n        (\"xopf\", (0, 0)),\n        (\"NotLessTilde;\", (8820, 0)),\n        (\"ls\", (0, 0)),\n        (\"intlarh\", (0, 0)),\n        (\"ulcrop\", (0, 0)),\n        (\"OverParenthes\", (0, 0)),\n        (\"triangled\", (0, 0)),\n        (\"Tscr\", (0, 0)),\n        (\"rightlef\", (0, 0)),\n        (\"SmallCir\", (0, 0)),\n        (\"LeftArrowRigh\", (0, 0)),\n        (\"sqca\", (0, 0)),\n        (\"cirsc\", (0, 0)),\n        (\"NotNes\", (0, 0)),\n        (\"odblac\", (0, 0)),\n        (\"the\", (0, 0)),\n        (\"boxbox;\", (10697, 0)),\n        (\"LeftAngleBracke\", (0, 0)),\n        (\"Col\", (0, 0)),\n        (\"Yscr;\", (119988, 0)),\n        (\"Ra\", (0, 0)),\n        (\"dzi\", (0, 0)),\n        (\"Bfr\", (0, 0)),\n        (\"nltri;\", (8938, 0)),\n        (\"Igr\", (0, 0)),\n        (\"TildeF\", (0, 0)),\n        (\"Squar\", (0, 0)),\n        (\"Sacut\", (0, 0)),\n        (\"divi\", (0, 0)),\n        (\"Capita\", (0, 0)),\n        (\"wscr;\", (120012, 0)),\n        (\"Wf\", (0, 0)),\n        (\"NotLessSlantEqua\", (0, 0)),\n        (\"dbl\", (0, 0)),\n        (\"rcei\", (0, 0)),\n        (\"rightleftarrow\", (0, 0)),\n        (\"gtrdot\", (0, 0)),\n        (\"gtquest\", (0, 0)),\n        (\"lstr\", (0, 0)),\n        (\"VerticalT\", (0, 0)),\n        (\"rhard\", (0, 0)),\n        (\"NotLessLess;\", (8810, 824)),\n        (\"cac\", (0, 0)),\n        (\"nfr;\", (120107, 0)),\n        (\"caron;\", (711, 0)),\n        (\"maltes\", (0, 0)),\n        (\"NewLi\", (0, 0)),\n        (\"rlhar;\", (8652, 0)),\n        (\"uparrow;\", (8593, 0)),\n        (\"CounterClockwiseContourIntegral\", (0, 0)),\n        (\"Apply\", (0, 0)),\n        (\"ncong;\", (8775, 0)),\n        (\"topbo\", (0, 0)),\n        (\"V\", (0, 0)),\n        (\"dtri\", (0, 0)),\n        (\"ubrev\", (0, 0)),\n        (\"ff\", (0, 0)),\n        (\"LeftDow\", (0, 0)),\n        (\"lfisht\", (0, 0)),\n        (\"emptyv\", (0, 0)),\n        (\"DiacriticalAcut\", (0, 0)),\n        (\"nrightarr\", (0, 0)),\n        (\"upharp\", (0, 0)),\n        (\"Ci\", (0, 0)),\n        (\"uc\", (0, 0)),\n        (\"awint;\", (10769, 0)),\n        (\"ci\", (0, 0)),\n        (\"scap;\", (10936, 0)),\n        (\"ope\", (0, 0)),\n        (\"oplu\", (0, 0)),\n        (\"Neg\", (0, 0)),\n        (\"LowerRightArro\", (0, 0)),\n        (\"SupersetE\", (0, 0)),\n        (\"Yopf;\", (120144, 0)),\n        (\"multi\", (0, 0)),\n        (\"Equilibrium\", (0, 0)),\n        (\"Less\", (0, 0)),\n        (\"NegativeThickSpa\", (0, 0)),\n        (\"sl\", (0, 0)),\n        (\"nshortmid;\", (8740, 0)),\n        (\"OverBar\", (0, 0)),\n        (\"NestedGreate\", (0, 0)),\n        (\"Ka\", (0, 0)),\n        (\"Oacute\", (211, 0)),\n        (\"prE;\", (10931, 0)),\n        (\"ReverseUpEquilibrium;\", (10607, 0)),\n        (\"Updownar\", (0, 0)),\n        (\"simplus;\", (10788, 0)),\n        (\"boxti\", (0, 0)),\n        (\"vsupn\", (0, 0)),\n        (\"FilledVerySmall\", (0, 0)),\n        (\"ol\", (0, 0)),\n        (\"marker\", (0, 0)),\n        (\"df\", (0, 0)),\n        (\"aelig;\", (230, 0)),\n        (\"longrightar\", (0, 0)),\n        (\"upsil\", (0, 0)),\n        (\"squarf\", (0, 0)),\n        (\"nVdash;\", (8878, 0)),\n        (\"do\", (0, 0)),\n        (\"Up\", (0, 0)),\n        (\"daleth;\", (8504, 0)),\n        (\"capd\", (0, 0)),\n        (\"isinv;\", (8712, 0)),\n        (\"NotNestedGreaterGreater;\", (10914, 824)),\n        (\"Tri\", (0, 0)),\n        (\"E\", (0, 0)),\n        (\"nLeftrightar\", (0, 0)),\n        (\"Medi\", (0, 0)),\n        (\"LessEqualGre\", (0, 0)),\n        (\"Rightarro\", (0, 0)),\n        (\"boxV;\", (9553, 0)),\n        (\"gvertneqq\", (0, 0)),\n        (\"ast\", (0, 0)),\n        (\"NotRight\", (0, 0)),\n        (\"asy\", (0, 0)),\n        (\"profal\", (0, 0)),\n        (\"go\", (0, 0)),\n        (\"Copf;\", (8450, 0)),\n        (\"nrighta\", (0, 0)),\n        (\"RightUpDo\", (0, 0)),\n        (\"notnivc;\", (8957, 0)),\n        (\"thic\", (0, 0)),\n        (\"Not\", (0, 0)),\n        (\"wedgeq\", (0, 0)),\n        (\"orderof\", (0, 0)),\n        (\"scnsim\", (0, 0)),\n        (\"Laplacetrf;\", (8466, 0)),\n        (\"subne;\", (8842, 0)),\n        (\"ffli\", (0, 0)),\n        (\"SquareInter\", (0, 0)),\n        (\"Vvd\", (0, 0)),\n        (\"lds\", (0, 0)),\n        (\"rarrc\", (0, 0)),\n        (\"NotLeftTriangleBa\", (0, 0)),\n        (\"Ber\", (0, 0)),\n        (\"Op\", (0, 0)),\n        (\"KH\", (0, 0)),\n        (\"lAt\", (0, 0)),\n        (\"therefor\", (0, 0)),\n        (\"eci\", (0, 0)),\n        (\"llhar\", (0, 0)),\n        (\"phm\", (0, 0)),\n        (\"gesdot;\", (10880, 0)),\n        (\"xni\", (0, 0)),\n        (\"nrigh\", (0, 0)),\n        (\"varsup\", (0, 0)),\n        (\"LessFullEqua\", (0, 0)),\n        (\"ReverseUpEquilibriu\", (0, 0)),\n        (\"boxhD\", (0, 0)),\n        (\"plus;\", (43, 0)),\n        (\"lowbar\", (0, 0)),\n        (\"Omega;\", (937, 0)),\n        (\"notindot\", (0, 0)),\n        (\"lat;\", (10923, 0)),\n        (\"leftrightsquigarro\", (0, 0)),\n        (\"Mopf\", (0, 0)),\n        (\"odso\", (0, 0)),\n        (\"srarr\", (0, 0)),\n        (\"ssmile\", (0, 0)),\n        (\"lrarr\", (0, 0)),\n        (\"emsp1\", (0, 0)),\n        (\"rr\", (0, 0)),\n        (\"measured\", (0, 0)),\n        (\"hoo\", (0, 0)),\n        (\"GreaterSlantEqual\", (0, 0)),\n        (\"ngeqslant\", (0, 0)),\n        (\"ndash;\", (8211, 0)),\n        (\"lns\", (0, 0)),\n        (\"shy\", (173, 0)),\n        (\"triminu\", (0, 0)),\n        (\"Oum\", (0, 0)),\n        (\"updownarr\", (0, 0)),\n        (\"lrt\", (0, 0)),\n        (\"ocir;\", (8858, 0)),\n        (\"DoubleVe\", (0, 0)),\n        (\"Gcedil;\", (290, 0)),\n        (\"nleft\", (0, 0)),\n        (\"gesc\", (0, 0)),\n        (\"bigwe\", (0, 0)),\n        (\"twoheadr\", (0, 0)),\n        (\"drbka\", (0, 0)),\n        (\"GreaterLess;\", (8823, 0)),\n        (\"NotDou\", (0, 0)),\n        (\"comp;\", (8705, 0)),\n        (\"Tcy\", (0, 0)),\n        (\"geq\", (0, 0)),\n        (\"Cconi\", (0, 0)),\n        (\"nsupse\", (0, 0)),\n        (\"LeftDownVectorBar\", (0, 0)),\n        (\"RightUpV\", (0, 0)),\n        (\"Eogon\", (0, 0)),\n        (\"suplarr\", (0, 0)),\n        (\"LeftRightArrow;\", (8596, 0)),\n        (\"topf;\", (120165, 0)),\n        (\"Zero\", (0, 0)),\n        (\"uharr;\", (8638, 0)),\n        (\"rar\", (0, 0)),\n        (\"longleftarr\", (0, 0)),\n        (\"OpenCurlyDoubleQuot\", (0, 0)),\n        (\"lmou\", (0, 0)),\n        (\"nleqslant;\", (10877, 824)),\n        (\"Vertical\", (0, 0)),\n        (\"boxdL\", (0, 0)),\n        (\"yopf\", (0, 0)),\n        (\"Congru\", (0, 0)),\n        (\"gesdot\", (0, 0)),\n        (\"boxDr;\", (9555, 0)),\n        (\"NotSqu\", (0, 0)),\n        (\"ntrianglerig\", (0, 0)),\n        (\"CloseCurlyDoubleQ\", (0, 0)),\n        (\"RightArrow\", (0, 0)),\n        (\"xut\", (0, 0)),\n        (\"ltla\", (0, 0)),\n        (\"Jc\", (0, 0)),\n        (\"zo\", (0, 0)),\n        (\"Racut\", (0, 0)),\n        (\"Jcy\", (0, 0)),\n        (\"EmptySm\", (0, 0)),\n        (\"eDot;\", (8785, 0)),\n        (\"trpezium;\", (9186, 0)),\n        (\"rdld\", (0, 0)),\n        (\"VerticalSeparato\", (0, 0)),\n        (\"ka\", (0, 0)),\n        (\"Sigma\", (0, 0)),\n        (\"RightTeeVector;\", (10587, 0)),\n        (\"xwed\", (0, 0)),\n        (\"DoubleUpDownArrow\", (0, 0)),\n        (\"CirclePlus;\", (8853, 0)),\n        (\"xopl\", (0, 0)),\n        (\"RightAng\", (0, 0)),\n        (\"bumpe\", (0, 0)),\n        (\"Chi;\", (935, 0)),\n        (\"rfish\", (0, 0)),\n        (\"nwarhk\", (0, 0)),\n        (\"fjli\", (0, 0)),\n        (\"rarrw;\", (8605, 0)),\n        (\"supseteqq\", (0, 0)),\n        (\"bsemi\", (0, 0)),\n        (\"DoubleRightArrow\", (0, 0)),\n        (\"robrk;\", (10215, 0)),\n        (\"cscr;\", (119992, 0)),\n        (\"boxvH\", (0, 0)),\n        (\"egrav\", (0, 0)),\n        (\"Yacu\", (0, 0)),\n        (\"roar\", (0, 0)),\n        (\"OpenCurlyQuote;\", (8216, 0)),\n        (\"Yop\", (0, 0)),\n        (\"subE\", (0, 0)),\n        (\"LeftRightVe\", (0, 0)),\n        (\"loo\", (0, 0)),\n        (\"rarrc;\", (10547, 0)),\n        (\"cupd\", (0, 0)),\n        (\"upu\", (0, 0)),\n        (\"xupl\", (0, 0)),\n        (\"rightthreetimes\", (0, 0)),\n        (\"KJcy;\", (1036, 0)),\n        (\"GreaterEqu\", (0, 0)),\n        (\"Med\", (0, 0)),\n        (\"NotSucc\", (0, 0)),\n        (\"bka\", (0, 0)),\n        (\"nrtri\", (0, 0)),\n        (\"qp\", (0, 0)),\n        (\"HilbertSpac\", (0, 0)),\n        (\"vp\", (0, 0)),\n        (\"cupo\", (0, 0)),\n        (\"Ufr;\", (120088, 0)),\n        (\"sub\", (0, 0)),\n        (\"rdldhar;\", (10601, 0)),\n        (\"otilde;\", (245, 0)),\n        (\"maltese\", (0, 0)),\n        (\"Scaron\", (0, 0)),\n        (\"Zacu\", (0, 0)),\n        (\"rbarr\", (0, 0)),\n        (\"bprim\", (0, 0)),\n        (\"loplus;\", (10797, 0)),\n        (\"tbrk\", (0, 0)),\n        (\"epsilon;\", (949, 0)),\n        (\"uml;\", (168, 0)),\n        (\"nparsl;\", (11005, 8421)),\n        (\"Nce\", (0, 0)),\n        (\"UpEquilibri\", (0, 0)),\n        (\"CounterCloc\", (0, 0)),\n        (\"leqq;\", (8806, 0)),\n        (\"SucceedsSlantEqu\", (0, 0)),\n        (\"sced\", (0, 0)),\n        (\"dotplus;\", (8724, 0)),\n        (\"REG\", (174, 0)),\n        (\"Omacr\", (0, 0)),\n        (\"trpeziu\", (0, 0)),\n        (\"LeftTee;\", (8867, 0)),\n        (\"UnderParent\", (0, 0)),\n        (\"UpperLeftArrow;\", (8598, 0)),\n        (\"DownArrowUpArrow;\", (8693, 0)),\n        (\"eD\", (0, 0)),\n        (\"lagra\", (0, 0)),\n        (\"spa\", (0, 0)),\n        (\"sscr;\", (120008, 0)),\n        (\"ETH;\", (208, 0)),\n        (\"rbarr;\", (10509, 0)),\n        (\"phiv;\", (981, 0)),\n        (\"Cedilla\", (0, 0)),\n        (\"andslope;\", (10840, 0)),\n        (\"slarr\", (0, 0)),\n        (\"angzarr;\", (9084, 0)),\n        (\"varthe\", (0, 0)),\n        (\"preccurly\", (0, 0)),\n        (\"triangledown\", (0, 0)),\n        (\"Sta\", (0, 0)),\n        (\"leftrightarrow\", (0, 0)),\n        (\"therefo\", (0, 0)),\n        (\"imagline\", (0, 0)),\n        (\"Udblac;\", (368, 0)),\n        (\"elint\", (0, 0)),\n        (\"uhb\", (0, 0)),\n        (\"NotSucceedsSlan\", (0, 0)),\n        (\"larrfs;\", (10525, 0)),\n        (\"Ze\", (0, 0)),\n        (\"varprop\", (0, 0)),\n        (\"varphi\", (0, 0)),\n        (\"lcaro\", (0, 0)),\n        (\"bre\", (0, 0)),\n        (\"dharr;\", (8642, 0)),\n        (\"Inters\", (0, 0)),\n        (\"ffllig;\", (64260, 0)),\n        (\"int\", (0, 0)),\n        (\"Implies\", (0, 0)),\n        (\"iecy\", (0, 0)),\n        (\"NotNestedGreaterGreater\", (0, 0)),\n        (\"csube;\", (10961, 0)),\n        (\"DDotrah\", (0, 0)),\n        (\"blacktriangleright\", (0, 0)),\n        (\"rsquo\", (0, 0)),\n        (\"Qscr;\", (119980, 0)),\n        (\"RightFloor;\", (8971, 0)),\n        (\"NotCupCap\", (0, 0)),\n        (\"bs\", (0, 0)),\n        (\"FilledVe\", (0, 0)),\n        (\"straig\", (0, 0)),\n        (\"ecaro\", (0, 0)),\n        (\"NotT\", (0, 0)),\n        (\"langle\", (0, 0)),\n        (\"Ga\", (0, 0)),\n        (\"kf\", (0, 0)),\n        (\"Wcirc\", (0, 0)),\n        (\"boxvL;\", (9569, 0)),\n        (\"qin\", (0, 0)),\n        (\"hercon\", (0, 0)),\n        (\"NotLessGre\", (0, 0)),\n        (\"LeftR\", (0, 0)),\n        (\"VerticalSepar\", (0, 0)),\n        (\"NegativeThinSp\", (0, 0)),\n        (\"Greate\", (0, 0)),\n        (\"jcirc;\", (309, 0)),\n        (\"ldquo\", (0, 0)),\n        (\"uphar\", (0, 0)),\n        (\"lambda\", (0, 0)),\n        (\"neArr\", (0, 0)),\n        (\"lbarr;\", (10508, 0)),\n        (\"downharpoonright\", (0, 0)),\n        (\"Lcaro\", (0, 0)),\n        (\"SquareUn\", (0, 0)),\n        (\"lp\", (0, 0)),\n        (\"varsupset\", (0, 0)),\n        (\"fr\", (0, 0)),\n        (\"ncong\", (0, 0)),\n        (\"Dcy;\", (1044, 0)),\n        (\"DownA\", (0, 0)),\n        (\"DiacriticalTilde\", (0, 0)),\n        (\"ReverseEquil\", (0, 0)),\n        (\"NotSucceedsSlantEqual;\", (8929, 0)),\n        (\"eqcolo\", (0, 0)),\n        (\"DoubleContourIntegr\", (0, 0)),\n        (\"HumpD\", (0, 0)),\n        (\"questeq\", (0, 0)),\n        (\"cem\", (0, 0)),\n        (\"Dashv\", (0, 0)),\n        (\"parallel\", (0, 0)),\n        (\"rightleftharpoon\", (0, 0)),\n        (\"ClockwiseConto\", (0, 0)),\n        (\"NotPrecedesEqu\", (0, 0)),\n        (\"DownLeftTee\", (0, 0)),\n        (\"OverBrack\", (0, 0)),\n        (\"NotEleme\", (0, 0)),\n        (\"nf\", (0, 0)),\n        (\"Hu\", (0, 0)),\n        (\"intc\", (0, 0)),\n        (\"Jser\", (0, 0)),\n        (\"circledS;\", (9416, 0)),\n        (\"Gamm\", (0, 0)),\n        (\"iqu\", (0, 0)),\n        (\"Oacu\", (0, 0)),\n        (\"divonx;\", (8903, 0)),\n        (\"lessapprox;\", (10885, 0)),\n        (\"orar\", (0, 0)),\n        (\"TildeFull\", (0, 0)),\n        (\"ShortLeftArrow;\", (8592, 0)),\n        (\"ie\", (0, 0)),\n        (\"NotRig\", (0, 0)),\n        (\"Pscr;\", (119979, 0)),\n        (\"oso\", (0, 0)),\n        (\"alef\", (0, 0)),\n        (\"pou\", (0, 0)),\n        (\"NotRightTriangle;\", (8939, 0)),\n        (\"prnap\", (0, 0)),\n        (\"da\", (0, 0)),\n        (\"RightArrowLeftA\", (0, 0)),\n        (\"utild\", (0, 0)),\n        (\"ReverseEl\", (0, 0)),\n        (\"scE\", (0, 0)),\n        (\"duhar\", (0, 0)),\n        (\"Ycir\", (0, 0)),\n        (\"NotSquareSubsetEqua\", (0, 0)),\n        (\"LongLeftRightArr\", (0, 0)),\n        (\"ShortD\", (0, 0)),\n        (\"male;\", (9794, 0)),\n        (\"sta\", (0, 0)),\n        (\"lharul;\", (10602, 0)),\n        (\"dscr;\", (119993, 0)),\n        (\"VerticalLine;\", (124, 0)),\n        (\"RightDouble\", (0, 0)),\n        (\"NotRightTriangleE\", (0, 0)),\n        (\"Close\", (0, 0)),\n        (\"perio\", (0, 0)),\n        (\"subsub\", (0, 0)),\n        (\"iu\", (0, 0)),\n        (\"gtreqqles\", (0, 0)),\n        (\"Leftrighta\", (0, 0)),\n        (\"caret;\", (8257, 0)),\n        (\"smallsetm\", (0, 0)),\n        (\"coprod\", (0, 0)),\n        (\"ipr\", (0, 0)),\n        (\"ta\", (0, 0)),\n        (\"Hcirc;\", (292, 0)),\n        (\"rfr\", (0, 0)),\n        (\"downharpoo\", (0, 0)),\n        (\"Uc\", (0, 0)),\n        (\"NotSupers\", (0, 0)),\n        (\"xfr\", (0, 0)),\n        (\"xfr;\", (120117, 0)),\n        (\"downharpoonrig\", (0, 0)),\n        (\"tced\", (0, 0)),\n        (\"barwed;\", (8965, 0)),\n        (\"lfis\", (0, 0)),\n        (\"comple\", (0, 0)),\n        (\"CounterClockwiseContourIn\", (0, 0)),\n        (\"gsiml\", (0, 0)),\n        (\"scpolint\", (0, 0)),\n        (\"NotGreaterSlantEqua\", (0, 0)),\n        (\"OpenCurlyDou\", (0, 0)),\n        (\"Nti\", (0, 0)),\n        (\"lstrok\", (0, 0)),\n        (\"NotTildeEqual;\", (8772, 0)),\n        (\"rightleftarro\", (0, 0)),\n        (\"plussim\", (0, 0)),\n        (\"subsi\", (0, 0)),\n        (\"SupersetEq\", (0, 0)),\n        (\"egrave;\", (232, 0)),\n        (\"risingdots\", (0, 0)),\n        (\"DifferentialD;\", (8518, 0)),\n        (\"omin\", (0, 0)),\n        (\"righ\", (0, 0)),\n        (\"succne\", (0, 0)),\n        (\"DoubleR\", (0, 0)),\n        (\"ratio;\", (8758, 0)),\n        (\"sca\", (0, 0)),\n        (\"NotLessEqu\", (0, 0)),\n        (\"NestedLessLes\", (0, 0)),\n        (\"LeftRightVector;\", (10574, 0)),\n        (\"ldq\", (0, 0)),\n        (\"gsime\", (0, 0)),\n        (\"f\", (0, 0)),\n        (\"zca\", (0, 0)),\n        (\"downdown\", (0, 0)),\n        (\"DownLeftV\", (0, 0)),\n        (\"supne\", (0, 0)),\n        (\"ni;\", (8715, 0)),\n        (\"Jukc\", (0, 0)),\n        (\"Acirc;\", (194, 0)),\n        (\"bnequ\", (0, 0)),\n        (\"LeftTriangleEqua\", (0, 0)),\n        (\"LongR\", (0, 0)),\n        (\"Racute\", (0, 0)),\n        (\"triplus;\", (10809, 0)),\n        (\"NonBreakingSpa\", (0, 0)),\n        (\"sq\", (0, 0)),\n        (\"triangleri\", (0, 0)),\n        (\"nis\", (0, 0)),\n        (\"Doubl\", (0, 0)),\n        (\"nsqsub\", (0, 0)),\n        (\"longle\", (0, 0)),\n        (\"nlsim;\", (8820, 0)),\n        (\"cfr\", (0, 0)),\n        (\"AElig;\", (198, 0)),\n        (\"LeftVectorBar;\", (10578, 0)),\n        (\"tprime;\", (8244, 0)),\n        (\"nmid\", (0, 0)),\n        (\"LeftFl\", (0, 0)),\n        (\"NotGreaterEqual\", (0, 0)),\n        (\"DownTe\", (0, 0)),\n        (\"Ubr\", (0, 0)),\n        (\"ascr\", (0, 0)),\n        (\"esdot\", (0, 0)),\n        (\"ropar;\", (10630, 0)),\n        (\"LowerRightArrow;\", (8600, 0)),\n        (\"sube;\", (8838, 0)),\n        (\"mumap\", (0, 0)),\n        (\"nca\", (0, 0)),\n        (\"ShortUpA\", (0, 0)),\n        (\"RightUpTeeVecto\", (0, 0)),\n        (\"dow\", (0, 0)),\n        (\"vartria\", (0, 0)),\n        (\"NotDoubleVerticalB\", (0, 0)),\n        (\"LeftDo\", (0, 0)),\n        (\"xn\", (0, 0)),\n        (\"ws\", (0, 0)),\n        (\"yi\", (0, 0)),\n        (\"luruh\", (0, 0)),\n        (\"heartsuit;\", (9829, 0)),\n        (\"olt\", (0, 0)),\n        (\"NestedLessL\", (0, 0)),\n        (\"NotReverseE\", (0, 0)),\n        (\"REG;\", (174, 0)),\n        (\"sqs\", (0, 0)),\n        (\"geqslan\", (0, 0)),\n        (\"precnapp\", (0, 0)),\n        (\"FilledVery\", (0, 0)),\n        (\"bigot\", (0, 0)),\n        (\"rAt\", (0, 0)),\n        (\"leftrighthar\", (0, 0)),\n        (\"gesdoto;\", (10882, 0)),\n        (\"LeftUpVectorB\", (0, 0)),\n        (\"Pscr\", (0, 0)),\n        (\"umacr\", (0, 0)),\n        (\"rati\", (0, 0)),\n        (\"Pfr\", (0, 0)),\n        (\"capand;\", (10820, 0)),\n        (\"thicks\", (0, 0)),\n        (\"varka\", (0, 0)),\n        (\"Mf\", (0, 0)),\n        (\"subplu\", (0, 0)),\n        (\"gtreqql\", (0, 0)),\n        (\"dd\", (0, 0)),\n        (\"complexes\", (0, 0)),\n        (\"ubr\", (0, 0)),\n        (\"xrarr\", (0, 0)),\n        (\"phmmat;\", (8499, 0)),\n        (\"UpArrowBar\", (0, 0)),\n        (\"subsetneqq\", (0, 0)),\n        (\"nparsl\", (0, 0)),\n        (\"raquo;\", (187, 0)),\n        (\"Uarr;\", (8607, 0)),\n        (\"homth\", (0, 0)),\n        (\"uuarr\", (0, 0)),\n        (\"Supset\", (0, 0)),\n        (\"triangleq;\", (8796, 0)),\n        (\"tscr\", (0, 0)),\n        (\"DownBr\", (0, 0)),\n        (\"LessGre\", (0, 0)),\n        (\"NotDo\", (0, 0)),\n        (\"OpenCurlyDoubleQuo\", (0, 0)),\n        (\"Fcy\", (0, 0)),\n        (\"eparsl\", (0, 0)),\n        (\"Escr;\", (8496, 0)),\n        (\"bottom;\", (8869, 0)),\n        (\"Fsc\", (0, 0)),\n        (\"curlyw\", (0, 0)),\n        (\"ShortU\", (0, 0)),\n        (\"NestedL\", (0, 0)),\n        (\"hookrigh\", (0, 0)),\n        (\"sdot;\", (8901, 0)),\n        (\"gtrdo\", (0, 0)),\n        (\"DoubleLeftTe\", (0, 0)),\n        (\"iacute;\", (237, 0)),\n        (\"leftright\", (0, 0)),\n        (\"NotPrecedesSlan\", (0, 0)),\n        (\"Omega\", (0, 0)),\n        (\"ovba\", (0, 0)),\n        (\"sstar\", (0, 0)),\n        (\"ohm;\", (937, 0)),\n        (\"Lambda\", (0, 0)),\n        (\"nleq\", (0, 0)),\n        (\"ges\", (0, 0)),\n        (\"LeftAngleBrack\", (0, 0)),\n        (\"gsim\", (0, 0)),\n        (\"NotTilde\", (0, 0)),\n        (\"nvDash;\", (8877, 0)),\n        (\"CounterClockwiseC\", (0, 0)),\n        (\"lne;\", (10887, 0)),\n        (\"NotCongruen\", (0, 0)),\n        (\"twoheadrightarro\", (0, 0)),\n        (\"re\", (0, 0)),\n        (\"curv\", (0, 0)),\n        (\"reals\", (0, 0)),\n        (\"epsi;\", (949, 0)),\n        (\"Dopf\", (0, 0)),\n        (\"mu\", (0, 0)),\n        (\"NotSquareSubse\", (0, 0)),\n        (\"boxmin\", (0, 0)),\n        (\"succeq;\", (10928, 0)),\n        (\"rcaron\", (0, 0)),\n        (\"longright\", (0, 0)),\n        (\"tdot;\", (8411, 0)),\n        (\"be\", (0, 0)),\n        (\"cupcup;\", (10826, 0)),\n        (\"pitch\", (0, 0)),\n        (\"jse\", (0, 0)),\n        (\"backep\", (0, 0)),\n        (\"yacu\", (0, 0)),\n        (\"gjcy\", (0, 0)),\n        (\"sqsubset;\", (8847, 0)),\n        (\"risingdot\", (0, 0)),\n        (\"NestedGrea\", (0, 0)),\n        (\"mnpl\", (0, 0)),\n        (\"LeftUpTeeVe\", (0, 0)),\n        (\"ands\", (0, 0)),\n        (\"topci\", (0, 0)),\n        (\"nrarrc\", (0, 0)),\n        (\"propto;\", (8733, 0)),\n        (\"curlyeqprec\", (0, 0)),\n        (\"ll;\", (8810, 0)),\n        (\"xodot\", (0, 0)),\n        (\"maltese;\", (10016, 0)),\n        (\"diamond;\", (8900, 0)),\n        (\"nRightar\", (0, 0)),\n        (\"C\", (0, 0)),\n        (\"xm\", (0, 0)),\n        (\"uuml\", (252, 0)),\n        (\"risi\", (0, 0)),\n        (\"Da\", (0, 0)),\n        (\"gnapp\", (0, 0)),\n        (\"npar\", (0, 0)),\n        (\"NotElement;\", (8713, 0)),\n        (\"IEcy;\", (1045, 0)),\n        (\"curvearr\", (0, 0)),\n        (\"FilledVeryS\", (0, 0)),\n        (\"hard\", (0, 0)),\n        (\"diam\", (0, 0)),\n        (\"Yum\", (0, 0)),\n        (\"Tcaron;\", (356, 0)),\n        (\"Igrav\", (0, 0)),\n        (\"nexis\", (0, 0)),\n        (\"NegativeMediu\", (0, 0)),\n        (\"otimes\", (0, 0)),\n        (\"wop\", (0, 0)),\n        (\"trianglel\", (0, 0)),\n        (\"bscr;\", (119991, 0)),\n        (\"oline;\", (8254, 0)),\n        (\"Coprodu\", (0, 0)),\n        (\"plusaci\", (0, 0)),\n        (\"lrar\", (0, 0)),\n        (\"Center\", (0, 0)),\n        (\"fno\", (0, 0)),\n        (\"nsh\", (0, 0)),\n        (\"Ouml;\", (214, 0)),\n        (\"nced\", (0, 0)),\n        (\"NotSuper\", (0, 0)),\n        (\"cd\", (0, 0)),\n        (\"longrightarr\", (0, 0)),\n        (\"supdsu\", (0, 0)),\n        (\"nvlt;\", (60, 8402)),\n        (\"Eacu\", (0, 0)),\n        (\"expect\", (0, 0)),\n        (\"Am\", (0, 0)),\n        (\"InvisibleTim\", (0, 0)),\n        (\"midcir\", (0, 0)),\n        (\"setminu\", (0, 0)),\n        (\"larrpl\", (0, 0)),\n        (\"larrpl;\", (10553, 0)),\n        (\"roang\", (0, 0)),\n        (\"App\", (0, 0)),\n        (\"NotGreaterTil\", (0, 0)),\n        (\"rbrks\", (0, 0)),\n        (\"VeryThinSpa\", (0, 0)),\n        (\"lthre\", (0, 0)),\n        (\"rla\", (0, 0)),\n        (\"lsaqu\", (0, 0)),\n        (\"NotGreaterSl\", (0, 0)),\n        (\"angmsdaa;\", (10664, 0)),\n        (\"NotSquar\", (0, 0)),\n        (\"LeftAr\", (0, 0)),\n        (\"us\", (0, 0)),\n        (\"ecar\", (0, 0)),\n        (\"Diffe\", (0, 0)),\n        (\"gneq;\", (10888, 0)),\n        (\"esd\", (0, 0)),\n        (\"DoubleUpDow\", (0, 0)),\n        (\"varphi;\", (981, 0)),\n        (\"ntgl\", (0, 0)),\n        (\"Imac\", (0, 0)),\n        (\"til\", (0, 0)),\n        (\"frasl;\", (8260, 0)),\n        (\"caps;\", (8745, 65024)),\n        (\"Uacu\", (0, 0)),\n        (\"models;\", (8871, 0)),\n        (\"RoundIm\", (0, 0)),\n        (\"Otil\", (0, 0)),\n        (\"Barv;\", (10983, 0)),\n        (\"lBarr;\", (10510, 0)),\n        (\"Rightar\", (0, 0)),\n        (\"clubsuit;\", (9827, 0)),\n        (\"minusd;\", (8760, 0)),\n        (\"rmousta\", (0, 0)),\n        (\"bsime;\", (8909, 0)),\n        (\"TildeTilde;\", (8776, 0)),\n        (\"acut\", (0, 0)),\n        (\"NotGreaterEqual;\", (8817, 0)),\n        (\"gcir\", (0, 0)),\n        (\"subedot;\", (10947, 0)),\n        (\"Epsi\", (0, 0)),\n        (\"rightarrowtail;\", (8611, 0)),\n        (\"quatin\", (0, 0)),\n        (\"boxDl\", (0, 0)),\n        (\"hookri\", (0, 0)),\n        (\"circledci\", (0, 0)),\n        (\"HumpDownHum\", (0, 0)),\n        (\"nvle;\", (8804, 8402)),\n        (\"longleftrighta\", (0, 0)),\n        (\"measuredangl\", (0, 0)),\n        (\"dA\", (0, 0)),\n        (\"circledS\", (0, 0)),\n        (\"iecy;\", (1077, 0)),\n        (\"qint\", (0, 0)),\n        (\"SmallCi\", (0, 0)),\n        (\"rcy;\", (1088, 0)),\n        (\"period\", (0, 0)),\n        (\"Ug\", (0, 0)),\n        (\"measur\", (0, 0)),\n        (\"umacr;\", (363, 0)),\n        (\"is\", (0, 0)),\n        (\"backsi\", (0, 0)),\n        (\"SmallC\", (0, 0)),\n        (\"auml\", (228, 0)),\n        (\"bigoplus;\", (10753, 0)),\n        (\"drcorn\", (0, 0)),\n        (\"ShortUpArrow;\", (8593, 0)),\n        (\"rppolin\", (0, 0)),\n        (\"Counte\", (0, 0)),\n        (\"DownRightTe\", (0, 0)),\n        (\"eplu\", (0, 0)),\n        (\"boxVh\", (0, 0)),\n        (\"vBar\", (0, 0)),\n        (\"perp;\", (8869, 0)),\n        (\"Lcedil\", (0, 0)),\n        (\"downharpoonri\", (0, 0)),\n        (\"rdqu\", (0, 0)),\n        (\"ContourInteg\", (0, 0)),\n        (\"ecirc\", (234, 0)),\n        (\"dotsqu\", (0, 0)),\n        (\"mstpos\", (0, 0)),\n        (\"CloseCurlyDouble\", (0, 0)),\n        (\"Delta\", (0, 0)),\n        (\"llc\", (0, 0)),\n        (\"NotSquareSubsetEqual\", (0, 0)),\n        (\"Umacr\", (0, 0)),\n        (\"LeftDownVectorB\", (0, 0)),\n        (\"Ncedil\", (0, 0)),\n        (\"trimi\", (0, 0)),\n        (\"andsl\", (0, 0)),\n        (\"rAarr;\", (8667, 0)),\n        (\"seA\", (0, 0)),\n        (\"Small\", (0, 0)),\n        (\"Vcy\", (0, 0)),\n        (\"coloneq;\", (8788, 0)),\n        (\"Verbar\", (0, 0)),\n        (\"rdca\", (0, 0)),\n        (\"SmallCircle\", (0, 0)),\n        (\"ye\", (0, 0)),\n        (\"bl\", (0, 0)),\n        (\"pho\", (0, 0)),\n        (\"amacr;\", (257, 0)),\n        (\"MinusPlus\", (0, 0)),\n        (\"lbrace\", (0, 0)),\n        (\"Sub;\", (8912, 0)),\n        (\"nlArr\", (0, 0)),\n        (\"zigr\", (0, 0)),\n        (\"Lap\", (0, 0)),\n        (\"Poinc\", (0, 0)),\n        (\"longr\", (0, 0)),\n        (\"DiacriticalDou\", (0, 0)),\n        (\"Bf\", (0, 0)),\n        (\"ltrif;\", (9666, 0)),\n        (\"varthet\", (0, 0)),\n        (\"thin\", (0, 0)),\n        (\"NotLeftTriangleBar\", (0, 0)),\n        (\"ogr\", (0, 0)),\n        (\"LessGr\", (0, 0)),\n        (\"complex\", (0, 0)),\n        (\"VerticalTilde;\", (8768, 0)),\n        (\"half;\", (189, 0)),\n        (\"NotSubsetEqual\", (0, 0)),\n        (\"frac58;\", (8541, 0)),\n        (\"napid;\", (8779, 824)),\n        (\"Gb\", (0, 0)),\n        (\"rbrksld;\", (10638, 0)),\n        (\"nL\", (0, 0)),\n        (\"rrarr\", (0, 0)),\n        (\"vBa\", (0, 0)),\n        (\"NotGreaterFu\", (0, 0)),\n        (\"DownLeftRightVect\", (0, 0)),\n        (\"circl\", (0, 0)),\n        (\"xsqc\", (0, 0)),\n        (\"harrw;\", (8621, 0)),\n        (\"PrecedesSlantEqu\", (0, 0)),\n        (\"ar\", (0, 0)),\n        (\"TildeFu\", (0, 0)),\n        (\"triangleleft;\", (9667, 0)),\n        (\"Superse\", (0, 0)),\n        (\"ltri\", (0, 0)),\n        (\"Ugrav\", (0, 0)),\n        (\"mopf;\", (120158, 0)),\n        (\"fallingdo\", (0, 0)),\n        (\"Gcir\", (0, 0)),\n        (\"zscr\", (0, 0)),\n        (\"iopf;\", (120154, 0)),\n        (\"ltrPar\", (0, 0)),\n        (\"bigtriangleup;\", (9651, 0)),\n        (\"setminus\", (0, 0)),\n        (\"yum\", (0, 0)),\n        (\"ration\", (0, 0)),\n        (\"rhar\", (0, 0)),\n        (\"Partial\", (0, 0)),\n        (\"updowna\", (0, 0)),\n        (\"UnderBracket;\", (9141, 0)),\n        (\"topb\", (0, 0)),\n        (\"Iukcy;\", (1030, 0)),\n        (\"asympe\", (0, 0)),\n        (\"notin;\", (8713, 0)),\n        (\"scsi\", (0, 0)),\n        (\"UnderParenthesis\", (0, 0)),\n        (\"cudarrr;\", (10549, 0)),\n        (\"bo\", (0, 0)),\n        (\"tc\", (0, 0)),\n        (\"urcr\", (0, 0)),\n        (\"gfr\", (0, 0)),\n        (\"NotNestedLess\", (0, 0)),\n        (\"xrA\", (0, 0)),\n        (\"wr\", (0, 0)),\n        (\"nequiv;\", (8802, 0)),\n        (\"NonBreakingSpac\", (0, 0)),\n        (\"bempty\", (0, 0)),\n        (\"ogo\", (0, 0)),\n        (\"Assig\", (0, 0)),\n        (\"Sce\", (0, 0)),\n        (\"plustw\", (0, 0)),\n        (\"lrco\", (0, 0)),\n        (\"NotLeftTr\", (0, 0)),\n        (\"tfr;\", (120113, 0)),\n        (\"subsup\", (0, 0)),\n        (\"kop\", (0, 0)),\n        (\"phon\", (0, 0)),\n        (\"doublebar\", (0, 0)),\n        (\"oror;\", (10838, 0)),\n        (\"veeba\", (0, 0)),\n        (\"Itilde\", (0, 0)),\n        (\"xlAr\", (0, 0)),\n        (\"kced\", (0, 0)),\n        (\"ShortDown\", (0, 0)),\n        (\"rd\", (0, 0)),\n        (\"NoBreak\", (0, 0)),\n        (\"NotTildeEqu\", (0, 0)),\n        (\"caron\", (0, 0)),\n        (\"expectatio\", (0, 0)),\n        (\"UnderParenthes\", (0, 0)),\n        (\"Backslas\", (0, 0)),\n        (\"Ccon\", (0, 0)),\n        (\"varepsilon\", (0, 0)),\n        (\"YUcy;\", (1070, 0)),\n        (\"urcor\", (0, 0)),\n        (\"MinusPl\", (0, 0)),\n        (\"CircleTime\", (0, 0)),\n        (\"SquareSub\", (0, 0)),\n        (\"Ucy;\", (1059, 0)),\n        (\"hopf\", (0, 0)),\n        (\"NotDouble\", (0, 0)),\n        (\"Dagger;\", (8225, 0)),\n        (\"leqq\", (0, 0)),\n        (\"Fo\", (0, 0)),\n        (\"srarr;\", (8594, 0)),\n        (\"NegativeVe\", (0, 0)),\n        (\"operp\", (0, 0)),\n        (\"RightTriangleE\", (0, 0)),\n        (\"ccaro\", (0, 0)),\n        (\"NotVerticalBa\", (0, 0)),\n        (\"profs\", (0, 0)),\n        (\"PrecedesSlantE\", (0, 0)),\n        (\"UnderParenthe\", (0, 0)),\n        (\"tstr\", (0, 0)),\n        (\"NotRightTriangleBa\", (0, 0)),\n        (\"ccupssm;\", (10832, 0)),\n        (\"vartriangleleft;\", (8882, 0)),\n        (\"eqslant\", (0, 0)),\n        (\"flat\", (0, 0)),\n        (\"eqslantless\", (0, 0)),\n        (\"nvrtrie\", (0, 0)),\n        (\"mea\", (0, 0)),\n        (\"DoubleCo\", (0, 0)),\n        (\"twoheadleftar\", (0, 0)),\n        (\"uw\", (0, 0)),\n        (\"RightDoubleBracke\", (0, 0)),\n        (\"ShortUpArrow\", (0, 0)),\n        (\"rbrack\", (0, 0)),\n        (\"lrm\", (0, 0)),\n        (\"LeftTeeV\", (0, 0)),\n        (\"GreaterGreat\", (0, 0)),\n        (\"nvi\", (0, 0)),\n        (\"RightUpVecto\", (0, 0)),\n        (\"ntrianglerighte\", (0, 0)),\n        (\"Osla\", (0, 0)),\n        (\"Rang;\", (10219, 0)),\n        (\"thicksi\", (0, 0)),\n        (\"Squ\", (0, 0)),\n        (\"nwnea\", (0, 0)),\n        (\"Sqrt;\", (8730, 0)),\n        (\"nvDash\", (0, 0)),\n        (\"Differen\", (0, 0)),\n        (\"harrci\", (0, 0)),\n        (\"oa\", (0, 0)),\n        (\"aacute;\", (225, 0)),\n        (\"rdl\", (0, 0)),\n        (\"qfr;\", (120110, 0)),\n        (\"tint;\", (8749, 0)),\n        (\"NotRightTriangleB\", (0, 0)),\n        (\"bN\", (0, 0)),\n        (\"napos;\", (329, 0)),\n        (\"lfr\", (0, 0)),\n        (\"Zcy;\", (1047, 0)),\n        (\"smallsetminus\", (0, 0)),\n        (\"supm\", (0, 0)),\n        (\"plusm\", (0, 0)),\n        (\"downharp\", (0, 0)),\n        (\"LeftDownVect\", (0, 0)),\n        (\"nap;\", (8777, 0)),\n        (\"Diacritical\", (0, 0)),\n        (\"leftrightharpoon\", (0, 0)),\n        (\"Coproduct\", (0, 0)),\n        (\"duha\", (0, 0)),\n        (\"Hump\", (0, 0)),\n        (\"isinsv;\", (8947, 0)),\n        (\"hardcy;\", (1098, 0)),\n        (\"oacut\", (0, 0)),\n        (\"blackloze\", (0, 0)),\n        (\"xwe\", (0, 0)),\n        (\"sup1;\", (185, 0)),\n        (\"DiacriticalAc\", (0, 0)),\n        (\"left\", (0, 0)),\n        (\"Oa\", (0, 0)),\n        (\"udha\", (0, 0)),\n        (\"nge\", (0, 0)),\n        (\"Coproduc\", (0, 0)),\n        (\"hyphen;\", (8208, 0)),\n        (\"RightTriangleBa\", (0, 0)),\n        (\"intlar\", (0, 0)),\n        (\"Zdot;\", (379, 0)),\n        (\"DiacriticalDoubleAcut\", (0, 0)),\n        (\"ShortR\", (0, 0)),\n        (\"bkarow\", (0, 0)),\n        (\"th\", (0, 0)),\n        (\"lar\", (0, 0)),\n        (\"cud\", (0, 0)),\n        (\"ne;\", (8800, 0)),\n        (\"RightAn\", (0, 0)),\n        (\"vD\", (0, 0)),\n        (\"downharpoonleft\", (0, 0)),\n        (\"pitchfo\", (0, 0)),\n        (\"lozenge\", (0, 0)),\n        (\"mn\", (0, 0)),\n        (\"Z\", (0, 0)),\n        (\"expectat\", (0, 0)),\n        (\"Horizon\", (0, 0)),\n        (\"Tcedil;\", (354, 0)),\n        (\"trid\", (0, 0)),\n        (\"NotLessLe\", (0, 0)),\n        (\"prim\", (0, 0)),\n        (\"ReverseEqu\", (0, 0)),\n        (\"Utilde;\", (360, 0)),\n        (\"omacr\", (0, 0)),\n        (\"mapstodow\", (0, 0)),\n        (\"cemptyv\", (0, 0)),\n        (\"UpArrow\", (0, 0)),\n        (\"qf\", (0, 0)),\n        (\"J\", (0, 0)),\n        (\"diamon\", (0, 0)),\n        (\"HorizontalLi\", (0, 0)),\n        (\"Sqrt\", (0, 0)),\n        (\"kap\", (0, 0)),\n        (\"CloseCurlyQ\", (0, 0)),\n        (\"EqualTil\", (0, 0)),\n        (\"fallingdotse\", (0, 0)),\n        (\"gE\", (0, 0)),\n        (\"sqsubset\", (0, 0)),\n        (\"FilledVerySmallSqua\", (0, 0)),\n        (\"UpperRightA\", (0, 0)),\n        (\"NotVerti\", (0, 0)),\n        (\"ntlg\", (0, 0)),\n        (\"pm\", (0, 0)),\n        (\"DiacriticalDouble\", (0, 0)),\n        (\"NotTildeFu\", (0, 0)),\n        (\"xharr;\", (10231, 0)),\n        (\"leqslant\", (0, 0)),\n        (\"DZ\", (0, 0)),\n        (\"twoheadleftarrow;\", (8606, 0)),\n        (\"Ic\", (0, 0)),\n        (\"DownR\", (0, 0)),\n        (\"realpar\", (0, 0)),\n        (\"Neste\", (0, 0)),\n        (\"nvltrie;\", (8884, 8402)),\n        (\"lcedil;\", (316, 0)),\n        (\"lur\", (0, 0)),\n        (\"NotSucceedsEqua\", (0, 0)),\n        (\"gtrle\", (0, 0)),\n        (\"qu\", (0, 0)),\n        (\"RightTriangleEqu\", (0, 0)),\n        (\"ReverseEqui\", (0, 0)),\n        (\"Gcedi\", (0, 0)),\n        (\"chi;\", (967, 0)),\n        (\"thorn\", (254, 0)),\n        (\"iinfi\", (0, 0)),\n        (\"midc\", (0, 0)),\n        (\"HilbertSpace\", (0, 0)),\n        (\"lnappro\", (0, 0)),\n        (\"cy\", (0, 0)),\n        (\"marke\", (0, 0)),\n        (\"lrtri;\", (8895, 0)),\n        (\"smashp\", (0, 0)),\n        (\"RightUpVectorBar\", (0, 0)),\n        (\"ngt\", (0, 0)),\n        (\"jcirc\", (0, 0)),\n        (\"Epsilo\", (0, 0)),\n        (\"GreaterTi\", (0, 0)),\n        (\"oacute;\", (243, 0)),\n        (\"tritime\", (0, 0)),\n        (\"iogo\", (0, 0)),\n        (\"looparrowr\", (0, 0)),\n        (\"Lac\", (0, 0)),\n        (\"vsupnE\", (0, 0)),\n        (\"cura\", (0, 0)),\n        (\"circ;\", (710, 0)),\n        (\"dzcy\", (0, 0)),\n        (\"napprox;\", (8777, 0)),\n        (\"ncongdot;\", (10861, 824)),\n        (\"DoubleLeftRightAr\", (0, 0)),\n        (\"Vertic\", (0, 0)),\n        (\"npart\", (0, 0)),\n        (\"triminus\", (0, 0)),\n        (\"egsdot;\", (10904, 0)),\n        (\"hfr\", (0, 0)),\n        (\"longleftri\", (0, 0)),\n        (\"rsquor\", (0, 0)),\n        (\"DownLeftTeeVec\", (0, 0)),\n        (\"zdot\", (0, 0)),\n        (\"SHCHcy\", (0, 0)),\n        (\"Intersec\", (0, 0)),\n        (\"An\", (0, 0)),\n        (\"ccirc;\", (265, 0)),\n        (\"swarro\", (0, 0)),\n        (\"quest\", (0, 0)),\n        (\"frac35\", (0, 0)),\n        (\"PrecedesSlantEqual\", (0, 0)),\n        (\"sbquo;\", (8218, 0)),\n        (\"imacr;\", (299, 0)),\n        (\"twoheadleftarr\", (0, 0)),\n        (\"leftthreetimes\", (0, 0)),\n        (\"sigma;\", (963, 0)),\n        (\"boxh\", (0, 0)),\n        (\"SquareSuperset;\", (8848, 0)),\n        (\"eqsl\", (0, 0)),\n        (\"circeq\", (0, 0)),\n        (\"lesseqgt\", (0, 0)),\n        (\"ufis\", (0, 0)),\n        (\"nsubseteqq\", (0, 0)),\n        (\"veebar\", (0, 0)),\n        (\"bigotimes;\", (10754, 0)),\n        (\"brvb\", (0, 0)),\n        (\"LeftTeeArrow;\", (8612, 0)),\n        (\"barw\", (0, 0)),\n        (\"rAtail\", (0, 0)),\n        (\"DownBrev\", (0, 0)),\n        (\"fo\", (0, 0)),\n        (\"Exists;\", (8707, 0)),\n        (\"equals;\", (61, 0)),\n        (\"upha\", (0, 0)),\n        (\"Proport\", (0, 0)),\n        (\"vel\", (0, 0)),\n        (\"subp\", (0, 0)),\n        (\"Gf\", (0, 0)),\n        (\"hoarr\", (0, 0)),\n        (\"thksim\", (0, 0)),\n        (\"atil\", (0, 0)),\n        (\"nleqslant\", (0, 0)),\n        (\"mscr;\", (120002, 0)),\n        (\"lsime;\", (10893, 0)),\n        (\"Hstr\", (0, 0)),\n        (\"yfr;\", (120118, 0)),\n        (\"UpArrowBa\", (0, 0)),\n        (\"filig\", (0, 0)),\n        (\"DoubleLeftRight\", (0, 0)),\n        (\"gci\", (0, 0)),\n        (\"dbkarow\", (0, 0)),\n        (\"lEg\", (0, 0)),\n        (\"bprime\", (0, 0)),\n        (\"nearrow\", (0, 0)),\n        (\"HumpEq\", (0, 0)),\n        (\"forkv;\", (10969, 0)),\n        (\"Igra\", (0, 0)),\n        (\"Bet\", (0, 0)),\n        (\"RightArrowLeft\", (0, 0)),\n        (\"RightDownTeeVector;\", (10589, 0)),\n        (\"CO\", (0, 0)),\n        (\"rarrtl\", (0, 0)),\n        (\"CapitalDi\", (0, 0)),\n        (\"TripleD\", (0, 0)),\n        (\"xcup;\", (8899, 0)),\n        (\"sci\", (0, 0)),\n        (\"Short\", (0, 0)),\n        (\"bdquo\", (0, 0)),\n        (\"zcar\", (0, 0)),\n        (\"RightCeiling;\", (8969, 0)),\n        (\"lcei\", (0, 0)),\n        (\"ijl\", (0, 0)),\n        (\"dlcorn;\", (8990, 0)),\n        (\"circlea\", (0, 0)),\n        (\"risingd\", (0, 0)),\n        (\"Cd\", (0, 0)),\n        (\"Rsc\", (0, 0)),\n        (\"NotPrecedesSlantEqu\", (0, 0)),\n        (\"thi\", (0, 0)),\n        (\"efD\", (0, 0)),\n        (\"LessEqualGr\", (0, 0)),\n        (\"Dstrok;\", (272, 0)),\n        (\"Iogo\", (0, 0)),\n        (\"Hacek\", (0, 0)),\n        (\"blacktri\", (0, 0)),\n        (\"Integral;\", (8747, 0)),\n        (\"lessgtr;\", (8822, 0)),\n        (\"notinE;\", (8953, 824)),\n        (\"xci\", (0, 0)),\n        (\"LeftT\", (0, 0)),\n        (\"esdo\", (0, 0)),\n        (\"GreaterSlant\", (0, 0)),\n        (\"NotGreaterTild\", (0, 0)),\n        (\"DoubleLeftRightArrow\", (0, 0)),\n        (\"nLeftarrow\", (0, 0)),\n        (\"supsub\", (0, 0)),\n        (\"Uti\", (0, 0)),\n        (\"Longleftarr\", (0, 0)),\n        (\"hear\", (0, 0)),\n        (\"bigw\", (0, 0)),\n        (\"Sm\", (0, 0)),\n        (\"Hscr\", (0, 0)),\n        (\"iexc\", (0, 0)),\n        (\"Tfr;\", (120087, 0)),\n        (\"rac\", (0, 0)),\n        (\"supsi\", (0, 0)),\n        (\"cirfnint;\", (10768, 0)),\n        (\"lefta\", (0, 0)),\n        (\"lla\", (0, 0)),\n        (\"qopf;\", (120162, 0)),\n        (\"les;\", (10877, 0)),\n        (\"EmptyVerySmallSqua\", (0, 0)),\n        (\"NotDoubleVerticalBar;\", (8742, 0)),\n        (\"barvee\", (0, 0)),\n        (\"ccups;\", (10828, 0)),\n        (\"PartialD\", (0, 0)),\n        (\"telrec\", (0, 0)),\n        (\"boxVh;\", (9579, 0)),\n        (\"VeryTh\", (0, 0)),\n        (\"NotVertical\", (0, 0)),\n        (\"ShortDownAr\", (0, 0)),\n        (\"supsub;\", (10964, 0)),\n        (\"blacklozeng\", (0, 0)),\n        (\"nRightarrow\", (0, 0)),\n        (\"Osc\", (0, 0)),\n        (\"rbbrk\", (0, 0)),\n        (\"iii\", (0, 0)),\n        (\"Uscr;\", (119984, 0)),\n        (\"RightVector;\", (8640, 0)),\n        (\"geqs\", (0, 0)),\n        (\"Agra\", (0, 0)),\n        (\"FilledSm\", (0, 0)),\n        (\"rArr\", (0, 0)),\n        (\"Equal;\", (10869, 0)),\n        (\"NotSupersetEq\", (0, 0)),\n        (\"capcap\", (0, 0)),\n        (\"ntild\", (0, 0)),\n        (\"rtim\", (0, 0)),\n        (\"nvda\", (0, 0)),\n        (\"NestedLess\", (0, 0)),\n        (\"lnsim;\", (8934, 0)),\n        (\"ulcro\", (0, 0)),\n        (\"oscr;\", (8500, 0)),\n        (\"tcaron\", (0, 0)),\n        (\"CloseCurlyDoubl\", (0, 0)),\n        (\"sqcu\", (0, 0)),\n        (\"olcir;\", (10686, 0)),\n        (\"And\", (0, 0)),\n        (\"or;\", (8744, 0)),\n        (\"Scir\", (0, 0)),\n        (\"Leftrightarr\", (0, 0)),\n        (\"NotLessSlantEqu\", (0, 0)),\n        (\"Ecy;\", (1069, 0)),\n        (\"rti\", (0, 0)),\n        (\"gt\", (62, 0)),\n        (\"boxHu;\", (9575, 0)),\n        (\"napp\", (0, 0)),\n        (\"ocy\", (0, 0)),\n        (\"DDot\", (0, 0)),\n        (\"ques\", (0, 0)),\n        (\"ltdot\", (0, 0)),\n        (\"EqualTild\", (0, 0)),\n        (\"nleftrightarrow\", (0, 0)),\n        (\"twohead\", (0, 0)),\n        (\"Scirc;\", (348, 0)),\n        (\"fpar\", (0, 0)),\n        (\"UpArrowDownArrow;\", (8645, 0)),\n        (\"Aog\", (0, 0)),\n        (\"point\", (0, 0)),\n        (\"leftar\", (0, 0)),\n        (\"lbbrk\", (0, 0)),\n        (\"DoubleRightArr\", (0, 0)),\n        (\"CounterClockwiseContour\", (0, 0)),\n        (\"ldrdh\", (0, 0)),\n        (\"NotEqualTil\", (0, 0)),\n        (\"Sf\", (0, 0)),\n        (\"uci\", (0, 0)),\n        (\"rsc\", (0, 0)),\n        (\"Popf\", (0, 0)),\n        (\"NotSubsetEqual;\", (8840, 0)),\n        (\"swnwa\", (0, 0)),\n        (\"fop\", (0, 0)),\n        (\"ThickSpa\", (0, 0)),\n        (\"luruhar;\", (10598, 0)),\n        (\"nsim\", (0, 0)),\n        (\"po\", (0, 0)),\n        (\"Bumpeq;\", (8782, 0)),\n        (\"vare\", (0, 0)),\n        (\"gtre\", (0, 0)),\n        (\"downhar\", (0, 0)),\n        (\"Oopf\", (0, 0)),\n        (\"blacktriangled\", (0, 0)),\n        (\"UpTeeArrow\", (0, 0)),\n        (\"cuwe\", (0, 0)),\n        (\"oror\", (0, 0)),\n        (\"Exponentia\", (0, 0)),\n        (\"zacute\", (0, 0)),\n        (\"RightDo\", (0, 0)),\n        (\"gtreqless\", (0, 0)),\n        (\"Dif\", (0, 0)),\n        (\"Qo\", (0, 0)),\n        (\"vc\", (0, 0)),\n        (\"trp\", (0, 0)),\n        (\"nsqsube;\", (8930, 0)),\n        (\"downdownarrows;\", (8650, 0)),\n        (\"rt\", (0, 0)),\n        (\"CircleMin\", (0, 0)),\n        (\"Invi\", (0, 0)),\n        (\"so\", (0, 0)),\n        (\"rightl\", (0, 0)),\n        (\"boxHD\", (0, 0)),\n        (\"Upsilon;\", (933, 0)),\n        (\"omega\", (0, 0)),\n        (\"beth\", (0, 0)),\n        (\"mcomma;\", (10793, 0)),\n        (\"lac\", (0, 0)),\n        (\"rArr;\", (8658, 0)),\n        (\"alph\", (0, 0)),\n        (\"cupdot\", (0, 0)),\n        (\"bloc\", (0, 0)),\n        (\"mc\", (0, 0)),\n        (\"Lsc\", (0, 0)),\n        (\"ce\", (0, 0)),\n        (\"LessEqualGreate\", (0, 0)),\n        (\"imagpa\", (0, 0)),\n        (\"dotminus\", (0, 0)),\n        (\"tria\", (0, 0)),\n        (\"LeftCeiling;\", (8968, 0)),\n        (\"ccu\", (0, 0)),\n        (\"shortmid;\", (8739, 0)),\n        (\"mark\", (0, 0)),\n        (\"trianglelefte\", (0, 0)),\n        (\"qs\", (0, 0)),\n        (\"trianglelef\", (0, 0)),\n        (\"mal\", (0, 0)),\n        (\"Righta\", (0, 0)),\n        (\"checkmark;\", (10003, 0)),\n        (\"xsc\", (0, 0)),\n        (\"ksc\", (0, 0)),\n        (\"leftharp\", (0, 0)),\n        (\"ReverseEleme\", (0, 0)),\n        (\"fil\", (0, 0)),\n        (\"incare\", (0, 0)),\n        (\"angst;\", (197, 0)),\n        (\"NotGreaterGreate\", (0, 0)),\n        (\"varph\", (0, 0)),\n        (\"GreaterFullEq\", (0, 0)),\n        (\"NotSubsetE\", (0, 0)),\n        (\"tild\", (0, 0)),\n        (\"ClockwiseContourInte\", (0, 0)),\n        (\"LowerRigh\", (0, 0)),\n        (\"Greater\", (0, 0)),\n        (\"dfr\", (0, 0)),\n        (\"subE;\", (10949, 0)),\n        (\"rx\", (0, 0)),\n        (\"RightDoubleB\", (0, 0)),\n        (\"Alpha\", (0, 0)),\n        (\"blk12;\", (9618, 0)),\n        (\"DotEqual;\", (8784, 0)),\n        (\"LeftUp\", (0, 0)),\n        (\"NotPrecedesEqua\", (0, 0)),\n        (\"Nu\", (0, 0)),\n        (\"UnderPa\", (0, 0)),\n        (\"vzigza\", (0, 0)),\n        (\"nexists;\", (8708, 0)),\n        (\"leftarr\", (0, 0)),\n        (\"lesg\", (0, 0)),\n        (\"DoubleD\", (0, 0)),\n        (\"beta\", (0, 0)),\n        (\"LeftDownVectorBar;\", (10585, 0)),\n        (\"va\", (0, 0)),\n        (\"Longrightar\", (0, 0)),\n        (\"cuve\", (0, 0)),\n        (\"bot\", (0, 0)),\n        (\"bottom\", (0, 0)),\n        (\"Fou\", (0, 0)),\n        (\"blacksquare\", (0, 0)),\n        (\"SucceedsT\", (0, 0)),\n        (\"Nced\", (0, 0)),\n        (\"uscr;\", (120010, 0)),\n        (\"ddarr;\", (8650, 0)),\n        (\"gtreqless;\", (8923, 0)),\n        (\"congdot;\", (10861, 0)),\n        (\"deg;\", (176, 0)),\n        (\"ffil\", (0, 0)),\n        (\"gcy;\", (1075, 0)),\n        (\"xl\", (0, 0)),\n        (\"lan\", (0, 0)),\n        (\"le\", (0, 0)),\n        (\"NotTildeEq\", (0, 0)),\n        (\"ium\", (0, 0)),\n        (\"utrif;\", (9652, 0)),\n        (\"gj\", (0, 0)),\n        (\"CenterD\", (0, 0)),\n        (\"precneqq;\", (10933, 0)),\n        (\"Imagin\", (0, 0)),\n        (\"mult\", (0, 0)),\n        (\"rightth\", (0, 0)),\n        (\"NotPrecedes\", (0, 0)),\n        (\"boxur\", (0, 0)),\n        (\"Uparrow\", (0, 0)),\n        (\"pfr\", (0, 0)),\n        (\"ubrc\", (0, 0)),\n        (\"ang\", (0, 0)),\n        (\"NotEqua\", (0, 0)),\n        (\"UpDownArr\", (0, 0)),\n        (\"TildeFullEq\", (0, 0)),\n        (\"Hcirc\", (0, 0)),\n        (\"CloseCurlyDoubleQuote;\", (8221, 0)),\n        (\"Poincar\", (0, 0)),\n        (\"smallse\", (0, 0)),\n        (\"simp\", (0, 0)),\n        (\"leqsla\", (0, 0)),\n        (\"Rrig\", (0, 0)),\n        (\"uo\", (0, 0)),\n        (\"east\", (0, 0)),\n        (\"IOcy;\", (1025, 0)),\n        (\"LeftTeeAr\", (0, 0)),\n        (\"rarrhk\", (0, 0)),\n        (\"UpperLef\", (0, 0)),\n        (\"mum\", (0, 0)),\n        (\"gtque\", (0, 0)),\n        (\"DownLeftTeeVecto\", (0, 0)),\n        (\"Supset;\", (8913, 0)),\n        (\"NotHumpEqua\", (0, 0)),\n        (\"rightrighta\", (0, 0)),\n        (\"abreve\", (0, 0)),\n        (\"Lapla\", (0, 0)),\n        (\"bigsta\", (0, 0)),\n        (\"ell\", (0, 0)),\n        (\"RightCeilin\", (0, 0)),\n        (\"Longleftrightarr\", (0, 0)),\n        (\"rightsquigarr\", (0, 0)),\n        (\"iquest\", (191, 0)),\n        (\"UpT\", (0, 0)),\n        (\"supsup\", (0, 0)),\n        (\"ZeroW\", (0, 0)),\n        (\"shcy\", (0, 0)),\n        (\"mda\", (0, 0)),\n        (\"SucceedsSlantEqua\", (0, 0)),\n        (\"ncy;\", (1085, 0)),\n        (\"scs\", (0, 0)),\n        (\"SquareInters\", (0, 0)),\n        (\"rharul\", (0, 0)),\n        (\"Verti\", (0, 0)),\n        (\"updown\", (0, 0)),\n        (\"lstrok;\", (322, 0)),\n        (\"vartheta\", (0, 0)),\n        (\"nls\", (0, 0)),\n        (\"setmn\", (0, 0)),\n        (\"supE\", (0, 0)),\n        (\"bigop\", (0, 0)),\n        (\"DoubleLongLeftRightArrow;\", (10234, 0)),\n        (\"Vdash\", (0, 0)),\n        (\"dtrif\", (0, 0)),\n        (\"lozf;\", (10731, 0)),\n        (\"odash;\", (8861, 0)),\n        (\"larrtl;\", (8610, 0)),\n        (\"ClockwiseCont\", (0, 0)),\n        (\"Assi\", (0, 0)),\n        (\"udbl\", (0, 0)),\n        (\"Imagina\", (0, 0)),\n        (\"nleftrig\", (0, 0)),\n        (\"acE;\", (8766, 819)),\n        (\"gneqq;\", (8809, 0)),\n        (\"and;\", (8743, 0)),\n        (\"downharpoonright;\", (8642, 0)),\n        (\"diamondsuit\", (0, 0)),\n        (\"bigoplus\", (0, 0)),\n        (\"oint;\", (8750, 0)),\n        (\"cirfn\", (0, 0)),\n        (\"nleftrightarro\", (0, 0)),\n        (\"vellip;\", (8942, 0)),\n        (\"LessFullEq\", (0, 0)),\n        (\"blacktriangler\", (0, 0)),\n        (\"DiacriticalA\", (0, 0)),\n        (\"VDa\", (0, 0)),\n        (\"leftharpoonup;\", (8636, 0)),\n        (\"Na\", (0, 0)),\n        (\"VerticalLin\", (0, 0)),\n        (\"iscr;\", (119998, 0)),\n        (\"ndas\", (0, 0)),\n        (\"lnsi\", (0, 0)),\n        (\"langl\", (0, 0)),\n        (\"sext;\", (10038, 0)),\n        (\"DownRightVectorBar;\", (10583, 0)),\n        (\"ldrd\", (0, 0)),\n        (\"Zcaro\", (0, 0)),\n        (\"Cedilla;\", (184, 0)),\n        (\"NotGreaterE\", (0, 0)),\n        (\"Zacute\", (0, 0)),\n        (\"telr\", (0, 0)),\n        (\"xhAr\", (0, 0)),\n        (\"NotTildeFul\", (0, 0)),\n        (\"ContourI\", (0, 0)),\n        (\"varkappa\", (0, 0)),\n        (\"uArr;\", (8657, 0)),\n        (\"OpenCurlyDoubleQ\", (0, 0)),\n        (\"triangledown;\", (9663, 0)),\n        (\"ucy;\", (1091, 0)),\n        (\"scy;\", (1089, 0)),\n        (\"NotLessLess\", (0, 0)),\n        (\"tst\", (0, 0)),\n        (\"eDo\", (0, 0)),\n        (\"Ov\", (0, 0)),\n        (\"twixt\", (0, 0)),\n        (\"Poincareplane\", (0, 0)),\n        (\"frac7\", (0, 0)),\n        (\"xutri\", (0, 0)),\n        (\"boxh;\", (9472, 0)),\n        (\"lessapprox\", (0, 0)),\n        (\"eqslantgtr;\", (10902, 0)),\n        (\"ovb\", (0, 0)),\n        (\"intp\", (0, 0)),\n        (\"fc\", (0, 0)),\n        (\"topfork;\", (10970, 0)),\n        (\"nLeftrightarrow\", (0, 0)),\n        (\"hfr;\", (120101, 0)),\n        (\"lfloo\", (0, 0)),\n        (\"nsq\", (0, 0)),\n        (\"arin\", (0, 0)),\n        (\"plusc\", (0, 0)),\n        (\"nvH\", (0, 0)),\n        (\"preca\", (0, 0)),\n        (\"wedge\", (0, 0)),\n        (\"LeftDownTeeVector\", (0, 0)),\n        (\"GreaterGreate\", (0, 0)),\n        (\"quaternions\", (0, 0)),\n        (\"multim\", (0, 0)),\n        (\"lesse\", (0, 0)),\n        (\"r\", (0, 0)),\n        (\"thicka\", (0, 0)),\n        (\"LongLeftR\", (0, 0)),\n        (\"NotH\", (0, 0)),\n        (\"qscr\", (0, 0)),\n        (\"NotNestedL\", (0, 0)),\n        (\"Vv\", (0, 0)),\n        (\"dwangle\", (0, 0)),\n        (\"supmu\", (0, 0)),\n        (\"NotNestedLes\", (0, 0)),\n        (\"Ubrcy\", (0, 0)),\n        (\"percn\", (0, 0)),\n        (\"Uopf;\", (120140, 0)),\n        (\"cuwed\", (0, 0)),\n        (\"submult;\", (10945, 0)),\n        (\"nleftrightarr\", (0, 0)),\n        (\"vsubnE;\", (10955, 65024)),\n        (\"nlt\", (0, 0)),\n        (\"NegativeThinSpace;\", (8203, 0)),\n        (\"hk\", (0, 0)),\n        (\"DoubleDownA\", (0, 0)),\n        (\"Gd\", (0, 0)),\n        (\"blac\", (0, 0)),\n        (\"ng\", (0, 0)),\n        (\"LeftRightVecto\", (0, 0)),\n        (\"gamma;\", (947, 0)),\n        (\"bern\", (0, 0)),\n        (\"zcaron\", (0, 0)),\n        (\"gtrsi\", (0, 0)),\n        (\"Differ\", (0, 0)),\n        (\"swnw\", (0, 0)),\n        (\"divideon\", (0, 0)),\n        (\"SucceedsSlantEq\", (0, 0)),\n        (\"leftarrowt\", (0, 0)),\n        (\"Ver\", (0, 0)),\n        (\"Vee;\", (8897, 0)),\n        (\"Edot\", (0, 0)),\n        (\"ioc\", (0, 0)),\n        (\"nvgt\", (0, 0)),\n        (\"small\", (0, 0)),\n        (\"Melli\", (0, 0)),\n        (\"timesbar\", (0, 0)),\n        (\"curvearro\", (0, 0)),\n        (\"OpenCurlyQuote\", (0, 0)),\n        (\"jscr;\", (119999, 0)),\n        (\"equivDD;\", (10872, 0)),\n        (\"sbqu\", (0, 0)),\n        (\"longleftrightar\", (0, 0)),\n        (\"vark\", (0, 0)),\n        (\"vnsu\", (0, 0)),\n        (\"tprim\", (0, 0)),\n        (\"LessTi\", (0, 0)),\n        (\"Vfr\", (0, 0)),\n        (\"lrcorner;\", (8991, 0)),\n        (\"Scedil\", (0, 0)),\n        (\"hookrightar\", (0, 0)),\n        (\"circledcirc;\", (8858, 0)),\n        (\"hstrok\", (0, 0)),\n        (\"gtcc\", (0, 0)),\n        (\"blacksqu\", (0, 0)),\n        (\"FilledSmallSqu\", (0, 0)),\n        (\"pertenk\", (0, 0)),\n        (\"nsmi\", (0, 0)),\n        (\"omega;\", (969, 0)),\n        (\"Product;\", (8719, 0)),\n        (\"Omac\", (0, 0)),\n        (\"LeftDownTe\", (0, 0)),\n        (\"EqualTi\", (0, 0)),\n        (\"ohm\", (0, 0)),\n        (\"midast\", (0, 0)),\n        (\"curlywedge;\", (8911, 0)),\n        (\"complement;\", (8705, 0)),\n        (\"rtimes\", (0, 0)),\n        (\"Lcy\", (0, 0)),\n        (\"nldr\", (0, 0)),\n        (\"bigtriangledown;\", (9661, 0)),\n        (\"RightTriangleEqual\", (0, 0)),\n        (\"nedo\", (0, 0)),\n        (\"otimesas\", (0, 0)),\n        (\"Gfr;\", (120074, 0)),\n        (\"db\", (0, 0)),\n        (\"Odb\", (0, 0)),\n        (\"Copro\", (0, 0)),\n        (\"Cfr\", (0, 0)),\n        (\"leftrightsqui\", (0, 0)),\n        (\"ys\", (0, 0)),\n        (\"betw\", (0, 0)),\n        (\"DiacriticalGrave;\", (96, 0)),\n        (\"LeftRightVect\", (0, 0)),\n        (\"St\", (0, 0)),\n        (\"TildeFullEqu\", (0, 0)),\n        (\"rightharpoonup\", (0, 0)),\n        (\"Ifr\", (0, 0)),\n        (\"zhcy\", (0, 0)),\n        (\"rangle\", (0, 0)),\n        (\"Zsc\", (0, 0)),\n        (\"pluse;\", (10866, 0)),\n        (\"Subs\", (0, 0)),\n        (\"LeftUpDownVecto\", (0, 0)),\n        (\"CircleDot\", (0, 0)),\n        (\"Yc\", (0, 0)),\n        (\"backepsilon\", (0, 0)),\n        (\"vz\", (0, 0)),\n        (\"ReverseEquilib\", (0, 0)),\n        (\"CapitalDiff\", (0, 0)),\n        (\"varrho;\", (1009, 0)),\n        (\"lurdsha\", (0, 0)),\n        (\"gnap;\", (10890, 0)),\n        (\"if\", (0, 0)),\n        (\"rarrlp\", (0, 0)),\n        (\"gac\", (0, 0)),\n        (\"xodo\", (0, 0)),\n        (\"righth\", (0, 0)),\n        (\"NotSquareSupersetEqual;\", (8931, 0)),\n        (\"RightDownTeeVecto\", (0, 0)),\n        (\"Ove\", (0, 0)),\n        (\"dHar\", (0, 0)),\n        (\"New\", (0, 0)),\n        (\"Open\", (0, 0)),\n        (\"precnsim;\", (8936, 0)),\n        (\"CounterClockwiseContourIntegra\", (0, 0)),\n        (\"rightleftharpoo\", (0, 0)),\n        (\"Odbl\", (0, 0)),\n        (\"gtlPa\", (0, 0)),\n        (\"backcon\", (0, 0)),\n        (\"sqsup;\", (8848, 0)),\n        (\"mopf\", (0, 0)),\n        (\"kscr;\", (120000, 0)),\n        (\"nharr;\", (8622, 0)),\n        (\"Ima\", (0, 0)),\n        (\"TildeTilde\", (0, 0)),\n        (\"Conint\", (0, 0)),\n        (\"DownArrowUpArro\", (0, 0)),\n        (\"circlear\", (0, 0)),\n        (\"UpDownArrow\", (0, 0)),\n        (\"because\", (0, 0)),\n        (\"udarr;\", (8645, 0)),\n        (\"tcy;\", (1090, 0)),\n        (\"Fs\", (0, 0)),\n        (\"boxuL;\", (9563, 0)),\n        (\"Ls\", (0, 0)),\n        (\"af\", (0, 0)),\n        (\"Ko\", (0, 0)),\n        (\"jscr\", (0, 0)),\n        (\"Dopf;\", (120123, 0)),\n        (\"cscr\", (0, 0)),\n        (\"ldca\", (0, 0)),\n        (\"Poincareplan\", (0, 0)),\n        (\"igrav\", (0, 0)),\n        (\"nrightarro\", (0, 0)),\n        (\"sho\", (0, 0)),\n        (\"kappa\", (0, 0)),\n        (\"bemptyv;\", (10672, 0)),\n        (\"sigmaf;\", (962, 0)),\n        (\"era\", (0, 0)),\n        (\"pitchfor\", (0, 0)),\n        (\"Ubrcy;\", (1038, 0)),\n        (\"expectation\", (0, 0)),\n        (\"Arin\", (0, 0)),\n        (\"mac\", (0, 0)),\n        (\"Longleftright\", (0, 0)),\n        (\"lurdshar\", (0, 0)),\n        (\"cedil;\", (184, 0)),\n        (\"lsh;\", (8624, 0)),\n        (\"nrArr\", (0, 0)),\n        (\"rightlefth\", (0, 0)),\n        (\"supdot\", (0, 0)),\n        (\"NotGreaterLess;\", (8825, 0)),\n        (\"NegativeMedi\", (0, 0)),\n        (\"LeftAngleBrac\", (0, 0)),\n        (\"Ncedi\", (0, 0)),\n        (\"amac\", (0, 0)),\n        (\"diamondsui\", (0, 0)),\n        (\"Emacr;\", (274, 0)),\n        (\"NegativeThic\", (0, 0)),\n        (\"ggg\", (0, 0)),\n        (\"imacr\", (0, 0)),\n        (\"lesges\", (0, 0)),\n        (\"Agrave\", (192, 0)),\n        (\"Vop\", (0, 0)),\n        (\"forkv\", (0, 0)),\n        (\"uharl;\", (8639, 0)),\n        (\"rightarrowtail\", (0, 0)),\n        (\"hamilt;\", (8459, 0)),\n        (\"rmou\", (0, 0)),\n        (\"leqslan\", (0, 0)),\n        (\"rds\", (0, 0)),\n        (\"ccir\", (0, 0)),\n        (\"cwint\", (0, 0)),\n        (\"shortp\", (0, 0)),\n        (\"sung\", (0, 0)),\n        (\"TRAD\", (0, 0)),\n        (\"NotSqua\", (0, 0)),\n        (\"DownLef\", (0, 0)),\n        (\"aog\", (0, 0)),\n        (\"VeryThinSp\", (0, 0)),\n        (\"ShortLeftAr\", (0, 0)),\n        (\"divid\", (0, 0)),\n        (\"integ\", (0, 0)),\n        (\"UpperLeftArro\", (0, 0)),\n        (\"frac45;\", (8536, 0)),\n        (\"UpperRightArrow;\", (8599, 0)),\n        (\"hksea\", (0, 0)),\n        (\"notinva\", (0, 0)),\n        (\"NotEqu\", (0, 0)),\n        (\"fnof;\", (402, 0)),\n        (\"blk34;\", (9619, 0)),\n        (\"infint\", (0, 0)),\n        (\"nltri\", (0, 0)),\n        (\"RightAngleBra\", (0, 0)),\n        (\"HilbertSpace;\", (8459, 0)),\n        (\"Upsi\", (0, 0)),\n        (\"rightharpoon\", (0, 0)),\n        (\"curl\", (0, 0)),\n        (\"DownTeeArro\", (0, 0)),\n        (\"rho;\", (961, 0)),\n        (\"suphsol\", (0, 0)),\n        (\"alp\", (0, 0)),\n        (\"nleqslan\", (0, 0)),\n        (\"ring\", (0, 0)),\n        (\"bumpeq\", (0, 0)),\n        (\"Vs\", (0, 0)),\n        (\"LeftTrian\", (0, 0)),\n        (\"curren;\", (164, 0)),\n        (\"rarrpl\", (0, 0)),\n        (\"longma\", (0, 0)),\n        (\"DJcy\", (0, 0)),\n        (\"Ncaron;\", (327, 0)),\n        (\"Zopf\", (0, 0)),\n        (\"UnderBrace;\", (9183, 0)),\n        (\"Poincare\", (0, 0)),\n        (\"gsim;\", (8819, 0)),\n        (\"ENG\", (0, 0)),\n        (\"uuml;\", (252, 0)),\n        (\"NotHumpDo\", (0, 0)),\n        (\"NotLeftTriangleEqual;\", (8940, 0)),\n        (\"phone;\", (9742, 0)),\n        (\"Breve;\", (728, 0)),\n        (\"leqslant;\", (10877, 0)),\n        (\"LeftTriang\", (0, 0)),\n        (\"leftrigh\", (0, 0)),\n        (\"Rou\", (0, 0)),\n        (\"el\", (0, 0)),\n        (\"NotLeftTriangleEqual\", (0, 0)),\n        (\"et\", (0, 0)),\n        (\"Leftrigh\", (0, 0)),\n        (\"igr\", (0, 0)),\n        (\"eqslantgt\", (0, 0)),\n        (\"bigoti\", (0, 0)),\n        (\"tcedi\", (0, 0)),\n        (\"ReverseEquilibrium;\", (8651, 0)),\n        (\"minus\", (0, 0)),\n        (\"profalar\", (0, 0)),\n        (\"F\", (0, 0)),\n        (\"rsaq\", (0, 0)),\n        (\"ngeq;\", (8817, 0)),\n        (\"nwAr\", (0, 0)),\n        (\"nsmid;\", (8740, 0)),\n        (\"esc\", (0, 0)),\n        (\"angmsdag;\", (10670, 0)),\n        (\"s\", (0, 0)),\n        (\"ds\", (0, 0)),\n        (\"rmoustache\", (0, 0)),\n        (\"LongLeftAr\", (0, 0)),\n        (\"zopf;\", (120171, 0)),\n        (\"RightDoubleBrac\", (0, 0)),\n        (\"ddot\", (0, 0)),\n        (\"cupbr\", (0, 0)),\n        (\"DoubleLongLeftRig\", (0, 0)),\n        (\"NotGreaterEqu\", (0, 0)),\n        (\"ms\", (0, 0)),\n        (\"NotSupe\", (0, 0)),\n        (\"ForAll;\", (8704, 0)),\n        (\"Gci\", (0, 0)),\n        (\"Filled\", (0, 0)),\n        (\"fili\", (0, 0)),\n        (\"ofcir\", (0, 0)),\n        (\"DownArrowBar\", (0, 0)),\n        (\"ShortUp\", (0, 0)),\n        (\"Lleftarrow\", (0, 0)),\n        (\"lHar;\", (10594, 0)),\n        (\"upuparrows\", (0, 0)),\n        (\"LeftRig\", (0, 0)),\n        (\"conin\", (0, 0)),\n        (\"nume\", (0, 0)),\n        (\"rsquo;\", (8217, 0)),\n        (\"ucirc;\", (251, 0)),\n        (\"urcorn\", (0, 0)),\n        (\"Ran\", (0, 0)),\n        (\"nequi\", (0, 0)),\n        (\"radic;\", (8730, 0)),\n        (\"DiacriticalGr\", (0, 0)),\n        (\"tshcy;\", (1115, 0)),\n        (\"ber\", (0, 0)),\n        (\"Xopf\", (0, 0)),\n        (\"Horizont\", (0, 0)),\n        (\"coni\", (0, 0)),\n        (\"smte;\", (10924, 0)),\n        (\"DiacriticalDot;\", (729, 0)),\n        (\"rarrtl;\", (8611, 0)),\n        (\"scaron;\", (353, 0)),\n        (\"pit\", (0, 0)),\n        (\"DifferentialD\", (0, 0)),\n        (\"RightFlo\", (0, 0)),\n        (\"In\", (0, 0)),\n        (\"GreaterT\", (0, 0)),\n        (\"vrtri\", (0, 0)),\n        (\"swarrow;\", (8601, 0)),\n        (\"subplus;\", (10943, 0)),\n        (\"rotime\", (0, 0)),\n        (\"downdownarro\", (0, 0)),\n        (\"dcy\", (0, 0)),\n        (\"plusac\", (0, 0)),\n        (\"UpArrowDownArro\", (0, 0)),\n        (\"propt\", (0, 0)),\n        (\"kappa;\", (954, 0)),\n        (\"shor\", (0, 0)),\n        (\"NotTildeTilde\", (0, 0)),\n        (\"kgre\", (0, 0)),\n        (\"lbrks\", (0, 0)),\n        (\"LeftDoubleBracket;\", (10214, 0)),\n        (\"dlc\", (0, 0)),\n        (\"boxvl;\", (9508, 0)),\n        (\"starf;\", (9733, 0)),\n        (\"Tab;\", (9, 0)),\n        (\"efDo\", (0, 0)),\n        (\"nmid;\", (8740, 0)),\n        (\"cacu\", (0, 0)),\n        (\"CloseCurlyDo\", (0, 0)),\n        (\"ltque\", (0, 0)),\n        (\"Cs\", (0, 0)),\n        (\"NotEq\", (0, 0)),\n        (\"Epsil\", (0, 0)),\n        (\"nsqs\", (0, 0)),\n        (\"Abreve\", (0, 0)),\n        (\"ldrusha\", (0, 0)),\n        (\"oline\", (0, 0)),\n        (\"SquareSubsetEq\", (0, 0)),\n        (\"apos;\", (39, 0)),\n        (\"longm\", (0, 0)),\n        (\"notinvc;\", (8950, 0)),\n        (\"NotRightTriangleEq\", (0, 0)),\n        (\"vartriangleleft\", (0, 0)),\n        (\"leqs\", (0, 0)),\n        (\"Upp\", (0, 0)),\n        (\"tim\", (0, 0)),\n        (\"prns\", (0, 0)),\n        (\"NestedGreat\", (0, 0)),\n        (\"Lmi\", (0, 0)),\n        (\"OpenCurl\", (0, 0)),\n        (\"UnderParenthesi\", (0, 0)),\n        (\"bi\", (0, 0)),\n        (\"gtrapp\", (0, 0)),\n        (\"Cdot\", (0, 0)),\n        (\"gEl;\", (10892, 0)),\n        (\"Upa\", (0, 0)),\n        (\"dash\", (0, 0)),\n        (\"DoubleLongLeftArrow\", (0, 0)),\n        (\"rppolint;\", (10770, 0)),\n        (\"blacktr\", (0, 0)),\n        (\"bcon\", (0, 0)),\n        (\"sun\", (0, 0)),\n        (\"RightUpTee\", (0, 0)),\n        (\"KJcy\", (0, 0)),\n        (\"hybull;\", (8259, 0)),\n        (\"simdo\", (0, 0)),\n        (\"bigsqcup\", (0, 0)),\n        (\"leftharpoondown\", (0, 0)),\n        (\"NotSq\", (0, 0)),\n        (\"longleftarrow\", (0, 0)),\n        (\"supseteqq;\", (10950, 0)),\n        (\"NotNestedGreat\", (0, 0)),\n        (\"nsub;\", (8836, 0)),\n        (\"dstrok;\", (273, 0)),\n        (\"mh\", (0, 0)),\n        (\"eDot\", (0, 0)),\n        (\"Jopf\", (0, 0)),\n        (\"jci\", (0, 0)),\n        (\"nspar\", (0, 0)),\n        (\"notnivb\", (0, 0)),\n        (\"subrarr\", (0, 0)),\n        (\"lsaq\", (0, 0)),\n        (\"rfloor\", (0, 0)),\n        (\"ntria\", (0, 0)),\n        (\"Cdo\", (0, 0)),\n        (\"not\", (172, 0)),\n        (\"Omicron\", (0, 0)),\n        (\"Ugrave\", (217, 0)),\n        (\"NotSquareSupers\", (0, 0)),\n        (\"top;\", (8868, 0)),\n        (\"Rrigh\", (0, 0)),\n        (\"DoubleConto\", (0, 0)),\n        (\"lcy\", (0, 0)),\n        (\"SquareSubsetE\", (0, 0)),\n        (\"scirc;\", (349, 0)),\n        (\"Differenti\", (0, 0)),\n        (\"beta;\", (946, 0)),\n        (\"NotHumpDow\", (0, 0)),\n        (\"yopf;\", (120170, 0)),\n        (\"RightUp\", (0, 0)),\n        (\"urcrop\", (0, 0)),\n        (\"lozenge;\", (9674, 0)),\n        (\"interc\", (0, 0)),\n        (\"fflig;\", (64256, 0)),\n        (\"trie;\", (8796, 0)),\n        (\"lhard;\", (8637, 0)),\n        (\"imped\", (0, 0)),\n        (\"prime;\", (8242, 0)),\n        (\"Uacut\", (0, 0)),\n        (\"NotE\", (0, 0)),\n        (\"Hum\", (0, 0)),\n        (\"NegativeT\", (0, 0)),\n        (\"boxUr;\", (9561, 0)),\n        (\"Impl\", (0, 0)),\n        (\"gd\", (0, 0)),\n        (\"nappro\", (0, 0)),\n        (\"Nsc\", (0, 0)),\n        (\"Subset;\", (8912, 0)),\n        (\"nleftarro\", (0, 0)),\n        (\"leftleftar\", (0, 0)),\n        (\"Ccar\", (0, 0)),\n        (\"Laplace\", (0, 0)),\n        (\"DoubleUpAr\", (0, 0)),\n        (\"lmid\", (0, 0)),\n        (\"Barv\", (0, 0)),\n        (\"THORN\", (222, 0)),\n        (\"infintie;\", (10717, 0)),\n        (\"mlc\", (0, 0)),\n        (\"Abr\", (0, 0)),\n        (\"Lef\", (0, 0)),\n        (\"downharpoonrigh\", (0, 0)),\n        (\"bigvee\", (0, 0)),\n        (\"fjlig;\", (102, 106)),\n        (\"Iscr\", (0, 0)),\n        (\"NotLeft\", (0, 0)),\n        (\"GreaterFullEqual\", (0, 0)),\n        (\"YI\", (0, 0)),\n        (\"NotPrecedesSlantEqual\", (0, 0)),\n        (\"seswar\", (0, 0)),\n        (\"Eps\", (0, 0)),\n        (\"FilledV\", (0, 0)),\n        (\"Integr\", (0, 0)),\n        (\"zeetr\", (0, 0)),\n        (\"subsim\", (0, 0)),\n        (\"ntriangleright\", (0, 0)),\n        (\"doteqdo\", (0, 0)),\n        (\"RightVectorBa\", (0, 0)),\n        (\"jmath\", (0, 0)),\n        (\"an\", (0, 0)),\n        (\"NotSquareSubset\", (0, 0)),\n        (\"nhpar;\", (10994, 0)),\n        (\"nLeftarr\", (0, 0)),\n        (\"vareps\", (0, 0)),\n        (\"frasl\", (0, 0)),\n        (\"CircleP\", (0, 0)),\n        (\"Empt\", (0, 0)),\n        (\"LeftAngleBracket\", (0, 0)),\n        (\"ec\", (0, 0)),\n        (\"perc\", (0, 0)),\n        (\"cent\", (162, 0)),\n        (\"rbrksld\", (0, 0)),\n        (\"Uarr\", (0, 0)),\n        (\"Integ\", (0, 0)),\n        (\"Ffr\", (0, 0)),\n        (\"Dow\", (0, 0)),\n        (\"Ncy;\", (1053, 0)),\n        (\"oac\", (0, 0)),\n        (\"Jci\", (0, 0)),\n        (\"z\", (0, 0)),\n        (\"intlarhk\", (0, 0)),\n        (\"psc\", (0, 0)),\n        (\"Sca\", (0, 0)),\n        (\"THOR\", (0, 0)),\n        (\"ogon;\", (731, 0)),\n        (\"EmptySma\", (0, 0)),\n        (\"ratail;\", (10522, 0)),\n        (\"roplu\", (0, 0)),\n        (\"loplus\", (0, 0)),\n        (\"subseteq;\", (8838, 0)),\n        (\"bsolb\", (0, 0)),\n        (\"subsete\", (0, 0)),\n        (\"notnivb;\", (8958, 0)),\n        (\"lopl\", (0, 0)),\n        (\"Inv\", (0, 0)),\n        (\"gop\", (0, 0)),\n        (\"NotC\", (0, 0)),\n        (\"Es\", (0, 0)),\n        (\"Over\", (0, 0)),\n        (\"Downarrow;\", (8659, 0)),\n        (\"bigtriangle\", (0, 0)),\n        (\"varpropto\", (0, 0)),\n        (\"nltrie;\", (8940, 0)),\n        (\"vellip\", (0, 0)),\n        (\"supsetneq;\", (8843, 0)),\n        (\"LJcy\", (0, 0)),\n        (\"homtht;\", (8763, 0)),\n        (\"Equilibr\", (0, 0)),\n        (\"NotNestedGreaterGrea\", (0, 0)),\n        (\"en\", (0, 0)),\n        (\"LeftFloo\", (0, 0)),\n        (\"cross;\", (10007, 0)),\n        (\"Vertica\", (0, 0)),\n        (\"biguplus;\", (10756, 0)),\n        (\"plu\", (0, 0)),\n        (\"RightUpTeeVe\", (0, 0)),\n        (\"rbb\", (0, 0)),\n        (\"nLeftr\", (0, 0)),\n        (\"Ele\", (0, 0)),\n        (\"gtreqqle\", (0, 0)),\n        (\"straightphi\", (0, 0)),\n        (\"longleftarro\", (0, 0)),\n        (\"lrcorne\", (0, 0)),\n        (\"ropar\", (0, 0)),\n        (\"kcedi\", (0, 0)),\n        (\"Wedg\", (0, 0)),\n        (\"hardcy\", (0, 0)),\n        (\"Rright\", (0, 0)),\n        (\"maps\", (0, 0)),\n        (\"nLl\", (0, 0)),\n        (\"realine;\", (8475, 0)),\n        (\"dcar\", (0, 0)),\n        (\"ddagger;\", (8225, 0)),\n        (\"lhblk\", (0, 0)),\n        (\"LeftTeeVec\", (0, 0)),\n        (\"Qopf\", (0, 0)),\n        (\"Mell\", (0, 0)),\n        (\"lr\", (0, 0)),\n        (\"twixt;\", (8812, 0)),\n        (\"lbrace;\", (123, 0)),\n        (\"csube\", (0, 0)),\n        (\"oacu\", (0, 0)),\n        (\"rarrpl;\", (10565, 0)),\n        (\"Aop\", (0, 0)),\n        (\"frow\", (0, 0)),\n        (\"simlE\", (0, 0)),\n        (\"DownRightVe\", (0, 0)),\n        (\"ClockwiseContourIntegr\", (0, 0)),\n        (\"LeftArrowRightA\", (0, 0)),\n        (\"supsim;\", (10952, 0)),\n        (\"boxHD;\", (9574, 0)),\n        (\"DownLeftTeeV\", (0, 0)),\n        (\"Proportional;\", (8733, 0)),\n        (\"CloseCurlyQuot\", (0, 0)),\n        (\"iuk\", (0, 0)),\n        (\"isindo\", (0, 0)),\n        (\"boxplus;\", (8862, 0)),\n        (\"Dou\", (0, 0)),\n        (\"diams;\", (9830, 0)),\n        (\"swa\", (0, 0)),\n        (\"compfn;\", (8728, 0)),\n        (\"eogo\", (0, 0)),\n        (\"LessEqu\", (0, 0)),\n        (\"UpArrowDown\", (0, 0)),\n        (\"rm\", (0, 0)),\n        (\"lnap;\", (10889, 0)),\n        (\"SOFTcy\", (0, 0)),\n        (\"curvearrowright\", (0, 0)),\n        (\"nld\", (0, 0)),\n        (\"dhar\", (0, 0)),\n        (\"GreaterFullEqua\", (0, 0)),\n        (\"long\", (0, 0)),\n        (\"integer\", (0, 0)),\n        (\"succneqq\", (0, 0)),\n        (\"SOFTcy;\", (1068, 0)),\n        (\"fallingdot\", (0, 0)),\n        (\"Such\", (0, 0)),\n        (\"eca\", (0, 0)),\n        (\"Produ\", (0, 0)),\n        (\"wr;\", (8768, 0)),\n        (\"SHCHcy;\", (1065, 0)),\n        (\"subsim;\", (10951, 0)),\n        (\"tris\", (0, 0)),\n        (\"UpTee\", (0, 0)),\n        (\"DownRightTeeVect\", (0, 0)),\n        (\"No\", (0, 0)),\n        (\"compl\", (0, 0)),\n        (\"NotDoubleVertic\", (0, 0)),\n        (\"nvge;\", (8805, 8402)),\n        (\"psi;\", (968, 0)),\n        (\"cci\", (0, 0)),\n        (\"x\", (0, 0)),\n        (\"rtrie\", (0, 0)),\n        (\"Udb\", (0, 0)),\n        (\"ZeroWidthSpace;\", (8203, 0)),\n        (\"nRight\", (0, 0)),\n        (\"hookrig\", (0, 0)),\n        (\"esim;\", (8770, 0)),\n        (\"Ugra\", (0, 0)),\n        (\"target\", (0, 0)),\n        (\"Gs\", (0, 0)),\n        (\"emsp;\", (8195, 0)),\n        (\"llarr;\", (8647, 0)),\n        (\"che\", (0, 0)),\n        (\"Implie\", (0, 0)),\n        (\"NotLessLes\", (0, 0)),\n        (\"RightUpDownVecto\", (0, 0)),\n        (\"nwarh\", (0, 0)),\n        (\"vs\", (0, 0)),\n        (\"lap\", (0, 0)),\n        (\"awint\", (0, 0)),\n        (\"omacr;\", (333, 0)),\n        (\"si\", (0, 0)),\n        (\"jfr\", (0, 0)),\n        (\"leftrightsquigarrow;\", (8621, 0)),\n        (\"RightDownTeeVec\", (0, 0)),\n        (\"sung;\", (9834, 0)),\n        (\"mstpo\", (0, 0)),\n        (\"dlcr\", (0, 0)),\n        (\"LowerRightAr\", (0, 0)),\n        (\"bb\", (0, 0)),\n        (\"ham\", (0, 0)),\n        (\"smas\", (0, 0)),\n        (\"nwA\", (0, 0)),\n        (\"cemp\", (0, 0)),\n        (\"LongLeftArrow\", (0, 0)),\n        (\"lesseqgtr\", (0, 0)),\n        (\"imof\", (0, 0)),\n        (\"between;\", (8812, 0)),\n        (\"NotPrecedesEq\", (0, 0)),\n        (\"nrA\", (0, 0)),\n        (\"UpperRig\", (0, 0)),\n        (\"CircleMinus\", (0, 0)),\n        (\"boxUl;\", (9564, 0)),\n        (\"mapst\", (0, 0)),\n        (\"KHc\", (0, 0)),\n        (\"SquareSupersetEqu\", (0, 0)),\n        (\"precnapprox\", (0, 0)),\n        (\"Eacute;\", (201, 0)),\n        (\"zacute;\", (378, 0)),\n        (\"Longrighta\", (0, 0)),\n        (\"nsccue;\", (8929, 0)),\n        (\"caro\", (0, 0)),\n        (\"NotGreaterTilde\", (0, 0)),\n        (\"jser\", (0, 0)),\n        (\"beps\", (0, 0)),\n        (\"Negati\", (0, 0)),\n        (\"ShortRightArrow;\", (8594, 0)),\n        (\"nLeftar\", (0, 0)),\n        (\"GreaterE\", (0, 0)),\n        (\"leftrig\", (0, 0)),\n        (\"LessSlantEq\", (0, 0)),\n        (\"ldrus\", (0, 0)),\n        (\"chcy\", (0, 0)),\n        (\"xdt\", (0, 0)),\n        (\"Gdot\", (0, 0)),\n        (\"blackloz\", (0, 0)),\n        (\"DoubleLeftRi\", (0, 0)),\n        (\"Sup;\", (8913, 0)),\n        (\"NotSu\", (0, 0)),\n        (\"Zeta\", (0, 0)),\n        (\"dcaron;\", (271, 0)),\n        (\"udb\", (0, 0)),\n        (\"leftleftarrow\", (0, 0)),\n        (\"Copf\", (0, 0)),\n        (\"NotSucceed\", (0, 0)),\n        (\"DotDot\", (0, 0)),\n        (\"NotVerticalB\", (0, 0)),\n        (\"Vvdash;\", (8874, 0)),\n        (\"trianglerighteq;\", (8885, 0)),\n        (\"szli\", (0, 0)),\n        (\"ntriangleright;\", (8939, 0)),\n        (\"short\", (0, 0)),\n        (\"mop\", (0, 0)),\n        (\"leftrightarrows;\", (8646, 0)),\n        (\"ufi\", (0, 0)),\n        (\"ReverseUpEquilibr\", (0, 0)),\n        (\"Gamma\", (0, 0)),\n        (\"NotLeftT\", (0, 0)),\n        (\"flat;\", (9837, 0)),\n        (\"Pre\", (0, 0)),\n        (\"looparrowright\", (0, 0)),\n        (\"glj\", (0, 0)),\n        (\"boxdL;\", (9557, 0)),\n        (\"ThickSp\", (0, 0)),\n        (\"shortparallel;\", (8741, 0)),\n        (\"dtdot\", (0, 0)),\n        (\"sfrow\", (0, 0)),\n        (\"UpperRightArr\", (0, 0)),\n        (\"suphsub\", (0, 0)),\n        (\"Gcy\", (0, 0)),\n        (\"otilde\", (245, 0)),\n        (\"ldrushar;\", (10571, 0)),\n        (\"nsmid\", (0, 0)),\n        (\"HumpEqual;\", (8783, 0)),\n        (\"THO\", (0, 0)),\n        (\"ReverseUpEquilibrium\", (0, 0)),\n        (\"nVD\", (0, 0)),\n        (\"CircleT\", (0, 0)),\n        (\"Tcaro\", (0, 0)),\n        (\"VerticalBar;\", (8739, 0)),\n        (\"LeftTriangle;\", (8882, 0)),\n        (\"divideont\", (0, 0)),\n        (\"Updown\", (0, 0)),\n        (\"Rcar\", (0, 0)),\n        (\"Dop\", (0, 0)),\n        (\"cues\", (0, 0)),\n        (\"odas\", (0, 0)),\n        (\"Rul\", (0, 0)),\n        (\"UnderParenthesis;\", (9181, 0)),\n        (\"checkm\", (0, 0)),\n        (\"OpenCurlyQuo\", (0, 0)),\n        (\"RoundImpl\", (0, 0)),\n        (\"Bar\", (0, 0)),\n        (\"OpenCurlyDoubleQuote\", (0, 0)),\n        (\"Cscr;\", (119966, 0)),\n        (\"sqsub;\", (8847, 0)),\n        (\"hsla\", (0, 0)),\n        (\"orderof;\", (8500, 0)),\n        (\"mfr\", (0, 0)),\n        (\"ldca;\", (10550, 0)),\n        (\"Jcir\", (0, 0)),\n        (\"yop\", (0, 0)),\n        (\"DoubleContourI\", (0, 0)),\n        (\"Uacute\", (218, 0)),\n        (\"ll\", (0, 0)),\n        (\"DoubleV\", (0, 0)),\n        (\"diams\", (0, 0)),\n        (\"vsu\", (0, 0)),\n        (\"csc\", (0, 0)),\n        (\"backco\", (0, 0)),\n        (\"orarr;\", (8635, 0)),\n        (\"dig\", (0, 0)),\n        (\"hksearow;\", (10533, 0)),\n        (\"nvlArr\", (0, 0)),\n        (\"NotNestedGreate\", (0, 0)),\n        (\"demptyv\", (0, 0)),\n        (\"Vvdas\", (0, 0)),\n        (\"boxUr\", (0, 0)),\n        (\"Th\", (0, 0)),\n        (\"circlearrowrigh\", (0, 0)),\n        (\"Hor\", (0, 0)),\n        (\"CirclePlu\", (0, 0)),\n        (\"jopf\", (0, 0)),\n        (\"DDotr\", (0, 0)),\n        (\"rAa\", (0, 0)),\n        (\"circled\", (0, 0)),\n        (\"pointin\", (0, 0)),\n        (\"varsubsetn\", (0, 0)),\n        (\"lfish\", (0, 0)),\n        (\"DownRightV\", (0, 0)),\n        (\"varsupsetneqq;\", (10956, 65024)),\n        (\"drcorn;\", (8991, 0)),\n        (\"integers;\", (8484, 0)),\n        (\"NotSquareSubsetE\", (0, 0)),\n        (\"UpArrow;\", (8593, 0)),\n        (\"lver\", (0, 0)),\n        (\"iiin\", (0, 0)),\n        (\"NotGreaterGr\", (0, 0)),\n        (\"gnap\", (0, 0)),\n        (\"measuredang\", (0, 0)),\n        (\"bott\", (0, 0)),\n        (\"aacu\", (0, 0)),\n        (\"xnis;\", (8955, 0)),\n        (\"planck\", (0, 0)),\n        (\"Uogon\", (0, 0)),\n        (\"Xi\", (0, 0)),\n        (\"dlco\", (0, 0)),\n        (\"Longleftrightar\", (0, 0)),\n        (\"Equilibri\", (0, 0)),\n        (\"Iog\", (0, 0)),\n        (\"cce\", (0, 0)),\n        (\"smt\", (0, 0)),\n        (\"DownRightTeeVector\", (0, 0)),\n        (\"zwnj\", (0, 0)),\n        (\"iacut\", (0, 0)),\n        (\"Longr\", (0, 0)),\n        (\"DownLeftRightVecto\", (0, 0)),\n        (\"Bcy\", (0, 0)),\n        (\"wedge;\", (8743, 0)),\n        (\"wci\", (0, 0)),\n        (\"dzig\", (0, 0)),\n        (\"xvee\", (0, 0)),\n        (\"UnderBra\", (0, 0)),\n        (\"ccirc\", (0, 0)),\n        (\"Elemen\", (0, 0)),\n        (\"ltd\", (0, 0)),\n        (\"lesssi\", (0, 0)),\n        (\"ngE;\", (8807, 824)),\n        (\"lbrksl\", (0, 0)),\n        (\"CounterClockwis\", (0, 0)),\n        (\"dotm\", (0, 0)),\n        (\"NegativeThickSpace;\", (8203, 0)),\n        (\"Bernoullis\", (0, 0)),\n        (\"CounterClock\", (0, 0)),\n        (\"CounterCl\", (0, 0)),\n        (\"Und\", (0, 0)),\n        (\"eu\", (0, 0)),\n        (\"wed\", (0, 0)),\n        (\"bsc\", (0, 0)),\n        (\"Uarroc\", (0, 0)),\n        (\"dwan\", (0, 0)),\n        (\"hooklef\", (0, 0)),\n        (\"InvisibleTi\", (0, 0)),\n        (\"kcy;\", (1082, 0)),\n        (\"Star\", (0, 0)),\n        (\"kappav\", (0, 0)),\n        (\"eth;\", (240, 0)),\n        (\"DiacriticalAcute;\", (180, 0)),\n        (\"acirc\", (226, 0)),\n        (\"HARDcy\", (0, 0)),\n        (\"NotPrecedesE\", (0, 0)),\n        (\"bowt\", (0, 0)),\n        (\"abr\", (0, 0)),\n        (\"loop\", (0, 0)),\n        (\"upharpoonle\", (0, 0)),\n        (\"bigsqcu\", (0, 0)),\n        (\"pi\", (0, 0)),\n        (\"rn\", (0, 0)),\n        (\"boxvr;\", (9500, 0)),\n        (\"angms\", (0, 0)),\n        (\"blacktria\", (0, 0)),\n        (\"LongRi\", (0, 0)),\n        (\"LeftF\", (0, 0)),\n        (\"Ch\", (0, 0)),\n        (\"UpDo\", (0, 0)),\n        (\"Aacute\", (193, 0)),\n        (\"eqslantle\", (0, 0)),\n        (\"dlcrop\", (0, 0)),\n        (\"emptyse\", (0, 0)),\n        (\"al\", (0, 0)),\n        (\"EmptyVerySmall\", (0, 0)),\n        (\"DownLeftRightV\", (0, 0)),\n        (\"sa\", (0, 0)),\n        (\"ver\", (0, 0)),\n        (\"preccurlyeq;\", (8828, 0)),\n        (\"Congrue\", (0, 0)),\n        (\"Hat;\", (94, 0)),\n        (\"nesim;\", (8770, 824)),\n        (\"coloneq\", (0, 0)),\n        (\"Alp\", (0, 0)),\n        (\"boxuL\", (0, 0)),\n        (\"smep\", (0, 0)),\n        (\"LowerLeftArr\", (0, 0)),\n        (\"nges;\", (10878, 824)),\n        (\"primes\", (0, 0)),\n        (\"hookleftar\", (0, 0)),\n        (\"ClockwiseContourIntegral;\", (8754, 0)),\n        (\"roplus;\", (10798, 0)),\n        (\"ntriangle\", (0, 0)),\n        (\"xwedge\", (0, 0)),\n        (\"rights\", (0, 0)),\n        (\"lmousta\", (0, 0)),\n        (\"Auml\", (196, 0)),\n        (\"RightDoubleBr\", (0, 0)),\n        (\"circledda\", (0, 0)),\n        (\"Cacu\", (0, 0)),\n        (\"uacu\", (0, 0)),\n        (\"precappro\", (0, 0)),\n        (\"targ\", (0, 0)),\n        (\"sqcup;\", (8852, 0)),\n        (\"Aacut\", (0, 0)),\n        (\"vzigzag\", (0, 0)),\n        (\"strai\", (0, 0)),\n        (\"LeftTriangleB\", (0, 0)),\n        (\"NotLessGreate\", (0, 0)),\n        (\"Po\", (0, 0)),\n        (\"cirfnin\", (0, 0)),\n        (\"nshor\", (0, 0)),\n        (\"bp\", (0, 0)),\n        (\"ograve;\", (242, 0)),\n        (\"ugrav\", (0, 0)),\n        (\"hkswar\", (0, 0)),\n        (\"tf\", (0, 0)),\n        (\"dstrok\", (0, 0)),\n        (\"rarrf\", (0, 0)),\n        (\"oelig\", (0, 0)),\n        (\"Dstrok\", (0, 0)),\n        (\"gam\", (0, 0)),\n        (\"sqsubse\", (0, 0)),\n        (\"Jsc\", (0, 0)),\n        (\"Supers\", (0, 0)),\n        (\"kappav;\", (1008, 0)),\n        (\"curar\", (0, 0)),\n        (\"ino\", (0, 0)),\n        (\"angrtvb\", (0, 0)),\n        (\"os\", (0, 0)),\n        (\"lbb\", (0, 0)),\n        (\"frac16\", (0, 0)),\n        (\"gtdot;\", (8919, 0)),\n        (\"Kopf;\", (120130, 0)),\n        (\"prurel;\", (8880, 0)),\n        (\"THORN;\", (222, 0)),\n        (\"TildeTi\", (0, 0)),\n        (\"lBar\", (0, 0)),\n        (\"blacktriangleleft\", (0, 0)),\n        (\"dlcrop;\", (8973, 0)),\n        (\"CounterClockwise\", (0, 0)),\n        (\"isinv\", (0, 0)),\n        (\"Proportion\", (0, 0)),\n        (\"DownRightVectorBa\", (0, 0)),\n        (\"mp;\", (8723, 0)),\n        (\"varn\", (0, 0)),\n        (\"LessSlantEqua\", (0, 0)),\n        (\"mco\", (0, 0)),\n        (\"Jse\", (0, 0)),\n        (\"rthre\", (0, 0)),\n        (\"Udbla\", (0, 0)),\n        (\"NegativeThickSp\", (0, 0)),\n        (\"LongLeftRigh\", (0, 0)),\n        (\"Theta;\", (920, 0)),\n        (\"wscr\", (0, 0)),\n        (\"SquareSuper\", (0, 0)),\n        (\"nap\", (0, 0)),\n        (\"gtqu\", (0, 0)),\n        (\"doublebarwe\", (0, 0)),\n        (\"ssetm\", (0, 0)),\n        (\"longrighta\", (0, 0)),\n        (\"PrecedesT\", (0, 0)),\n        (\"lop\", (0, 0)),\n        (\"Itilde;\", (296, 0)),\n        (\"sup2\", (178, 0)),\n        (\"RuleD\", (0, 0)),\n        (\"Fouriertrf\", (0, 0)),\n        (\"flli\", (0, 0)),\n        (\"multima\", (0, 0)),\n        (\"Delta;\", (916, 0)),\n        (\"DoubleLon\", (0, 0)),\n        (\"rBarr\", (0, 0)),\n        (\"smal\", (0, 0)),\n        (\"DownLeftVect\", (0, 0)),\n        (\"Rfr;\", (8476, 0)),\n        (\"LeftU\", (0, 0)),\n        (\"helli\", (0, 0)),\n        (\"Gammad;\", (988, 0)),\n        (\"righthar\", (0, 0)),\n        (\"nsce\", (0, 0)),\n        (\"spar\", (0, 0)),\n        (\"nGt;\", (8811, 8402)),\n        (\"ud\", (0, 0)),\n        (\"varpi\", (0, 0)),\n        (\"Og\", (0, 0)),\n        (\"Leftarr\", (0, 0)),\n        (\"Mediu\", (0, 0)),\n        (\"plusmn;\", (177, 0)),\n        (\"RightTriangle\", (0, 0)),\n        (\"ncon\", (0, 0)),\n        (\"Nca\", (0, 0)),\n        (\"napE\", (0, 0)),\n        (\"succneqq;\", (10934, 0)),\n        (\"Ubrc\", (0, 0)),\n        (\"divide;\", (247, 0)),\n        (\"kg\", (0, 0)),\n        (\"topcir;\", (10993, 0)),\n        (\"LeftDownTee\", (0, 0)),\n        (\"NegativeVeryTh\", (0, 0)),\n        (\"fema\", (0, 0)),\n        (\"frac15\", (0, 0)),\n        (\"scn\", (0, 0)),\n        (\"RightTeeVe\", (0, 0)),\n        (\"blackl\", (0, 0)),\n        (\"Shor\", (0, 0)),\n        (\"DoubleLeftArrow;\", (8656, 0)),\n        (\"Rr\", (0, 0)),\n        (\"ngeqq\", (0, 0)),\n        (\"Uarrocir;\", (10569, 0)),\n        (\"NotRev\", (0, 0)),\n        (\"NotDoubleVerti\", (0, 0)),\n        (\"Lcar\", (0, 0)),\n        (\"LeftTeeArr\", (0, 0)),\n        (\"supsu\", (0, 0)),\n        (\"PrecedesTi\", (0, 0)),\n        (\"oci\", (0, 0)),\n        (\"angm\", (0, 0)),\n        (\"fsc\", (0, 0)),\n        (\"complem\", (0, 0)),\n        (\"straightphi;\", (981, 0)),\n        (\"sqsupe;\", (8850, 0)),\n        (\"LongRightArrow;\", (10230, 0)),\n        (\"dbla\", (0, 0)),\n        (\"Psi;\", (936, 0)),\n        (\"drbk\", (0, 0)),\n        (\"ring;\", (730, 0)),\n        (\"leftleftarrows;\", (8647, 0)),\n        (\"ntrianglerighteq;\", (8941, 0)),\n        (\"updownarro\", (0, 0)),\n        (\"hsl\", (0, 0)),\n        (\"ClockwiseCo\", (0, 0)),\n        (\"imath\", (0, 0)),\n        (\"LeftTeeA\", (0, 0)),\n        (\"hstro\", (0, 0)),\n        (\"NotHum\", (0, 0)),\n        (\"Re;\", (8476, 0)),\n        (\"ycir\", (0, 0)),\n        (\"subsu\", (0, 0)),\n        (\"wre\", (0, 0)),\n        (\"cwconint\", (0, 0)),\n        (\"NotSucceedsTild\", (0, 0)),\n        (\"ntrian\", (0, 0)),\n        (\"lHar\", (0, 0)),\n        (\"Prime\", (0, 0)),\n        (\"SmallCircl\", (0, 0)),\n        (\"Backsl\", (0, 0)),\n        (\"euml;\", (235, 0)),\n        (\"ntl\", (0, 0)),\n        (\"Fop\", (0, 0)),\n        (\"lcy;\", (1083, 0)),\n        (\"doublebarw\", (0, 0)),\n        (\"Oac\", (0, 0)),\n        (\"zdot;\", (380, 0)),\n        (\"ReverseUpEqu\", (0, 0)),\n        (\"ucir\", (0, 0)),\n        (\"Interse\", (0, 0)),\n        (\"Otilde;\", (213, 0)),\n        (\"rflo\", (0, 0)),\n        (\"LeftVectorBar\", (0, 0)),\n        (\"gtrsim\", (0, 0)),\n        (\"subn\", (0, 0)),\n        (\"spar;\", (8741, 0)),\n        (\"Tc\", (0, 0)),\n        (\"UpArr\", (0, 0)),\n        (\"Ccir\", (0, 0)),\n        (\"RightAngleBracket\", (0, 0)),\n        (\"udarr\", (0, 0)),\n        (\"uwan\", (0, 0)),\n        (\"club\", (0, 0)),\n        (\"lopf;\", (120157, 0)),\n        (\"xharr\", (0, 0)),\n        (\"xma\", (0, 0)),\n        (\"ltci\", (0, 0)),\n        (\"nw\", (0, 0)),\n        (\"FilledVerySm\", (0, 0)),\n        (\"hs\", (0, 0)),\n        (\"UpperLeftArrow\", (0, 0)),\n        (\"NotSuperset\", (0, 0)),\n        (\"SHCHc\", (0, 0)),\n        (\"Rscr\", (0, 0)),\n        (\"FilledVerySma\", (0, 0)),\n        (\"trimin\", (0, 0)),\n        (\"uring;\", (367, 0)),\n        (\"lAtai\", (0, 0)),\n        (\"Equilib\", (0, 0)),\n        (\"varpropt\", (0, 0)),\n        (\"inod\", (0, 0)),\n        (\"Longrightarrow;\", (10233, 0)),\n        (\"Yf\", (0, 0)),\n        (\"Bo\", (0, 0)),\n        (\"Round\", (0, 0)),\n        (\"capb\", (0, 0)),\n        (\"ecir\", (0, 0)),\n        (\"NotHumpDownHump\", (0, 0)),\n        (\"curarrm\", (0, 0)),\n        (\"Aac\", (0, 0)),\n        (\"lthree;\", (8907, 0)),\n        (\"olcir\", (0, 0)),\n        (\"Intersection;\", (8898, 0)),\n    ],\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","python","target","release","build","selectors-2bdab89f9e5858d6","out","ascii_case_insensitive_html_attributes.rs"],"content":"{ static SET: ::phf::Set\u003c\u0026'static str\u003e = ::phf::Set { map: ::phf::Map {\n    key: 10121458955350035957,\n    disps: \u0026[\n        (0, 2),\n        (8, 17),\n        (1, 5),\n        (0, 0),\n        (0, 20),\n        (0, 3),\n        (15, 2),\n        (17, 19),\n        (8, 9),\n        (0, 15),\n    ],\n    entries: \u0026[\n        (\"dir\", ()),\n        (\"http-equiv\", ()),\n        (\"rel\", ()),\n        (\"enctype\", ()),\n        (\"align\", ()),\n        (\"accept\", ()),\n        (\"nohref\", ()),\n        (\"lang\", ()),\n        (\"bgcolor\", ()),\n        (\"direction\", ()),\n        (\"valign\", ()),\n        (\"checked\", ()),\n        (\"frame\", ()),\n        (\"link\", ()),\n        (\"accept-charset\", ()),\n        (\"hreflang\", ()),\n        (\"text\", ()),\n        (\"valuetype\", ()),\n        (\"language\", ()),\n        (\"nowrap\", ()),\n        (\"vlink\", ()),\n        (\"disabled\", ()),\n        (\"noshade\", ()),\n        (\"codetype\", ()),\n        (\"defer\", ()),\n        (\"noresize\", ()),\n        (\"target\", ()),\n        (\"scrolling\", ()),\n        (\"rules\", ()),\n        (\"scope\", ()),\n        (\"rev\", ()),\n        (\"media\", ()),\n        (\"method\", ()),\n        (\"charset\", ()),\n        (\"alink\", ()),\n        (\"selected\", ()),\n        (\"multiple\", ()),\n        (\"color\", ()),\n        (\"shape\", ()),\n        (\"type\", ()),\n        (\"clear\", ()),\n        (\"compact\", ()),\n        (\"face\", ()),\n        (\"declare\", ()),\n        (\"axis\", ()),\n        (\"readonly\", ()),\n    ],\n} }; \u0026SET }","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","python","target","release","build","target-lexicon-2dea3163bae4a5f7","out","host.rs"],"content":"\n#[allow(unused_imports)]\nuse crate::Aarch64Architecture::*;\n#[allow(unused_imports)]\nuse crate::ArmArchitecture::*;\n#[allow(unused_imports)]\nuse crate::CustomVendor;\n#[allow(unused_imports)]\nuse crate::Mips32Architecture::*;\n#[allow(unused_imports)]\nuse crate::Mips64Architecture::*;\n#[allow(unused_imports)]\nuse crate::Riscv32Architecture::*;\n#[allow(unused_imports)]\nuse crate::Riscv64Architecture::*;\n#[allow(unused_imports)]\nuse crate::X86_32Architecture::*;\n\n/// The `Triple` of the current host.\npub const HOST: Triple = Triple {\n    architecture: Architecture::X86_64,\n    vendor: Vendor::Unknown,\n    operating_system: OperatingSystem::Linux,\n    environment: Environment::Gnu,\n    binary_format: BinaryFormat::Elf,\n};\n\nimpl Architecture {\n    /// Return the architecture for the current host.\n    pub const fn host() -\u003e Self {\n        Architecture::X86_64\n    }\n}\n\nimpl Vendor {\n    /// Return the vendor for the current host.\n    pub const fn host() -\u003e Self {\n        Vendor::Unknown\n    }\n}\n\nimpl OperatingSystem {\n    /// Return the operating system for the current host.\n    pub const fn host() -\u003e Self {\n        OperatingSystem::Linux\n    }\n}\n\nimpl Environment {\n    /// Return the environment for the current host.\n    pub const fn host() -\u003e Self {\n        Environment::Gnu\n    }\n}\n\nimpl BinaryFormat {\n    /// Return the binary format for the current host.\n    pub const fn host() -\u003e Self {\n        BinaryFormat::Elf\n    }\n}\n\nimpl Triple {\n    /// Return the triple for the current host.\n    pub const fn host() -\u003e Self {\n        Self {\n            architecture: Architecture::X86_64,\n            vendor: Vendor::Unknown,\n            operating_system: OperatingSystem::Linux,\n            environment: Environment::Gnu,\n            binary_format: BinaryFormat::Elf,\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","python","target","release","build","typenum-17580a91a03d6b57","out","tests.rs"],"content":"\nuse typenum::*;\nuse core::ops::*;\nuse core::cmp::Ordering;\n\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Sub_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0SubU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_0() {\n    type A = UTerm;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU0 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Sub_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1SubU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Sub_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1SubU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_PartialDiv_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU1 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU3 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU3 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU4 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU5 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU5 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2SubU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2SubU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU2 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2SubU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_PartialDiv_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PartialDivU2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PartialDivU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU2 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU3 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU3 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU3 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU3 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU4 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU4 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU4 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU4 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU4 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU4 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU4 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU4 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU4 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U64 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU64\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU5 as Unsigned\u003e::to_u64(), \u003cU64 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU5 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU5 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU5 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU5 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU1 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U12 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU12\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU2 as Unsigned\u003e::to_u64(), \u003cU12 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU2 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU2 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U24 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU24\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU3 as Unsigned\u003e::to_u64(), \u003cU24 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU3 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU3 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U27 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU27\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU3 as Unsigned\u003e::to_u64(), \u003cU27 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_PartialDiv_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PartialDivU3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PartialDivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU3 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU4 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU4 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U48 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU48\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU4 as Unsigned\u003e::to_u64(), \u003cU48 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU4 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U12 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU12\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU4 as Unsigned\u003e::to_u64(), \u003cU12 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U81 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU81\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU4 as Unsigned\u003e::to_u64(), \u003cU81 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU4 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU4 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU5 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U96 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU96\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU5 as Unsigned\u003e::to_u64(), \u003cU96 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU5 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U15 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU15\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU5 as Unsigned\u003e::to_u64(), \u003cU15 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U243 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU243\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU5 as Unsigned\u003e::to_u64(), \u003cU243 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU5 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU5 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU1 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU2 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU2 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU2 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PartialDivU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU3 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U12 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU12\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU3 as Unsigned\u003e::to_u64(), \u003cU12 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U64 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU64\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU3 as Unsigned\u003e::to_u64(), \u003cU64 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU3 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U64 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU64\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU4 as Unsigned\u003e::to_u64(), \u003cU64 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU4 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU4 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U256 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU256\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU4 as Unsigned\u003e::to_u64(), \u003cU256 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PartialDivU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU4 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U128 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU128\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU5 as Unsigned\u003e::to_u64(), \u003cU128 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU5 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U20 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU20\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU5 as Unsigned\u003e::to_u64(), \u003cU20 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1024 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1024\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU5 as Unsigned\u003e::to_u64(), \u003cU1024 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU1 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU1 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU2 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU2 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U20 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU20\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU2 as Unsigned\u003e::to_u64(), \u003cU20 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU2 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU2 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U25 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU25\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU2 as Unsigned\u003e::to_u64(), \u003cU25 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU2 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU3 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U40 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU40\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU3 as Unsigned\u003e::to_u64(), \u003cU40 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU3 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U15 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU15\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU3 as Unsigned\u003e::to_u64(), \u003cU15 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U125 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU125\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU3 as Unsigned\u003e::to_u64(), \u003cU125 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU3 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U80 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU80\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU4 as Unsigned\u003e::to_u64(), \u003cU80 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU4 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U20 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU20\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU4 as Unsigned\u003e::to_u64(), \u003cU20 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U625 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU625\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU4 as Unsigned\u003e::to_u64(), \u003cU625 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U160 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU160\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU5 as Unsigned\u003e::to_u64(), \u003cU160 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU5 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U25 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU25\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU5 as Unsigned\u003e::to_u64(), \u003cU25 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U3125 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU3125\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU5 as Unsigned\u003e::to_u64(), \u003cU3125 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_PartialDiv_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PartialDivU5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PartialDivU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU5 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN5 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivN5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN5 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN4 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN4 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN3 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN3 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN2 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN2 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN1 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Add_0 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Sub_0 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Min_0 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Gcd_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP1 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP2 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP2 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP2 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP3 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP3 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N125 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN125\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP3 as Integer\u003e::to_i64(), \u003cN125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP4 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP4 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P625 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP625\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP4 as Integer\u003e::to_i64(), \u003cP625 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N25 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN25\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP5 as Integer\u003e::to_i64(), \u003cN25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivP5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3125 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN3125\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP5 as Integer\u003e::to_i64(), \u003cN3125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN5 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN5 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN4 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN3 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN3 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN2 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Add_0 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Sub_0 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Min_0 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Gcd_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP2 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP2 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP3 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP3 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N64 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN64\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP3 as Integer\u003e::to_i64(), \u003cN64 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N16 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP4 as Integer\u003e::to_i64(), \u003cN16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P256 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP256\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP4 as Integer\u003e::to_i64(), \u003cP256 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP5 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP5 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1024 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1024\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP5 as Integer\u003e::to_i64(), \u003cN1024 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN5 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN5 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN4 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN4 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN3 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivN3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN3 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Add_0 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Sub_0 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Min_0 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Gcd_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP2 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP3 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivP3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N27 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN27\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP3 as Integer\u003e::to_i64(), \u003cN27 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP4 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP4 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P81 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP81\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP4 as Integer\u003e::to_i64(), \u003cP81 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP5 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP5 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N243 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN243\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP5 as Integer\u003e::to_i64(), \u003cN243 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN5 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN4 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN2 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Add_0 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Sub_0 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Min_0 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Gcd_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP3 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP4 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP5 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N32 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN32\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP5 as Integer\u003e::to_i64(), \u003cN32 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN5 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PartialDivN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN1 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Add_0 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Sub_0 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Min_0 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Gcd_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PartialDivP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP5 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Add_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Sub_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Gcd_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow__0() {\n    type A = Z0;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp__0() {\n    type A = Z0;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0Cmp_0 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN5 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PartialDivN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Add_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Sub_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Max_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Gcd_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PartialDivP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP1 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP5 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN5 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN4 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Add_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Sub_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Max_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Gcd_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP2 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP3 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP4 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP5 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P32 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP32\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP5 as Integer\u003e::to_i64(), \u003cP32 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN5 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN5 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN4 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN4 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN3 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivN3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Add_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Sub_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Max_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Gcd_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP2 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP3 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivP3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P27 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP27\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP3 as Integer\u003e::to_i64(), \u003cP27 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP3 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP4 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP4 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P81 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP81\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP4 as Integer\u003e::to_i64(), \u003cP81 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP5 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP5 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P243 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP243\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP5 as Integer\u003e::to_i64(), \u003cP243 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN5 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN5 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N16 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN4 as Integer\u003e::to_i64(), \u003cN16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN3 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN3 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN2 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Add_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Sub_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Max_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Gcd_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP2 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP2 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP3 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP3 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P64 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP64\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP3 as Integer\u003e::to_i64(), \u003cP64 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P256 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP256\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP4 as Integer\u003e::to_i64(), \u003cP256 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP4 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP5 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP5 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1024 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1024\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP5 as Integer\u003e::to_i64(), \u003cP1024 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N25 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN25\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN5 as Integer\u003e::to_i64(), \u003cN25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivN5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN4 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN4 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN3 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN3 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN2 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN2 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN1 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Add_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Sub_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Max_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Gcd_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP1 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP2 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP2 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP2 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP3 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP3 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P125 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP125\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP3 as Integer\u003e::to_i64(), \u003cP125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP4 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP4 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P625 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP625\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP4 as Integer\u003e::to_i64(), \u003cP625 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP5 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivP5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3125 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP3125\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP5 as Integer\u003e::to_i64(), \u003cP3125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP5 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN5 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n    assert_eq!(\u003cNegN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN5 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN4 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n    assert_eq!(\u003cNegN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN4 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN3 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n    assert_eq!(\u003cNegN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN3 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN2 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n    assert_eq!(\u003cNegN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN2 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Neg() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN1 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n    assert_eq!(\u003cNegN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Abs() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN1 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Neg() {\n    type A = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type Neg_0 = \u003c\u003cA as Neg\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n    assert_eq!(\u003cNeg_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Abs() {\n    type A = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type Abs_0 = \u003c\u003cA as Abs\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n    assert_eq!(\u003cAbs_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Neg() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP1 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n    assert_eq!(\u003cNegP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Abs() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP1 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP2 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n    assert_eq!(\u003cNegP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP2 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP3 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n    assert_eq!(\u003cNegP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP3 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP4 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n    assert_eq!(\u003cNegP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP4 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP5 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n    assert_eq!(\u003cNegP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP5 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","src","client.rs"],"content":"use crate::edit_analysis;\nuse crate::headers;\nuse crate::login::extract_cookies_from_response;\nuse crate::parsing::LastFmParser;\nuse crate::r#trait::LastFmEditClient;\nuse crate::retry;\nuse crate::types::{\n    AlbumPage, ClientConfig, ClientEvent, ClientEventReceiver, EditResponse, ExactScrobbleEdit,\n    LastFmEditSession, LastFmError, OperationalDelayConfig, RateLimitConfig, RateLimitType,\n    RequestInfo, RetryConfig, ScrobbleEdit, SharedEventBroadcaster, SingleEditResponse, Track,\n    TrackPage,\n};\nuse crate::Result;\nuse async_trait::async_trait;\nuse http_client::{HttpClient, Request, Response};\nuse http_types::{Method, Url};\nuse scraper::{Html, Selector};\nuse std::sync::{Arc, Mutex};\n\n#[derive(Clone)]\npub struct LastFmEditClientImpl {\n    client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n    session: Arc\u003cMutex\u003cLastFmEditSession\u003e\u003e,\n    parser: LastFmParser,\n    broadcaster: Arc\u003cSharedEventBroadcaster\u003e,\n    config: ClientConfig,\n}\n\nimpl LastFmEditClientImpl {\n    /// Custom URL encoding for Last.fm paths\n    fn lastfm_encode(\u0026self, input: \u0026str) -\u003e String {\n        urlencoding::encode(input).to_string()\n    }\n\n    pub fn from_session(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n    ) -\u003e Self {\n        Self::from_session_with_arc(Arc::from(client), session)\n    }\n\n    fn from_session_with_arc(\n        client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n    ) -\u003e Self {\n        Self::from_session_with_broadcaster_arc(\n            client,\n            session,\n            Arc::new(SharedEventBroadcaster::new()),\n        )\n    }\n\n    pub fn from_session_with_rate_limit_patterns(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        rate_limit_patterns: Vec\u003cString\u003e,\n    ) -\u003e Self {\n        let config = ClientConfig::default()\n            .with_rate_limit_config(RateLimitConfig::default().with_patterns(rate_limit_patterns));\n        Self::from_session_with_client_config(client, session, config)\n    }\n\n    pub async fn login_with_credentials(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        username: \u0026str,\n        password: \u0026str,\n    ) -\u003e Result\u003cSelf\u003e {\n        let client_arc: Arc\u003cdyn HttpClient + Send + Sync\u003e = Arc::from(client);\n        let login_manager =\n            crate::login::LoginManager::new(client_arc.clone(), \"https://www.last.fm\".to_string());\n        let session = login_manager.login(username, password).await?;\n        Ok(Self::from_session_with_arc(client_arc, session))\n    }\n\n    pub fn from_session_with_client_config(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        config: ClientConfig,\n    ) -\u003e Self {\n        Self::from_session_with_client_config_arc(Arc::from(client), session, config)\n    }\n\n    pub async fn login_with_credentials_and_client_config(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        username: \u0026str,\n        password: \u0026str,\n        config: ClientConfig,\n    ) -\u003e Result\u003cSelf\u003e {\n        let client_arc: Arc\u003cdyn HttpClient + Send + Sync\u003e = Arc::from(client);\n        let login_manager =\n            crate::login::LoginManager::new(client_arc.clone(), \"https://www.last.fm\".to_string());\n        let session = login_manager.login(username, password).await?;\n        Ok(Self::from_session_with_client_config_arc(\n            client_arc, session, config,\n        ))\n    }\n\n    pub fn from_session_with_config(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        retry_config: RetryConfig,\n        rate_limit_config: RateLimitConfig,\n    ) -\u003e Self {\n        Self::from_session_with_config_arc(\n            Arc::from(client),\n            session,\n            retry_config,\n            rate_limit_config,\n        )\n    }\n\n    pub async fn login_with_credentials_and_config(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        username: \u0026str,\n        password: \u0026str,\n        retry_config: RetryConfig,\n        rate_limit_config: RateLimitConfig,\n    ) -\u003e Result\u003cSelf\u003e {\n        let client_arc: Arc\u003cdyn HttpClient + Send + Sync\u003e = Arc::from(client);\n        let login_manager =\n            crate::login::LoginManager::new(client_arc.clone(), \"https://www.last.fm\".to_string());\n        let session = login_manager.login(username, password).await?;\n        Ok(Self::from_session_with_config_arc(\n            client_arc,\n            session,\n            retry_config,\n            rate_limit_config,\n        ))\n    }\n\n    fn from_session_with_broadcaster(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        broadcaster: Arc\u003cSharedEventBroadcaster\u003e,\n    ) -\u003e Self {\n        Self::from_session_with_broadcaster_arc(Arc::from(client), session, broadcaster)\n    }\n\n    fn from_session_with_client_config_arc(\n        client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        config: ClientConfig,\n    ) -\u003e Self {\n        Self::from_session_with_client_config_and_broadcaster_arc(\n            client,\n            session,\n            config,\n            Arc::new(SharedEventBroadcaster::new()),\n        )\n    }\n\n    fn from_session_with_config_arc(\n        client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        retry_config: RetryConfig,\n        rate_limit_config: RateLimitConfig,\n    ) -\u003e Self {\n        let config = ClientConfig {\n            retry: retry_config,\n            rate_limit: rate_limit_config,\n            operational_delays: OperationalDelayConfig::default(),\n        };\n        Self::from_session_with_client_config_arc(client, session, config)\n    }\n\n    fn from_session_with_broadcaster_arc(\n        client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        broadcaster: Arc\u003cSharedEventBroadcaster\u003e,\n    ) -\u003e Self {\n        Self::from_session_with_client_config_and_broadcaster_arc(\n            client,\n            session,\n            ClientConfig::default(),\n            broadcaster,\n        )\n    }\n\n    fn from_session_with_client_config_and_broadcaster_arc(\n        client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        config: ClientConfig,\n        broadcaster: Arc\u003cSharedEventBroadcaster\u003e,\n    ) -\u003e Self {\n        Self {\n            client,\n            session: Arc::new(Mutex::new(session)),\n            parser: LastFmParser::new(),\n            broadcaster,\n            config,\n        }\n    }\n\n    pub fn get_session(\u0026self) -\u003e LastFmEditSession {\n        self.session.lock().unwrap().clone()\n    }\n\n    pub fn with_shared_broadcaster(\u0026self, client: Box\u003cdyn HttpClient + Send + Sync\u003e) -\u003e Self {\n        let session = self.get_session();\n        Self::from_session_with_broadcaster(client, session, self.broadcaster.clone())\n    }\n\n    pub fn username(\u0026self) -\u003e String {\n        self.session.lock().unwrap().username.clone()\n    }\n\n    pub async fn validate_session(\u0026self) -\u003e bool {\n        let test_url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/settings/subscription/automatic-edits/tracks\",\n                session.base_url\n            )\n        };\n\n        let mut request = Request::new(Method::Get, test_url.parse::\u003cUrl\u003e().unwrap());\n\n        {\n            let session = self.session.lock().unwrap();\n            headers::add_cookies(\u0026mut request, \u0026session.cookies);\n        }\n\n        headers::add_get_headers(\u0026mut request, false, None);\n\n        match self.client.send(request).await {\n            Ok(response) =\u003e {\n                if response.status() == 302 || response.status() == 301 {\n                    if let Some(location) = response.header(\"location\") {\n                        if let Some(redirect_url) = location.get(0) {\n                            let redirect_url_str = redirect_url.as_str();\n                            let is_valid = !redirect_url_str.contains(\"/login\");\n\n                            return is_valid;\n                        }\n                    }\n                }\n                true\n            }\n            Err(_e) =\u003e false,\n        }\n    }\n\n    pub async fn delete_scrobble(\n        \u0026self,\n        artist_name: \u0026str,\n        track_name: \u0026str,\n        timestamp: u64,\n    ) -\u003e Result\u003cbool\u003e {\n        let config = RetryConfig {\n            max_retries: 3,\n            base_delay: 5,\n            max_delay: 300,\n            enabled: true,\n        };\n\n        let artist_name = artist_name.to_string();\n        let track_name = track_name.to_string();\n        let client = self.clone();\n\n        match retry::retry_with_backoff(\n            config,\n            \"Delete scrobble\",\n            || client.delete_scrobble_impl(\u0026artist_name, \u0026track_name, timestamp),\n            |delay, rate_limit_timestamp, operation_name| {\n                self.broadcast_event(ClientEvent::RateLimited {\n                    delay_seconds: delay,\n                    request: None,\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    rate_limit_timestamp,\n                });\n                log::debug!(\"{operation_name} rate limited, waiting {delay} seconds\");\n            },\n            |total_duration, _operation_name| {\n                self.broadcast_event(ClientEvent::RateLimitEnded {\n                    request: crate::types::RequestInfo::from_url_and_method(\n                        \u0026format!(\"delete_scrobble/{artist_name}/{track_name}/{timestamp}\"),\n                        \"POST\",\n                    ),\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    total_rate_limit_duration_seconds: total_duration,\n                });\n            },\n        )\n        .await\n        {\n            Ok(retry_result) =\u003e Ok(retry_result.result),\n            Err(_) =\u003e Ok(false),\n        }\n    }\n\n    async fn delete_scrobble_impl(\n        \u0026self,\n        artist_name: \u0026str,\n        track_name: \u0026str,\n        timestamp: u64,\n    ) -\u003e Result\u003cbool\u003e {\n        let delete_url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/delete\",\n                session.base_url, session.username\n            )\n        };\n\n        log::debug!(\"Getting fresh CSRF token for delete\");\n        let library_url = {\n            let session = self.session.lock().unwrap();\n            format!(\"{}/user/{}/library\", session.base_url, session.username)\n        };\n\n        let mut response = self.get(\u0026library_url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        let document = Html::parse_document(\u0026content);\n        let fresh_csrf_token = self.extract_csrf_token(\u0026document)?;\n\n        log::debug!(\"Submitting delete request with fresh token\");\n\n        let mut request = Request::new(Method::Post, delete_url.parse::\u003cUrl\u003e().unwrap());\n\n        let referer_url = {\n            let session = self.session.lock().unwrap();\n            headers::add_cookies(\u0026mut request, \u0026session.cookies);\n            format!(\"{}/user/{}\", session.base_url, session.username)\n        };\n\n        headers::add_edit_headers(\u0026mut request, \u0026referer_url);\n\n        let form_data = [\n            (\"csrfmiddlewaretoken\", fresh_csrf_token.as_str()),\n            (\"artist_name\", artist_name),\n            (\"track_name\", track_name),\n            (\"timestamp\", \u0026timestamp.to_string()),\n            (\"ajax\", \"1\"),\n        ];\n\n        let form_string: String = form_data\n            .iter()\n            .map(|(k, v)| format!(\"{}={}\", urlencoding::encode(k), urlencoding::encode(v)))\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\u0026\");\n\n        request.set_body(form_string);\n\n        log::debug!(\n            \"Deleting scrobble: '{track_name}' by '{artist_name}' with timestamp {timestamp}\"\n        );\n\n        let request_info = RequestInfo::from_url_and_method(\u0026delete_url, \"POST\");\n        let request_start = std::time::Instant::now();\n\n        self.broadcast_event(ClientEvent::RequestStarted {\n            request: request_info.clone(),\n        });\n\n        let mut response = self\n            .client\n            .send(request)\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        self.broadcast_event(ClientEvent::RequestCompleted {\n            request: request_info.clone(),\n            status_code: response.status().into(),\n            duration_ms: request_start.elapsed().as_millis() as u64,\n        });\n\n        log::debug!(\"Delete response status: {}\", response.status());\n\n        let response_text = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        let success = response.status().is_success();\n\n        if success {\n            log::debug!(\"Successfully deleted scrobble\");\n        } else {\n            log::debug!(\"Delete failed with response: {response_text}\");\n        }\n\n        Ok(success)\n    }\n\n    pub fn subscribe(\u0026self) -\u003e ClientEventReceiver {\n        self.broadcaster.subscribe()\n    }\n\n    pub fn latest_event(\u0026self) -\u003e Option\u003cClientEvent\u003e {\n        self.broadcaster.latest_event()\n    }\n\n    fn broadcast_event(\u0026self, event: ClientEvent) {\n        self.broadcaster.broadcast_event(event);\n    }\n\n    pub async fn get_recent_scrobbles(\u0026self, page: u32) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library?page={}\",\n                session.base_url, session.username, page\n            )\n        };\n\n        log::debug!(\"Fetching recent scrobbles page {page}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"Recent scrobbles response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        let document = Html::parse_document(\u0026content);\n        self.parser.parse_recent_scrobbles(\u0026document)\n    }\n\n    pub async fn get_recent_tracks_page(\u0026self, page: u32) -\u003e Result\u003cTrackPage\u003e {\n        let tracks = self.get_recent_scrobbles(page).await?;\n\n        let has_next_page = !tracks.is_empty();\n\n        Ok(TrackPage {\n            tracks,\n            page_number: page,\n            has_next_page,\n            total_pages: None,\n        })\n    }\n\n    pub async fn find_recent_scrobble_for_track(\n        \u0026self,\n        track_name: \u0026str,\n        artist_name: \u0026str,\n        max_pages: u32,\n    ) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        log::debug!(\"Searching for recent scrobble: '{track_name}' by '{artist_name}'\");\n\n        for page in 1..=max_pages {\n            let scrobbles = self.get_recent_scrobbles(page).await?;\n\n            for scrobble in scrobbles {\n                if scrobble.name == track_name \u0026\u0026 scrobble.artist == artist_name {\n                    log::debug!(\n                        \"Found recent scrobble: '{}' with timestamp {:?}\",\n                        scrobble.name,\n                        scrobble.timestamp\n                    );\n                    return Ok(Some(scrobble));\n                }\n            }\n        }\n\n        log::debug!(\n            \"No recent scrobble found for '{track_name}' by '{artist_name}' in {max_pages} pages\"\n        );\n        Ok(None)\n    }\n\n    pub async fn edit_scrobble(\u0026self, edit: \u0026ScrobbleEdit) -\u003e Result\u003cEditResponse\u003e {\n        let discovered_edits = self.discover_scrobble_edit_variations(edit).await?;\n\n        if discovered_edits.is_empty() {\n            let context = match (\u0026edit.track_name_original, \u0026edit.album_name_original) {\n                (Some(track_name), _) =\u003e {\n                    format!(\"track '{}' by '{}'\", track_name, edit.artist_name_original)\n                }\n                (None, Some(album_name)) =\u003e {\n                    format!(\"album '{}' by '{}'\", album_name, edit.artist_name_original)\n                }\n                (None, None) =\u003e format!(\"artist '{}'\", edit.artist_name_original),\n            };\n            return Err(LastFmError::Parse(format!(\n                \"No scrobbles found for {context}. Make sure the names are correct and that you have scrobbled recently.\"\n            )));\n        }\n\n        log::info!(\n            \"Discovered {} scrobble instances to edit\",\n            discovered_edits.len()\n        );\n\n        let mut all_results = Vec::new();\n\n        for (index, discovered_edit) in discovered_edits.iter().enumerate() {\n            log::debug!(\n                \"Processing scrobble {}/{}: '{}' from '{}'\",\n                index + 1,\n                discovered_edits.len(),\n                discovered_edit.track_name_original,\n                discovered_edit.album_name_original\n            );\n\n            let mut modified_exact_edit = discovered_edit.clone();\n\n            if let Some(new_track_name) = \u0026edit.track_name {\n                modified_exact_edit.track_name = new_track_name.clone();\n            }\n            if let Some(new_album_name) = \u0026edit.album_name {\n                modified_exact_edit.album_name = new_album_name.clone();\n            }\n            modified_exact_edit.artist_name = edit.artist_name.clone();\n            if let Some(new_album_artist_name) = \u0026edit.album_artist_name {\n                modified_exact_edit.album_artist_name = new_album_artist_name.clone();\n            }\n            modified_exact_edit.edit_all = edit.edit_all;\n\n            let album_info = format!(\n                \"{} by {}\",\n                modified_exact_edit.album_name_original,\n                modified_exact_edit.album_artist_name_original\n            );\n\n            let single_response = self.edit_scrobble_single(\u0026modified_exact_edit, 3).await?;\n            let success = single_response.success();\n            let message = single_response.message();\n\n            all_results.push(SingleEditResponse {\n                success,\n                message,\n                album_info: Some(album_info),\n                exact_scrobble_edit: modified_exact_edit.clone(),\n            });\n\n            if index \u003c discovered_edits.len() - 1\n                \u0026\u0026 self.config.operational_delays.edit_delay_ms \u003e 0\n            {\n                tokio::time::sleep(std::time::Duration::from_millis(\n                    self.config.operational_delays.edit_delay_ms,\n                ))\n                .await;\n            }\n        }\n\n        Ok(EditResponse::from_results(all_results))\n    }\n\n    pub async fn edit_scrobble_single(\n        \u0026self,\n        exact_edit: \u0026ExactScrobbleEdit,\n        max_retries: u32,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        let config = RetryConfig {\n            max_retries,\n            base_delay: 5,\n            max_delay: 300,\n            enabled: true,\n        };\n\n        let edit_clone = exact_edit.clone();\n        let client = self.clone();\n\n        match retry::retry_with_backoff(\n            config,\n            \"Edit scrobble\",\n            || client.edit_scrobble_impl(\u0026edit_clone),\n            |delay, rate_limit_timestamp, operation_name| {\n                self.broadcast_event(ClientEvent::RateLimited {\n                    delay_seconds: delay,\n                    request: None, // No specific request context in retry callback\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    rate_limit_timestamp,\n                });\n                log::debug!(\"{operation_name} rate limited, waiting {delay} seconds\");\n            },\n            |total_duration, _operation_name| {\n                self.broadcast_event(ClientEvent::RateLimitEnded {\n                    request: crate::types::RequestInfo::from_url_and_method(\n                        \u0026format!(\n                            \"edit_scrobble/{}/{}\",\n                            edit_clone.artist_name, edit_clone.track_name\n                        ),\n                        \"POST\",\n                    ),\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    total_rate_limit_duration_seconds: total_duration,\n                });\n            },\n        )\n        .await\n        {\n            Ok(retry_result) =\u003e Ok(EditResponse::single(\n                retry_result.result,\n                None,\n                None,\n                exact_edit.clone(),\n            )),\n            Err(LastFmError::RateLimit { .. }) =\u003e Ok(EditResponse::single(\n                false,\n                Some(format!(\"Rate limit exceeded after {max_retries} retries\")),\n                None,\n                exact_edit.clone(),\n            )),\n            Err(other_error) =\u003e Ok(EditResponse::single(\n                false,\n                Some(other_error.to_string()),\n                None,\n                exact_edit.clone(),\n            )),\n        }\n    }\n\n    async fn edit_scrobble_impl(\u0026self, exact_edit: \u0026ExactScrobbleEdit) -\u003e Result\u003cbool\u003e {\n        let start_time = std::time::Instant::now();\n        let result = self.edit_scrobble_impl_internal(exact_edit).await;\n        let duration_ms = start_time.elapsed().as_millis() as u64;\n\n        match \u0026result {\n            Ok(success) =\u003e {\n                self.broadcast_event(ClientEvent::EditAttempted {\n                    edit: exact_edit.clone(),\n                    success: *success,\n                    error_message: None,\n                    duration_ms,\n                });\n            }\n            Err(error) =\u003e {\n                self.broadcast_event(ClientEvent::EditAttempted {\n                    edit: exact_edit.clone(),\n                    success: false,\n                    error_message: Some(error.to_string()),\n                    duration_ms,\n                });\n            }\n        }\n\n        result\n    }\n\n    async fn edit_scrobble_impl_internal(\u0026self, exact_edit: \u0026ExactScrobbleEdit) -\u003e Result\u003cbool\u003e {\n        let edit_url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/edit?edited-variation=library-track-scrobble\",\n                session.base_url, session.username\n            )\n        };\n\n        log::debug!(\"Getting fresh CSRF token for edit\");\n        let form_html = self.get_edit_form_html(\u0026edit_url).await?;\n\n        let form_document = Html::parse_document(\u0026form_html);\n        let fresh_csrf_token = self.extract_csrf_token(\u0026form_document)?;\n\n        log::debug!(\"Submitting edit with fresh token\");\n\n        let form_data = exact_edit.build_form_data(\u0026fresh_csrf_token);\n\n        log::debug!(\n            \"Editing scrobble: '{}' -\u003e '{}'\",\n            exact_edit.track_name_original,\n            exact_edit.track_name\n        );\n        {\n            let session = self.session.lock().unwrap();\n            log::trace!(\"Session cookies count: {}\", session.cookies.len());\n        }\n\n        let mut request = Request::new(Method::Post, edit_url.parse::\u003cUrl\u003e().unwrap());\n\n        let referer_url = {\n            let session = self.session.lock().unwrap();\n            headers::add_cookies(\u0026mut request, \u0026session.cookies);\n            format!(\"{}/user/{}/library\", session.base_url, session.username)\n        };\n\n        headers::add_edit_headers(\u0026mut request, \u0026referer_url);\n\n        let form_string: String = form_data\n            .iter()\n            .map(|(k, v)| format!(\"{}={}\", urlencoding::encode(k), urlencoding::encode(v)))\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\u0026\");\n\n        request.set_body(form_string);\n\n        let request_info = RequestInfo::from_url_and_method(\u0026edit_url, \"POST\");\n        let request_start = std::time::Instant::now();\n\n        self.broadcast_event(ClientEvent::RequestStarted {\n            request: request_info.clone(),\n        });\n\n        let mut response = self\n            .client\n            .send(request)\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        self.broadcast_event(ClientEvent::RequestCompleted {\n            request: request_info.clone(),\n            status_code: response.status().into(),\n            duration_ms: request_start.elapsed().as_millis() as u64,\n        });\n\n        log::debug!(\"Edit response status: {}\", response.status());\n\n        let response_text = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        let analysis = edit_analysis::analyze_edit_response(\u0026response_text, response.status());\n\n        Ok(analysis.success)\n    }\n\n    async fn get_edit_form_html(\u0026self, edit_url: \u0026str) -\u003e Result\u003cString\u003e {\n        let mut form_response = self.get(edit_url).await?;\n        let form_html = form_response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\"Edit form response status: {}\", form_response.status());\n        Ok(form_html)\n    }\n\n    pub async fn load_edit_form_values_internal(\n        \u0026self,\n        track_name: \u0026str,\n        artist_name: \u0026str,\n    ) -\u003e Result\u003cVec\u003cExactScrobbleEdit\u003e\u003e {\n        log::debug!(\"Loading edit form values for '{track_name}' by '{artist_name}'\");\n\n        let base_track_url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/music/+noredirect/{}/_/{}\",\n                session.base_url,\n                session.username,\n                urlencoding::encode(artist_name),\n                urlencoding::encode(track_name)\n            )\n        };\n\n        log::debug!(\"Fetching track page: {base_track_url}\");\n\n        let mut response = self.get(\u0026base_track_url).await?;\n        let html = response\n            .body_string()\n            .await\n            .map_err(|e| crate::LastFmError::Http(e.to_string()))?;\n\n        let document = Html::parse_document(\u0026html);\n\n        let mut all_scrobble_edits = Vec::new();\n        let mut unique_albums = std::collections::HashSet::new();\n        let max_pages = 5;\n\n        let page_edits = self.extract_scrobble_edits_from_page(\n            \u0026document,\n            track_name,\n            artist_name,\n            \u0026mut unique_albums,\n        )?;\n        all_scrobble_edits.extend(page_edits);\n\n        log::debug!(\n            \"Page 1: found {} unique album variations\",\n            all_scrobble_edits.len()\n        );\n\n        let pagination_selector = Selector::parse(\".pagination .pagination-next\").unwrap();\n        let mut has_next_page = document.select(\u0026pagination_selector).next().is_some();\n        let mut page = 2;\n\n        while has_next_page \u0026\u0026 page \u003c= max_pages {\n            let page_url = {\n                let session = self.session.lock().unwrap();\n                format!(\n                    \"{}/user/{}/library/music/{}/_/{}?page={page}\",\n                    session.base_url,\n                    session.username,\n                    urlencoding::encode(artist_name),\n                    urlencoding::encode(track_name)\n                )\n            };\n\n            log::debug!(\"Fetching page {page} for additional album variations\");\n\n            let mut response = self.get(\u0026page_url).await?;\n            let html = response\n                .body_string()\n                .await\n                .map_err(|e| crate::LastFmError::Http(e.to_string()))?;\n\n            let document = Html::parse_document(\u0026html);\n\n            let page_edits = self.extract_scrobble_edits_from_page(\n                \u0026document,\n                track_name,\n                artist_name,\n                \u0026mut unique_albums,\n            )?;\n\n            let initial_count = all_scrobble_edits.len();\n            all_scrobble_edits.extend(page_edits);\n            let found_new_unique_albums = all_scrobble_edits.len() \u003e initial_count;\n\n            has_next_page = document.select(\u0026pagination_selector).next().is_some();\n\n            log::debug!(\n                \"Page {page}: found {} total unique albums ({})\",\n                all_scrobble_edits.len(),\n                if found_new_unique_albums {\n                    \"new albums found\"\n                } else {\n                    \"no new unique albums\"\n                }\n            );\n\n            page += 1;\n        }\n\n        if all_scrobble_edits.is_empty() {\n            return Err(crate::LastFmError::Parse(format!(\n                \"No scrobble forms found for track '{track_name}' by '{artist_name}'\"\n            )));\n        }\n\n        log::debug!(\n            \"Final result: found {} unique album variations for '{track_name}' by '{artist_name}'\",\n            all_scrobble_edits.len(),\n        );\n\n        Ok(all_scrobble_edits)\n    }\n\n    fn extract_scrobble_edits_from_page(\n        \u0026self,\n        document: \u0026Html,\n        expected_track: \u0026str,\n        expected_artist: \u0026str,\n        unique_albums: \u0026mut std::collections::HashSet\u003c(String, String)\u003e,\n    ) -\u003e Result\u003cVec\u003cExactScrobbleEdit\u003e\u003e {\n        let mut scrobble_edits = Vec::new();\n        let table_selector =\n            Selector::parse(\"table.chartlist:not(.chartlist__placeholder)\").unwrap();\n        let table = document.select(\u0026table_selector).next().ok_or_else(|| {\n            crate::LastFmError::Parse(\"No chartlist table found on track page\".to_string())\n        })?;\n\n        let row_selector = Selector::parse(\"tr\").unwrap();\n        for row in table.select(\u0026row_selector) {\n            let count_bar_link_selector = Selector::parse(\".chartlist-count-bar-link\").unwrap();\n            if row.select(\u0026count_bar_link_selector).next().is_some() {\n                log::debug!(\"Found count bar link, skipping aggregated row\");\n                continue;\n            }\n\n            let form_selector = Selector::parse(\"form[data-edit-scrobble]\").unwrap();\n            if let Some(form) = row.select(\u0026form_selector).next() {\n                let extract_form_value = |name: \u0026str| -\u003e Option\u003cString\u003e {\n                    let selector = Selector::parse(\u0026format!(\"input[name='{name}']\")).unwrap();\n                    form.select(\u0026selector)\n                        .next()\n                        .and_then(|input| input.value().attr(\"value\"))\n                        .map(|s| s.to_string())\n                };\n\n                let form_track = extract_form_value(\"track_name\").unwrap_or_default();\n                let form_artist = extract_form_value(\"artist_name\").unwrap_or_default();\n                let form_album = extract_form_value(\"album_name\").unwrap_or_default();\n                let form_album_artist =\n                    extract_form_value(\"album_artist_name\").unwrap_or_else(|| form_artist.clone());\n                let form_timestamp = extract_form_value(\"timestamp\").unwrap_or_default();\n\n                if form_track == expected_track \u0026\u0026 form_artist == expected_artist {\n                    let album_key = (form_album.clone(), form_album_artist.clone());\n                    if unique_albums.insert(album_key) {\n                        let timestamp = if form_timestamp.is_empty() {\n                            None\n                        } else {\n                            form_timestamp.parse::\u003cu64\u003e().ok()\n                        };\n\n                        if let Some(timestamp) = timestamp {\n                            let scrobble_edit = ExactScrobbleEdit::new(\n                                form_track.clone(),\n                                form_album.clone(),\n                                form_artist.clone(),\n                                form_album_artist.clone(),\n                                form_track,\n                                form_album,\n                                form_artist,\n                                form_album_artist,\n                                timestamp,\n                                true,\n                            );\n                            scrobble_edits.push(scrobble_edit);\n                        } else {\n                            log::warn!(\n                                \"⚠️ Skipping form without valid timestamp: '{form_album}' by '{form_album_artist}'\"\n                            );\n                        }\n                    }\n                }\n            }\n        }\n\n        Ok(scrobble_edits)\n    }\n\n    pub async fn get_artist_tracks_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003cTrackPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/music/{}/+tracks?page={}\u0026ajax=true\",\n                session.base_url,\n                session.username,\n                urlencoding::encode(artist),\n                page\n            )\n        };\n\n        log::debug!(\"Fetching tracks page {page} for artist: {artist}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"AJAX response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        log::debug!(\"Parsing HTML response from AJAX endpoint\");\n        let document = Html::parse_document(\u0026content);\n        self.parser.parse_tracks_page(\u0026document, page, artist, None)\n    }\n\n    pub fn extract_tracks_from_document(\n        \u0026self,\n        document: \u0026Html,\n        artist: \u0026str,\n        album: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        self.parser\n            .extract_tracks_from_document(document, artist, album)\n    }\n\n    pub fn parse_tracks_page(\n        \u0026self,\n        document: \u0026Html,\n        page_number: u32,\n        artist: \u0026str,\n        album: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cTrackPage\u003e {\n        self.parser\n            .parse_tracks_page(document, page_number, artist, album)\n    }\n\n    fn extract_csrf_token(\u0026self, document: \u0026Html) -\u003e Result\u003cString\u003e {\n        let csrf_selector = Selector::parse(\"input[name=\\\"csrfmiddlewaretoken\\\"]\").unwrap();\n\n        document\n            .select(\u0026csrf_selector)\n            .next()\n            .and_then(|input| input.value().attr(\"value\"))\n            .map(|token| token.to_string())\n            .ok_or(LastFmError::CsrfNotFound)\n    }\n\n    pub async fn get(\u0026self, url: \u0026str) -\u003e Result\u003cResponse\u003e {\n        self.get_with_retry(url).await\n    }\n\n    async fn get_with_retry(\u0026self, url: \u0026str) -\u003e Result\u003cResponse\u003e {\n        let config = self.config.retry.clone();\n\n        let url_string = url.to_string();\n        let client = self.clone();\n\n        let retry_result = retry::retry_with_backoff(\n            config,\n            \u0026format!(\"GET {url}\"),\n            || async {\n                let mut response = client.get_with_redirects(\u0026url_string, 0).await?;\n\n                let body = client\n                    .extract_response_body(\u0026url_string, \u0026mut response)\n                    .await?;\n\n                if response.status().is_success() \u0026\u0026 client.is_rate_limit_response(\u0026body) {\n                    log::debug!(\"Response body contains rate limit patterns\");\n                    return Err(LastFmError::RateLimit { retry_after: 60 });\n                }\n\n                let mut new_response = http_types::Response::new(response.status());\n                for (name, values) in response.iter() {\n                    for value in values {\n                        let _ = new_response.insert_header(name.clone(), value.clone());\n                    }\n                }\n                new_response.set_body(body);\n\n                Ok(new_response)\n            },\n            |delay, rate_limit_timestamp, operation_name| {\n                self.broadcast_event(ClientEvent::RateLimited {\n                    delay_seconds: delay,\n                    request: None, // No specific request context in retry callback\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    rate_limit_timestamp,\n                });\n                log::debug!(\"{operation_name} rate limited, waiting {delay} seconds\");\n            },\n            |total_duration, _operation_name| {\n                self.broadcast_event(ClientEvent::RateLimitEnded {\n                    request: crate::types::RequestInfo::from_url_and_method(\u0026url_string, \"GET\"),\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    total_rate_limit_duration_seconds: total_duration,\n                });\n            },\n        )\n        .await?;\n\n        Ok(retry_result.result)\n    }\n\n    async fn get_with_redirects(\u0026self, url: \u0026str, redirect_count: u32) -\u003e Result\u003cResponse\u003e {\n        if redirect_count \u003e 5 {\n            return Err(LastFmError::Http(\"Too many redirects\".to_string()));\n        }\n\n        let mut request = Request::new(Method::Get, url.parse::\u003cUrl\u003e().unwrap());\n\n        {\n            let session = self.session.lock().unwrap();\n            headers::add_cookies(\u0026mut request, \u0026session.cookies);\n            if session.cookies.is_empty() \u0026\u0026 url.contains(\"page=\") {\n                log::debug!(\"No cookies available for paginated request!\");\n            }\n        }\n\n        let is_ajax = url.contains(\"ajax=true\");\n        let referer_url = if url.contains(\"page=\") {\n            Some(url.split('?').next().unwrap_or(url))\n        } else {\n            None\n        };\n\n        headers::add_get_headers(\u0026mut request, is_ajax, referer_url);\n\n        let request_info = RequestInfo::from_url_and_method(url, \"GET\");\n        let request_start = std::time::Instant::now();\n\n        self.broadcast_event(ClientEvent::RequestStarted {\n            request: request_info.clone(),\n        });\n\n        let response = self\n            .client\n            .send(request)\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        self.broadcast_event(ClientEvent::RequestCompleted {\n            request: request_info.clone(),\n            status_code: response.status().into(),\n            duration_ms: request_start.elapsed().as_millis() as u64,\n        });\n\n        self.extract_cookies(\u0026response);\n\n        if response.status() == 302 || response.status() == 301 {\n            if let Some(location) = response.header(\"location\") {\n                if let Some(redirect_url) = location.get(0) {\n                    let redirect_url_str = redirect_url.as_str();\n                    if url.contains(\"page=\") {\n                        log::debug!(\"Following redirect from {url} to {redirect_url_str}\");\n\n                        if redirect_url_str.contains(\"/login\") {\n                            log::debug!(\"Redirect to login page - authentication failed for paginated request\");\n                            return Err(LastFmError::Auth(\n                                \"Session expired or invalid for paginated request\".to_string(),\n                            ));\n                        }\n                    }\n\n                    let full_redirect_url = if redirect_url_str.starts_with('/') {\n                        let base_url = self.session.lock().unwrap().base_url.clone();\n                        format!(\"{base_url}{redirect_url_str}\")\n                    } else if redirect_url_str.starts_with(\"http\") {\n                        redirect_url_str.to_string()\n                    } else {\n                        let base_url = url\n                            .rsplit('/')\n                            .skip(1)\n                            .collect::\u003cVec\u003c_\u003e\u003e()\n                            .into_iter()\n                            .rev()\n                            .collect::\u003cVec\u003c_\u003e\u003e()\n                            .join(\"/\");\n                        format!(\"{base_url}/{redirect_url_str}\")\n                    };\n\n                    return Box::pin(\n                        self.get_with_redirects(\u0026full_redirect_url, redirect_count + 1),\n                    )\n                    .await;\n                }\n            }\n        }\n\n        if self.config.rate_limit.detect_by_status \u0026\u0026 response.status() == 429 {\n            let retry_after = response\n                .header(\"retry-after\")\n                .and_then(|h| h.get(0))\n                .and_then(|v| v.as_str().parse::\u003cu64\u003e().ok())\n                .unwrap_or(60);\n            self.broadcast_event(ClientEvent::RateLimited {\n                delay_seconds: retry_after,\n                request: Some(request_info.clone()),\n                rate_limit_type: RateLimitType::Http429,\n                rate_limit_timestamp: std::time::SystemTime::now()\n                    .duration_since(std::time::UNIX_EPOCH)\n                    .unwrap_or_default()\n                    .as_secs(),\n            });\n            return Err(LastFmError::RateLimit { retry_after });\n        }\n\n        if self.config.rate_limit.detect_by_status \u0026\u0026 response.status() == 403 {\n            log::debug!(\"Got 403 response, checking if it's a rate limit\");\n            {\n                let session = self.session.lock().unwrap();\n                if !session.cookies.is_empty() {\n                    log::debug!(\"403 on authenticated request - likely rate limit\");\n                    self.broadcast_event(ClientEvent::RateLimited {\n                        delay_seconds: 60,\n                        request: Some(request_info.clone()),\n                        rate_limit_type: RateLimitType::Http403,\n                        rate_limit_timestamp: std::time::SystemTime::now()\n                            .duration_since(std::time::UNIX_EPOCH)\n                            .unwrap_or_default()\n                            .as_secs(),\n                    });\n                    return Err(LastFmError::RateLimit { retry_after: 60 });\n                }\n            }\n        }\n\n        Ok(response)\n    }\n\n    fn is_rate_limit_response(\u0026self, response_body: \u0026str) -\u003e bool {\n        let rate_limit_config = \u0026self.config.rate_limit;\n\n        if !rate_limit_config.detect_by_patterns \u0026\u0026 rate_limit_config.custom_patterns.is_empty() {\n            return false;\n        }\n\n        let body_lower = response_body.to_lowercase();\n\n        for pattern in \u0026rate_limit_config.custom_patterns {\n            if body_lower.contains(\u0026pattern.to_lowercase()) {\n                log::debug!(\"Rate limit detected (custom pattern: '{pattern}')\");\n                return true;\n            }\n        }\n\n        if rate_limit_config.detect_by_patterns {\n            for pattern in \u0026rate_limit_config.patterns {\n                let pattern_lower = pattern.to_lowercase();\n                if body_lower.contains(\u0026pattern_lower) {\n                    log::debug!(\"Rate limit detected (pattern: '{pattern}')\");\n                    return true;\n                }\n            }\n        }\n\n        false\n    }\n\n    fn extract_cookies(\u0026self, response: \u0026Response) {\n        let mut session = self.session.lock().unwrap();\n        extract_cookies_from_response(response, \u0026mut session.cookies);\n    }\n\n    async fn extract_response_body(\u0026self, _url: \u0026str, response: \u0026mut Response) -\u003e Result\u003cString\u003e {\n        let body = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        Ok(body)\n    }\n\n    pub async fn get_artists_page(\u0026self, page: u32) -\u003e Result\u003ccrate::ArtistPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/artists?page={}\",\n                session.base_url, session.username, page\n            )\n        };\n\n        log::debug!(\"Fetching artists page {page}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"Artist library response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        log::debug!(\"Parsing HTML response from artist library endpoint\");\n        let document = Html::parse_document(\u0026content);\n        self.parser.parse_artists_page(\u0026document, page)\n    }\n\n    pub async fn get_artist_albums_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003cAlbumPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/music/{}/+albums?page={}\u0026ajax=true\",\n                session.base_url,\n                session.username,\n                urlencoding::encode(artist),\n                page\n            )\n        };\n\n        log::debug!(\"Fetching albums page {page} for artist: {artist}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"AJAX response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        log::debug!(\"Parsing HTML response from AJAX endpoint\");\n        let document = Html::parse_document(\u0026content);\n        self.parser.parse_albums_page(\u0026document, page, artist)\n    }\n\n    pub async fn get_album_tracks_page(\n        \u0026self,\n        album_name: \u0026str,\n        artist_name: \u0026str,\n        page: u32,\n    ) -\u003e Result\u003cTrackPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/music/{}/{}?page={}\u0026ajax=true\",\n                session.base_url,\n                session.username,\n                self.lastfm_encode(artist_name),\n                self.lastfm_encode(album_name),\n                page\n            )\n        };\n\n        log::debug!(\"Fetching tracks page {page} for album '{album_name}' by '{artist_name}'\");\n        log::debug!(\"🔗 Album URL: {url}\");\n\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"AJAX response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        log::debug!(\"Parsing HTML response from AJAX endpoint\");\n        let document = Html::parse_document(\u0026content);\n        let result =\n            self.parser\n                .parse_tracks_page(\u0026document, page, artist_name, Some(album_name))?;\n\n        // Debug logging for albums that return 0 tracks\n        if result.tracks.is_empty() {\n            if content.contains(\"404\") || content.contains(\"Not Found\") {\n                log::warn!(\"🚨 404 ERROR for album '{album_name}' by '{artist_name}': {url}\");\n            } else if content.contains(\"no tracks\") || content.contains(\"no music\") {\n                log::debug!(\"ℹ️  Album '{album_name}' by '{artist_name}' explicitly has no tracks in user's library\");\n            } else {\n                log::warn!(\n                    \"🚨 UNKNOWN EMPTY RESPONSE for album '{album_name}' by '{artist_name}': {url}\"\n                );\n                log::debug!(\"🔍 Response length: {} chars\", content.len());\n                log::debug!(\n                    \"🔍 Response preview (first 200 chars): {}\",\n                    \u0026content.chars().take(200).collect::\u003cString\u003e()\n                );\n            }\n        } else {\n            log::debug!(\n                \"✅ SUCCESS: Album '{album_name}' by '{artist_name}' returned {} tracks\",\n                result.tracks.len()\n            );\n        }\n\n        Ok(result)\n    }\n\n    pub async fn search_tracks_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003cTrackPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/tracks/search?page={}\u0026query={}\u0026ajax=1\",\n                session.base_url,\n                session.username,\n                page,\n                urlencoding::encode(query)\n            )\n        };\n\n        log::debug!(\"Searching tracks for query '{query}' on page {page}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"Track search response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        let document = Html::parse_document(\u0026content);\n        let tracks = self.parser.parse_track_search_results(\u0026document)?;\n\n        // For search results, we need to determine pagination differently\n        // since we don't have the same pagination structure as regular library pages\n        let (has_next_page, total_pages) = self.parser.parse_pagination(\u0026document, page)?;\n\n        Ok(TrackPage {\n            tracks,\n            page_number: page,\n            has_next_page,\n            total_pages,\n        })\n    }\n\n    pub async fn search_albums_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003cAlbumPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/albums/search?page={}\u0026query={}\u0026ajax=1\",\n                session.base_url,\n                session.username,\n                page,\n                urlencoding::encode(query)\n            )\n        };\n\n        log::debug!(\"Searching albums for query '{query}' on page {page}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"Album search response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        let document = Html::parse_document(\u0026content);\n        let albums = self.parser.parse_album_search_results(\u0026document)?;\n\n        // For search results, we need to determine pagination differently\n        let (has_next_page, total_pages) = self.parser.parse_pagination(\u0026document, page)?;\n\n        Ok(AlbumPage {\n            albums,\n            page_number: page,\n            has_next_page,\n            total_pages,\n        })\n    }\n\n    /// Expose the inner HTTP client for advanced use cases like VCR cassette management\n    pub fn inner_client(\u0026self) -\u003e Arc\u003cdyn HttpClient + Send + Sync\u003e {\n        self.client.clone()\n    }\n}\n\n#[async_trait(?Send)]\nimpl LastFmEditClient for LastFmEditClientImpl {\n    fn username(\u0026self) -\u003e String {\n        self.username()\n    }\n\n    async fn find_recent_scrobble_for_track(\n        \u0026self,\n        track_name: \u0026str,\n        artist_name: \u0026str,\n        max_pages: u32,\n    ) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        self.find_recent_scrobble_for_track(track_name, artist_name, max_pages)\n            .await\n    }\n\n    async fn edit_scrobble(\u0026self, edit: \u0026ScrobbleEdit) -\u003e Result\u003cEditResponse\u003e {\n        self.edit_scrobble(edit).await\n    }\n\n    async fn edit_scrobble_single(\n        \u0026self,\n        exact_edit: \u0026ExactScrobbleEdit,\n        max_retries: u32,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        self.edit_scrobble_single(exact_edit, max_retries).await\n    }\n\n    fn get_session(\u0026self) -\u003e LastFmEditSession {\n        self.get_session()\n    }\n\n    fn subscribe(\u0026self) -\u003e ClientEventReceiver {\n        self.subscribe()\n    }\n\n    fn latest_event(\u0026self) -\u003e Option\u003cClientEvent\u003e {\n        self.latest_event()\n    }\n\n    fn discover_scrobbles(\n        \u0026self,\n        edit: ScrobbleEdit,\n    ) -\u003e Box\u003cdyn crate::AsyncDiscoveryIterator\u003ccrate::ExactScrobbleEdit\u003e\u003e {\n        let track_name = edit.track_name_original.clone();\n        let album_name = edit.album_name_original.clone();\n\n        match (\u0026track_name, \u0026album_name) {\n            (Some(track_name), Some(album_name)) =\u003e Box::new(crate::ExactMatchDiscovery::new(\n                self.clone(),\n                edit,\n                track_name.clone(),\n                album_name.clone(),\n            )),\n\n            (Some(track_name), None) =\u003e Box::new(crate::TrackVariationsDiscovery::new(\n                self.clone(),\n                edit,\n                track_name.clone(),\n            )),\n\n            (None, Some(album_name)) =\u003e Box::new(crate::AlbumTracksDiscovery::new(\n                self.clone(),\n                edit,\n                album_name.clone(),\n            )),\n\n            (None, None) =\u003e Box::new(crate::ArtistTracksDiscovery::new(self.clone(), edit)),\n        }\n    }\n\n    async fn get_artists_page(\u0026self, page: u32) -\u003e Result\u003ccrate::ArtistPage\u003e {\n        self.get_artists_page(page).await\n    }\n\n    async fn get_artist_tracks_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003cTrackPage\u003e {\n        self.get_artist_tracks_page(artist, page).await\n    }\n\n    async fn get_artist_albums_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003cAlbumPage\u003e {\n        self.get_artist_albums_page(artist, page).await\n    }\n\n    async fn get_album_tracks_page(\n        \u0026self,\n        album_name: \u0026str,\n        artist_name: \u0026str,\n        page: u32,\n    ) -\u003e Result\u003cTrackPage\u003e {\n        self.get_album_tracks_page(album_name, artist_name, page)\n            .await\n    }\n\n    async fn get_recent_tracks_page(\u0026self, page: u32) -\u003e Result\u003cTrackPage\u003e {\n        self.get_recent_tracks_page(page).await\n    }\n\n    fn artists(\u0026self) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003ccrate::Artist\u003e\u003e {\n        Box::new(crate::iterator::ArtistsIterator::new(self.clone()))\n    }\n\n    fn artist_tracks(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::ArtistTracksIterator::new(\n            self.clone(),\n            artist.to_string(),\n        ))\n    }\n\n    fn artist_tracks_direct(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::iterator::ArtistTracksDirectIterator::new(\n            self.clone(),\n            artist.to_string(),\n        ))\n    }\n\n    fn artist_albums(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003ccrate::Album\u003e\u003e {\n        Box::new(crate::ArtistAlbumsIterator::new(\n            self.clone(),\n            artist.to_string(),\n        ))\n    }\n\n    fn album_tracks(\n        \u0026self,\n        album_name: \u0026str,\n        artist_name: \u0026str,\n    ) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::AlbumTracksIterator::new(\n            self.clone(),\n            album_name.to_string(),\n            artist_name.to_string(),\n        ))\n    }\n\n    fn recent_tracks(\u0026self) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::RecentTracksIterator::new(self.clone()))\n    }\n\n    fn recent_tracks_from_page(\n        \u0026self,\n        starting_page: u32,\n    ) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::RecentTracksIterator::with_starting_page(\n            self.clone(),\n            starting_page,\n        ))\n    }\n\n    fn search_tracks(\u0026self, query: \u0026str) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::SearchTracksIterator::new(\n            self.clone(),\n            query.to_string(),\n        ))\n    }\n\n    fn search_albums(\u0026self, query: \u0026str) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003ccrate::Album\u003e\u003e {\n        Box::new(crate::SearchAlbumsIterator::new(\n            self.clone(),\n            query.to_string(),\n        ))\n    }\n\n    async fn search_tracks_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003ccrate::TrackPage\u003e {\n        self.search_tracks_page(query, page).await\n    }\n\n    async fn search_albums_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003ccrate::AlbumPage\u003e {\n        self.search_albums_page(query, page).await\n    }\n\n    async fn validate_session(\u0026self) -\u003e bool {\n        self.validate_session().await\n    }\n\n    async fn delete_scrobble(\n        \u0026self,\n        artist_name: \u0026str,\n        track_name: \u0026str,\n        timestamp: u64,\n    ) -\u003e Result\u003cbool\u003e {\n        self.delete_scrobble(artist_name, track_name, timestamp)\n            .await\n    }\n}\n","traces":[{"line":31,"address":[5952096,5952244,5952238],"length":1,"stats":{"Line":1}},{"line":32,"address":[3519263],"length":1,"stats":{"Line":2}},{"line":35,"address":[3554458,3554483,3554208],"length":1,"stats":{"Line":6}},{"line":39,"address":[3519522,3519424],"length":1,"stats":{"Line":14}},{"line":42,"address":[3519988,3519664],"length":1,"stats":{"Line":7}},{"line":47,"address":[5404673],"length":1,"stats":{"Line":7}},{"line":48,"address":[5404707],"length":1,"stats":{"Line":6}},{"line":49,"address":[3519867,3519798],"length":1,"stats":{"Line":10}},{"line":53,"address":[5953425,5952928,5953486],"length":1,"stats":{"Line":0}},{"line":58,"address":[5573819,5573572],"length":1,"stats":{"Line":0}},{"line":59,"address":[3555169,3554996,3555315],"length":1,"stats":{"Line":0}},{"line":60,"address":[5405349],"length":1,"stats":{"Line":0}},{"line":63,"address":[3520624],"length":1,"stats":{"Line":0}},{"line":68,"address":[5697280,5697431],"length":1,"stats":{"Line":0}},{"line":69,"address":[3339979,3340351,3339946,3340076],"length":1,"stats":{"Line":0}},{"line":71,"address":[5773445,5773680,5773529,5773088],"length":1,"stats":{"Line":0}},{"line":72,"address":[5774480,5774277],"length":1,"stats":{"Line":0}},{"line":75,"address":[5249104,5249500],"length":1,"stats":{"Line":2}},{"line":80,"address":[5688842,5688724],"length":1,"stats":{"Line":9}},{"line":83,"address":[5954080],"length":1,"stats":{"Line":1}},{"line":89,"address":[2929778,2929932],"length":1,"stats":{"Line":3}},{"line":90,"address":[5775534,5775398,5775434,5775848],"length":1,"stats":{"Line":1}},{"line":92,"address":[5700191,5699541,5699917,5700010],"length":1,"stats":{"Line":2}},{"line":93,"address":[3343638,3343562],"length":1,"stats":{"Line":2}},{"line":94,"address":[5511564],"length":1,"stats":{"Line":1}},{"line":98,"address":[5689216,5689604],"length":1,"stats":{"Line":1}},{"line":105,"address":[5406362],"length":1,"stats":{"Line":0}},{"line":106,"address":[5249862],"length":1,"stats":{"Line":0}},{"line":107,"address":[18438489],"length":1,"stats":{"Line":1}},{"line":108,"address":[5575084],"length":1,"stats":{"Line":0}},{"line":112,"address":[5250096],"length":1,"stats":{"Line":0}},{"line":119,"address":[5400882,5400724],"length":1,"stats":{"Line":0}},{"line":120,"address":[3344864,3344728,3345178,3344764],"length":1,"stats":{"Line":0}},{"line":122,"address":[3345084,3344615,3344991,3345265],"length":1,"stats":{"Line":0}},{"line":123,"address":[5779480,5779396],"length":1,"stats":{"Line":0}},{"line":124,"address":[5850398],"length":1,"stats":{"Line":0}},{"line":125,"address":[5514179],"length":1,"stats":{"Line":0}},{"line":126,"address":[5850539],"length":1,"stats":{"Line":0}},{"line":127,"address":[5703569],"length":1,"stats":{"Line":0}},{"line":131,"address":[5689808,5690122],"length":1,"stats":{"Line":1}},{"line":136,"address":[5250324,5250437],"length":1,"stats":{"Line":3}},{"line":139,"address":[5576241,5575760,5576207],"length":1,"stats":{"Line":6}},{"line":145,"address":[5955185],"length":1,"stats":{"Line":3}},{"line":146,"address":[5690235],"length":1,"stats":{"Line":5}},{"line":147,"address":[5690302],"length":1,"stats":{"Line":4}},{"line":148,"address":[5690387,5690459],"length":1,"stats":{"Line":13}},{"line":152,"address":[5955664,5956161,5956127],"length":1,"stats":{"Line":0}},{"line":161,"address":[5576390],"length":1,"stats":{"Line":0}},{"line":163,"address":[5690967],"length":1,"stats":{"Line":0}},{"line":166,"address":[5577126,5577160,5576800],"length":1,"stats":{"Line":6}},{"line":172,"address":[5956230],"length":1,"stats":{"Line":5}},{"line":173,"address":[5691288],"length":1,"stats":{"Line":6}},{"line":174,"address":[5956352],"length":1,"stats":{"Line":5}},{"line":175,"address":[5251858],"length":1,"stats":{"Line":6}},{"line":179,"address":[3524002,3524040,3523696],"length":1,"stats":{"Line":11}},{"line":187,"address":[3523762,3523819],"length":1,"stats":{"Line":24}},{"line":188,"address":[5691754],"length":1,"stats":{"Line":14}},{"line":194,"address":[5691968,5692163,5692157],"length":1,"stats":{"Line":3}},{"line":195,"address":[20640844],"length":1,"stats":{"Line":7}},{"line":198,"address":[5692641,5692176,5692613],"length":1,"stats":{"Line":1}},{"line":199,"address":[3524312],"length":1,"stats":{"Line":1}},{"line":200,"address":[3559351,3559307,3559042,3559188],"length":1,"stats":{"Line":3}},{"line":203,"address":[5957863,5957857,5957664],"length":1,"stats":{"Line":1}},{"line":204,"address":[5409774,5409905],"length":1,"stats":{"Line":2}},{"line":207,"address":[5704303,5705795,5704469,5704272,5704426],"length":1,"stats":{"Line":4}},{"line":209,"address":[2934675,2934547],"length":1,"stats":{"Line":2}},{"line":210,"address":[5851706],"length":1,"stats":{"Line":1}},{"line":212,"address":[18439328,18439488],"length":1,"stats":{"Line":1}},{"line":216,"address":[5851852,5851967],"length":1,"stats":{"Line":2}},{"line":219,"address":[2935266,2935183],"length":1,"stats":{"Line":2}},{"line":220,"address":[2935342,2935433],"length":1,"stats":{"Line":2}},{"line":223,"address":[5404094],"length":1,"stats":{"Line":1}},{"line":225,"address":[3107031],"length":1,"stats":{"Line":3}},{"line":226,"address":[3348707],"length":1,"stats":{"Line":1}},{"line":227,"address":[2936363,2936472,2936298],"length":1,"stats":{"Line":3}},{"line":228,"address":[2936435,2936555],"length":1,"stats":{"Line":0}},{"line":229,"address":[5405206],"length":1,"stats":{"Line":0}},{"line":230,"address":[5853626],"length":1,"stats":{"Line":0}},{"line":231,"address":[20641224],"length":1,"stats":{"Line":0}},{"line":233,"address":[5706707],"length":1,"stats":{"Line":0}},{"line":237,"address":[2936520],"length":1,"stats":{"Line":1}},{"line":239,"address":[5706116],"length":1,"stats":{"Line":0}},{"line":243,"address":[5578528],"length":1,"stats":{"Line":1}},{"line":256,"address":[5405820],"length":1,"stats":{"Line":1}},{"line":257,"address":[5783009],"length":1,"stats":{"Line":1}},{"line":258,"address":[3349828],"length":1,"stats":{"Line":1}},{"line":260,"address":[5406621,5406343,5406750,5406216],"length":1,"stats":{"Line":4}},{"line":263,"address":[5707395,5708560,5708584],"length":1,"stats":{"Line":3}},{"line":264,"address":[5855696],"length":1,"stats":{"Line":0}},{"line":265,"address":[5407403,5407437],"length":1,"stats":{"Line":0}},{"line":267,"address":[5519491],"length":1,"stats":{"Line":0}},{"line":268,"address":[5708757],"length":1,"stats":{"Line":0}},{"line":271,"address":[5708863,5708908],"length":1,"stats":{"Line":0}},{"line":273,"address":[5709754,5707489,5709760,5709200],"length":1,"stats":{"Line":1}},{"line":274,"address":[5520000,5520344],"length":1,"stats":{"Line":0}},{"line":275,"address":[2939575],"length":1,"stats":{"Line":0}},{"line":276,"address":[5407928],"length":1,"stats":{"Line":0}},{"line":279,"address":[5520336],"length":1,"stats":{"Line":0}},{"line":284,"address":[5783388,5782939,5783445,5783754,5783548],"length":1,"stats":{"Line":3}},{"line":286,"address":[5855133],"length":1,"stats":{"Line":1}},{"line":287,"address":[2938135],"length":1,"stats":{"Line":0}},{"line":291,"address":[5578624],"length":1,"stats":{"Line":1}},{"line":298,"address":[5710079,5710284],"length":1,"stats":{"Line":2}},{"line":299,"address":[5409127,5409185],"length":1,"stats":{"Line":2}},{"line":301,"address":[5521128,5521230],"length":1,"stats":{"Line":2}},{"line":305,"address":[5521426,5521576,5521529],"length":1,"stats":{"Line":3}},{"line":307,"address":[5521535,5521817],"length":1,"stats":{"Line":2}},{"line":308,"address":[5858165,5858244],"length":1,"stats":{"Line":2}},{"line":311,"address":[5788086,5787472,5787199,5787327,5785894],"length":1,"stats":{"Line":2}},{"line":312,"address":[2942551,2942219,2942477,2942107,2942641,2946594],"length":1,"stats":{"Line":4}},{"line":314,"address":[20641472,20641371],"length":1,"stats":{"Line":3}},{"line":315,"address":[18497012],"length":1,"stats":{"Line":0}},{"line":317,"address":[5788556,5788661],"length":1,"stats":{"Line":2}},{"line":318,"address":[5411707,5411615,5415387],"length":1,"stats":{"Line":2}},{"line":320,"address":[2943149,2943252,2943307],"length":1,"stats":{"Line":3}},{"line":322,"address":[5789082,5789422],"length":1,"stats":{"Line":2}},{"line":325,"address":[5789626,5789532],"length":1,"stats":{"Line":2}},{"line":326,"address":[5524726,5524827],"length":1,"stats":{"Line":2}},{"line":327,"address":[5861149],"length":1,"stats":{"Line":1}},{"line":330,"address":[2944405,2944275],"length":1,"stats":{"Line":2}},{"line":332,"address":[5790745],"length":1,"stats":{"Line":1}},{"line":333,"address":[5525288],"length":1,"stats":{"Line":1}},{"line":334,"address":[5413305],"length":1,"stats":{"Line":1}},{"line":335,"address":[2944574],"length":1,"stats":{"Line":1}},{"line":336,"address":[5861771,5861912],"length":1,"stats":{"Line":2}},{"line":337,"address":[5790691],"length":1,"stats":{"Line":1}},{"line":340,"address":[3357736,3357893,3357638],"length":1,"stats":{"Line":3}},{"line":342,"address":[3362720,3362753],"length":1,"stats":{"Line":2}},{"line":346,"address":[5791255],"length":1,"stats":{"Line":1}},{"line":348,"address":[5862694,5862595],"length":1,"stats":{"Line":2}},{"line":352,"address":[3358141,3358589],"length":1,"stats":{"Line":2}},{"line":353,"address":[3358750,3358628],"length":1,"stats":{"Line":2}},{"line":355,"address":[5863268,5863321],"length":1,"stats":{"Line":2}},{"line":356,"address":[5792027],"length":1,"stats":{"Line":1}},{"line":359,"address":[2946947,2948038,2946857,2946298,2946424,2946507,2946813],"length":1,"stats":{"Line":5}},{"line":361,"address":[2946340],"length":1,"stats":{"Line":1}},{"line":362,"address":[3109201],"length":1,"stats":{"Line":3}},{"line":363,"address":[5527827,5531410,5531392],"length":1,"stats":{"Line":0}},{"line":365,"address":[5415911,5416251],"length":1,"stats":{"Line":2}},{"line":366,"address":[5415934],"length":1,"stats":{"Line":1}},{"line":367,"address":[5864420,5864343],"length":1,"stats":{"Line":2}},{"line":368,"address":[2947270,2947354],"length":1,"stats":{"Line":2}},{"line":371,"address":[3360313,3360224],"length":1,"stats":{"Line":2}},{"line":373,"address":[5718406,5718154,5717780,5718464,5718578],"length":1,"stats":{"Line":4}},{"line":375,"address":[3109226],"length":1,"stats":{"Line":3}},{"line":376,"address":[5529298,5531554,5531536],"length":1,"stats":{"Line":0}},{"line":378,"address":[5794503,5794423],"length":1,"stats":{"Line":2}},{"line":380,"address":[2948610],"length":1,"stats":{"Line":1}},{"line":381,"address":[3361348,3361720],"length":1,"stats":{"Line":2}},{"line":383,"address":[5718901,5718954,5718810],"length":1,"stats":{"Line":0}},{"line":386,"address":[5865919],"length":1,"stats":{"Line":1}},{"line":389,"address":[5253584],"length":1,"stats":{"Line":2}},{"line":390,"address":[3559829],"length":1,"stats":{"Line":1}},{"line":393,"address":[5693168],"length":1,"stats":{"Line":1}},{"line":394,"address":[5410272],"length":1,"stats":{"Line":1}},{"line":397,"address":[5578848,5579004,5579033],"length":1,"stats":{"Line":4}},{"line":398,"address":[5578943,5578868],"length":1,"stats":{"Line":13}},{"line":401,"address":[5532975,5531868,5531742,5531932,5531680],"length":1,"stats":{"Line":4}},{"line":403,"address":[5531833,5531987],"length":1,"stats":{"Line":2}},{"line":404,"address":[5532216,5532158],"length":1,"stats":{"Line":2}},{"line":406,"address":[3363823,3363925],"length":1,"stats":{"Line":2}},{"line":410,"address":[5797513,5797413,5797569],"length":1,"stats":{"Line":3}},{"line":411,"address":[5533007,5531898,5532527,5533579,5532871],"length":1,"stats":{"Line":2}},{"line":412,"address":[5723009,5722657,5723181,5722763,5723067],"length":1,"stats":{"Line":4}},{"line":414,"address":[5739650],"length":1,"stats":{"Line":3}},{"line":415,"address":[5724240,5723149,5724258],"length":1,"stats":{"Line":0}},{"line":417,"address":[5723472],"length":1,"stats":{"Line":0}},{"line":423,"address":[5422058,5422471],"length":1,"stats":{"Line":2}},{"line":424,"address":[5799562],"length":1,"stats":{"Line":1}},{"line":427,"address":[5693472,5693484],"length":1,"stats":{"Line":6}},{"line":428,"address":[5535257,5535371,5535314,5536152,5535476],"length":1,"stats":{"Line":2}},{"line":430,"address":[5872096,5872161],"length":1,"stats":{"Line":6}},{"line":432,"address":[5800972],"length":1,"stats":{"Line":3}},{"line":433,"address":[5725167],"length":1,"stats":{"Line":3}},{"line":434,"address":[5800950],"length":1,"stats":{"Line":2}},{"line":436,"address":[2954905],"length":1,"stats":{"Line":1}},{"line":440,"address":[3560176],"length":1,"stats":{"Line":2}},{"line":446,"address":[5536508,5536555,5536372],"length":1,"stats":{"Line":3}},{"line":448,"address":[5425850,5424434,5424792],"length":1,"stats":{"Line":2}},{"line":449,"address":[3371277,3368185,3368742,3368770,3369730,3369014,3370283],"length":1,"stats":{"Line":4}},{"line":451,"address":[5726822,5726714,5726957],"length":1,"stats":{"Line":3}},{"line":452,"address":[5727125,5727925,5727897],"length":1,"stats":{"Line":5}},{"line":453,"address":[20587622,20587356],"length":1,"stats":{"Line":2}},{"line":458,"address":[18498100],"length":1,"stats":{"Line":2}},{"line":463,"address":[20642495],"length":1,"stats":{"Line":1}},{"line":466,"address":[5538072],"length":1,"stats":{"Line":0}},{"line":469,"address":[5539804,5539613,5540054,5542345,5539536,5539889],"length":1,"stats":{"Line":8}},{"line":470,"address":[5729328,5729000,5731599,5729203,5729082],"length":1,"stats":{"Line":4}},{"line":472,"address":[2959340,2959423],"length":1,"stats":{"Line":2}},{"line":473,"address":[2960318,2959474],"length":1,"stats":{"Line":0}},{"line":474,"address":[2960272],"length":1,"stats":{"Line":0}},{"line":475,"address":[5541921,5541476],"length":1,"stats":{"Line":0}},{"line":477,"address":[5730794],"length":1,"stats":{"Line":0}},{"line":478,"address":[5878018,5877818],"length":1,"stats":{"Line":0}},{"line":480,"address":[5429512],"length":1,"stats":{"Line":1}},{"line":482,"address":[5429652,5430044],"length":1,"stats":{"Line":0}},{"line":483,"address":[20797702,20797937,20796661,20797767,20797895],"length":1,"stats":{"Line":1}},{"line":487,"address":[5877000,5876845,5877163,5877035],"length":1,"stats":{"Line":4}},{"line":492,"address":[5805742],"length":1,"stats":{"Line":1}},{"line":494,"address":[5541273,5541155,5541415,5542862],"length":1,"stats":{"Line":4}},{"line":495,"address":[20590804,20589254,20591169,20590492,20591028,20591572,20591876,20589860,20591221,20590244,20591343,20591700,20590422,20591752,20589979,20589912,20590620,20589382,20590544,20589504,20591476,20589331,20589632,20589764,20590116,20590296,20591424,20589580,20590168,20591624,20590031,20590672,20590371,20590880,20591824,20589712,20589203,20590932,20590752,20591080,20589452,20591291],"length":1,"stats":{"Line":3}},{"line":503,"address":[18444928],"length":1,"stats":{"Line":1}},{"line":505,"address":[18444976],"length":1,"stats":{"Line":2}},{"line":506,"address":[5808952,5808792,5808929],"length":1,"stats":{"Line":2}},{"line":508,"address":[5543819,5544300,5544082],"length":1,"stats":{"Line":3}},{"line":509,"address":[5880346,5880429,5880406],"length":1,"stats":{"Line":2}},{"line":511,"address":[5809297,5809101,5809323],"length":1,"stats":{"Line":2}},{"line":512,"address":[3376525,3376208],"length":1,"stats":{"Line":2}},{"line":513,"address":[5880878,5880798,5880904],"length":1,"stats":{"Line":2}},{"line":515,"address":[3376305],"length":1,"stats":{"Line":1}},{"line":517,"address":[2963360,2963600],"length":1,"stats":{"Line":2}},{"line":523,"address":[2958731,2961247,2963865,2963769],"length":1,"stats":{"Line":2}},{"line":524,"address":[5545513],"length":1,"stats":{"Line":2}},{"line":525,"address":[5545556],"length":1,"stats":{"Line":1}},{"line":527,"address":[5735045,5734838],"length":1,"stats":{"Line":3}},{"line":529,"address":[5881865],"length":1,"stats":{"Line":2}},{"line":530,"address":[3377385],"length":1,"stats":{"Line":2}},{"line":531,"address":[5433646],"length":1,"stats":{"Line":2}},{"line":534,"address":[3377677],"length":1,"stats":{"Line":2}},{"line":535,"address":[5546040],"length":1,"stats":{"Line":2}},{"line":537,"address":[5735411,5735333],"length":1,"stats":{"Line":0}},{"line":538,"address":[5882322],"length":1,"stats":{"Line":0}},{"line":540,"address":[5734018],"length":1,"stats":{"Line":0}},{"line":544,"address":[5430924],"length":1,"stats":{"Line":1}},{"line":547,"address":[5579248],"length":1,"stats":{"Line":1}},{"line":559,"address":[5882904],"length":1,"stats":{"Line":1}},{"line":560,"address":[5811752],"length":1,"stats":{"Line":1}},{"line":562,"address":[5883301,5883175,5883569,5883709],"length":1,"stats":{"Line":4}},{"line":565,"address":[5738484,5738464,5736074],"length":1,"stats":{"Line":3}},{"line":566,"address":[5814256],"length":1,"stats":{"Line":0}},{"line":567,"address":[5738555,5738589],"length":1,"stats":{"Line":0}},{"line":569,"address":[2967923],"length":1,"stats":{"Line":0}},{"line":570,"address":[5549333],"length":1,"stats":{"Line":0}},{"line":573,"address":[5549484,5549439],"length":1,"stats":{"Line":0}},{"line":575,"address":[3381520,3382038,3382032,3378621],"length":1,"stats":{"Line":1}},{"line":576,"address":[3381870,3381568],"length":1,"stats":{"Line":0}},{"line":577,"address":[2968685],"length":1,"stats":{"Line":0}},{"line":578,"address":[5886088],"length":1,"stats":{"Line":0}},{"line":584,"address":[5815110],"length":1,"stats":{"Line":0}},{"line":589,"address":[5739367],"length":1,"stats":{"Line":3}},{"line":591,"address":[5736743,5736878,5736959],"length":1,"stats":{"Line":4}},{"line":592,"address":[2966172],"length":1,"stats":{"Line":1}},{"line":593,"address":[5812511],"length":1,"stats":{"Line":1}},{"line":594,"address":[2966209],"length":1,"stats":{"Line":1}},{"line":595,"address":[2966225],"length":1,"stats":{"Line":1}},{"line":597,"address":[21073360,21073371],"length":1,"stats":{"Line":0}},{"line":599,"address":[21073365],"length":1,"stats":{"Line":0}},{"line":600,"address":[5548164],"length":1,"stats":{"Line":0}},{"line":601,"address":[5436110],"length":1,"stats":{"Line":0}},{"line":603,"address":[5547922,5548644,5548721],"length":1,"stats":{"Line":0}},{"line":605,"address":[5548513,5547959],"length":1,"stats":{"Line":0}},{"line":606,"address":[5884809],"length":1,"stats":{"Line":0}},{"line":607,"address":[2967216],"length":1,"stats":{"Line":0}},{"line":612,"address":[5438240,5438659,5439714,5438299,5438429,5438469],"length":1,"stats":{"Line":4}},{"line":613,"address":[2969205,2969064],"length":1,"stats":{"Line":2}},{"line":614,"address":[2969128,2969345,2969211],"length":1,"stats":{"Line":1}},{"line":615,"address":[5438926,5439011],"length":1,"stats":{"Line":2}},{"line":617,"address":[5740392],"length":1,"stats":{"Line":2}},{"line":618,"address":[2969791],"length":1,"stats":{"Line":1}},{"line":619,"address":[5439168,5439266],"length":1,"stats":{"Line":3}},{"line":620,"address":[2969829],"length":1,"stats":{"Line":2}},{"line":621,"address":[5887545],"length":1,"stats":{"Line":2}},{"line":622,"address":[2969869],"length":1,"stats":{"Line":2}},{"line":626,"address":[18445030],"length":1,"stats":{"Line":1}},{"line":627,"address":[5439633,5439108],"length":1,"stats":{"Line":0}},{"line":628,"address":[5887461],"length":1,"stats":{"Line":0}},{"line":630,"address":[2970153,2970200],"length":1,"stats":{"Line":0}},{"line":631,"address":[20739248],"length":1,"stats":{"Line":0}},{"line":636,"address":[20801470],"length":1,"stats":{"Line":2}},{"line":639,"address":[18502160],"length":1,"stats":{"Line":4}},{"line":640,"address":[21059992],"length":1,"stats":{"Line":0}},{"line":641,"address":[2970568,2970756],"length":1,"stats":{"Line":2}},{"line":642,"address":[5817371,5817429],"length":1,"stats":{"Line":2}},{"line":644,"address":[5741650,5741548],"length":1,"stats":{"Line":2}},{"line":648,"address":[5440621,5440683,5440518],"length":1,"stats":{"Line":3}},{"line":649,"address":[5291074],"length":1,"stats":{"Line":2}},{"line":651,"address":[5889836,5889941],"length":1,"stats":{"Line":2}},{"line":652,"address":[5441631,5441723,5445468],"length":1,"stats":{"Line":2}},{"line":654,"address":[3385844,3385741,3385906],"length":1,"stats":{"Line":3}},{"line":656,"address":[5554422,5554106],"length":1,"stats":{"Line":2}},{"line":658,"address":[3386289,3386189,3386336],"length":1,"stats":{"Line":6}},{"line":664,"address":[5744193,5743799],"length":1,"stats":{"Line":4}},{"line":665,"address":[5891389,5891293,5891417],"length":1,"stats":{"Line":6}},{"line":668,"address":[3387367,3387263],"length":1,"stats":{"Line":4}},{"line":671,"address":[2974267,2974169],"length":1,"stats":{"Line":4}},{"line":672,"address":[5745268,5745167],"length":1,"stats":{"Line":4}},{"line":673,"address":[2974506],"length":1,"stats":{"Line":2}},{"line":676,"address":[2974870,2974740],"length":1,"stats":{"Line":4}},{"line":678,"address":[2974877,2974959,2975084],"length":1,"stats":{"Line":3}},{"line":680,"address":[3392000,3392046],"length":1,"stats":{"Line":2}},{"line":684,"address":[3388561],"length":1,"stats":{"Line":1}},{"line":686,"address":[5821885],"length":1,"stats":{"Line":1}},{"line":687,"address":[5821971,5822086],"length":1,"stats":{"Line":2}},{"line":689,"address":[5822092,5822138],"length":1,"stats":{"Line":2}},{"line":690,"address":[2975504],"length":1,"stats":{"Line":1}},{"line":693,"address":[5747046,5747188,5748286,5746740,5746527,5746657,5747074],"length":1,"stats":{"Line":5}},{"line":695,"address":[2975690],"length":1,"stats":{"Line":1}},{"line":696,"address":[3389193,3389258,3389544,3383860,3389354],"length":1,"stats":{"Line":3}},{"line":697,"address":[5448624,5448642,5445828],"length":1,"stats":{"Line":0}},{"line":699,"address":[5747647,5747314],"length":1,"stats":{"Line":2}},{"line":700,"address":[2976450],"length":1,"stats":{"Line":1}},{"line":701,"address":[3389899,3389976],"length":1,"stats":{"Line":2}},{"line":702,"address":[5558346,5558258],"length":1,"stats":{"Line":2}},{"line":705,"address":[5446468,5446557],"length":1,"stats":{"Line":2}},{"line":707,"address":[2977552,2976941,2977626,2977311,2977716],"length":1,"stats":{"Line":4}},{"line":709,"address":[5895507,5888393,5895203,5895263,5895318],"length":1,"stats":{"Line":3}},{"line":710,"address":[5748607,5750096,5750114],"length":1,"stats":{"Line":0}},{"line":712,"address":[5895837,5895756],"length":1,"stats":{"Line":4}},{"line":714,"address":[5895905],"length":1,"stats":{"Line":1}},{"line":717,"address":[5897248,5897412,5897590,5897467,5897298,5898228],"length":1,"stats":{"Line":4}},{"line":718,"address":[5736687],"length":1,"stats":{"Line":2}},{"line":719,"address":[2980553,2980007,2980463,2980107,2980392],"length":1,"stats":{"Line":4}},{"line":721,"address":[5736706],"length":1,"stats":{"Line":3}},{"line":722,"address":[5898513,5899184,5899202],"length":1,"stats":{"Line":0}},{"line":724,"address":[2980650,2980845,2980740],"length":1,"stats":{"Line":3}},{"line":725,"address":[3394230],"length":1,"stats":{"Line":1}},{"line":728,"address":[5410896],"length":1,"stats":{"Line":1}},{"line":733,"address":[5563333,5563544,5563588],"length":1,"stats":{"Line":4}},{"line":736,"address":[5828542,5828919],"length":1,"stats":{"Line":3}},{"line":737,"address":[5900563,5900412,5900462,5900354],"length":1,"stats":{"Line":4}},{"line":739,"address":[2982271],"length":1,"stats":{"Line":2}},{"line":740,"address":[5753369],"length":1,"stats":{"Line":2}},{"line":741,"address":[2982407],"length":1,"stats":{"Line":2}},{"line":742,"address":[5753525],"length":1,"stats":{"Line":2}},{"line":746,"address":[5753988,5753832,5753932],"length":1,"stats":{"Line":5}},{"line":748,"address":[3396434,3396796,3395155,3397555,3396941],"length":1,"stats":{"Line":4}},{"line":749,"address":[5754880,5755247,5755305,5754992,5757122,5755419],"length":1,"stats":{"Line":4}},{"line":751,"address":[5453637,5451352,5453951,5453697,5453759],"length":1,"stats":{"Line":3}},{"line":752,"address":[5909666,5902395,5909648],"length":1,"stats":{"Line":0}},{"line":754,"address":[5566383,5566278],"length":1,"stats":{"Line":2}},{"line":756,"address":[5755657],"length":1,"stats":{"Line":1}},{"line":757,"address":[5566501],"length":1,"stats":{"Line":1}},{"line":758,"address":[3398328],"length":1,"stats":{"Line":1}},{"line":760,"address":[5566643,5567831,5566735,5566602,5566822],"length":1,"stats":{"Line":3}},{"line":761,"address":[5755862],"length":1,"stats":{"Line":1}},{"line":762,"address":[5831616],"length":1,"stats":{"Line":1}},{"line":763,"address":[5566631],"length":1,"stats":{"Line":1}},{"line":764,"address":[5454559],"length":1,"stats":{"Line":1}},{"line":766,"address":[3398682],"length":1,"stats":{"Line":1}},{"line":768,"address":[5756409,5756537,5756317],"length":1,"stats":{"Line":0}},{"line":773,"address":[2985283,2985647],"length":1,"stats":{"Line":2}},{"line":774,"address":[5455585,5455490],"length":1,"stats":{"Line":2}},{"line":775,"address":[3399538],"length":1,"stats":{"Line":1}},{"line":777,"address":[5835159,5832804],"length":1,"stats":{"Line":2}},{"line":779,"address":[5906453,5907697],"length":1,"stats":{"Line":2}},{"line":780,"address":[3403440,3403338,3403390,3403541],"length":1,"stats":{"Line":4}},{"line":782,"address":[2989597],"length":1,"stats":{"Line":1}},{"line":783,"address":[5907873],"length":1,"stats":{"Line":1}},{"line":784,"address":[5459585],"length":1,"stats":{"Line":1}},{"line":785,"address":[2989823],"length":1,"stats":{"Line":1}},{"line":789,"address":[2990175,2990271],"length":1,"stats":{"Line":2}},{"line":791,"address":[5458657],"length":1,"stats":{"Line":3}},{"line":792,"address":[2991032,2991093,2991252,2986397,2986487,2986272],"length":1,"stats":{"Line":4}},{"line":794,"address":[5567942,5567976,5568168,5573046,5563474,5573106],"length":1,"stats":{"Line":4}},{"line":795,"address":[5573554,5573536,5568327],"length":1,"stats":{"Line":0}},{"line":797,"address":[5833460,5833543],"length":1,"stats":{"Line":2}},{"line":799,"address":[5833769,5833682,5833562,5833593],"length":1,"stats":{"Line":5}},{"line":801,"address":[5456502],"length":1,"stats":{"Line":1}},{"line":802,"address":[3400333],"length":1,"stats":{"Line":2}},{"line":803,"address":[5757845],"length":1,"stats":{"Line":2}},{"line":806,"address":[5758134,5758217],"length":1,"stats":{"Line":2}},{"line":807,"address":[5905233],"length":1,"stats":{"Line":1}},{"line":808,"address":[5758306],"length":1,"stats":{"Line":1}},{"line":810,"address":[3400873],"length":1,"stats":{"Line":2}},{"line":812,"address":[5834558,5834527],"length":1,"stats":{"Line":2}},{"line":822,"address":[3401692,3401105,3401733],"length":1,"stats":{"Line":4}},{"line":825,"address":[2988226,2988326],"length":1,"stats":{"Line":2}},{"line":826,"address":[5836125,5835285],"length":1,"stats":{"Line":0}},{"line":831,"address":[2988550,2988332,2988414,2988677],"length":1,"stats":{"Line":3}},{"line":836,"address":[3402084],"length":1,"stats":{"Line":1}},{"line":839,"address":[5583090,5579488,5584192],"length":1,"stats":{"Line":1}},{"line":846,"address":[3560663],"length":1,"stats":{"Line":1}},{"line":847,"address":[5411224,5411152],"length":1,"stats":{"Line":2}},{"line":849,"address":[5959202,5959341,5959273,5959463],"length":1,"stats":{"Line":3}},{"line":850,"address":[5461614],"length":1,"stats":{"Line":0}},{"line":853,"address":[3526679],"length":1,"stats":{"Line":1}},{"line":854,"address":[5694664,5694743,5694867],"length":1,"stats":{"Line":3}},{"line":855,"address":[5960113,5959919],"length":1,"stats":{"Line":2}},{"line":856,"address":[3527346,3527267],"length":1,"stats":{"Line":2}},{"line":857,"address":[5258686,5258760],"length":1,"stats":{"Line":0}},{"line":861,"address":[3562034],"length":1,"stats":{"Line":1}},{"line":862,"address":[5581229,5581079,5583600,5581158],"length":1,"stats":{"Line":4}},{"line":863,"address":[5256145],"length":1,"stats":{"Line":2}},{"line":864,"address":[3405560],"length":1,"stats":{"Line":1}},{"line":865,"address":[5462056,5462148],"length":1,"stats":{"Line":2}},{"line":867,"address":[5574401,5574400],"length":1,"stats":{"Line":2}},{"line":868,"address":[5574470,5574448],"length":1,"stats":{"Line":2}},{"line":871,"address":[5695705,5695762],"length":1,"stats":{"Line":2}},{"line":872,"address":[3562517,3562425],"length":1,"stats":{"Line":2}},{"line":873,"address":[3528004,3528077],"length":1,"stats":{"Line":2}},{"line":874,"address":[5462416,5462433],"length":1,"stats":{"Line":4}},{"line":876,"address":[5256663,5256587],"length":1,"stats":{"Line":2}},{"line":878,"address":[5413330,5413436,5413392],"length":1,"stats":{"Line":3}},{"line":879,"address":[5256839],"length":1,"stats":{"Line":1}},{"line":880,"address":[5582161],"length":1,"stats":{"Line":1}},{"line":881,"address":[3528777,3528707],"length":1,"stats":{"Line":1}},{"line":882,"address":[3528765],"length":1,"stats":{"Line":0}},{"line":884,"address":[5696646,5696699],"length":1,"stats":{"Line":2}},{"line":887,"address":[5582379],"length":1,"stats":{"Line":1}},{"line":889,"address":[5582414,5582486],"length":1,"stats":{"Line":2}},{"line":890,"address":[3528990,3529058],"length":1,"stats":{"Line":2}},{"line":891,"address":[5696970,5697035],"length":1,"stats":{"Line":2}},{"line":892,"address":[5697043],"length":1,"stats":{"Line":1}},{"line":893,"address":[5697113],"length":1,"stats":{"Line":1}},{"line":894,"address":[3563761],"length":1,"stats":{"Line":1}},{"line":895,"address":[5962185],"length":1,"stats":{"Line":1}},{"line":896,"address":[5257681],"length":1,"stats":{"Line":1}},{"line":900,"address":[5583029],"length":1,"stats":{"Line":1}},{"line":902,"address":[5413913,5414616],"length":1,"stats":{"Line":0}},{"line":911,"address":[5959980],"length":1,"stats":{"Line":1}},{"line":914,"address":[5584224,5584247],"length":1,"stats":{"Line":6}},{"line":916,"address":[5574875,5574721],"length":1,"stats":{"Line":2}},{"line":917,"address":[5764352,5764294,5764402],"length":1,"stats":{"Line":3}},{"line":919,"address":[5462887],"length":1,"stats":{"Line":1}},{"line":920,"address":[5575069],"length":1,"stats":{"Line":1}},{"line":921,"address":[5575123],"length":1,"stats":{"Line":1}},{"line":926,"address":[5911702,5911802,5911858],"length":1,"stats":{"Line":3}},{"line":927,"address":[5841673,5840544,5839778,5841092,5840953],"length":1,"stats":{"Line":2}},{"line":928,"address":[3408613,3408255,3408785,3408361,3408671],"length":1,"stats":{"Line":5}},{"line":930,"address":[3406551,3408334,3408394,3408453,3408645],"length":1,"stats":{"Line":3}},{"line":931,"address":[3410128,3408753,3410146],"length":1,"stats":{"Line":0}},{"line":933,"address":[5766480,5766390,5766638,5766698,5766531],"length":1,"stats":{"Line":0}},{"line":939,"address":[5465624,5465590,5465158],"length":1,"stats":{"Line":4}},{"line":940,"address":[5577929,5577684],"length":1,"stats":{"Line":2}},{"line":941,"address":[2995856],"length":1,"stats":{"Line":1}},{"line":944,"address":[5584272],"length":1,"stats":{"Line":0}},{"line":950,"address":[5698719],"length":1,"stats":{"Line":0}},{"line":954,"address":[5698752],"length":1,"stats":{"Line":0}},{"line":961,"address":[5963800],"length":1,"stats":{"Line":0}},{"line":965,"address":[5259296,5259715,5259709],"length":1,"stats":{"Line":1}},{"line":966,"address":[5259334],"length":1,"stats":{"Line":1}},{"line":968,"address":[5963940,5964073,5964005,5964145],"length":1,"stats":{"Line":4}},{"line":971,"address":[5466448,5466449],"length":1,"stats":{"Line":2}},{"line":972,"address":[5767824,5767846],"length":1,"stats":{"Line":2}},{"line":973,"address":[5259589],"length":1,"stats":{"Line":1}},{"line":976,"address":[2996691,2997092,2996839,2996728,2996578,2996528],"length":1,"stats":{"Line":4}},{"line":977,"address":[3364455],"length":1,"stats":{"Line":4}},{"line":980,"address":[3410976,3411780,3411158,3411198,3411029,3412444],"length":1,"stats":{"Line":7}},{"line":981,"address":[5579395],"length":1,"stats":{"Line":3}},{"line":983,"address":[5579504],"length":1,"stats":{"Line":3}},{"line":984,"address":[3411284],"length":1,"stats":{"Line":3}},{"line":988,"address":[3411348,3411424],"length":1,"stats":{"Line":6}},{"line":989,"address":[5770250,5769133,5770040,5770064,5770314,5771251,5770032,5770495,5770126],"length":1,"stats":{"Line":25}},{"line":990,"address":[5770385,5771195,5770521,5770280,5770188],"length":1,"stats":{"Line":12}},{"line":992,"address":[5917952,5918090,5918136,5918422,5918567,5920143,5918480],"length":1,"stats":{"Line":29}},{"line":993,"address":[5771070,5770963],"length":1,"stats":{"Line":14}},{"line":994,"address":[5771527,5771161,5771446,5770301,5771101,5771257],"length":1,"stats":{"Line":14}},{"line":996,"address":[5582578,5582420,5582500],"length":1,"stats":{"Line":11}},{"line":997,"address":[5772765,5772861,5771907],"length":1,"stats":{"Line":3}},{"line":998,"address":[3415267],"length":1,"stats":{"Line":1}},{"line":1001,"address":[3414456,3414291],"length":1,"stats":{"Line":3}},{"line":1002,"address":[5772057,5771982],"length":1,"stats":{"Line":3}},{"line":1003,"address":[5582993,5583174],"length":1,"stats":{"Line":4}},{"line":1004,"address":[3001132,3001062,3001069],"length":1,"stats":{"Line":2}},{"line":1007,"address":[5772251],"length":1,"stats":{"Line":3}},{"line":1009,"address":[5583113],"length":1,"stats":{"Line":2}},{"line":1011,"address":[5920160],"length":1,"stats":{"Line":1}},{"line":1012,"address":[5471901,5471867],"length":1,"stats":{"Line":2}},{"line":1014,"address":[3001699],"length":1,"stats":{"Line":1}},{"line":1015,"address":[5920229],"length":1,"stats":{"Line":1}},{"line":1018,"address":[21060199],"length":1,"stats":{"Line":2}},{"line":1020,"address":[5472336],"length":1,"stats":{"Line":1}},{"line":1021,"address":[5773708,5773763],"length":1,"stats":{"Line":2}},{"line":1022,"address":[3002212],"length":1,"stats":{"Line":1}},{"line":1023,"address":[5773755],"length":1,"stats":{"Line":1}},{"line":1024,"address":[20647228,20647171],"length":1,"stats":{"Line":0}},{"line":1028,"address":[5916580,5916075,5916201,5916962,5916261,5916499,5916318,5915697,5916719],"length":1,"stats":{"Line":15}},{"line":1030,"address":[5845568],"length":1,"stats":{"Line":2}},{"line":1033,"address":[5584999,5584976],"length":1,"stats":{"Line":22}},{"line":1034,"address":[5921117],"length":1,"stats":{"Line":9}},{"line":1035,"address":[5584987,5586976],"length":1,"stats":{"Line":0}},{"line":1038,"address":[5585063,5584944],"length":1,"stats":{"Line":13}},{"line":1041,"address":[5921501,5921407],"length":1,"stats":{"Line":13}},{"line":1042,"address":[5473257,5473356],"length":1,"stats":{"Line":13}},{"line":1043,"address":[3003302,3003226],"length":1,"stats":{"Line":9}},{"line":1044,"address":[3003361],"length":1,"stats":{"Line":0}},{"line":1048,"address":[5775198],"length":1,"stats":{"Line":4}},{"line":1049,"address":[5922562,5922268,5922339],"length":1,"stats":{"Line":12}},{"line":1050,"address":[5775333,5775428],"length":1,"stats":{"Line":10}},{"line":1052,"address":[20741180],"length":1,"stats":{"Line":2}},{"line":1055,"address":[5922388],"length":1,"stats":{"Line":2}},{"line":1057,"address":[5474231],"length":1,"stats":{"Line":2}},{"line":1058,"address":[18504599,18509071,18504523],"length":1,"stats":{"Line":13}},{"line":1060,"address":[5775720,5775766],"length":1,"stats":{"Line":18}},{"line":1061,"address":[5922759],"length":1,"stats":{"Line":4}},{"line":1064,"address":[5923639,5923781,5923034,5922907,5923117,5923667,5930154],"length":1,"stats":{"Line":45}},{"line":1065,"address":[18447751,18447824,18452010],"length":1,"stats":{"Line":0}},{"line":1066,"address":[5474617],"length":1,"stats":{"Line":4}},{"line":1067,"address":[5452034],"length":1,"stats":{"Line":13}},{"line":1068,"address":[5594256,5587493,5594274],"length":1,"stats":{"Line":0}},{"line":1070,"address":[5776905,5777268],"length":1,"stats":{"Line":8}},{"line":1071,"address":[5923944],"length":1,"stats":{"Line":9}},{"line":1072,"address":[5475749,5475666],"length":1,"stats":{"Line":13}},{"line":1073,"address":[5852850,5852950],"length":1,"stats":{"Line":13}},{"line":1076,"address":[20742570],"length":1,"stats":{"Line":9}},{"line":1078,"address":[21067056,21067065],"length":1,"stats":{"Line":15}},{"line":1079,"address":[5853324,5853470],"length":1,"stats":{"Line":2}},{"line":1080,"address":[3006189],"length":1,"stats":{"Line":1}},{"line":1081,"address":[5476543],"length":1,"stats":{"Line":1}},{"line":1082,"address":[5476623],"length":1,"stats":{"Line":1}},{"line":1083,"address":[5853915,5853802],"length":1,"stats":{"Line":2}},{"line":1085,"address":[5853860,5854263],"length":1,"stats":{"Line":2}},{"line":1086,"address":[5855856,5854272,5855896],"length":1,"stats":{"Line":0}},{"line":1087,"address":[3422881],"length":1,"stats":{"Line":0}},{"line":1088,"address":[5590870],"length":1,"stats":{"Line":0}},{"line":1093,"address":[5588762,5589335],"length":1,"stats":{"Line":2}},{"line":1094,"address":[5925649,5926385],"length":1,"stats":{"Line":2}},{"line":1095,"address":[3007998],"length":1,"stats":{"Line":1}},{"line":1096,"address":[3007954,3007093,3008182,3006997],"length":1,"stats":{"Line":1}},{"line":1097,"address":[5477407,5478039],"length":1,"stats":{"Line":0}},{"line":1099,"address":[20742895,20743254],"length":1,"stats":{"Line":0}},{"line":1107,"address":[5589860],"length":1,"stats":{"Line":0}},{"line":1110,"address":[5783372,5779991,5780053],"length":1,"stats":{"Line":3}},{"line":1111,"address":[5779311,5779891],"length":1,"stats":{"Line":2}},{"line":1113,"address":[5452056],"length":1,"stats":{"Line":3}},{"line":1118,"address":[3006096,3008928],"length":1,"stats":{"Line":14}},{"line":1119,"address":[5929454,5927684],"length":1,"stats":{"Line":0}},{"line":1121,"address":[3011929,3011920],"length":1,"stats":{"Line":0}},{"line":1122,"address":[5594441,5594432],"length":1,"stats":{"Line":0}},{"line":1124,"address":[20744435,20744387],"length":1,"stats":{"Line":0}},{"line":1125,"address":[20652003,20651860],"length":1,"stats":{"Line":0}},{"line":1126,"address":[5929568],"length":1,"stats":{"Line":0}},{"line":1127,"address":[21065215,21065156],"length":1,"stats":{"Line":0}},{"line":1128,"address":[5481343,5481416],"length":1,"stats":{"Line":0}},{"line":1133,"address":[18450203,18450599],"length":1,"stats":{"Line":0}},{"line":1136,"address":[20597614],"length":1,"stats":{"Line":14}},{"line":1137,"address":[5856784,5856685],"length":1,"stats":{"Line":0}},{"line":1139,"address":[5928007,5928289],"length":1,"stats":{"Line":0}},{"line":1140,"address":[5592204,5592125],"length":1,"stats":{"Line":0}},{"line":1141,"address":[3009924,3009807,3009877],"length":1,"stats":{"Line":0}},{"line":1142,"address":[5592319,5592913],"length":1,"stats":{"Line":0}},{"line":1143,"address":[20652306,20652236],"length":1,"stats":{"Line":0}},{"line":1144,"address":[5480270,5480513],"length":1,"stats":{"Line":0}},{"line":1145,"address":[5592689],"length":1,"stats":{"Line":0}},{"line":1146,"address":[5928953,5929038],"length":1,"stats":{"Line":0}},{"line":1151,"address":[5782328],"length":1,"stats":{"Line":0}},{"line":1156,"address":[5856469],"length":1,"stats":{"Line":9}},{"line":1159,"address":[3532681,3533224,3531536],"length":1,"stats":{"Line":3}},{"line":1160,"address":[5585095],"length":1,"stats":{"Line":6}},{"line":1162,"address":[5585103],"length":1,"stats":{"Line":6}},{"line":1163,"address":[5416675],"length":1,"stats":{"Line":0}},{"line":1166,"address":[5416619],"length":1,"stats":{"Line":5}},{"line":1168,"address":[5416760,5416644],"length":1,"stats":{"Line":3}},{"line":1169,"address":[18452631,18454373,18452416,18452463,18455351,18452362],"length":1,"stats":{"Line":0}},{"line":1170,"address":[5261247,5261312],"length":1,"stats":{"Line":0}},{"line":1171,"address":[5261299],"length":1,"stats":{"Line":0}},{"line":1175,"address":[20654488],"length":1,"stats":{"Line":3}},{"line":1176,"address":[20810757,20809386,20809252,20809360,20809562],"length":1,"stats":{"Line":2}},{"line":1177,"address":[5965022],"length":1,"stats":{"Line":2}},{"line":1178,"address":[5965084,5965155],"length":1,"stats":{"Line":7}},{"line":1179,"address":[5700218,5700300],"length":1,"stats":{"Line":2}},{"line":1180,"address":[5260718],"length":1,"stats":{"Line":1}},{"line":1185,"address":[5699842],"length":1,"stats":{"Line":1}},{"line":1188,"address":[21069162,21068199],"length":1,"stats":{"Line":4}},{"line":1189,"address":[5261619],"length":1,"stats":{"Line":9}},{"line":1190,"address":[5701302,5701239],"length":1,"stats":{"Line":13}},{"line":1193,"address":[5701360,5701383],"length":1,"stats":{"Line":28}},{"line":1194,"address":[18702996],"length":1,"stats":{"Line":22}},{"line":1196,"address":[3336135],"length":1,"stats":{"Line":11}},{"line":1197,"address":[5784358,5784626,5784608],"length":1,"stats":{"Line":0}},{"line":1199,"address":[5595212],"length":1,"stats":{"Line":1}},{"line":1202,"address":[5418492,5418480],"length":1,"stats":{"Line":8}},{"line":1204,"address":[5595811,5595657],"length":1,"stats":{"Line":4}},{"line":1205,"address":[20749635],"length":1,"stats":{"Line":4}},{"line":1207,"address":[21070443],"length":1,"stats":{"Line":4}},{"line":1211,"address":[5785593,5785649,5785493],"length":1,"stats":{"Line":6}},{"line":1212,"address":[3427466,3428451,3428587,3429165,3428095],"length":1,"stats":{"Line":4}},{"line":1213,"address":[20602413],"length":1,"stats":{"Line":7}},{"line":1215,"address":[5736098],"length":1,"stats":{"Line":5}},{"line":1216,"address":[3430816,3429493,3430834],"length":1,"stats":{"Line":0}},{"line":1218,"address":[5787337],"length":1,"stats":{"Line":0}},{"line":1224,"address":[3015888,3015426,3015854],"length":1,"stats":{"Line":6}},{"line":1225,"address":[20602720],"length":1,"stats":{"Line":4}},{"line":1226,"address":[5486606],"length":1,"stats":{"Line":2}},{"line":1229,"address":[20750114,20750185],"length":1,"stats":{"Line":8}},{"line":1231,"address":[3016833,3016991],"length":1,"stats":{"Line":4}},{"line":1232,"address":[5599826,5599776,5599718],"length":1,"stats":{"Line":6}},{"line":1234,"address":[18455979,18455943,18456006,18456045],"length":1,"stats":{"Line":2}},{"line":1235,"address":[18512161,18510833,18511312,18511348,18511208,18512226,18509730,18512293,18511883,18512435],"length":1,"stats":{"Line":2}},{"line":1236,"address":[21067279],"length":1,"stats":{"Line":2}},{"line":1241,"address":[20812494],"length":1,"stats":{"Line":6}},{"line":1242,"address":[5624559],"length":1,"stats":{"Line":4}},{"line":1243,"address":[3433445,3432915,3433021,3433273,3433331],"length":1,"stats":{"Line":4}},{"line":1245,"address":[5289906],"length":1,"stats":{"Line":3}},{"line":1246,"address":[5792256,5792274,5790917],"length":1,"stats":{"Line":0}},{"line":1248,"address":[20750336],"length":1,"stats":{"Line":3}},{"line":1254,"address":[5938154,5938620,5938586],"length":1,"stats":{"Line":3}},{"line":1255,"address":[3019708,3019951],"length":1,"stats":{"Line":2}},{"line":1256,"address":[3434350],"length":1,"stats":{"Line":1}},{"line":1259,"address":[5587088],"length":1,"stats":{"Line":1}},{"line":1265,"address":[20812800],"length":1,"stats":{"Line":0}},{"line":1266,"address":[18456412],"length":1,"stats":{"Line":2}},{"line":1267,"address":[5868685,5868911,5868743,5868801],"length":1,"stats":{"Line":4}},{"line":1269,"address":[5868606],"length":1,"stats":{"Line":1}},{"line":1270,"address":[5603716],"length":1,"stats":{"Line":1}},{"line":1271,"address":[18513520],"length":1,"stats":{"Line":1}},{"line":1272,"address":[5940136],"length":1,"stats":{"Line":2}},{"line":1273,"address":[20812928],"length":1,"stats":{"Line":0}},{"line":1277,"address":[5492166,5492266,5492320],"length":1,"stats":{"Line":5}},{"line":1278,"address":[3022106,3021669,3022162],"length":1,"stats":{"Line":4}},{"line":1280,"address":[5870288,5870149,5870890,5869787,5868425],"length":1,"stats":{"Line":4}},{"line":1281,"address":[5493751,5494181,5494067,5493645,5498971,5494009],"length":1,"stats":{"Line":8}},{"line":1283,"address":[5456050],"length":1,"stats":{"Line":3}},{"line":1284,"address":[3023506,3028304,3028327],"length":1,"stats":{"Line":0}},{"line":1286,"address":[18513623],"length":1,"stats":{"Line":0}},{"line":1292,"address":[3438208,3438716,3438676],"length":1,"stats":{"Line":4}},{"line":1293,"address":[5796194,5796469],"length":1,"stats":{"Line":3}},{"line":1294,"address":[5607388,5607291,5607256,5607240,5607484],"length":1,"stats":{"Line":5}},{"line":1296,"address":[5943516,5943508,5943708],"length":1,"stats":{"Line":2}},{"line":1299,"address":[20750951,20750893],"length":1,"stats":{"Line":3}},{"line":1300,"address":[18456847,18456798],"length":1,"stats":{"Line":0}},{"line":1301,"address":[5496387,5498412],"length":1,"stats":{"Line":0}},{"line":1302,"address":[3026004,3025827],"length":1,"stats":{"Line":0}},{"line":1303,"address":[3440439,3441900],"length":1,"stats":{"Line":0}},{"line":1305,"address":[5873900,5873794],"length":1,"stats":{"Line":0}},{"line":1308,"address":[3026596,3026105,3026542],"length":1,"stats":{"Line":0}},{"line":1309,"address":[20658582],"length":1,"stats":{"Line":0}},{"line":1315,"address":[21071577,21072084],"length":1,"stats":{"Line":0}},{"line":1321,"address":[3025041],"length":1,"stats":{"Line":1}},{"line":1324,"address":[3568151,3568128],"length":1,"stats":{"Line":4}},{"line":1326,"address":[5611531,5611377],"length":1,"stats":{"Line":2}},{"line":1327,"address":[5948097,5948016,5947958],"length":1,"stats":{"Line":3}},{"line":1329,"address":[3028867],"length":1,"stats":{"Line":1}},{"line":1330,"address":[5611725],"length":1,"stats":{"Line":1}},{"line":1332,"address":[3029034],"length":1,"stats":{"Line":1}},{"line":1336,"address":[3029422,3029322,3029478],"length":1,"stats":{"Line":3}},{"line":1337,"address":[5612599,5611442,5612735,5612208,5613313],"length":1,"stats":{"Line":2}},{"line":1338,"address":[3030689,3030763,3030853,3030437,3030331,3032385],"length":1,"stats":{"Line":4}},{"line":1340,"address":[5802589,5802781,5802530,5800711,5802470],"length":1,"stats":{"Line":3}},{"line":1341,"address":[5878633,5880240,5880258],"length":1,"stats":{"Line":0}},{"line":1343,"address":[5614040],"length":1,"stats":{"Line":0}},{"line":1349,"address":[5803126,5803539],"length":1,"stats":{"Line":2}},{"line":1350,"address":[5879389,5880190,5879302],"length":1,"stats":{"Line":2}},{"line":1354,"address":[5502505,5502595],"length":1,"stats":{"Line":2}},{"line":1356,"address":[3032058],"length":1,"stats":{"Line":1}},{"line":1357,"address":[5614871],"length":1,"stats":{"Line":1}},{"line":1358,"address":[5804151],"length":1,"stats":{"Line":1}},{"line":1364,"address":[5262080,5262103],"length":1,"stats":{"Line":4}},{"line":1366,"address":[5503489,5503643],"length":1,"stats":{"Line":2}},{"line":1367,"address":[5805200,5805281,5805142],"length":1,"stats":{"Line":3}},{"line":1369,"address":[5880807],"length":1,"stats":{"Line":1}},{"line":1370,"address":[5805165],"length":1,"stats":{"Line":1}},{"line":1372,"address":[3447746],"length":1,"stats":{"Line":1}},{"line":1376,"address":[5616294,5616450,5616394],"length":1,"stats":{"Line":3}},{"line":1377,"address":[5881392,5881783,5881919,5882497,5880626],"length":1,"stats":{"Line":2}},{"line":1378,"address":[5882857,5882685,5882433,5884429,5882327,5882743],"length":1,"stats":{"Line":4}},{"line":1380,"address":[6002290],"length":1,"stats":{"Line":3}},{"line":1381,"address":[5807081,5808688,5808706],"length":1,"stats":{"Line":0}},{"line":1383,"address":[5954222,5954346,5954513,5954312,5954453],"length":1,"stats":{"Line":3}},{"line":1389,"address":[3035559,3035150],"length":1,"stats":{"Line":2}},{"line":1390,"address":[5618589,5619390,5618502],"length":1,"stats":{"Line":2}},{"line":1393,"address":[3450521,3450611],"length":1,"stats":{"Line":2}},{"line":1395,"address":[5884098],"length":1,"stats":{"Line":1}},{"line":1396,"address":[5884055],"length":1,"stats":{"Line":1}},{"line":1397,"address":[5955351],"length":1,"stats":{"Line":1}},{"line":1404,"address":[5701680],"length":1,"stats":{"Line":0}},{"line":1405,"address":[3568229],"length":1,"stats":{"Line":0}},{"line":1411,"address":[3568592],"length":1,"stats":{"Line":0}},{"line":1412,"address":[5702113],"length":1,"stats":{"Line":0}},{"line":1421,"address":[3451703,3451995,3451775],"length":1,"stats":{"Line":3}},{"line":1422,"address":[5299095],"length":1,"stats":{"Line":3}},{"line":1425,"address":[5702295],"length":1,"stats":{"Line":4}},{"line":1426,"address":[5462951],"length":1,"stats":{"Line":1}},{"line":1434,"address":[5632439],"length":1,"stats":{"Line":0}},{"line":1437,"address":[5419520],"length":1,"stats":{"Line":0}},{"line":1438,"address":[3534561],"length":1,"stats":{"Line":0}},{"line":1441,"address":[3568928],"length":1,"stats":{"Line":0}},{"line":1442,"address":[5967493],"length":1,"stats":{"Line":0}},{"line":1445,"address":[5967504],"length":1,"stats":{"Line":0}},{"line":1446,"address":[5967521],"length":1,"stats":{"Line":0}},{"line":1449,"address":[5420591,5419632,5421483],"length":1,"stats":{"Line":1}},{"line":1453,"address":[5419744],"length":1,"stats":{"Line":1}},{"line":1454,"address":[5702738],"length":1,"stats":{"Line":1}},{"line":1456,"address":[5702600,5702799,5703189],"length":1,"stats":{"Line":3}},{"line":1457,"address":[5421314,5420624,5421215],"length":1,"stats":{"Line":3}},{"line":1458,"address":[3569994,3570338],"length":1,"stats":{"Line":2}},{"line":1459,"address":[3536066],"length":1,"stats":{"Line":1}},{"line":1460,"address":[5589613,5589678],"length":1,"stats":{"Line":2}},{"line":1461,"address":[3536182],"length":1,"stats":{"Line":1}},{"line":1464,"address":[5420841,5420916,5420689],"length":1,"stats":{"Line":3}},{"line":1465,"address":[5420718],"length":1,"stats":{"Line":1}},{"line":1466,"address":[3570058],"length":1,"stats":{"Line":1}},{"line":1467,"address":[3570101],"length":1,"stats":{"Line":1}},{"line":1470,"address":[5588953,5588562,5589028],"length":1,"stats":{"Line":4}},{"line":1471,"address":[3535338,3535087],"length":1,"stats":{"Line":2}},{"line":1472,"address":[5263698],"length":1,"stats":{"Line":1}},{"line":1473,"address":[5588893],"length":1,"stats":{"Line":1}},{"line":1476,"address":[5420086,5420142],"length":1,"stats":{"Line":2}},{"line":1480,"address":[5590070],"length":1,"stats":{"Line":8}},{"line":1481,"address":[5510417,5510541,5510214],"length":1,"stats":{"Line":2}},{"line":1484,"address":[5590166],"length":1,"stats":{"Line":4}},{"line":1485,"address":[3345223],"length":1,"stats":{"Line":1}},{"line":1488,"address":[5265126],"length":1,"stats":{"Line":8}},{"line":1489,"address":[5960444,5960102,5960307],"length":1,"stats":{"Line":2}},{"line":1498,"address":[5512837,5512765,5513072],"length":1,"stats":{"Line":4}},{"line":1499,"address":[5960898,5961146,5961200,5961251,5961456],"length":1,"stats":{"Line":4}},{"line":1502,"address":[5961855,5961520,5961555,5961659,5961987,5962269,5961808],"length":1,"stats":{"Line":4}},{"line":1503,"address":[5814881,5814678,5815005],"length":1,"stats":{"Line":1}},{"line":1506,"address":[5704960],"length":1,"stats":{"Line":2}},{"line":1507,"address":[5704991],"length":1,"stats":{"Line":2}},{"line":1510,"address":[3537368,3537152,3537400],"length":1,"stats":{"Line":2}},{"line":1511,"address":[3571499,3571548,3571407],"length":1,"stats":{"Line":6}},{"line":1512,"address":[5970103],"length":1,"stats":{"Line":2}},{"line":1513,"address":[5265590],"length":1,"stats":{"Line":2}},{"line":1517,"address":[3571616,3571824,3571852],"length":1,"stats":{"Line":1}},{"line":1518,"address":[5422523,5422431,5422571],"length":1,"stats":{"Line":3}},{"line":1519,"address":[3571671],"length":1,"stats":{"Line":1}},{"line":1520,"address":[5265846],"length":1,"stats":{"Line":1}},{"line":1524,"address":[5422886,5422640,5422854],"length":1,"stats":{"Line":1}},{"line":1525,"address":[5266062,5266201,5266153],"length":1,"stats":{"Line":3}},{"line":1526,"address":[5970614],"length":1,"stats":{"Line":1}},{"line":1527,"address":[3571956],"length":1,"stats":{"Line":1}},{"line":1531,"address":[5423276,5423270,5422896],"length":1,"stats":{"Line":1}},{"line":1536,"address":[5591747,5591497,5591675],"length":1,"stats":{"Line":3}},{"line":1537,"address":[5266361],"length":1,"stats":{"Line":1}},{"line":1538,"address":[5970936,5971006],"length":1,"stats":{"Line":2}},{"line":1539,"address":[5706022],"length":1,"stats":{"Line":1}},{"line":1543,"address":[5266688],"length":1,"stats":{"Line":2}},{"line":1544,"address":[5423342],"length":1,"stats":{"Line":2}},{"line":1547,"address":[5266784],"length":1,"stats":{"Line":1}},{"line":1551,"address":[5971384],"length":1,"stats":{"Line":1}},{"line":1552,"address":[3572635],"length":1,"stats":{"Line":1}},{"line":1557,"address":[5592294,5592048,5592262],"length":1,"stats":{"Line":1}},{"line":1558,"address":[3538681,3538590,3538729],"length":1,"stats":{"Line":3}},{"line":1559,"address":[5266950],"length":1,"stats":{"Line":1}},{"line":1560,"address":[5706532],"length":1,"stats":{"Line":1}},{"line":1564,"address":[3539046,3539014,3538800],"length":1,"stats":{"Line":2}},{"line":1565,"address":[5267337,5267289,5267198],"length":1,"stats":{"Line":5}},{"line":1566,"address":[3538854],"length":1,"stats":{"Line":2}},{"line":1567,"address":[5706788],"length":1,"stats":{"Line":2}},{"line":1571,"address":[5424070],"length":1,"stats":{"Line":4}},{"line":1572,"address":[5962454,5962796,5962659],"length":1,"stats":{"Line":1}},{"line":1575,"address":[5592710],"length":1,"stats":{"Line":7}},{"line":1576,"address":[5464055],"length":1,"stats":{"Line":1}},{"line":1579,"address":[5892840,5892960,5893182,5892617,5892701,5892768,5892592],"length":1,"stats":{"Line":4}},{"line":1580,"address":[3119063],"length":1,"stats":{"Line":2}},{"line":1589,"address":[5817978,5818198,5817905],"length":1,"stats":{"Line":3}},{"line":1590,"address":[5748023],"length":1,"stats":{"Line":3}}],"covered":579,"coverable":738},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","album_tracks.rs"],"content":"use super::common::filter_by_original_album_artist;\nuse crate::{\n    AsyncDiscoveryIterator, AsyncPaginatedIterator, ExactScrobbleEdit, LastFmEditClientImpl,\n    Result, ScrobbleEdit,\n};\nuse async_trait::async_trait;\n\n/// Case 3: Album tracks discovery (album specified, track not specified)\n///\n/// This discovers all tracks in a specific album by iterating through the album's tracks\n/// and for each track, loading its scrobbles incrementally. This is now truly incremental\n/// like the artist tracks discovery.\npub struct AlbumTracksDiscovery {\n    client: LastFmEditClientImpl,\n    edit: ScrobbleEdit,\n    album_name: String,\n    tracks_iterator: crate::AlbumTracksIterator,\n    current_track_results: Vec\u003cExactScrobbleEdit\u003e,\n    current_track_index: usize,\n}\n\nimpl AlbumTracksDiscovery {\n    pub fn new(client: LastFmEditClientImpl, edit: ScrobbleEdit, album_name: String) -\u003e Self {\n        let tracks_iterator = crate::AlbumTracksIterator::new(\n            client.clone(),\n            album_name.clone(),\n            edit.artist_name_original.clone(),\n        );\n\n        Self {\n            client,\n            edit,\n            album_name,\n            tracks_iterator,\n            current_track_results: Vec::new(),\n            current_track_index: 0,\n        }\n    }\n}\n\n#[async_trait(?Send)]\nimpl AsyncDiscoveryIterator\u003cExactScrobbleEdit\u003e for AlbumTracksDiscovery {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cExactScrobbleEdit\u003e\u003e {\n        // If we have results from the current track, return the next one\n        if self.current_track_index \u003c self.current_track_results.len() {\n            let result = self.current_track_results[self.current_track_index].clone();\n            self.current_track_index += 1;\n            return Ok(Some(result));\n        }\n\n        // Get the next track from the iterator\n        while let Some(track) = self.tracks_iterator.next().await? {\n            log::debug!(\n                \"Getting scrobble data for track '{}' from album '{}' by '{}'\",\n                track.name,\n                self.album_name,\n                self.edit.artist_name_original\n            );\n\n            // Get scrobble data for this track\n            match self\n                .client\n                .load_edit_form_values_internal(\u0026track.name, \u0026self.edit.artist_name_original)\n                .await\n            {\n                Ok(track_scrobbles) =\u003e {\n                    // Apply user's changes and filtering\n                    let mut modified_edits = Vec::new();\n                    for scrobble in track_scrobbles {\n                        let mut modified_edit = scrobble.clone();\n                        if let Some(new_track_name) = \u0026self.edit.track_name {\n                            modified_edit.track_name = new_track_name.clone();\n                        }\n                        if let Some(new_album_name) = \u0026self.edit.album_name {\n                            modified_edit.album_name = new_album_name.clone();\n                        }\n                        modified_edit.artist_name = self.edit.artist_name.clone();\n                        if let Some(new_album_artist_name) = \u0026self.edit.album_artist_name {\n                            modified_edit.album_artist_name = new_album_artist_name.clone();\n                        }\n                        modified_edit.edit_all = self.edit.edit_all;\n                        modified_edits.push(modified_edit);\n                    }\n\n                    let filtered_edits =\n                        filter_by_original_album_artist(modified_edits, \u0026self.edit);\n\n                    if !filtered_edits.is_empty() {\n                        // Store results and return the first one\n                        self.current_track_results = filtered_edits;\n                        self.current_track_index = 1; // We'll return the first result below\n                        return Ok(Some(self.current_track_results[0].clone()));\n                    }\n                }\n                Err(e) =\u003e {\n                    log::debug!(\n                        \"Failed to get scrobble data for track '{}': {}\",\n                        track.name,\n                        e\n                    );\n                    // Continue with next track\n                }\n            }\n        }\n\n        // No more tracks\n        Ok(None)\n    }\n}\n","traces":[{"line":23,"address":[3805344,3806184,3806350],"length":1,"stats":{"Line":1}},{"line":25,"address":[6149880,6149933],"length":1,"stats":{"Line":2}},{"line":26,"address":[6050213,6050275],"length":1,"stats":{"Line":2}},{"line":27,"address":[3321851],"length":1,"stats":{"Line":1}},{"line":35,"address":[3322195],"length":1,"stats":{"Line":1}},{"line":43,"address":[5660335],"length":1,"stats":{"Line":4}},{"line":45,"address":[5865681],"length":1,"stats":{"Line":1}},{"line":46,"address":[6247900],"length":1,"stats":{"Line":1}},{"line":47,"address":[3548554,3548702],"length":1,"stats":{"Line":1}},{"line":48,"address":[5500283],"length":1,"stats":{"Line":1}},{"line":52,"address":[5865458,5869855,5869907,5871306,5866126,5865755],"length":1,"stats":{"Line":3}},{"line":53,"address":[5987797,5987741,5987669],"length":1,"stats":{"Line":3}},{"line":61,"address":[5689013,5693849,5693299,5689122,5693803],"length":1,"stats":{"Line":7}},{"line":63,"address":[5505426,5505002],"length":1,"stats":{"Line":3}},{"line":64,"address":[5301778],"length":1,"stats":{"Line":7}},{"line":66,"address":[5500910],"length":1,"stats":{"Line":1}},{"line":68,"address":[5689270],"length":1,"stats":{"Line":1}},{"line":69,"address":[6248894,6249029,6248778],"length":1,"stats":{"Line":3}},{"line":70,"address":[5689680,5690521],"length":1,"stats":{"Line":2}},{"line":71,"address":[5690561,5690931],"length":1,"stats":{"Line":1}},{"line":72,"address":[5985224,5985090,5985243],"length":1,"stats":{"Line":0}},{"line":74,"address":[3743701,3743984,3744207],"length":1,"stats":{"Line":3}},{"line":75,"address":[3743992,3744049,3744068],"length":1,"stats":{"Line":2}},{"line":77,"address":[3744231,3744212,3744011],"length":1,"stats":{"Line":2}},{"line":78,"address":[3744771,3744370],"length":1,"stats":{"Line":1}},{"line":79,"address":[3551520,3551501,3551343],"length":1,"stats":{"Line":0}},{"line":81,"address":[5985881],"length":1,"stats":{"Line":1}},{"line":82,"address":[5691458],"length":1,"stats":{"Line":1}},{"line":85,"address":[5867167,5867053],"length":1,"stats":{"Line":2}},{"line":88,"address":[3742871,3742942],"length":1,"stats":{"Line":2}},{"line":90,"address":[3549952,3549868],"length":1,"stats":{"Line":1}},{"line":91,"address":[5690126],"length":1,"stats":{"Line":1}},{"line":92,"address":[5690149],"length":1,"stats":{"Line":1}},{"line":95,"address":[3742190],"length":1,"stats":{"Line":0}},{"line":96,"address":[3745185,3745213,3742222],"length":1,"stats":{"Line":0}},{"line":107,"address":[3746927],"length":1,"stats":{"Line":1}}],"covered":32,"coverable":36},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","artist_tracks.rs"],"content":"use super::common::filter_by_original_album_artist;\nuse crate::{\n    AsyncDiscoveryIterator, AsyncPaginatedIterator, ExactScrobbleEdit, LastFmEditClientImpl,\n    Result, ScrobbleEdit,\n};\nuse async_trait::async_trait;\n\n/// Case 4: Artist tracks discovery (neither track nor album specified)\n///\n/// This discovers all tracks by an artist by iterating through the artist's catalog\n/// and for each track, loading its scrobbles incrementally. This is the most complex\n/// case as it involves nested iteration.\npub struct ArtistTracksDiscovery {\n    client: LastFmEditClientImpl,\n    edit: ScrobbleEdit,\n    tracks_iterator: crate::ArtistTracksIterator,\n    current_track_results: Vec\u003cExactScrobbleEdit\u003e,\n    current_track_index: usize,\n}\n\nimpl ArtistTracksDiscovery {\n    pub fn new(client: LastFmEditClientImpl, edit: ScrobbleEdit) -\u003e Self {\n        let tracks_iterator =\n            crate::ArtistTracksIterator::new(client.clone(), edit.artist_name_original.clone());\n\n        Self {\n            client,\n            edit,\n            tracks_iterator,\n            current_track_results: Vec::new(),\n            current_track_index: 0,\n        }\n    }\n}\n\n#[async_trait(?Send)]\nimpl AsyncDiscoveryIterator\u003cExactScrobbleEdit\u003e for ArtistTracksDiscovery {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cExactScrobbleEdit\u003e\u003e {\n        // If we have results from the current track, return the next one\n        if self.current_track_index \u003c self.current_track_results.len() {\n            let result = self.current_track_results[self.current_track_index].clone();\n            self.current_track_index += 1;\n            return Ok(Some(result));\n        }\n\n        // Get the next track from the iterator\n        while let Some(track) = self.tracks_iterator.next().await? {\n            // Get scrobble data for this track\n            match self\n                .client\n                .load_edit_form_values_internal(\u0026track.name, \u0026self.edit.artist_name_original)\n                .await\n            {\n                Ok(track_scrobbles) =\u003e {\n                    // Apply user's changes and filtering\n                    let mut modified_edits = Vec::new();\n                    for scrobble in track_scrobbles {\n                        let mut modified_edit = scrobble.clone();\n                        if let Some(new_track_name) = \u0026self.edit.track_name {\n                            modified_edit.track_name = new_track_name.clone();\n                        }\n                        if let Some(new_album_name) = \u0026self.edit.album_name {\n                            modified_edit.album_name = new_album_name.clone();\n                        }\n                        modified_edit.artist_name = self.edit.artist_name.clone();\n                        if let Some(new_album_artist_name) = \u0026self.edit.album_artist_name {\n                            modified_edit.album_artist_name = new_album_artist_name.clone();\n                        }\n                        modified_edit.edit_all = self.edit.edit_all;\n                        modified_edits.push(modified_edit);\n                    }\n\n                    let filtered_edits =\n                        filter_by_original_album_artist(modified_edits, \u0026self.edit);\n\n                    if !filtered_edits.is_empty() {\n                        // Store results and return the first one\n                        self.current_track_results = filtered_edits;\n                        self.current_track_index = 1; // We'll return the first result below\n                        return Ok(Some(self.current_track_results[0].clone()));\n                    }\n                }\n                Err(e) =\u003e {\n                    log::warn!(\n                        \"Failed to get scrobble data for track '{}': {}\",\n                        track.name,\n                        e\n                    );\n                    // Continue with next track\n                }\n            }\n        }\n\n        // No more tracks\n        Ok(None)\n    }\n}\n","traces":[{"line":22,"address":[2791346,2790720,2791427],"length":1,"stats":{"Line":1}},{"line":23,"address":[3791915],"length":1,"stats":{"Line":1}},{"line":30,"address":[5808898],"length":1,"stats":{"Line":1}},{"line":38,"address":[6395087],"length":1,"stats":{"Line":4}},{"line":40,"address":[6333873],"length":1,"stats":{"Line":1}},{"line":41,"address":[3777388],"length":1,"stats":{"Line":1}},{"line":42,"address":[5952030,5951882],"length":1,"stats":{"Line":1}},{"line":43,"address":[6071883],"length":1,"stats":{"Line":1}},{"line":47,"address":[5471087],"length":1,"stats":{"Line":3}},{"line":49,"address":[5570162,5574386,5574432,5574237,5570053],"length":1,"stats":{"Line":5}},{"line":51,"address":[3544221,3544156],"length":1,"stats":{"Line":2}},{"line":52,"address":[6334581,6333671,6338961,6334386,6338901,6334352],"length":1,"stats":{"Line":5}},{"line":54,"address":[5570270],"length":1,"stats":{"Line":1}},{"line":56,"address":[5760486],"length":1,"stats":{"Line":1}},{"line":57,"address":[6334990,6334874,6335125],"length":1,"stats":{"Line":3}},{"line":58,"address":[6072960,6073801],"length":1,"stats":{"Line":2}},{"line":59,"address":[5761777,5762144],"length":1,"stats":{"Line":1}},{"line":60,"address":[5954117,5954136,5953986],"length":1,"stats":{"Line":0}},{"line":62,"address":[6336474,6336197,6336697],"length":1,"stats":{"Line":1}},{"line":63,"address":[5571986,5572062,5572043],"length":1,"stats":{"Line":0}},{"line":65,"address":[3542154,3542173,3541953],"length":1,"stats":{"Line":2}},{"line":66,"address":[3780252,3780641],"length":1,"stats":{"Line":2}},{"line":67,"address":[3542539,3542387,3542558],"length":1,"stats":{"Line":2}},{"line":69,"address":[5572461],"length":1,"stats":{"Line":1}},{"line":70,"address":[3542434],"length":1,"stats":{"Line":1}},{"line":73,"address":[5570749,5570863],"length":1,"stats":{"Line":2}},{"line":76,"address":[3778830,3778759],"length":1,"stats":{"Line":2}},{"line":78,"address":[5570948,5571040],"length":1,"stats":{"Line":1}},{"line":79,"address":[3541134],"length":1,"stats":{"Line":1}},{"line":80,"address":[5761365],"length":1,"stats":{"Line":1}},{"line":83,"address":[5570190],"length":1,"stats":{"Line":0}},{"line":84,"address":[5763343,5763371,5760398],"length":1,"stats":{"Line":0}},{"line":95,"address":[3782358],"length":1,"stats":{"Line":1}}],"covered":29,"coverable":33},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","common.rs"],"content":"use crate::{ExactScrobbleEdit, ScrobbleEdit};\n\n/// Filter discovered edits based on original album artist if specified\n///\n/// When album_artist_name_original is specified in the ScrobbleEdit, we only want\n/// to return ExactScrobbleEdits that match that original album artist value.\n/// This prevents implicit fan-out over different album artists.\npub fn filter_by_original_album_artist(\n    discovered_edits: Vec\u003cExactScrobbleEdit\u003e,\n    edit: \u0026ScrobbleEdit,\n) -\u003e Vec\u003cExactScrobbleEdit\u003e {\n    if let Some(target_album_artist) = \u0026edit.album_artist_name_original {\n        log::debug!(\n            \"Filtering {} discovered edits to only include album artist '{}'\",\n            discovered_edits.len(),\n            target_album_artist\n        );\n\n        let filtered: Vec\u003cExactScrobbleEdit\u003e = discovered_edits\n            .into_iter()\n            .filter(|scrobble| scrobble.album_artist_name_original == *target_album_artist)\n            .collect();\n\n        log::debug!(\n            \"After filtering by album artist '{}': {} edits remain\",\n            target_album_artist,\n            filtered.len()\n        );\n\n        filtered\n    } else {\n        discovered_edits\n    }\n}\n","traces":[{"line":8,"address":[5980000,5981204],"length":1,"stats":{"Line":1}},{"line":12,"address":[6093639,6094299,6093486],"length":1,"stats":{"Line":3}},{"line":13,"address":[6093835],"length":1,"stats":{"Line":0}},{"line":19,"address":[5715252,5715661],"length":1,"stats":{"Line":2}},{"line":21,"address":[6047129,6047104],"length":1,"stats":{"Line":3}},{"line":24,"address":[3550122],"length":1,"stats":{"Line":3}},{"line":30,"address":[3549992],"length":1,"stats":{"Line":1}},{"line":32,"address":[3549337],"length":1,"stats":{"Line":1}}],"covered":7,"coverable":8},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","discovery_iterator.rs"],"content":"use crate::Result;\nuse async_trait::async_trait;\n\n/// Async iterator trait for discovering scrobble edits incrementally\n///\n/// This trait is designed for iterators that yield individual results one at a time,\n/// unlike AsyncPaginatedIterator which is designed for page-based iteration.\n/// This is particularly useful for discovery operations that might make many API\n/// requests and need to avoid rate limiting by yielding results incrementally.\n#[async_trait(?Send)]\npub trait AsyncDiscoveryIterator\u003cT\u003e {\n    /// Get the next item from the iterator\n    ///\n    /// Returns `Ok(Some(item))` if there's a next item available,\n    /// `Ok(None)` if the iterator is exhausted, or `Err(e)` if an error occurred.\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cT\u003e\u003e;\n\n    /// Collect all remaining items from the iterator into a Vec\n    ///\n    /// This is a convenience method that calls `next()` repeatedly until\n    /// the iterator is exhausted and collects all results.\n    async fn collect_all(\u0026mut self) -\u003e Result\u003cVec\u003cT\u003e\u003e {\n        let mut items = Vec::new();\n        while let Some(item) = self.next().await? {\n            items.push(item);\n        }\n        Ok(items)\n    }\n\n    /// Take the first `n` items from the iterator\n    ///\n    /// This stops after collecting `n` items or when the iterator is exhausted,\n    /// whichever comes first.\n    async fn take(\u0026mut self, n: usize) -\u003e Result\u003cVec\u003cT\u003e\u003e {\n        let mut items = Vec::with_capacity(n);\n        for _ in 0..n {\n            if let Some(item) = self.next().await? {\n                items.push(item);\n            } else {\n                break;\n            }\n        }\n        Ok(items)\n    }\n}\n","traces":[{"line":22,"address":[3544457],"length":1,"stats":{"Line":8}},{"line":23,"address":[6150652,6153372,6152012,6149292],"length":1,"stats":{"Line":2}},{"line":24,"address":[5413609,5414969,5412572,5412983,5410889,5411981,5413341,5413366,5412249,5413932,5414726,5410621,5413282,5410646,5411922,5412006,5415292,5410263,5411212,5411623,5414343,5414701,5410562,5414642],"length":1,"stats":{"Line":8}},{"line":25,"address":[5411151,5413871,5415231,5415277,5411197,5413917,5412557,5412511],"length":1,"stats":{"Line":4}},{"line":27,"address":[3440313,3441609,3439017,3437721],"length":1,"stats":{"Line":2}},{"line":34,"address":[6076862],"length":1,"stats":{"Line":0}},{"line":35,"address":[5889783,5892791,5891287,5894295],"length":1,"stats":{"Line":0}},{"line":36,"address":[5417652,5419156,5420660,5416148,5417639,5417559,5420647,5421255,5416135,5419751,5419063,5416743,5418247,5419143,5416055,5420567],"length":1,"stats":{"Line":0}},{"line":37,"address":[3348868,3352756,3348308,3351364],"length":1,"stats":{"Line":0}},{"line":38,"address":[3659421,3656367,3660879,3657917,3656413,3660925,3657871,3659375],"length":1,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}}],"covered":5,"coverable":12},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","exact_match.rs"],"content":"use super::common::filter_by_original_album_artist;\nuse crate::{\n    AsyncDiscoveryIterator, ExactScrobbleEdit, LastFmEditClientImpl, LastFmError, Result,\n    ScrobbleEdit,\n};\nuse async_trait::async_trait;\n\n/// Case 1: Exact match discovery (track + album specified)\n///\n/// This discovers the specific scrobble that matches both the track and album,\n/// yielding at most one result.\npub struct ExactMatchDiscovery {\n    client: LastFmEditClientImpl,\n    edit: ScrobbleEdit,\n    track_name: String,\n    album_name: String,\n    result: Option\u003cExactScrobbleEdit\u003e,\n    completed: bool,\n}\n\nimpl ExactMatchDiscovery {\n    pub fn new(\n        client: LastFmEditClientImpl,\n        edit: ScrobbleEdit,\n        track_name: String,\n        album_name: String,\n    ) -\u003e Self {\n        Self {\n            client,\n            edit,\n            track_name,\n            album_name,\n            result: None,\n            completed: false,\n        }\n    }\n}\n\n#[async_trait(?Send)]\nimpl AsyncDiscoveryIterator\u003cExactScrobbleEdit\u003e for ExactMatchDiscovery {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cExactScrobbleEdit\u003e\u003e {\n        if self.completed {\n            return Ok(None);\n        }\n\n        if self.result.is_none() {\n            // Perform the lookup inline (previously discover_track_album_exact_match)\n            log::debug!(\n                \"Looking up missing metadata for track '{}' on album '{}' by '{}'\",\n                self.track_name,\n                self.album_name,\n                self.edit.artist_name_original\n            );\n\n            match self\n                .client\n                .load_edit_form_values_internal(\u0026self.track_name, \u0026self.edit.artist_name_original)\n                .await\n            {\n                Ok(all_variations) =\u003e {\n                    // Filter by album artist first if specified, then find the variation that matches the specific album\n                    let filtered_variations =\n                        filter_by_original_album_artist(all_variations, \u0026self.edit);\n\n                    if let Some(exact_edit) = filtered_variations\n                        .iter()\n                        .find(|variation| variation.album_name_original == self.album_name)\n                    {\n                        // Apply the user's desired changes to this exact variation\n                        let mut modified_edit = exact_edit.clone();\n                        if let Some(new_track_name) = \u0026self.edit.track_name {\n                            modified_edit.track_name = new_track_name.clone();\n                        }\n                        if let Some(new_album_name) = \u0026self.edit.album_name {\n                            modified_edit.album_name = new_album_name.clone();\n                        }\n                        modified_edit.artist_name = self.edit.artist_name.clone();\n                        if let Some(new_album_artist_name) = \u0026self.edit.album_artist_name {\n                            modified_edit.album_artist_name = new_album_artist_name.clone();\n                        }\n                        modified_edit.edit_all = self.edit.edit_all;\n\n                        self.result = Some(modified_edit);\n                    } else {\n                        let album_artist_filter = if self.edit.album_artist_name_original.is_some()\n                        {\n                            format!(\n                                \" with album artist '{}'\",\n                                self.edit.album_artist_name_original.as_ref().unwrap()\n                            )\n                        } else {\n                            String::new()\n                        };\n                        self.completed = true;\n                        return Err(LastFmError::Parse(format!(\n                            \"Track '{}' not found on album '{}' by '{}'{} in recent scrobbles\",\n                            self.track_name,\n                            self.album_name,\n                            self.edit.artist_name_original,\n                            album_artist_filter\n                        )));\n                    }\n                }\n                Err(e) =\u003e {\n                    self.completed = true;\n                    return Err(e);\n                }\n            }\n        }\n\n        self.completed = true;\n        Ok(self.result.take())\n    }\n}\n","traces":[{"line":22,"address":[3740448],"length":1,"stats":{"Line":1}},{"line":41,"address":[5740590,5740752,5740975,5741916,5744259,5740528,5740925],"length":1,"stats":{"Line":4}},{"line":42,"address":[3305926],"length":1,"stats":{"Line":1}},{"line":43,"address":[3305984],"length":1,"stats":{"Line":1}},{"line":46,"address":[5662760,5662667],"length":1,"stats":{"Line":2}},{"line":48,"address":[6053594,6053714],"length":1,"stats":{"Line":2}},{"line":55,"address":[3073433,3073120,3073382,3073150,3072536],"length":1,"stats":{"Line":5}},{"line":57,"address":[5467317,5466849],"length":1,"stats":{"Line":2}},{"line":58,"address":[3348183],"length":1,"stats":{"Line":3}},{"line":60,"address":[5836407],"length":1,"stats":{"Line":1}},{"line":62,"address":[3073667],"length":1,"stats":{"Line":1}},{"line":65,"address":[5742430,5742513,5742579],"length":1,"stats":{"Line":3}},{"line":67,"address":[3310128,3310145,3307488],"length":1,"stats":{"Line":3}},{"line":70,"address":[5664427,5664319],"length":1,"stats":{"Line":2}},{"line":71,"address":[3074075,3074436],"length":1,"stats":{"Line":1}},{"line":72,"address":[5743025,5742894,5743044],"length":1,"stats":{"Line":0}},{"line":74,"address":[5468497,5468774,5468997],"length":1,"stats":{"Line":1}},{"line":75,"address":[5837246,5837303,5837322],"length":1,"stats":{"Line":0}},{"line":77,"address":[6055834,6055633,6055853],"length":1,"stats":{"Line":2}},{"line":78,"address":[5743999,5743576],"length":1,"stats":{"Line":1}},{"line":79,"address":[5665508,5665299,5665489],"length":1,"stats":{"Line":0}},{"line":81,"address":[3074929],"length":1,"stats":{"Line":1}},{"line":83,"address":[3308626,3308932],"length":1,"stats":{"Line":1}},{"line":85,"address":[3309408,3307606],"length":1,"stats":{"Line":0}},{"line":87,"address":[5666284],"length":1,"stats":{"Line":0}},{"line":89,"address":[3075848,3075749],"length":1,"stats":{"Line":0}},{"line":92,"address":[5666181,5666142],"length":1,"stats":{"Line":0}},{"line":94,"address":[3309463],"length":1,"stats":{"Line":0}},{"line":95,"address":[5666202,5666460],"length":1,"stats":{"Line":0}},{"line":104,"address":[3073465],"length":1,"stats":{"Line":0}},{"line":105,"address":[5836301],"length":1,"stats":{"Line":0}},{"line":106,"address":[5663920],"length":1,"stats":{"Line":0}},{"line":111,"address":[5835166],"length":1,"stats":{"Line":1}},{"line":112,"address":[3306065,3309099],"length":1,"stats":{"Line":2}}],"covered":22,"coverable":34},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","mod.rs"],"content":"pub mod album_tracks;\npub mod artist_tracks;\npub mod common;\npub mod discovery_iterator;\npub mod exact_match;\npub mod track_variations;\n\npub use album_tracks::AlbumTracksDiscovery;\npub use artist_tracks::ArtistTracksDiscovery;\npub use common::filter_by_original_album_artist;\npub use discovery_iterator::AsyncDiscoveryIterator;\npub use exact_match::ExactMatchDiscovery;\npub use track_variations::TrackVariationsDiscovery;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","track_variations.rs"],"content":"use super::common::filter_by_original_album_artist;\nuse crate::{\n    AsyncDiscoveryIterator, ExactScrobbleEdit, LastFmEditClientImpl, Result, ScrobbleEdit,\n};\nuse async_trait::async_trait;\n\n/// Case 2: Track variations discovery (track specified, album not specified)\n///\n/// This discovers all album variations of a specific track by loading the track's\n/// scrobble data incrementally and yielding each variation as it processes them.\n/// This is now truly incremental like the artist and album tracks discovery.\npub struct TrackVariationsDiscovery {\n    client: LastFmEditClientImpl,\n    edit: ScrobbleEdit,\n    track_name: String,\n    scrobbles_loaded: bool,\n    current_results: Vec\u003cExactScrobbleEdit\u003e,\n    current_index: usize,\n}\n\nimpl TrackVariationsDiscovery {\n    pub fn new(client: LastFmEditClientImpl, edit: ScrobbleEdit, track_name: String) -\u003e Self {\n        Self {\n            client,\n            edit,\n            track_name,\n            scrobbles_loaded: false,\n            current_results: Vec::new(),\n            current_index: 0,\n        }\n    }\n}\n\n#[async_trait(?Send)]\nimpl AsyncDiscoveryIterator\u003cExactScrobbleEdit\u003e for TrackVariationsDiscovery {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cExactScrobbleEdit\u003e\u003e {\n        // If we have results from current batch, return the next one\n        if self.current_index \u003c self.current_results.len() {\n            let result = self.current_results[self.current_index].clone();\n            self.current_index += 1;\n            return Ok(Some(result));\n        }\n\n        // If we haven't loaded scrobbles yet, load them\n        if !self.scrobbles_loaded {\n            log::debug!(\n                \"Getting scrobble data for track '{}' by '{}'\",\n                self.track_name,\n                self.edit.artist_name_original\n            );\n\n            match self\n                .client\n                .load_edit_form_values_internal(\u0026self.track_name, \u0026self.edit.artist_name_original)\n                .await\n            {\n                Ok(track_scrobbles) =\u003e {\n                    // Apply user's changes and filtering\n                    let mut modified_edits = Vec::new();\n                    for scrobble in track_scrobbles {\n                        let mut modified_edit = scrobble.clone();\n                        if let Some(new_track_name) = \u0026self.edit.track_name {\n                            modified_edit.track_name = new_track_name.clone();\n                        }\n                        if let Some(new_album_name) = \u0026self.edit.album_name {\n                            modified_edit.album_name = new_album_name.clone();\n                        }\n                        modified_edit.artist_name = self.edit.artist_name.clone();\n                        if let Some(new_album_artist_name) = \u0026self.edit.album_artist_name {\n                            modified_edit.album_artist_name = new_album_artist_name.clone();\n                        }\n                        modified_edit.edit_all = self.edit.edit_all;\n                        modified_edits.push(modified_edit);\n                    }\n\n                    let filtered_edits =\n                        filter_by_original_album_artist(modified_edits, \u0026self.edit);\n\n                    if !filtered_edits.is_empty() {\n                        // Store results and return the first one\n                        self.current_results = filtered_edits;\n                        self.current_index = 1; // We'll return the first result below\n                        self.scrobbles_loaded = true;\n                        return Ok(Some(self.current_results[0].clone()));\n                    }\n                }\n                Err(e) =\u003e {\n                    log::debug!(\n                        \"Failed to get scrobble data for track '{}': {}\",\n                        self.track_name,\n                        e\n                    );\n                    self.scrobbles_loaded = true;\n                    return Err(e);\n                }\n            }\n            self.scrobbles_loaded = true;\n        }\n\n        // No more results\n        Ok(None)\n    }\n}\n","traces":[{"line":22,"address":[6154921,6154962,6154512],"length":1,"stats":{"Line":1}},{"line":28,"address":[6154682],"length":1,"stats":{"Line":1}},{"line":36,"address":[5842111],"length":1,"stats":{"Line":4}},{"line":38,"address":[5985637],"length":1,"stats":{"Line":1}},{"line":39,"address":[5274424,5273606],"length":1,"stats":{"Line":2}},{"line":40,"address":[5721567,5721709],"length":1,"stats":{"Line":1}},{"line":41,"address":[5274490],"length":1,"stats":{"Line":1}},{"line":45,"address":[5435839,5438361],"length":1,"stats":{"Line":1}},{"line":46,"address":[3555135,3555203,3555008],"length":1,"stats":{"Line":3}},{"line":52,"address":[3555645,3555691,3556228,3555141,3556173],"length":1,"stats":{"Line":5}},{"line":54,"address":[3555170,3555578],"length":1,"stats":{"Line":2}},{"line":55,"address":[5757703],"length":1,"stats":{"Line":3}},{"line":57,"address":[5722125],"length":1,"stats":{"Line":1}},{"line":59,"address":[3318405],"length":1,"stats":{"Line":1}},{"line":60,"address":[5275348,5275213,5275097],"length":1,"stats":{"Line":3}},{"line":61,"address":[5722569,5723352],"length":1,"stats":{"Line":2}},{"line":62,"address":[5607072,5607433],"length":1,"stats":{"Line":2}},{"line":63,"address":[5438737,5438587,5438718],"length":1,"stats":{"Line":2}},{"line":65,"address":[5988478,5988755,5988978],"length":1,"stats":{"Line":1}},{"line":66,"address":[5438967,5438948,5438891],"length":1,"stats":{"Line":0}},{"line":68,"address":[5439130,5438910,5439111],"length":1,"stats":{"Line":2}},{"line":69,"address":[5724149,5724538],"length":1,"stats":{"Line":2}},{"line":70,"address":[3320408,3320560,3320579],"length":1,"stats":{"Line":2}},{"line":72,"address":[3320430],"length":1,"stats":{"Line":1}},{"line":73,"address":[3320455],"length":1,"stats":{"Line":1}},{"line":76,"address":[3556920,3556806],"length":1,"stats":{"Line":2}},{"line":79,"address":[3318989,3318936],"length":1,"stats":{"Line":2}},{"line":81,"address":[5722883,5722791],"length":1,"stats":{"Line":1}},{"line":82,"address":[5438129],"length":1,"stats":{"Line":1}},{"line":83,"address":[5606712],"length":1,"stats":{"Line":1}},{"line":84,"address":[3557259],"length":1,"stats":{"Line":1}},{"line":87,"address":[3318280],"length":1,"stats":{"Line":0}},{"line":88,"address":[5440069,5440249,5437200],"length":1,"stats":{"Line":0}},{"line":93,"address":[5440079],"length":1,"stats":{"Line":0}},{"line":94,"address":[3559186],"length":1,"stats":{"Line":0}},{"line":97,"address":[3557430],"length":1,"stats":{"Line":0}},{"line":101,"address":[3555053],"length":1,"stats":{"Line":1}}],"covered":31,"coverable":37},{"path":["/","home","imalison","Projects","lastfm-edit","src","edit_analysis.rs"],"content":"use http_types::StatusCode;\nuse scraper::{Html, Selector};\n\n/// Result of analyzing an edit response from Last.fm\n#[derive(Debug, Clone)]\npub struct EditAnalysisResult {\n    /// Whether the edit was successful based on all indicators\n    pub success: bool,\n    /// Optional detailed message about the result\n    pub message: Option\u003cString\u003e,\n    /// Track name found in the response (if any)\n    pub actual_track_name: Option\u003cString\u003e,\n    /// Album name found in the response (if any)\n    pub actual_album_name: Option\u003cString\u003e,\n}\n\n/// Analyze the HTML response from a Last.fm edit request to determine success/failure\n///\n/// This function parses the response HTML to look for success/error indicators\n/// and extract the actual track/album names that were processed.\n///\n/// # Arguments\n/// * `response_text` - The HTML response body from the edit request\n/// * `status_code` - The HTTP status code of the response\n///\n/// # Returns\n/// An `EditAnalysisResult` containing the analysis results\npub fn analyze_edit_response(response_text: \u0026str, status_code: StatusCode) -\u003e EditAnalysisResult {\n    // Parse the HTML response to check for actual success/failure\n    let document = Html::parse_document(response_text);\n\n    // Check for success indicator\n    let success_selector = Selector::parse(\".alert-success\").unwrap();\n    let error_selector = Selector::parse(\".alert-danger, .alert-error, .error\").unwrap();\n\n    let has_success_alert = document.select(\u0026success_selector).next().is_some();\n    let has_error_alert = document.select(\u0026error_selector).next().is_some();\n\n    // Extract track and album names from the response\n    let (actual_track_name, actual_album_name) =\n        extract_track_album_names(\u0026document, response_text);\n\n    log::debug!(\n        \"Response analysis: success_alert={}, error_alert={}, track='{}', album='{}'\",\n        has_success_alert,\n        has_error_alert,\n        actual_track_name.as_deref().unwrap_or(\"not found\"),\n        actual_album_name.as_deref().unwrap_or(\"not found\")\n    );\n\n    // Determine if edit was truly successful\n    let final_success = status_code.is_success() \u0026\u0026 has_success_alert \u0026\u0026 !has_error_alert;\n\n    // Create detailed message\n    let message = if has_error_alert {\n        // Extract error message\n        if let Some(error_element) = document.select(\u0026error_selector).next() {\n            Some(format!(\n                \"Edit failed: {}\",\n                error_element.text().collect::\u003cString\u003e().trim()\n            ))\n        } else {\n            Some(\"Edit failed with unknown error\".to_string())\n        }\n    } else if final_success {\n        Some(format!(\n            \"Edit successful - Track: '{}', Album: '{}'\",\n            actual_track_name.as_deref().unwrap_or(\"unknown\"),\n            actual_album_name.as_deref().unwrap_or(\"unknown\")\n        ))\n    } else {\n        Some(format!(\"Edit failed with status: {status_code}\"))\n    };\n\n    EditAnalysisResult {\n        success: final_success,\n        message,\n        actual_track_name,\n        actual_album_name,\n    }\n}\n\n/// Extract track and album names from the edit response\n///\n/// This function tries multiple strategies to find the actual track and album names\n/// in the response, including direct CSS selectors and regex patterns.\nfn extract_track_album_names(\n    document: \u0026Html,\n    response_text: \u0026str,\n) -\u003e (Option\u003cString\u003e, Option\u003cString\u003e) {\n    let mut actual_track_name = None;\n    let mut actual_album_name = None;\n\n    // Try direct selectors first\n    let track_name_selector = Selector::parse(\"td.chartlist-name a\").unwrap();\n    let album_name_selector = Selector::parse(\"td.chartlist-album a\").unwrap();\n\n    if let Some(track_element) = document.select(\u0026track_name_selector).next() {\n        actual_track_name = Some(track_element.text().collect::\u003cString\u003e().trim().to_string());\n    }\n\n    if let Some(album_element) = document.select(\u0026album_name_selector).next() {\n        actual_album_name = Some(album_element.text().collect::\u003cString\u003e().trim().to_string());\n    }\n\n    // If not found, try extracting from the raw response text using generic patterns\n    if actual_track_name.is_none() || actual_album_name.is_none() {\n        if actual_track_name.is_none() {\n            actual_track_name = extract_track_name_from_text(response_text);\n        }\n\n        if actual_album_name.is_none() {\n            actual_album_name = extract_album_name_from_text(response_text);\n        }\n    }\n\n    (actual_track_name, actual_album_name)\n}\n\n/// Extract track name from response text using regex patterns\nfn extract_track_name_from_text(response_text: \u0026str) -\u003e Option\u003cString\u003e {\n    // Look for track name in href=\"/music/{artist}/_/{track}\"\n    // Use regex to find track URLs\n    let track_pattern = regex::Regex::new(r#\"href=\"/music/[^\"]+/_/([^\"]+)\"\"#).unwrap();\n    if let Some(captures) = track_pattern.captures(response_text) {\n        if let Some(track_match) = captures.get(1) {\n            let raw_track = track_match.as_str();\n            // URL decode the track name\n            let decoded_track = urlencoding::decode(raw_track)\n                .unwrap_or_else(|_| raw_track.into())\n                .replace('+', \" \");\n            return Some(decoded_track);\n        }\n    }\n    None\n}\n\n/// Extract album name from response text using regex patterns\nfn extract_album_name_from_text(response_text: \u0026str) -\u003e Option\u003cString\u003e {\n    // Look for album name in href=\"/music/{artist}/{album}\"\n    // Find album links that are not track links (don't contain /_/)\n    let album_pattern =\n        regex::Regex::new(r#\"href=\"/music/[^\"]+/([^\"/_]+)\"[^\u003e]*\u003e[^\u003c]*\u003c/a\u003e\"#).unwrap();\n    if let Some(captures) = album_pattern.captures(response_text) {\n        if let Some(album_match) = captures.get(1) {\n            let raw_album = album_match.as_str();\n            // URL decode the album name\n            let decoded_album = urlencoding::decode(raw_album)\n                .unwrap_or_else(|_| raw_album.into())\n                .replace('+', \" \");\n            return Some(decoded_album);\n        }\n    }\n    None\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_analyze_success_response() {\n        let html = r#\"\n            \u003cdiv class=\"alert-success\"\u003eEdit successful\u003c/div\u003e\n            \u003ctable\u003e\n                \u003ctr\u003e\n                    \u003ctd class=\"chartlist-name\"\u003e\u003ca href=\"/music/artist/_/track\"\u003eTest Track\u003c/a\u003e\u003c/td\u003e\n                    \u003ctd class=\"chartlist-album\"\u003e\u003ca href=\"/music/artist/album\"\u003eTest Album\u003c/a\u003e\u003c/td\u003e\n                \u003c/tr\u003e\n            \u003c/table\u003e\n        \"#;\n\n        let result = analyze_edit_response(html, StatusCode::Ok);\n        assert!(result.success);\n        // The CSS selectors should extract the text content of the links\n        assert_eq!(result.actual_track_name, Some(\"Test Track\".to_string()));\n        assert_eq!(result.actual_album_name, Some(\"Test Album\".to_string()));\n    }\n\n    #[test]\n    fn test_analyze_error_response() {\n        let html = r#\"\n            \u003cdiv class=\"alert-danger\"\u003eEdit failed: Invalid data\u003c/div\u003e\n        \"#;\n\n        let result = analyze_edit_response(html, StatusCode::Ok);\n        assert!(!result.success);\n        assert!(result\n            .message\n            .unwrap()\n            .contains(\"Edit failed: Invalid data\"));\n    }\n\n    #[test]\n    fn test_extract_from_regex_patterns() {\n        let html = r#\"\n            Some content with \u003ca href=\"/music/Artist/AlbumName\"\u003ealbum link\u003c/a\u003e\n            and later \u003ca href=\"/music/Artist/_/TrackName\"\u003etrack link\u003c/a\u003e\n        \"#;\n\n        let result = analyze_edit_response(html, StatusCode::Ok);\n        // Should extract from regex patterns when direct selectors fail\n        // The track pattern captures from /_/ URLs, album pattern from non-/_/ URLs\n        assert_eq!(result.actual_track_name, Some(\"TrackName\".to_string()));\n        assert_eq!(result.actual_album_name, Some(\"AlbumName\".to_string()));\n    }\n}\n","traces":[{"line":28,"address":[3731792,3734964,3734837],"length":1,"stats":{"Line":5}},{"line":30,"address":[5976242],"length":1,"stats":{"Line":5}},{"line":33,"address":[5976259,5976334],"length":1,"stats":{"Line":10}},{"line":34,"address":[3424999,3424924],"length":1,"stats":{"Line":10}},{"line":36,"address":[3732204,3732125],"length":1,"stats":{"Line":10}},{"line":37,"address":[5976717],"length":1,"stats":{"Line":5}},{"line":40,"address":[3732539],"length":1,"stats":{"Line":5}},{"line":43,"address":[3425515,3425900,3426031,3425646,3425611],"length":1,"stats":{"Line":3}},{"line":52,"address":[5974590,5973921],"length":1,"stats":{"Line":4}},{"line":55,"address":[3426330],"length":1,"stats":{"Line":2}},{"line":57,"address":[3734353,3734282,3734891,3733440],"length":1,"stats":{"Line":6}},{"line":58,"address":[6240734,6240829],"length":1,"stats":{"Line":2}},{"line":60,"address":[3427321,3427398,3427484],"length":1,"stats":{"Line":6}},{"line":63,"address":[3734440,3734843],"length":1,"stats":{"Line":0}},{"line":65,"address":[5920037,5920543,5920005,5919156],"length":1,"stats":{"Line":6}},{"line":66,"address":[5858262,5858137],"length":1,"stats":{"Line":4}},{"line":68,"address":[5977889,5978286],"length":1,"stats":{"Line":4}},{"line":69,"address":[6240196],"length":1,"stats":{"Line":2}},{"line":72,"address":[5977921,5977862],"length":1,"stats":{"Line":2}},{"line":87,"address":[3430138,3427888,3428826],"length":1,"stats":{"Line":5}},{"line":91,"address":[6241256],"length":1,"stats":{"Line":5}},{"line":92,"address":[5979474],"length":1,"stats":{"Line":5}},{"line":95,"address":[5920906,5920834],"length":1,"stats":{"Line":8}},{"line":96,"address":[3735222,3735297],"length":1,"stats":{"Line":9}},{"line":98,"address":[5976562,5976633,5976701],"length":1,"stats":{"Line":15}},{"line":99,"address":[6241753,6241802,6242005],"length":1,"stats":{"Line":2}},{"line":102,"address":[6242259,6242161],"length":1,"stats":{"Line":6}},{"line":103,"address":[3428995,3429060,3429243],"length":1,"stats":{"Line":2}},{"line":107,"address":[5860770,5860684],"length":1,"stats":{"Line":5}},{"line":108,"address":[5977780,5977974,5978189],"length":1,"stats":{"Line":10}},{"line":109,"address":[5922536,5922562],"length":1,"stats":{"Line":4}},{"line":112,"address":[5981148,5981366,5981558],"length":1,"stats":{"Line":6}},{"line":113,"address":[5922737,5922763],"length":1,"stats":{"Line":2}},{"line":117,"address":[3429485],"length":1,"stats":{"Line":2}},{"line":121,"address":[6244507,6243504,6244433],"length":1,"stats":{"Line":4}},{"line":124,"address":[6243547],"length":1,"stats":{"Line":4}},{"line":125,"address":[5923163,5923211],"length":1,"stats":{"Line":7}},{"line":126,"address":[6243836,6243924],"length":1,"stats":{"Line":4}},{"line":127,"address":[5862012,5861963],"length":1,"stats":{"Line":4}},{"line":129,"address":[3737868,3738014],"length":1,"stats":{"Line":4}},{"line":130,"address":[6255984,6256011],"length":1,"stats":{"Line":0}},{"line":132,"address":[5923847],"length":1,"stats":{"Line":2}},{"line":135,"address":[5923982],"length":1,"stats":{"Line":2}},{"line":139,"address":[5979536,5980465,5980539],"length":1,"stats":{"Line":2}},{"line":142,"address":[6244579],"length":1,"stats":{"Line":2}},{"line":144,"address":[3738459,3738507],"length":1,"stats":{"Line":6}},{"line":145,"address":[5983124,5983036],"length":1,"stats":{"Line":4}},{"line":146,"address":[5924588,5924539],"length":1,"stats":{"Line":4}},{"line":148,"address":[5863214,5863068],"length":1,"stats":{"Line":4}},{"line":149,"address":[5991120,5991147],"length":1,"stats":{"Line":0}},{"line":151,"address":[5980359],"length":1,"stats":{"Line":2}},{"line":154,"address":[3739278],"length":1,"stats":{"Line":2}}],"covered":49,"coverable":52},{"path":["/","home","imalison","Projects","lastfm-edit","src","headers.rs"],"content":"use http_client::Request;\n\n/// Common Chrome user agent string for all requests\nconst USER_AGENT: \u0026str = \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36\";\n\n/// Common Chrome headers for security info\nconst SEC_CH_UA: \u0026str =\n    \"\\\"Not)A;Brand\\\";v=\\\"8\\\", \\\"Chromium\\\";v=\\\"138\\\", \\\"Google Chrome\\\";v=\\\"138\\\"\";\nconst SEC_CH_UA_MOBILE: \u0026str = \"?0\";\nconst SEC_CH_UA_PLATFORM: \u0026str = \"\\\"Linux\\\"\";\n\n/// Add common browser headers to a request\npub fn add_common_headers(request: \u0026mut Request) {\n    let _ = request.insert_header(\"User-Agent\", USER_AGENT);\n    let _ = request.insert_header(\"Accept-Language\", \"en-US,en;q=0.9\");\n    let _ = request.insert_header(\"Accept-Encoding\", \"gzip, deflate, br\");\n    let _ = request.insert_header(\"DNT\", \"1\");\n    let _ = request.insert_header(\"Connection\", \"keep-alive\");\n    let _ = request.insert_header(\"sec-ch-ua\", SEC_CH_UA);\n    let _ = request.insert_header(\"sec-ch-ua-mobile\", SEC_CH_UA_MOBILE);\n    let _ = request.insert_header(\"sec-ch-ua-platform\", SEC_CH_UA_PLATFORM);\n}\n\n/// Add headers for AJAX form edit requests\npub fn add_edit_headers(request: \u0026mut Request, referer_url: \u0026str) {\n    add_common_headers(request);\n    let _ = request.insert_header(\"Accept\", \"*/*\");\n    let _ = request.insert_header(\n        \"Content-Type\",\n        \"application/x-www-form-urlencoded;charset=UTF-8\",\n    );\n    let _ = request.insert_header(\"Priority\", \"u=1, i\");\n    let _ = request.insert_header(\"X-Requested-With\", \"XMLHttpRequest\");\n    let _ = request.insert_header(\"Sec-Fetch-Dest\", \"empty\");\n    let _ = request.insert_header(\"Sec-Fetch-Mode\", \"cors\");\n    let _ = request.insert_header(\"Sec-Fetch-Site\", \"same-origin\");\n    let _ = request.insert_header(\"Referer\", referer_url);\n}\n\n/// Add headers for GET requests (regular pages or AJAX)\npub fn add_get_headers(request: \u0026mut Request, is_ajax: bool, referer_url: Option\u003c\u0026str\u003e) {\n    add_common_headers(request);\n\n    if is_ajax {\n        let _ = request.insert_header(\"Accept\", \"*/*\");\n        let _ = request.insert_header(\"X-Requested-With\", \"XMLHttpRequest\");\n    } else {\n        let _ = request.insert_header(\n            \"Accept\",\n            \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\"\n        );\n        let _ = request.insert_header(\"Upgrade-Insecure-Requests\", \"1\");\n    }\n\n    if let Some(referer) = referer_url {\n        let _ = request.insert_header(\"Referer\", referer);\n    }\n}\n\n/// Add cookies to a request if they exist\npub fn add_cookies(request: \u0026mut Request, cookies: \u0026[String]) {\n    if !cookies.is_empty() {\n        let cookie_header = cookies.join(\"; \");\n        let _ = request.insert_header(\"Cookie\", \u0026cookie_header);\n    }\n}\n","traces":[{"line":13,"address":[6088944],"length":1,"stats":{"Line":9}},{"line":14,"address":[21100713,21100656,21100665,21100704],"length":1,"stats":{"Line":4}},{"line":15,"address":[20842288,20842352,20842308,20842372],"length":1,"stats":{"Line":9}},{"line":16,"address":[21125222],"length":1,"stats":{"Line":4}},{"line":17,"address":[5974387],"length":1,"stats":{"Line":9}},{"line":18,"address":[5824183],"length":1,"stats":{"Line":4}},{"line":19,"address":[20970377],"length":1,"stats":{"Line":9}},{"line":20,"address":[5824297],"length":1,"stats":{"Line":4}},{"line":21,"address":[3612995],"length":1,"stats":{"Line":9}},{"line":25,"address":[2801696],"length":1,"stats":{"Line":1}},{"line":26,"address":[21125312],"length":1,"stats":{"Line":1}},{"line":27,"address":[6089465],"length":1,"stats":{"Line":1}},{"line":28,"address":[5824525],"length":1,"stats":{"Line":1}},{"line":32,"address":[5974833],"length":1,"stats":{"Line":1}},{"line":33,"address":[3613269],"length":1,"stats":{"Line":1}},{"line":34,"address":[5974943],"length":1,"stats":{"Line":1}},{"line":35,"address":[5975001],"length":1,"stats":{"Line":1}},{"line":36,"address":[5975059],"length":1,"stats":{"Line":1}},{"line":37,"address":[5824871],"length":1,"stats":{"Line":1}},{"line":41,"address":[5824928],"length":1,"stats":{"Line":9}},{"line":42,"address":[2802238],"length":1,"stats":{"Line":4}},{"line":44,"address":[6089976],"length":1,"stats":{"Line":4}},{"line":45,"address":[5825105],"length":1,"stats":{"Line":4}},{"line":46,"address":[3613797],"length":1,"stats":{"Line":1}},{"line":48,"address":[5708049],"length":1,"stats":{"Line":5}},{"line":52,"address":[5896869],"length":1,"stats":{"Line":3}},{"line":55,"address":[5975460],"length":1,"stats":{"Line":9}},{"line":56,"address":[5897087],"length":1,"stats":{"Line":2}},{"line":61,"address":[5708605,5708368,5708599],"length":1,"stats":{"Line":4}},{"line":62,"address":[2802642],"length":1,"stats":{"Line":9}},{"line":63,"address":[5708454],"length":1,"stats":{"Line":4}},{"line":64,"address":[3614154,3614080],"length":1,"stats":{"Line":13}}],"covered":32,"coverable":32},{"path":["/","home","imalison","Projects","lastfm-edit","src","iterator.rs"],"content":"use crate::r#trait::LastFmEditClient;\nuse crate::{Album, AlbumPage, Result, Track, TrackPage};\n\nuse async_trait::async_trait;\n\n/// Async iterator trait for paginated Last.fm data.\n///\n/// This trait provides a common interface for iterating over paginated data from Last.fm,\n/// such as tracks, albums, and recent scrobbles. All iterators implement efficient streaming\n/// with automatic pagination and built-in rate limiting.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n///\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut tracks = client.artist_tracks(\"Radiohead\");\n///\n/// // Iterate one by one\n/// while let Some(track) = tracks.next().await? {\n///     println!(\"{}\", track.name);\n/// }\n///\n/// // Or collect a limited number\n/// let first_10 = tracks.take(10).await?;\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\n#[cfg_attr(feature = \"mock\", mockall::automock)]\n#[async_trait(?Send)]\npub trait AsyncPaginatedIterator\u003cT\u003e {\n    /// Fetch the next item from the iterator.\n    ///\n    /// This method automatically handles pagination, fetching new pages as needed.\n    /// Returns `None` when there are no more items available.\n    ///\n    /// # Returns\n    ///\n    /// - `Ok(Some(item))` - Next item in the sequence\n    /// - `Ok(None)` - No more items available\n    /// - `Err(...)` - Network or parsing error occurred\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cT\u003e\u003e;\n\n    /// Collect all remaining items into a Vec.\n    ///\n    /// **Warning**: This method will fetch ALL remaining pages, which could be\n    /// many thousands of items for large libraries. Use [`take`](Self::take) for\n    /// safer bounded collection.\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n    /// # tokio_test::block_on(async {\n    /// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n    /// let mut tracks = client.artist_tracks(\"Small Artist\");\n    /// let all_tracks = tracks.collect_all().await?;\n    /// println!(\"Found {} tracks total\", all_tracks.len());\n    /// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n    /// # });\n    /// ```\n    async fn collect_all(\u0026mut self) -\u003e Result\u003cVec\u003cT\u003e\u003e {\n        let mut items = Vec::new();\n        while let Some(item) = self.next().await? {\n            items.push(item);\n        }\n        Ok(items)\n    }\n\n    /// Take up to n items from the iterator.\n    ///\n    /// This is the recommended way to collect a bounded number of items\n    /// from potentially large datasets.\n    ///\n    /// # Arguments\n    ///\n    /// * `n` - Maximum number of items to collect\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n    /// # tokio_test::block_on(async {\n    /// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n    /// let mut tracks = client.artist_tracks(\"Radiohead\");\n    /// let top_20 = tracks.take(20).await?;\n    /// println!(\"Top 20 tracks: {:?}\", top_20);\n    /// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n    /// # });\n    /// ```\n    async fn take(\u0026mut self, n: usize) -\u003e Result\u003cVec\u003cT\u003e\u003e {\n        let mut items = Vec::new();\n        for _ in 0..n {\n            match self.next().await? {\n                Some(item) =\u003e items.push(item),\n                None =\u003e break,\n            }\n        }\n        Ok(items)\n    }\n\n    /// Get the current page number (0-indexed).\n    ///\n    /// Returns the page number of the most recently fetched page.\n    fn current_page(\u0026self) -\u003e u32;\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `Some(n)` if the total page count is known, `None` otherwise.\n    /// This information may not be available until at least one page has been fetched.\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        None // Default implementation returns None\n    }\n}\n\n/// Iterator for browsing an artist's tracks from a user's library.\n///\n/// This iterator provides access to all tracks by a specific artist\n/// in the authenticated user's Last.fm library. Unlike the basic track listing,\n/// this iterator fetches tracks by iterating through the artist's albums first,\n/// which provides complete album information for each track.\n///\n/// The iterator loads albums and their tracks as needed and handles rate limiting\n/// automatically to be respectful to Last.fm's servers.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut tracks = client.artist_tracks(\"The Beatles\");\n///\n/// // Get the top 5 tracks with album information\n/// let top_tracks = tracks.take(5).await?;\n/// for track in top_tracks {\n///     let album = track.album.as_deref().unwrap_or(\"Unknown Album\");\n///     println!(\"{} [{}] (played {} times)\", track.name, album, track.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct ArtistTracksIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    artist: String,\n    album_iterator: Option\u003cArtistAlbumsIterator\u003cC\u003e\u003e,\n    current_album_tracks: Option\u003cAlbumTracksIterator\u003cC\u003e\u003e,\n    track_buffer: Vec\u003cTrack\u003e,\n    finished: bool,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient + Clone\u003e AsyncPaginatedIterator\u003cTrack\u003e for ArtistTracksIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        // If we're finished, return None\n        if self.finished {\n            return Ok(None);\n        }\n\n        // If track buffer is empty, try to get more tracks\n        while self.track_buffer.is_empty() {\n            // If we don't have a current album tracks iterator, get the next album\n            if self.current_album_tracks.is_none() {\n                // Initialize album iterator if needed\n                if self.album_iterator.is_none() {\n                    self.album_iterator = Some(ArtistAlbumsIterator::new(\n                        self.client.clone(),\n                        self.artist.clone(),\n                    ));\n                }\n\n                // Get next album\n                if let Some(ref mut album_iter) = self.album_iterator {\n                    if let Some(album) = album_iter.next().await? {\n                        log::debug!(\n                            \"Processing album '{}' for artist '{}'\",\n                            album.name,\n                            self.artist\n                        );\n                        // Create album tracks iterator for this album\n                        self.current_album_tracks = Some(AlbumTracksIterator::new(\n                            self.client.clone(),\n                            album.name.clone(),\n                            self.artist.clone(),\n                        ));\n                    } else {\n                        // No more albums, we're done\n                        log::debug!(\"No more albums for artist '{}'\", self.artist);\n                        self.finished = true;\n                        return Ok(None);\n                    }\n                }\n            }\n\n            // Get tracks from current album\n            if let Some(ref mut album_tracks) = self.current_album_tracks {\n                if let Some(track) = album_tracks.next().await? {\n                    self.track_buffer.push(track);\n                } else {\n                    // This album is exhausted, move to next album\n                    log::debug!(\n                        \"Finished processing current album for artist '{}'\",\n                        self.artist\n                    );\n                    self.current_album_tracks = None;\n                    // Continue the loop to try getting the next album\n                }\n            }\n        }\n\n        // Return the next track from our buffer\n        Ok(self.track_buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        // Since we're iterating through albums, return the album iterator's current page\n        if let Some(ref album_iter) = self.album_iterator {\n            album_iter.current_page()\n        } else {\n            0\n        }\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        // Since we're iterating through albums, return the album iterator's total pages\n        if let Some(ref album_iter) = self.album_iterator {\n            album_iter.total_pages()\n        } else {\n            None\n        }\n    }\n}\n\nimpl\u003cC: LastFmEditClient + Clone\u003e ArtistTracksIterator\u003cC\u003e {\n    /// Create a new artist tracks iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::artist_tracks`](crate::LastFmEditClient::artist_tracks).\n    pub fn new(client: C, artist: String) -\u003e Self {\n        Self {\n            client,\n            artist,\n            album_iterator: None,\n            current_album_tracks: None,\n            track_buffer: Vec::new(),\n            finished: false,\n        }\n    }\n}\n\n/// Iterator for browsing an artist's tracks directly using the paginated artist tracks endpoint.\n///\n/// This iterator provides access to all tracks by a specific artist\n/// in the authenticated user's Last.fm library by directly using the\n/// `/user/{username}/library/music/{artist}/+tracks` endpoint with pagination.\n/// This is more efficient than the album-based approach as it doesn't need to\n/// iterate through albums first.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut tracks = client.artist_tracks_direct(\"The Beatles\");\n///\n/// // Get the first 10 tracks directly from the paginated endpoint\n/// let first_10_tracks = tracks.take(10).await?;\n/// for track in first_10_tracks {\n///     println!(\"{} (played {} times)\", track.name, track.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct ArtistTracksDirectIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    artist: String,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003cTrack\u003e,\n    total_pages: Option\u003cu32\u003e,\n    tracks_yielded: u32,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cTrack\u003e for ArtistTracksDirectIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if let Some(page) = self.next_page().await? {\n                self.buffer = page.tracks;\n                self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            }\n        }\n\n        if let Some(track) = self.buffer.pop() {\n            self.tracks_yielded += 1;\n            Ok(Some(track))\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e ArtistTracksDirectIterator\u003cC\u003e {\n    /// Create a new direct artist tracks iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::artist_tracks_direct`](crate::LastFmEditClient::artist_tracks_direct).\n    pub fn new(client: C, artist: String) -\u003e Self {\n        Self {\n            client,\n            artist,\n            current_page: 1,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n            tracks_yielded: 0,\n        }\n    }\n\n    /// Fetch the next page of tracks.\n    ///\n    /// This method handles pagination automatically and includes rate limiting.\n    pub async fn next_page(\u0026mut self) -\u003e Result\u003cOption\u003cTrackPage\u003e\u003e {\n        if !self.has_more {\n            return Ok(None);\n        }\n\n        log::debug!(\n            \"Fetching page {} of {} tracks (yielded {} tracks so far)\",\n            self.current_page,\n            self.artist,\n            self.tracks_yielded\n        );\n\n        let page = self\n            .client\n            .get_artist_tracks_page(\u0026self.artist, self.current_page)\n            .await?;\n\n        self.has_more = page.has_next_page;\n        self.current_page += 1;\n        self.total_pages = page.total_pages;\n\n        Ok(Some(page))\n    }\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `None` until at least one page has been fetched.\n    pub fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\n/// Iterator for browsing an artist's albums from a user's library.\n///\n/// This iterator provides paginated access to all albums by a specific artist\n/// in the authenticated user's Last.fm library, ordered by play count.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut albums = client.artist_albums(\"Pink Floyd\");\n///\n/// // Get all albums (be careful with large discographies!)\n/// while let Some(album) = albums.next().await? {\n///     println!(\"{} (played {} times)\", album.name, album.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct ArtistAlbumsIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    artist: String,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003cAlbum\u003e,\n    total_pages: Option\u003cu32\u003e,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cAlbum\u003e for ArtistAlbumsIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cAlbum\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if let Some(page) = self.next_page().await? {\n                self.buffer = page.albums;\n                self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            }\n        }\n\n        Ok(self.buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e ArtistAlbumsIterator\u003cC\u003e {\n    /// Create a new artist albums iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::artist_albums`](crate::LastFmEditClient::artist_albums).\n    pub fn new(client: C, artist: String) -\u003e Self {\n        Self {\n            client,\n            artist,\n            current_page: 1,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Fetch the next page of albums.\n    ///\n    /// This method handles pagination automatically and includes rate limiting.\n    pub async fn next_page(\u0026mut self) -\u003e Result\u003cOption\u003cAlbumPage\u003e\u003e {\n        if !self.has_more {\n            return Ok(None);\n        }\n\n        let page = self\n            .client\n            .get_artist_albums_page(\u0026self.artist, self.current_page)\n            .await?;\n\n        self.has_more = page.has_next_page;\n        self.current_page += 1;\n        self.total_pages = page.total_pages;\n\n        Ok(Some(page))\n    }\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `None` until at least one page has been fetched.\n    pub fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\n/// Iterator for browsing a user's recent tracks/scrobbles.\n///\n/// This iterator provides access to the user's recent listening history with timestamps,\n/// which is essential for finding tracks that can be edited. It supports optional\n/// timestamp-based filtering to avoid reprocessing old data.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// // Get recent tracks with timestamps\n/// let mut recent = client.recent_tracks();\n/// while let Some(track) = recent.next().await? {\n///     if let Some(timestamp) = track.timestamp {\n///         println!(\"{} - {} ({})\", track.artist, track.name, timestamp);\n///     }\n/// }\n///\n/// // Or stop at a specific timestamp to avoid reprocessing\n/// let last_processed = 1640995200;\n/// let mut recent = lastfm_edit::RecentTracksIterator::new(client).with_stop_timestamp(last_processed);\n/// let new_tracks = recent.collect_all().await?;\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct RecentTracksIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003cTrack\u003e,\n    stop_at_timestamp: Option\u003cu64\u003e,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cTrack\u003e for RecentTracksIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if !self.has_more {\n                return Ok(None);\n            }\n\n            let page = self\n                .client\n                .get_recent_tracks_page(self.current_page)\n                .await?;\n\n            if page.tracks.is_empty() {\n                self.has_more = false;\n                return Ok(None);\n            }\n\n            self.has_more = page.has_next_page;\n\n            // Check if we should stop based on timestamp\n            if let Some(stop_timestamp) = self.stop_at_timestamp {\n                let mut filtered_tracks = Vec::new();\n                for track in page.tracks {\n                    if let Some(track_timestamp) = track.timestamp {\n                        if track_timestamp \u003c= stop_timestamp {\n                            self.has_more = false;\n                            break;\n                        }\n                    }\n                    filtered_tracks.push(track);\n                }\n                self.buffer = filtered_tracks;\n            } else {\n                self.buffer = page.tracks;\n            }\n\n            self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            self.current_page += 1;\n        }\n\n        Ok(self.buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e RecentTracksIterator\u003cC\u003e {\n    /// Create a new recent tracks iterator starting from page 1.\n    ///\n    /// This is typically called via [`LastFmEditClient::recent_tracks`](crate::LastFmEditClient::recent_tracks).\n    pub fn new(client: C) -\u003e Self {\n        Self::with_starting_page(client, 1)\n    }\n\n    /// Create a new recent tracks iterator starting from a specific page.\n    ///\n    /// This allows resuming pagination from an arbitrary page, useful for\n    /// continuing from where a previous iteration left off.\n    ///\n    /// # Arguments\n    ///\n    /// * `client` - The LastFmEditClient to use for API calls\n    /// * `starting_page` - The page number to start from (1-indexed)\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n    /// # tokio_test::block_on(async {\n    /// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n    ///\n    /// // Start from page 5\n    /// let mut recent = client.recent_tracks_from_page(5);\n    /// let tracks = recent.take(10).await?;\n    /// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n    /// # });\n    /// ```\n    pub fn with_starting_page(client: C, starting_page: u32) -\u003e Self {\n        let page = std::cmp::max(1, starting_page);\n        Self {\n            client,\n            current_page: page,\n            has_more: true,\n            buffer: Vec::new(),\n            stop_at_timestamp: None,\n        }\n    }\n\n    /// Set a timestamp to stop iteration at.\n    ///\n    /// When this is set, the iterator will stop returning tracks once it encounters\n    /// a track with a timestamp less than or equal to the specified value. This is\n    /// useful for incremental processing to avoid reprocessing old data.\n    ///\n    /// # Arguments\n    ///\n    /// * `timestamp` - Unix timestamp to stop at\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n    /// # tokio_test::block_on(async {\n    /// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n    /// let last_processed = 1640995200; // Some previous timestamp\n    ///\n    /// let mut recent = lastfm_edit::RecentTracksIterator::new(client).with_stop_timestamp(last_processed);\n    /// let new_tracks = recent.collect_all().await?; // Only gets new tracks\n    /// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n    /// # });\n    /// ```\n    pub fn with_stop_timestamp(mut self, timestamp: u64) -\u003e Self {\n        self.stop_at_timestamp = Some(timestamp);\n        self\n    }\n}\n\n/// Iterator for browsing tracks in a specific album from a user's library.\n///\n/// This iterator provides access to all tracks in a specific album by an artist\n/// in the authenticated user's Last.fm library. Unlike paginated iterators,\n/// this loads tracks once and iterates through them.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut tracks = client.album_tracks(\"The Dark Side of the Moon\", \"Pink Floyd\");\n///\n/// // Get all tracks in the album\n/// while let Some(track) = tracks.next().await? {\n///     println!(\"{} - {}\", track.name, track.artist);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct AlbumTracksIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    album_name: String,\n    artist_name: String,\n    tracks: Option\u003cVec\u003cTrack\u003e\u003e,\n    index: usize,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cTrack\u003e for AlbumTracksIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        // Load tracks if not already loaded\n        if self.tracks.is_none() {\n            // Use get_album_tracks_page instead of get_album_tracks to avoid infinite recursion\n            let tracks_page = self\n                .client\n                .get_album_tracks_page(\u0026self.album_name, \u0026self.artist_name, 1)\n                .await?;\n            log::debug!(\n                \"Album '{}' by '{}' has {} tracks: {:?}\",\n                self.album_name,\n                self.artist_name,\n                tracks_page.tracks.len(),\n                tracks_page\n                    .tracks\n                    .iter()\n                    .map(|t| \u0026t.name)\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n            );\n\n            if tracks_page.tracks.is_empty() {\n                log::warn!(\n                    \"🚨 ZERO TRACKS FOUND for album '{}' by '{}' - investigating...\",\n                    self.album_name,\n                    self.artist_name\n                );\n                log::debug!(\"Full TrackPage for empty album: has_next_page={}, page_number={}, total_pages={:?}\", \n                           tracks_page.has_next_page, tracks_page.page_number, tracks_page.total_pages);\n            }\n            self.tracks = Some(tracks_page.tracks);\n        }\n\n        // Return next track\n        if let Some(tracks) = \u0026self.tracks {\n            if self.index \u003c tracks.len() {\n                let track = tracks[self.index].clone();\n                self.index += 1;\n                Ok(Some(track))\n            } else {\n                Ok(None)\n            }\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        // Album tracks don't have pages, so return 0\n        0\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e AlbumTracksIterator\u003cC\u003e {\n    /// Create a new album tracks iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::album_tracks`](crate::LastFmEditClient::album_tracks).\n    pub fn new(client: C, album_name: String, artist_name: String) -\u003e Self {\n        Self {\n            client,\n            album_name,\n            artist_name,\n            tracks: None,\n            index: 0,\n        }\n    }\n}\n\n/// Iterator for searching tracks in the user's library.\n///\n/// This iterator provides paginated access to tracks that match a search query\n/// in the authenticated user's Last.fm library, using Last.fm's built-in search functionality.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut search_results = client.search_tracks(\"remaster\");\n///\n/// // Get first 20 search results\n/// while let Some(track) = search_results.next().await? {\n///     println!(\"{} - {} (played {} times)\", track.artist, track.name, track.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct SearchTracksIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    query: String,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003cTrack\u003e,\n    total_pages: Option\u003cu32\u003e,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cTrack\u003e for SearchTracksIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if let Some(page) = self.next_page().await? {\n                self.buffer = page.tracks;\n                self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            }\n        }\n\n        Ok(self.buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e SearchTracksIterator\u003cC\u003e {\n    /// Create a new search tracks iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::search_tracks`](crate::LastFmEditClient::search_tracks).\n    pub fn new(client: C, query: String) -\u003e Self {\n        Self {\n            client,\n            query,\n            current_page: 1,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Create a new search tracks iterator starting from a specific page.\n    ///\n    /// This is useful for implementing offset functionality efficiently by starting\n    /// at the appropriate page rather than iterating through all previous pages.\n    pub fn with_starting_page(client: C, query: String, starting_page: u32) -\u003e Self {\n        let page = std::cmp::max(1, starting_page);\n        Self {\n            client,\n            query,\n            current_page: page,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Fetch the next page of search results.\n    ///\n    /// This method handles pagination automatically and includes rate limiting\n    /// to be respectful to Last.fm's servers.\n    pub async fn next_page(\u0026mut self) -\u003e Result\u003cOption\u003cTrackPage\u003e\u003e {\n        if !self.has_more {\n            return Ok(None);\n        }\n\n        let page = self\n            .client\n            .search_tracks_page(\u0026self.query, self.current_page)\n            .await?;\n\n        self.has_more = page.has_next_page;\n        self.current_page += 1;\n        self.total_pages = page.total_pages;\n\n        Ok(Some(page))\n    }\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `None` until at least one page has been fetched.\n    pub fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\n/// Iterator for searching albums in the user's library.\n///\n/// This iterator provides paginated access to albums that match a search query\n/// in the authenticated user's Last.fm library, using Last.fm's built-in search functionality.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut search_results = client.search_albums(\"deluxe\");\n///\n/// // Get first 10 search results\n/// let top_10 = search_results.take(10).await?;\n/// for album in top_10 {\n///     println!(\"{} - {} (played {} times)\", album.artist, album.name, album.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct SearchAlbumsIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    query: String,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003cAlbum\u003e,\n    total_pages: Option\u003cu32\u003e,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cAlbum\u003e for SearchAlbumsIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cAlbum\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if let Some(page) = self.next_page().await? {\n                self.buffer = page.albums;\n                self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            }\n        }\n\n        Ok(self.buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e SearchAlbumsIterator\u003cC\u003e {\n    /// Create a new search albums iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::search_albums`](crate::LastFmEditClient::search_albums).\n    pub fn new(client: C, query: String) -\u003e Self {\n        Self {\n            client,\n            query,\n            current_page: 1,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Create a new search albums iterator starting from a specific page.\n    ///\n    /// This is useful for implementing offset functionality efficiently by starting\n    /// at the appropriate page rather than iterating through all previous pages.\n    pub fn with_starting_page(client: C, query: String, starting_page: u32) -\u003e Self {\n        let page = std::cmp::max(1, starting_page);\n        Self {\n            client,\n            query,\n            current_page: page,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Fetch the next page of search results.\n    ///\n    /// This method handles pagination automatically and includes rate limiting\n    /// to be respectful to Last.fm's servers.\n    pub async fn next_page(\u0026mut self) -\u003e Result\u003cOption\u003cAlbumPage\u003e\u003e {\n        if !self.has_more {\n            return Ok(None);\n        }\n\n        let page = self\n            .client\n            .search_albums_page(\u0026self.query, self.current_page)\n            .await?;\n\n        self.has_more = page.has_next_page;\n        self.current_page += 1;\n        self.total_pages = page.total_pages;\n\n        Ok(Some(page))\n    }\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `None` until at least one page has been fetched.\n    pub fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\n// =============================================================================\n// ARTISTS ITERATOR\n// =============================================================================\n\n/// Iterator for browsing all artists in the user's library.\n///\n/// This iterator provides access to all artists in the authenticated user's Last.fm library,\n/// sorted by play count (highest first). The iterator loads artists as needed and handles\n/// rate limiting automatically to be respectful to Last.fm's servers.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut artists = client.artists();\n///\n/// // Get the top 10 artists\n/// let top_artists = artists.take(10).await?;\n/// for artist in top_artists {\n///     println!(\"{} ({} plays)\", artist.name, artist.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct ArtistsIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003ccrate::Artist\u003e,\n    total_pages: Option\u003cu32\u003e,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003ccrate::Artist\u003e for ArtistsIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003ccrate::Artist\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if let Some(page) = self.next_page().await? {\n                self.buffer = page.artists;\n                self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            }\n        }\n\n        Ok(self.buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e ArtistsIterator\u003cC\u003e {\n    /// Create a new artists iterator.\n    ///\n    /// This iterator will start from page 1 and load all artists in the user's library.\n    pub fn new(client: C) -\u003e Self {\n        Self {\n            client,\n            current_page: 1,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Create a new artists iterator starting from a specific page.\n    ///\n    /// This is useful for implementing offset functionality efficiently by starting\n    /// at the appropriate page rather than iterating through all previous pages.\n    pub fn with_starting_page(client: C, starting_page: u32) -\u003e Self {\n        let page = std::cmp::max(1, starting_page);\n        Self {\n            client,\n            current_page: page,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Fetch the next page of artists.\n    ///\n    /// This method handles pagination automatically and includes rate limiting\n    /// to be respectful to Last.fm's servers.\n    pub async fn next_page(\u0026mut self) -\u003e Result\u003cOption\u003ccrate::ArtistPage\u003e\u003e {\n        if !self.has_more {\n            return Ok(None);\n        }\n\n        let page = self.client.get_artists_page(self.current_page).await?;\n\n        self.has_more = page.has_next_page;\n        self.current_page += 1;\n        self.total_pages = page.total_pages;\n\n        Ok(Some(page))\n    }\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `None` until at least one page has been fetched.\n    pub fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n","traces":[{"line":67,"address":[6170057,6170297,6170153,6176231,6179404,6180800,6177760,6176240,6170393,6178170,6179267,6171939,6172429,6172076,6170249,6181166,6175300,6170345,6170909,6173596,6173882,6176364,6173838,6173507,6171952,6177795,6173459,6173949,6170556,6171987,6170798,6179757,6180787,6180924,6175256,6174896,6174931,6179690,6175020,6175367,6176650,6172318,6177747,6170842,6179280,6170105,6174879,6181210,6177884,6170467,6173472,6172362,6178126,6178237,6181277,6176606,6170432,6170201,6180835,6182207,6179646,6179315,6176717,6176275],"length":1,"stats":{"Line":0}},{"line":68,"address":[5629830,5628310,5625270,5620982,5619462,5623920,5626790,5622502],"length":1,"stats":{"Line":0}},{"line":69,"address":[5796231,5797751,5793386,5790780,5798513,5798919,5795473,5789665,5790448,5796256,5790364,5793302,5793959,5795068,5799933,5794652,5788903,5791968,5792252,5794359,5790423,5799580,5797776,5799212,5799271,5794711,5796172,5796588,5791884,5795879,5791591,5797692,5799296,5788928,5793015,5788844,5789260,5794736,5790071,5793361,5796993,5797399,5798108,5793638,5791185,5788551,5791943,5792605],"length":1,"stats":{"Line":0}},{"line":70,"address":[5623176,5629084,5627564,5630504,5626098,5629138,5623230,5624584,5627618,5620290,5626044,5621810,5620236,5621756,5624530,5630558],"length":1,"stats":{"Line":0}},{"line":72,"address":[5441842,5438802,5435934,5434514,5437286,5443262,5432994,5440322],"length":1,"stats":{"Line":0}},{"line":97,"address":[5443984,5445708,5447606,5450508,5447174,5453424,5452406,5455350,5443486,5450384,5443550,5450374,5453846,5448784,5452586,5454963,5443806,5445584,5447219,5443742,5451974,5447184,5453410,5455306,5445619,5453802,5453548,5444586,5445574,5454026,5443870,5443678,5444362,5455052,5446186,5450419,5446006,5447786,5448908,5449386,5448819,5449162,5449206,5443614,5444108,5450762,5447308,5447562,5453459,5452362,5454928,5444019,5445962,5450806,5451984,5452019,5456418,5452108,5450986,5448774,5455530,5444406,5443934,5454914],"length":1,"stats":{"Line":15}},{"line":98,"address":[3693576,3687336,3688936,3692136,3695080,3690536,3684136,3685736],"length":1,"stats":{"Line":4}},{"line":99,"address":[3114034,3108018,3112565,3105780,3104901,3113945,3109481,3104914,3111892,3104825,3111013,3113344,3103273,3107332,3106377,3112578,3110937,3110336,3114736,3108884,3109557,3108005,3106453,3109570,3107929,3111026,3103349,3103362,3112489,3104228,3114021,3106466],"length":1,"stats":{"Line":16}},{"line":100,"address":[3348004,3350788,3349892,3349156,3350484,3349508,3350180,3352436],"length":1,"stats":{"Line":9}},{"line":101,"address":[],"length":0,"stats":{"Line":8}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[5448472,5450072,5445272,5456116,5451672,5453108,5454612,5446872],"length":1,"stats":{"Line":5}},{"line":117,"address":[5643792,5643824],"length":1,"stats":{"Line":0}},{"line":118,"address":[6195221,6195189],"length":1,"stats":{"Line":0}},{"line":162,"address":[5644345,5643865,5643963,5643904,5644107,5644298,5644472,5648357],"length":1,"stats":{"Line":4}},{"line":164,"address":[3696704],"length":1,"stats":{"Line":1}},{"line":165,"address":[5813789],"length":1,"stats":{"Line":0}},{"line":169,"address":[6195781,6197347],"length":1,"stats":{"Line":2}},{"line":171,"address":[5932494,5932399],"length":1,"stats":{"Line":2}},{"line":173,"address":[],"length":0,"stats":{"Line":2}},{"line":174,"address":[3117513,3117410,3117485],"length":1,"stats":{"Line":2}},{"line":175,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[5932728],"length":1,"stats":{"Line":1}},{"line":181,"address":[5648330,5646201,5646618],"length":1,"stats":{"Line":3}},{"line":182,"address":[5646763,5646711,5644498,5644137,5648906,5646645],"length":1,"stats":{"Line":3}},{"line":183,"address":[5816816,5816852,5816681],"length":1,"stats":{"Line":3}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[3700445,3700342,3700477],"length":1,"stats":{"Line":2}},{"line":190,"address":[5933862,5934244],"length":1,"stats":{"Line":2}},{"line":191,"address":[6199317,6199244],"length":1,"stats":{"Line":2}},{"line":192,"address":[3700269],"length":1,"stats":{"Line":1}},{"line":196,"address":[5933763,5934789,5934980],"length":1,"stats":{"Line":3}},{"line":197,"address":[5461039],"length":1,"stats":{"Line":1}},{"line":198,"address":[5817778],"length":1,"stats":{"Line":1}},{"line":204,"address":[6200300,6197316,6197492],"length":1,"stats":{"Line":3}},{"line":205,"address":[5469733],"length":1,"stats":{"Line":5}},{"line":206,"address":[5458042,5457895],"length":1,"stats":{"Line":2}},{"line":209,"address":[],"length":0,"stats":{"Line":3}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":1}},{"line":220,"address":[5932433,5932361],"length":1,"stats":{"Line":2}},{"line":223,"address":[5461728],"length":1,"stats":{"Line":0}},{"line":225,"address":[6200494],"length":1,"stats":{"Line":0}},{"line":226,"address":[5649155],"length":1,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[5818544],"length":1,"stats":{"Line":0}},{"line":234,"address":[5935598],"length":1,"stats":{"Line":0}},{"line":235,"address":[3120179],"length":1,"stats":{"Line":0}},{"line":237,"address":[5461907],"length":1,"stats":{"Line":0}},{"line":246,"address":[6160480,6160886,6160946],"length":1,"stats":{"Line":2}},{"line":252,"address":[5778596],"length":1,"stats":{"Line":2}},{"line":296,"address":[3702246,3701715,3701969,3703480,3701641,3701680,3702013,3701817],"length":1,"stats":{"Line":4}},{"line":298,"address":[3702025,3703080],"length":1,"stats":{"Line":2}},{"line":299,"address":[5305796],"length":1,"stats":{"Line":2}},{"line":300,"address":[5936943,5936838],"length":1,"stats":{"Line":1}},{"line":301,"address":[5820023],"length":1,"stats":{"Line":1}},{"line":305,"address":[5937203,5936130,5937448,5937346],"length":1,"stats":{"Line":4}},{"line":306,"address":[5463595,5463690,5463513],"length":1,"stats":{"Line":2}},{"line":307,"address":[6202362],"length":1,"stats":{"Line":1}},{"line":309,"address":[3703244],"length":1,"stats":{"Line":1}},{"line":313,"address":[5937696],"length":1,"stats":{"Line":0}},{"line":314,"address":[3122149],"length":1,"stats":{"Line":0}},{"line":317,"address":[3122176],"length":1,"stats":{"Line":0}},{"line":318,"address":[5463973],"length":1,"stats":{"Line":0}},{"line":326,"address":[5609568,5609945,5609967],"length":1,"stats":{"Line":1}},{"line":332,"address":[5609690],"length":1,"stats":{"Line":1}},{"line":341,"address":[5422632,5422786,5422624,5424300,5422965,5423584,5422681,5422640],"length":1,"stats":{"Line":4}},{"line":342,"address":[3082347],"length":1,"stats":{"Line":1}},{"line":343,"address":[3082410],"length":1,"stats":{"Line":1}},{"line":346,"address":[3662568,3662712,3662759],"length":1,"stats":{"Line":3}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[3663540,3663174,3664002,3663236,3662718,3663636,3663469],"length":1,"stats":{"Line":5}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[3082623,3083044],"length":1,"stats":{"Line":2}},{"line":356,"address":[5780276,5780229,5780628,5779533,5780330,5780541],"length":1,"stats":{"Line":3}},{"line":358,"address":[5424029],"length":1,"stats":{"Line":1}},{"line":359,"address":[6162988,6162809],"length":1,"stats":{"Line":1}},{"line":360,"address":[5424115],"length":1,"stats":{"Line":1}},{"line":362,"address":[5780873],"length":1,"stats":{"Line":1}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[5937769,5938089,5937808,5937937,5938366,5937843,5938133,5939294],"length":1,"stats":{"Line":4}},{"line":408,"address":[5938145,5939200],"length":1,"stats":{"Line":2}},{"line":409,"address":[5651887,5651564,5651824,5651992],"length":1,"stats":{"Line":2}},{"line":410,"address":[5938999,5938894],"length":1,"stats":{"Line":1}},{"line":411,"address":[5822079],"length":1,"stats":{"Line":1}},{"line":415,"address":[3705160,3704122],"length":1,"stats":{"Line":2}},{"line":418,"address":[3705248],"length":1,"stats":{"Line":0}},{"line":419,"address":[3705253],"length":1,"stats":{"Line":0}},{"line":422,"address":[5822304],"length":1,"stats":{"Line":0}},{"line":423,"address":[5939349],"length":1,"stats":{"Line":0}},{"line":431,"address":[5424320,5424687,5424709],"length":1,"stats":{"Line":2}},{"line":437,"address":[5781162],"length":1,"stats":{"Line":2}},{"line":445,"address":[5424752,5424787,5425900,5425034,5424736,5424744,5425208,5424874],"length":1,"stats":{"Line":5}},{"line":446,"address":[5612214],"length":1,"stats":{"Line":2}},{"line":447,"address":[5612274],"length":1,"stats":{"Line":1}},{"line":450,"address":[6164208,6164304,6164658,6163860,6163922,6163706,6164140],"length":1,"stats":{"Line":8}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":4}},{"line":453,"address":[5612796,5612594,5612261,5612880,5612543,5612499],"length":1,"stats":{"Line":5}},{"line":455,"address":[6164393],"length":1,"stats":{"Line":1}},{"line":456,"address":[5782386,5782556],"length":1,"stats":{"Line":1}},{"line":457,"address":[],"length":0,"stats":{"Line":1}},{"line":459,"address":[5782473],"length":1,"stats":{"Line":1}},{"line":465,"address":[5899680],"length":1,"stats":{"Line":0}},{"line":466,"address":[3665621],"length":1,"stats":{"Line":0}},{"line":509,"address":[3705360,3705503,3705395,3706014,3705661,3705321,3705705,3707775],"length":1,"stats":{"Line":4}},{"line":511,"address":[3708020,3705717],"length":1,"stats":{"Line":2}},{"line":512,"address":[3705796],"length":1,"stats":{"Line":1}},{"line":513,"address":[5466118],"length":1,"stats":{"Line":0}},{"line":516,"address":[5654016,5653640,5653521,5653543,5653920,5655801,5653852],"length":1,"stats":{"Line":7}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[5822897],"length":1,"stats":{"Line":1}},{"line":519,"address":[],"length":0,"stats":{"Line":4}},{"line":521,"address":[3124961,3124905],"length":1,"stats":{"Line":4}},{"line":522,"address":[5940683],"length":1,"stats":{"Line":0}},{"line":523,"address":[3125035],"length":1,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":2}},{"line":529,"address":[5467101,5466896,5468242],"length":1,"stats":{"Line":3}},{"line":530,"address":[6205879],"length":1,"stats":{"Line":0}},{"line":531,"address":[6206116,6206003,6206251],"length":1,"stats":{"Line":0}},{"line":532,"address":[5654913,5654956],"length":1,"stats":{"Line":0}},{"line":533,"address":[5654972],"length":1,"stats":{"Line":0}},{"line":534,"address":[5824506],"length":1,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[6206576,6206643],"length":1,"stats":{"Line":0}},{"line":542,"address":[5468107,5467146],"length":1,"stats":{"Line":1}},{"line":545,"address":[5468034,5468257],"length":1,"stats":{"Line":2}},{"line":546,"address":[6207081,6207020],"length":1,"stats":{"Line":1}},{"line":549,"address":[5942109,5939822],"length":1,"stats":{"Line":2}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[5942213],"length":1,"stats":{"Line":0}},{"line":561,"address":[3085456],"length":1,"stats":{"Line":2}},{"line":562,"address":[3085464],"length":1,"stats":{"Line":2}},{"line":589,"address":[5613344,5613764],"length":1,"stats":{"Line":2}},{"line":590,"address":[5899870,5899784],"length":1,"stats":{"Line":4}},{"line":595,"address":[3665901],"length":1,"stats":{"Line":2}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":4}},{"line":665,"address":[3126963,3129693],"length":1,"stats":{"Line":3}},{"line":667,"address":[5469331,5469638,5469567,5469734,5469043,5469239],"length":1,"stats":{"Line":5}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[6207909,6207815],"length":1,"stats":{"Line":2}},{"line":670,"address":[5942477,5943107,5943375,5943462,5943048,5943164],"length":1,"stats":{"Line":5}},{"line":671,"address":[],"length":0,"stats":{"Line":5}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[5944432,5943734],"length":1,"stats":{"Line":2}},{"line":684,"address":[5470880,5470783],"length":1,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[6209587,6209964],"length":1,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[5470678,5471576],"length":1,"stats":{"Line":1}},{"line":696,"address":[5471738,5471824,5468969],"length":1,"stats":{"Line":4}},{"line":697,"address":[5945506,5945639,5945877,5945596],"length":1,"stats":{"Line":6}},{"line":698,"address":[],"length":0,"stats":{"Line":3}},{"line":699,"address":[5945882,5945742],"length":1,"stats":{"Line":2}},{"line":700,"address":[3129999],"length":1,"stats":{"Line":1}},{"line":702,"address":[5945601],"length":1,"stats":{"Line":1}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[3666144],"length":1,"stats":{"Line":1}},{"line":763,"address":[5659825,5660021,5661182,5659977,5659657,5659696,5660254,5659731],"length":1,"stats":{"Line":4}},{"line":765,"address":[5946433,5947488],"length":1,"stats":{"Line":2}},{"line":766,"address":[3126308],"length":1,"stats":{"Line":2}},{"line":767,"address":[5830247,5830142],"length":1,"stats":{"Line":1}},{"line":768,"address":[3713343],"length":1,"stats":{"Line":1}},{"line":772,"address":[5661112,5660074],"length":1,"stats":{"Line":2}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[6212597],"length":1,"stats":{"Line":0}},{"line":779,"address":[5830592],"length":1,"stats":{"Line":0}},{"line":780,"address":[5473877],"length":1,"stats":{"Line":0}},{"line":788,"address":[],"length":0,"stats":{"Line":1}},{"line":794,"address":[],"length":0,"stats":{"Line":1}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[3539670,3539564],"length":1,"stats":{"Line":0}},{"line":810,"address":[3539796],"length":1,"stats":{"Line":0}},{"line":819,"address":[5783784,5784074,5784940,5783792,5784248,5783914,5783827,5783776],"length":1,"stats":{"Line":4}},{"line":820,"address":[3666870],"length":1,"stats":{"Line":1}},{"line":821,"address":[5783954],"length":1,"stats":{"Line":1}},{"line":824,"address":[5901986,5901034,5901188,5901536,5901632,5901468,5901250],"length":1,"stats":{"Line":5}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[5427413,5427288],"length":1,"stats":{"Line":2}},{"line":827,"address":[5901219,5901314,5900981,5901263,5901516,5901600],"length":1,"stats":{"Line":3}},{"line":829,"address":[3667657],"length":1,"stats":{"Line":1}},{"line":830,"address":[6166738,6166908],"length":1,"stats":{"Line":1}},{"line":831,"address":[5784758],"length":1,"stats":{"Line":1}},{"line":833,"address":[],"length":0,"stats":{"Line":1}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[5661312,5661637,5661870,5661441,5661273,5661593,5661347,5662798],"length":1,"stats":{"Line":6}},{"line":880,"address":[5831009,5832064],"length":1,"stats":{"Line":2}},{"line":881,"address":[5638404],"length":1,"stats":{"Line":2}},{"line":882,"address":[5831863,5831758],"length":1,"stats":{"Line":1}},{"line":883,"address":[5662623],"length":1,"stats":{"Line":1}},{"line":887,"address":[3132210,3133196],"length":1,"stats":{"Line":2}},{"line":890,"address":[3715152],"length":1,"stats":{"Line":0}},{"line":891,"address":[5949221],"length":1,"stats":{"Line":0}},{"line":894,"address":[6214240],"length":1,"stats":{"Line":0}},{"line":895,"address":[3715189],"length":1,"stats":{"Line":0}},{"line":903,"address":[3667936,3668303,3668325],"length":1,"stats":{"Line":2}},{"line":909,"address":[],"length":0,"stats":{"Line":1}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":934,"address":[5785848,5786540,5785376,5785392,5785384,5785674,5785514,5785427],"length":1,"stats":{"Line":4}},{"line":935,"address":[],"length":0,"stats":{"Line":1}},{"line":936,"address":[],"length":0,"stats":{"Line":1}},{"line":939,"address":[5785748,5785594,5785810,5786096,5786028,5786192,5786546],"length":1,"stats":{"Line":6}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":941,"address":[3088312,3088437],"length":1,"stats":{"Line":2}},{"line":942,"address":[5429440,5429356,5429059,5428821,5429103,5429154],"length":1,"stats":{"Line":5}},{"line":944,"address":[6168313],"length":1,"stats":{"Line":1}},{"line":945,"address":[5617116,5616946],"length":1,"stats":{"Line":1}},{"line":946,"address":[],"length":0,"stats":{"Line":1}},{"line":948,"address":[6168425],"length":1,"stats":{"Line":1}},{"line":954,"address":[],"length":0,"stats":{"Line":0}},{"line":955,"address":[],"length":0,"stats":{"Line":0}},{"line":997,"address":[3715810,3715393,3716730,3715539,3715299,3715225,3715264,3715583],"length":1,"stats":{"Line":7}},{"line":999,"address":[6215692,6214651],"length":1,"stats":{"Line":3}},{"line":1000,"address":[5301108],"length":1,"stats":{"Line":2}},{"line":1001,"address":[5476642,5476744],"length":1,"stats":{"Line":2}},{"line":1002,"address":[5950624],"length":1,"stats":{"Line":2}},{"line":1006,"address":[],"length":0,"stats":{"Line":4}},{"line":1009,"address":[5950800],"length":1,"stats":{"Line":0}},{"line":1010,"address":[5664405],"length":1,"stats":{"Line":0}},{"line":1013,"address":[6215824],"length":1,"stats":{"Line":0}},{"line":1014,"address":[5477077],"length":1,"stats":{"Line":0}},{"line":1022,"address":[5429840,5430136],"length":1,"stats":{"Line":2}},{"line":1027,"address":[3669635],"length":1,"stats":{"Line":2}},{"line":1036,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":0}},{"line":1042,"address":[],"length":0,"stats":{"Line":0}},{"line":1051,"address":[5787018,5786888,5786896,5786931,5787302,5787179,5786880,5787994],"length":1,"stats":{"Line":8}},{"line":1052,"address":[5430278],"length":1,"stats":{"Line":2}},{"line":1053,"address":[3089730],"length":1,"stats":{"Line":0}},{"line":1056,"address":[6169130,6169265,6169077,6170032,6169360],"length":1,"stats":{"Line":4}},{"line":1058,"address":[],"length":0,"stats":{"Line":2}},{"line":1059,"address":[5431040,5431210],"length":1,"stats":{"Line":2}},{"line":1060,"address":[],"length":0,"stats":{"Line":2}},{"line":1062,"address":[3670823],"length":1,"stats":{"Line":2}},{"line":1068,"address":[],"length":0,"stats":{"Line":0}},{"line":1069,"address":[],"length":0,"stats":{"Line":0}}],"covered":156,"coverable":262},{"path":["/","home","imalison","Projects","lastfm-edit","src","lib.rs"],"content":"//! # lastfm-edit\n//!\n//! A Rust crate for programmatic access to Last.fm's scrobble editing functionality via web scraping.\n//!\n//! This crate provides a high-level interface for authenticating with Last.fm, browsing user libraries,\n//! and performing bulk edits on scrobbled tracks. It uses web scraping to access functionality not\n//! available through Last.fm's public API.\n//!\n//! ## Features\n//!\n//! - **Authentication**: Login to Last.fm with username/password\n//! - **Library browsing**: Paginated access to tracks, albums, and recent scrobbles\n//! - **Bulk editing**: Edit track names, artist names, and album information\n//! - **Async iterators**: Stream large datasets efficiently\n//! - **HTTP client abstraction**: Works with any HTTP client implementation\n//!\n//! ## Quick Start\n//!\n//! ```rust,no_run\n//! use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, AsyncPaginatedIterator, Result};\n//!\n//! #[tokio::main]\n//! async fn main() -\u003e Result\u003c()\u003e {\n//!     // Create HTTP client and login\n//!     let http_client = http_client::native::NativeClient::new();\n//!     let client = LastFmEditClientImpl::login_with_credentials(\n//!         Box::new(http_client),\n//!         \"username\",\n//!         \"password\"\n//!     ).await?;\n//!\n//!     // Browse recent tracks\n//!     let mut recent_tracks = client.recent_tracks();\n//!     while let Some(track) = recent_tracks.next().await? {\n//!         println!(\"{} - {}\", track.artist, track.name);\n//!     }\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ## Core Components\n//!\n//! - [`LastFmEditClient`] - Main client trait for interacting with Last.fm\n//! - [`Track`], [`Album`] - Data structures for music metadata\n//! - [`AsyncPaginatedIterator`] - Trait for streaming paginated data\n//! - [`ScrobbleEdit`] - Represents track edit operations\n//! - [`LastFmError`] - Error types for the crate\n//!\n//! ## Installation\n//!\n//! Add this to your `Cargo.toml`:\n//! ```toml\n//! [dependencies]\n//! lastfm-edit = \"3.1.0\"\n//! http-client = { version = \"^6.6.3\", package = \"http-client-2\", features = [\"curl_client\"] }\n//! tokio = { version = \"1.0\", features = [\"full\"] }\n//! ```\n//!\n//! ## Usage Patterns\n//!\n//! ### Basic Library Browsing\n//!\n//! ```rust,no_run\n//! use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, AsyncPaginatedIterator, Result};\n//!\n//! #[tokio::main]\n//! async fn main() -\u003e Result\u003c()\u003e {\n//!     let http_client = http_client::native::NativeClient::new();\n//!     let client = LastFmEditClientImpl::login_with_credentials(\n//!         Box::new(http_client),\n//!         \"username\",\n//!         \"password\"\n//!     ).await?;\n//!\n//!     // Get all tracks by an artist\n//!     let mut tracks = client.artist_tracks(\"Radiohead\");\n//!     while let Some(track) = tracks.next().await? {\n//!         println!(\"{} - {}\", track.artist, track.name);\n//!     }\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ### Bulk Track Editing\n//!\n//! ```rust,no_run\n//! use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, ScrobbleEdit, AsyncPaginatedIterator, Result};\n//!\n//! #[tokio::main]\n//! async fn main() -\u003e Result\u003c()\u003e {\n//!     let http_client = http_client::native::NativeClient::new();\n//!     let client = LastFmEditClientImpl::login_with_credentials(\n//!         Box::new(http_client),\n//!         \"username\",\n//!         \"password\"\n//!     ).await?;\n//!\n//!     // Find and edit tracks\n//!     let tracks = client.artist_tracks(\"Artist Name\").collect_all().await?;\n//!     for track in tracks {\n//!         if track.name.contains(\"(Remaster)\") {\n//!             let new_name = track.name.replace(\" (Remaster)\", \"\");\n//!\n//!             // Create edit for this track\n//!             let edit = ScrobbleEdit::from_track_info(\n//!                 \u0026track.name,\n//!                 \u0026track.name, // Use track name as album fallback\n//!                 \u0026track.artist,\n//!                 0 // No timestamp needed for bulk edit\n//!             )\n//!             .with_track_name(\u0026new_name)\n//!             .with_edit_all(true);\n//!\n//!             let response = client.edit_scrobble(\u0026edit).await?;\n//!             if response.success() {\n//!                 println!(\"Successfully edited: {} -\u003e {}\", track.name, new_name);\n//!             }\n//!         }\n//!     }\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ### Recent Tracks Monitoring\n//!\n//! ```rust,no_run\n//! use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, AsyncPaginatedIterator, Result};\n//!\n//! #[tokio::main]\n//! async fn main() -\u003e Result\u003c()\u003e {\n//!     let http_client = http_client::native::NativeClient::new();\n//!     let client = LastFmEditClientImpl::login_with_credentials(\n//!         Box::new(http_client),\n//!         \"username\",\n//!         \"password\"\n//!     ).await?;\n//!\n//!     // Get recent tracks (first 100)\n//!     let recent_tracks = client.recent_tracks().take(100).await?;\n//!     println!(\"Found {} recent tracks\", recent_tracks.len());\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ### Mocking for Testing\n//!\n//! Enable the `mock` feature to use `MockLastFmEditClient` for testing:\n//!\n//! ```toml\n//! [dev-dependencies]\n//! lastfm-edit = { version = \"3.1.0\", features = [\"mock\"] }\n//! mockall = \"0.13\"\n//! ```\n//!\n//! ```rust,ignore\n//! #[cfg(feature = \"mock\")]\n//! mod tests {\n//!     use lastfm_edit::{LastFmEditClient, MockLastFmEditClient, Result, EditResponse, ScrobbleEdit};\n//!     use mockall::predicate::*;\n//!\n//!     #[tokio::test]\n//!     async fn test_edit_workflow() -\u003e Result\u003c()\u003e {\n//!         let mut mock_client = MockLastFmEditClient::new();\n//!\n//!         // Set up expectations\n//!         mock_client\n//!             .expect_login()\n//!             .with(eq(\"testuser\"), eq(\"testpass\"))\n//!             .times(1)\n//!             .returning(|_, _| Ok(()));\n//!\n//!         mock_client\n//!             .expect_edit_scrobble()\n//!             .times(1)\n//!             .returning(|_| Ok(EditResponse {\n//!                 success: true,\n//!                 message: Some(\"Edit successful\".to_string()),\n//!             }));\n//!\n//!         // Use as trait object\n//!         let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n//!\n//!         client.login(\"testuser\", \"testpass\").await?;\n//!\n//!         let edit = ScrobbleEdit::new(\n//!             Some(\"Old Track\".to_string()),\n//!             Some(\"Old Album\".to_string()),\n//!             Some(\"Old Artist\".to_string()),\n//!             Some(\"Old Artist\".to_string()),\n//!             \"New Track\".to_string(),\n//!             \"New Album\".to_string(),\n//!             \"New Artist\".to_string(),\n//!             \"New Artist\".to_string(),\n//!             1640995200,\n//!             false,\n//!         );\n//!\n//!         let response = client.edit_scrobble(\u0026edit).await?;\n//!         assert!(response.success);\n//!\n//!         Ok(())\n//!     }\n//! }\n//! ```\n//!\n//! ## License\n//!\n//! MIT\n\npub mod client;\npub mod discovery;\npub mod edit_analysis;\npub mod headers;\npub mod iterator;\npub mod login;\npub mod parsing;\npub mod retry;\npub mod session_persistence;\npub mod r#trait;\npub mod types;\npub mod vcr_form_data;\npub mod vcr_matcher;\npub mod vcr_test_utils;\n\npub use client::LastFmEditClientImpl;\npub use discovery::{\n    AlbumTracksDiscovery, ArtistTracksDiscovery, AsyncDiscoveryIterator, ExactMatchDiscovery,\n    TrackVariationsDiscovery,\n};\npub use login::LoginManager;\npub use r#trait::LastFmEditClient;\n\n// Re-export all types from the consolidated types module\npub use iterator::AsyncPaginatedIterator;\npub use types::{\n    Album, AlbumPage, Artist, ArtistPage, ClientConfig, ClientEvent, ClientEventReceiver,\n    ClientEventWatcher, EditResponse, ExactScrobbleEdit, LastFmEditSession, LastFmError,\n    OperationalDelayConfig, RateLimitConfig, RateLimitType, RequestInfo, RetryConfig, RetryResult,\n    ScrobbleEdit, SharedEventBroadcaster, SingleEditResponse, Track, TrackPage,\n};\n\n// Type aliases for iterators with the concrete client type\npub type ArtistsIterator = iterator::ArtistsIterator\u003cLastFmEditClientImpl\u003e;\npub type ArtistTracksIterator = iterator::ArtistTracksIterator\u003cLastFmEditClientImpl\u003e;\npub type ArtistTracksDirectIterator = iterator::ArtistTracksDirectIterator\u003cLastFmEditClientImpl\u003e;\npub type ArtistAlbumsIterator = iterator::ArtistAlbumsIterator\u003cLastFmEditClientImpl\u003e;\npub type AlbumTracksIterator = iterator::AlbumTracksIterator\u003cLastFmEditClientImpl\u003e;\npub type RecentTracksIterator = iterator::RecentTracksIterator\u003cLastFmEditClientImpl\u003e;\npub type SearchTracksIterator = iterator::SearchTracksIterator\u003cLastFmEditClientImpl\u003e;\npub type SearchAlbumsIterator = iterator::SearchAlbumsIterator\u003cLastFmEditClientImpl\u003e;\n#[cfg(feature = \"mock\")]\npub use r#trait::MockLastFmEditClient;\n\n// Re-export the mock iterator when the mock feature is enabled\n#[cfg(feature = \"mock\")]\npub use iterator::MockAsyncPaginatedIterator;\npub use session_persistence::{SessionManager, SessionPersistence};\n\n// Re-export scraper types for testing\npub use scraper::Html;\n\n/// A convenient type alias for [`Result`] with [`LastFmError`] as the error type.\npub type Result\u003cT\u003e = std::result::Result\u003cT, LastFmError\u003e;\n","traces":[{"line":247,"address":[21749552,21750622,21748839,21748773,21750688,21749486,21751559,21751637],"length":1,"stats":{"Line":4}},{"line":248,"address":[6531763,6535614],"length":1,"stats":{"Line":3}},{"line":249,"address":[24048246,24051056,24050101,24048959],"length":1,"stats":{"Line":1}},{"line":250,"address":[23938667,23938599],"length":1,"stats":{"Line":2}},{"line":251,"address":[27337440],"length":1,"stats":{"Line":6}},{"line":252,"address":[24259288,24259371],"length":1,"stats":{"Line":1}},{"line":253,"address":[23938860],"length":1,"stats":{"Line":1}},{"line":254,"address":[6960433,6960593],"length":1,"stats":{"Line":2}},{"line":267,"address":[9259922,9260064,9260021,9260117,9260112,9260074,9259904,9260016],"length":1,"stats":{"Line":2}}],"covered":9,"coverable":9},{"path":["/","home","imalison","Projects","lastfm-edit","src","login.rs"],"content":"use crate::types::{LastFmEditSession, LastFmError};\nuse crate::Result;\nuse http_client::{HttpClient, Request};\nuse http_types::{Method, Url};\nuse scraper::{Html, Selector};\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\n/// Login functionality separated from the main client\npub struct LoginManager {\n    client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n    base_url: String,\n}\n\nimpl LoginManager {\n    pub fn new(client: Arc\u003cdyn HttpClient + Send + Sync\u003e, base_url: String) -\u003e Self {\n        Self { client, base_url }\n    }\n\n    /// Authenticate with Last.fm using username and password.\n    ///\n    /// This method:\n    /// 1. Fetches the login page to extract CSRF tokens\n    /// 2. Submits the login form with credentials\n    /// 3. Validates the authentication by checking for session cookies\n    /// 4. Returns a valid session for use with the client\n    ///\n    /// # Arguments\n    ///\n    /// * `username` - Last.fm username or email\n    /// * `password` - Last.fm password\n    ///\n    /// # Returns\n    ///\n    /// Returns a [`LastFmEditSession`] on successful authentication, or [`LastFmError::Auth`] on failure.\n    pub async fn login(\u0026self, username: \u0026str, password: \u0026str) -\u003e Result\u003cLastFmEditSession\u003e {\n        log::info!(\"🔐 Starting Last.fm login for username: {username}\");\n\n        // Step 1: Fetch login page and extract CSRF token and cookies\n        let login_url = format!(\"{}/login\", self.base_url);\n        let (csrf_token, next_field, mut cookies) = self.fetch_login_page(\u0026login_url).await?;\n\n        // Step 2: Submit login form\n        let response = self\n            .submit_login_form(\n                \u0026login_url,\n                username,\n                password,\n                \u0026csrf_token,\n                \u0026next_field,\n                \u0026cookies,\n            )\n            .await?;\n\n        // Step 3: Extract cookies from login response\n        extract_cookies_from_response(\u0026response, \u0026mut cookies);\n        log::debug!(\"🍪 Cookies after login response: {cookies:?}\");\n\n        // Step 4: Validate login response\n        self.validate_login_response(response, username, cookies, csrf_token)\n            .await\n    }\n\n    /// Fetch the login page and extract CSRF token, next field, and cookies\n    async fn fetch_login_page(\n        \u0026self,\n        login_url: \u0026str,\n    ) -\u003e Result\u003c(String, Option\u003cString\u003e, Vec\u003cString\u003e)\u003e {\n        log::debug!(\"📡 Fetching login page: {login_url}\");\n        let mut response = self.get(login_url).await?;\n\n        log::debug!(\"📋 Login page response status: {}\", response.status());\n        log::debug!(\n            \"📋 Login page response headers: {:?}\",\n            response.iter().collect::\u003cVec\u003c_\u003e\u003e()\n        );\n\n        // Extract cookies from the login page response\n        let mut cookies = Vec::new();\n        extract_cookies_from_response(\u0026response, \u0026mut cookies);\n        log::debug!(\"🍪 Initial cookies from login page: {cookies:?}\");\n\n        // Read and parse the HTML response\n        let html = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\"📄 Login page HTML length: {} chars\", html.len());\n        if html.len() \u003c 500 {\n            log::debug!(\"📄 Login page HTML content (short): {html}\");\n        }\n\n        // Extract CSRF token and next field from form\n        let (csrf_token, next_field) = self.extract_login_form_data(\u0026html)?;\n        log::debug!(\"🔑 Extracted CSRF token: {csrf_token}\",);\n        log::debug!(\"➡️  Next field: {next_field:?}\");\n\n        Ok((csrf_token, next_field, cookies))\n    }\n\n    /// Submit the login form with credentials\n    async fn submit_login_form(\n        \u0026self,\n        login_url: \u0026str,\n        username: \u0026str,\n        password: \u0026str,\n        csrf_token: \u0026str,\n        next_field: \u0026Option\u003cString\u003e,\n        cookies: \u0026[String],\n    ) -\u003e Result\u003chttp_types::Response\u003e {\n        // Prepare form data\n        let mut form_data = HashMap::new();\n        form_data.insert(\"csrfmiddlewaretoken\", csrf_token);\n        form_data.insert(\"username_or_email\", username);\n        form_data.insert(\"password\", password);\n\n        if let Some(ref next_value) = next_field {\n            form_data.insert(\"next\", next_value);\n            log::debug!(\"➡️  Including next field in form: {next_value}\");\n        }\n\n        log::debug!(\n            \"📝 Form data fields: {:?}\",\n            form_data.keys().collect::\u003cVec\u003c_\u003e\u003e()\n        );\n        log::debug!(\"📝 Form username: {username}\");\n        log::debug!(\"📝 Form password length: {} chars\", password.len());\n\n        // Create and configure the POST request\n        let mut request = self.create_login_request(login_url, cookies)?;\n\n        // Convert form data to URL-encoded string\n        let form_string: String = form_data\n            .iter()\n            .map(|(k, v)| format!(\"{}={}\", urlencoding::encode(k), urlencoding::encode(v)))\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\u0026\");\n\n        log::debug!(\"📤 Sending POST request to: {login_url}\");\n        log::debug!(\"📤 Form body length: {} chars\", form_string.len());\n        log::debug!(\"📤 Form body (masked): {form_string}\");\n        log::debug!(\"📤 Request headers: Referer={}, Origin={}, Content-Type=application/x-www-form-urlencoded\", \n            login_url, \u0026self.base_url);\n\n        request.set_body(form_string);\n\n        // Send the request\n        let response = self\n            .client\n            .send(request)\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\"📥 Login response status: {}\", response.status());\n        log::debug!(\n            \"📥 Login response headers: {:?}\",\n            response.iter().collect::\u003cVec\u003c_\u003e\u003e()\n        );\n\n        Ok(response)\n    }\n\n    /// Create and configure the login POST request with all necessary headers\n    fn create_login_request(\u0026self, login_url: \u0026str, cookies: \u0026[String]) -\u003e Result\u003cRequest\u003e {\n        let mut request = Request::new(Method::Post, login_url.parse::\u003cUrl\u003e().unwrap());\n\n        // Set all the required headers\n        let _ = request.insert_header(\"Referer\", login_url);\n        let _ = request.insert_header(\"Origin\", \u0026self.base_url);\n        let _ = request.insert_header(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        let _ = request.insert_header(\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36\"\n        );\n        let _ = request.insert_header(\n            \"Accept\",\n            \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\"\n        );\n        let _ = request.insert_header(\"Accept-Language\", \"en-US,en;q=0.9\");\n        let _ = request.insert_header(\"Accept-Encoding\", \"gzip, deflate, br\");\n        let _ = request.insert_header(\"DNT\", \"1\");\n        let _ = request.insert_header(\"Connection\", \"keep-alive\");\n        let _ = request.insert_header(\"Upgrade-Insecure-Requests\", \"1\");\n        let _ = request.insert_header(\n            \"sec-ch-ua\",\n            \"\\\"Not)A;Brand\\\";v=\\\"8\\\", \\\"Chromium\\\";v=\\\"138\\\", \\\"Google Chrome\\\";v=\\\"138\\\"\",\n        );\n        let _ = request.insert_header(\"sec-ch-ua-mobile\", \"?0\");\n        let _ = request.insert_header(\"sec-ch-ua-platform\", \"\\\"Linux\\\"\");\n        let _ = request.insert_header(\"Sec-Fetch-Dest\", \"document\");\n        let _ = request.insert_header(\"Sec-Fetch-Mode\", \"navigate\");\n        let _ = request.insert_header(\"Sec-Fetch-Site\", \"same-origin\");\n        let _ = request.insert_header(\"Sec-Fetch-User\", \"?1\");\n\n        // Add cookies if we have any\n        if !cookies.is_empty() {\n            let cookie_header = cookies.join(\"; \");\n            let _ = request.insert_header(\"Cookie\", \u0026cookie_header);\n        }\n\n        Ok(request)\n    }\n\n    /// Validate the login response and return a session if successful\n    async fn validate_login_response(\n        \u0026self,\n        mut response: http_types::Response,\n        username: \u0026str,\n        cookies: Vec\u003cString\u003e,\n        csrf_token: String,\n    ) -\u003e Result\u003cLastFmEditSession\u003e {\n        // Handle 403 Forbidden responses (likely CSRF failures)\n        if response.status() == 403 {\n            return self.handle_403_response(response).await;\n        }\n\n        // Check for successful session establishment\n        if let Some(session) =\n            self.check_session_success(\u0026response, username, \u0026cookies, \u0026csrf_token)\n        {\n            return Ok(session);\n        }\n\n        // For other cases, analyze the response body\n        let response_html = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"📄 Login response HTML length: {} chars\",\n            response_html.len()\n        );\n        if response_html.len() \u003c 500 {\n            log::debug!(\"📄 Login response HTML content (short): {response_html}\");\n        }\n\n        // Check if we were redirected away from login page (success indicator)\n        let has_login_form = self.check_for_login_form(\u0026response_html);\n        log::debug!(\"🔍 Final login validation:\");\n        log::debug!(\"   - Response contains login form: {has_login_form}\");\n        log::debug!(\"   - Response status: {}\", response.status());\n\n        if !has_login_form \u0026\u0026 response.status() == 200 {\n            log::info!(\"✅ Login successful - no login form detected in response\");\n            Ok(LastFmEditSession::new(\n                username.to_string(),\n                cookies,\n                Some(csrf_token),\n                self.base_url.clone(),\n            ))\n        } else {\n            // Parse and return error message\n            let error_msg = self.parse_login_error(\u0026response_html);\n            log::warn!(\"❌ Login failed: {error_msg}\");\n            Err(LastFmError::Auth(error_msg))\n        }\n    }\n\n    /// Handle 403 Forbidden responses\n    async fn handle_403_response(\n        \u0026self,\n        mut response: http_types::Response,\n    ) -\u003e Result\u003cLastFmEditSession\u003e {\n        let response_html = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\"📄 403 response HTML length: {} chars\", response_html.len());\n        if response_html.len() \u003c 2000 {\n            log::debug!(\"📄 403 response HTML content: {response_html}\");\n        } else {\n            // Log first and last 500 chars for large responses\n            log::debug!(\"📄 403 response HTML start: {}\", \u0026response_html[..500]);\n            log::debug!(\n                \"📄 403 response HTML end: {}\",\n                \u0026response_html[response_html.len() - 500..]\n            );\n        }\n\n        let login_error = self.parse_login_error(\u0026response_html);\n        Err(LastFmError::Auth(login_error))\n    }\n\n    /// Check if the response indicates successful session establishment\n    fn check_session_success(\n        \u0026self,\n        response: \u0026http_types::Response,\n        username: \u0026str,\n        cookies: \u0026[String],\n        csrf_token: \u0026str,\n    ) -\u003e Option\u003cLastFmEditSession\u003e {\n        let has_real_session = cookies\n            .iter()\n            .any(|cookie| cookie.starts_with(\"sessionid=.\") \u0026\u0026 cookie.len() \u003e 50);\n\n        log::debug!(\"🔍 Session validation:\");\n        log::debug!(\"   - Has real session cookie: {has_real_session}\");\n        log::debug!(\"   - Response status: {}\", response.status());\n        log::debug!(\"   - All cookies: {cookies:?}\");\n\n        if has_real_session \u0026\u0026 (response.status() == 302 || response.status() == 200) {\n            log::info!(\"✅ Login successful - authenticated session established\");\n            Some(LastFmEditSession::new(\n                username.to_string(),\n                cookies.to_vec(),\n                Some(csrf_token.to_string()),\n                self.base_url.clone(),\n            ))\n        } else {\n            None\n        }\n    }\n\n    /// Make a simple HTTP GET request (without retry logic)\n    async fn get(\u0026self, url: \u0026str) -\u003e Result\u003chttp_types::Response\u003e {\n        let mut request = Request::new(Method::Get, url.parse::\u003cUrl\u003e().unwrap());\n        let _ = request.insert_header(\"User-Agent\", \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36\");\n\n        self.client\n            .send(request)\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))\n    }\n\n    /// Extract login form data (CSRF token and next field)\n    fn extract_login_form_data(\u0026self, html: \u0026str) -\u003e Result\u003c(String, Option\u003cString\u003e)\u003e {\n        let document = Html::parse_document(html);\n\n        let csrf_token = self.extract_csrf_token(\u0026document)?;\n\n        // Check if there's a 'next' field in the form\n        let next_selector = Selector::parse(\"input[name=\\\"next\\\"]\").unwrap();\n        let next_field = document\n            .select(\u0026next_selector)\n            .next()\n            .and_then(|input| input.value().attr(\"value\"))\n            .map(|s| s.to_string());\n\n        Ok((csrf_token, next_field))\n    }\n\n    fn extract_csrf_token(\u0026self, document: \u0026Html) -\u003e Result\u003cString\u003e {\n        let csrf_selector = Selector::parse(\"input[name=\\\"csrfmiddlewaretoken\\\"]\").unwrap();\n\n        let csrf_token = document\n            .select(\u0026csrf_selector)\n            .next()\n            .and_then(|input| input.value().attr(\"value\"))\n            .map(|token| token.to_string())\n            .ok_or(LastFmError::CsrfNotFound)?;\n\n        log::debug!(\"🔑 CSRF token extracted from HTML: {csrf_token}\");\n        Ok(csrf_token)\n    }\n\n    /// Parse login error messages from HTML\n    fn parse_login_error(\u0026self, html: \u0026str) -\u003e String {\n        let document = Html::parse_document(html);\n\n        let error_selector = Selector::parse(\".alert-danger, .form-error, .error-message\").unwrap();\n\n        let mut error_messages = Vec::new();\n        for error in document.select(\u0026error_selector) {\n            let error_text = error.text().collect::\u003cString\u003e().trim().to_string();\n            if !error_text.is_empty() {\n                error_messages.push(error_text);\n            }\n        }\n\n        if error_messages.is_empty() {\n            \"Login failed - please check your credentials\".to_string()\n        } else {\n            format!(\"Login failed: {}\", error_messages.join(\"; \"))\n        }\n    }\n\n    /// Check if HTML contains a login form\n    fn check_for_login_form(\u0026self, html: \u0026str) -\u003e bool {\n        let document = Html::parse_document(html);\n        let login_form_selector =\n            Selector::parse(\"form[action*=\\\"login\\\"], input[name=\\\"username_or_email\\\"]\").unwrap();\n        document.select(\u0026login_form_selector).next().is_some()\n    }\n}\n\n/// Extract cookies from HTTP response - utility function\npub fn extract_cookies_from_response(response: \u0026http_types::Response, cookies: \u0026mut Vec\u003cString\u003e) {\n    if let Some(cookie_headers) = response.header(\"set-cookie\") {\n        for cookie_header in cookie_headers {\n            let cookie_str = cookie_header.as_str();\n            // Extract just the cookie name=value part (before any semicolon)\n            if let Some(cookie_value) = cookie_str.split(';').next() {\n                let cookie_name = cookie_value.split('=').next().unwrap_or(\"\");\n\n                // Remove any existing cookie with the same name\n                cookies.retain(|existing| !existing.starts_with(\u0026format!(\"{cookie_name}=\")));\n                cookies.push(cookie_value.to_string());\n            }\n        }\n    }\n}\n","traces":[{"line":16,"address":[5478176],"length":1,"stats":{"Line":1}},{"line":36,"address":[3235146,3234164,3234340,3234425,3236350,3234080],"length":1,"stats":{"Line":4}},{"line":37,"address":[6080946,6080986,6080756],"length":1,"stats":{"Line":3}},{"line":40,"address":[3234488,3234810],"length":1,"stats":{"Line":2}},{"line":41,"address":[3363506],"length":1,"stats":{"Line":2}},{"line":44,"address":[6083021,6082245,6082719,6082643,6083049,6083136],"length":1,"stats":{"Line":5}},{"line":46,"address":[5960601],"length":1,"stats":{"Line":1}},{"line":47,"address":[5578279],"length":1,"stats":{"Line":1}},{"line":48,"address":[5578311],"length":1,"stats":{"Line":1}},{"line":49,"address":[3507279],"length":1,"stats":{"Line":1}},{"line":50,"address":[6343530],"length":1,"stats":{"Line":1}},{"line":51,"address":[5960849],"length":1,"stats":{"Line":1}},{"line":53,"address":[5316760],"length":1,"stats":{"Line":3}},{"line":56,"address":[3236798],"length":1,"stats":{"Line":1}},{"line":57,"address":[5769477,5769716],"length":1,"stats":{"Line":2}},{"line":60,"address":[5770568,5769533,5770064],"length":1,"stats":{"Line":3}},{"line":61,"address":[3509061,3505756,3509424,3508733,3508773],"length":1,"stats":{"Line":3}},{"line":65,"address":[2875456],"length":1,"stats":{"Line":1}},{"line":69,"address":[6346015,6346178,6346225],"length":1,"stats":{"Line":3}},{"line":70,"address":[5281535],"length":1,"stats":{"Line":2}},{"line":72,"address":[5964448,5964502,5964348],"length":1,"stats":{"Line":3}},{"line":73,"address":[3239654,3240040,3240211,3240075],"length":1,"stats":{"Line":0}},{"line":79,"address":[5964846],"length":1,"stats":{"Line":1}},{"line":80,"address":[5773109],"length":1,"stats":{"Line":1}},{"line":81,"address":[5965404,5965496],"length":1,"stats":{"Line":2}},{"line":84,"address":[3512222,3511870,3514964,3512678,3512588,3512514],"length":1,"stats":{"Line":4}},{"line":86,"address":[5998114],"length":1,"stats":{"Line":3}},{"line":87,"address":[5776448,5776466,5774038],"length":1,"stats":{"Line":0}},{"line":89,"address":[6088171,6088139,6088043],"length":1,"stats":{"Line":3}},{"line":90,"address":[5966826,5966489],"length":1,"stats":{"Line":2}},{"line":91,"address":[6088543],"length":1,"stats":{"Line":0}},{"line":95,"address":[5967215,5966834],"length":1,"stats":{"Line":2}},{"line":96,"address":[3513863,3513953,3514004],"length":1,"stats":{"Line":3}},{"line":97,"address":[5776004,5775367,5775682],"length":1,"stats":{"Line":3}},{"line":99,"address":[3243100],"length":1,"stats":{"Line":1}},{"line":103,"address":[5835888],"length":1,"stats":{"Line":1}},{"line":113,"address":[5586808],"length":1,"stats":{"Line":1}},{"line":114,"address":[3515752],"length":1,"stats":{"Line":1}},{"line":115,"address":[6352156],"length":1,"stats":{"Line":1}},{"line":116,"address":[5969514],"length":1,"stats":{"Line":1}},{"line":118,"address":[6352261],"length":1,"stats":{"Line":1}},{"line":119,"address":[3244805,3244928],"length":1,"stats":{"Line":2}},{"line":120,"address":[3516111],"length":1,"stats":{"Line":1}},{"line":123,"address":[5777448,5777898,5778088,5777952],"length":1,"stats":{"Line":0}},{"line":127,"address":[3245770,3245312,3245824],"length":1,"stats":{"Line":3}},{"line":128,"address":[3517322,3517259,3516916],"length":1,"stats":{"Line":3}},{"line":131,"address":[5588517,5588930,5591355],"length":1,"stats":{"Line":2}},{"line":134,"address":[3247036,3246793,3246887],"length":1,"stats":{"Line":3}},{"line":136,"address":[3521664,3521710],"length":1,"stats":{"Line":2}},{"line":140,"address":[3518273,3518379],"length":1,"stats":{"Line":2}},{"line":141,"address":[3247215,3247608,3247554],"length":1,"stats":{"Line":3}},{"line":142,"address":[5972360,5972745,5972799],"length":1,"stats":{"Line":3}},{"line":143,"address":[6094973,6094415,6094761,6094849],"length":1,"stats":{"Line":3}},{"line":146,"address":[5780895],"length":1,"stats":{"Line":1}},{"line":149,"address":[5591107,5591219,5591296,5591609,5591637,5591751],"length":1,"stats":{"Line":5}},{"line":151,"address":[6095234],"length":1,"stats":{"Line":1}},{"line":152,"address":[5733479],"length":1,"stats":{"Line":3}},{"line":153,"address":[5593394,5591719,5593376],"length":1,"stats":{"Line":0}},{"line":155,"address":[3249631,3249490,3249580],"length":1,"stats":{"Line":3}},{"line":156,"address":[6096607],"length":1,"stats":{"Line":0}},{"line":161,"address":[5592359],"length":1,"stats":{"Line":1}},{"line":165,"address":[2875728,2877225,2877219],"length":1,"stats":{"Line":1}},{"line":166,"address":[5953250],"length":1,"stats":{"Line":1}},{"line":169,"address":[6218353,6218425],"length":1,"stats":{"Line":2}},{"line":170,"address":[2876021],"length":1,"stats":{"Line":1}},{"line":171,"address":[5953512],"length":1,"stats":{"Line":1}},{"line":172,"address":[5478988],"length":1,"stats":{"Line":1}},{"line":176,"address":[5479056],"length":1,"stats":{"Line":1}},{"line":180,"address":[2876248],"length":1,"stats":{"Line":1}},{"line":181,"address":[5953784],"length":1,"stats":{"Line":1}},{"line":182,"address":[5479260],"length":1,"stats":{"Line":1}},{"line":183,"address":[6218912],"length":1,"stats":{"Line":1}},{"line":184,"address":[6218978],"length":1,"stats":{"Line":1}},{"line":185,"address":[3719414],"length":1,"stats":{"Line":1}},{"line":189,"address":[2876606],"length":1,"stats":{"Line":1}},{"line":190,"address":[5954190],"length":1,"stats":{"Line":1}},{"line":191,"address":[5837218],"length":1,"stats":{"Line":1}},{"line":192,"address":[5837286],"length":1,"stats":{"Line":1}},{"line":193,"address":[3719754],"length":1,"stats":{"Line":1}},{"line":194,"address":[3719822],"length":1,"stats":{"Line":1}},{"line":197,"address":[5668140],"length":1,"stats":{"Line":1}},{"line":198,"address":[5668175],"length":1,"stats":{"Line":1}},{"line":199,"address":[5668354,5668266],"length":1,"stats":{"Line":2}},{"line":202,"address":[6219599],"length":1,"stats":{"Line":1}},{"line":206,"address":[2877248],"length":1,"stats":{"Line":1}},{"line":214,"address":[5976509,5976355],"length":1,"stats":{"Line":2}},{"line":215,"address":[5785009,5784211,5784459,5785129],"length":1,"stats":{"Line":0}},{"line":219,"address":[5784604,5784355],"length":1,"stats":{"Line":2}},{"line":222,"address":[5784802],"length":1,"stats":{"Line":1}},{"line":226,"address":[6099627,6098750,6099741,6099569,6098811,6103790],"length":1,"stats":{"Line":0}},{"line":228,"address":[5999877],"length":1,"stats":{"Line":0}},{"line":229,"address":[3528583,3524277,3528560],"length":1,"stats":{"Line":0}},{"line":231,"address":[5595842,5595746,5595874,5595991],"length":1,"stats":{"Line":0}},{"line":235,"address":[3524516,3524865],"length":1,"stats":{"Line":0}},{"line":236,"address":[3524930],"length":1,"stats":{"Line":0}},{"line":240,"address":[3253845,3254271],"length":1,"stats":{"Line":0}},{"line":241,"address":[5596673,5596779],"length":1,"stats":{"Line":0}},{"line":242,"address":[3254705,3254363,3254651],"length":1,"stats":{"Line":0}},{"line":243,"address":[5597364,5597025,5597389],"length":1,"stats":{"Line":0}},{"line":245,"address":[5597723,5597370,5599012,5597807],"length":1,"stats":{"Line":0}},{"line":246,"address":[3526603,3526507],"length":1,"stats":{"Line":0}},{"line":247,"address":[3527090,3527185],"length":1,"stats":{"Line":0}},{"line":248,"address":[5598201,5597907],"length":1,"stats":{"Line":0}},{"line":249,"address":[5598209],"length":1,"stats":{"Line":0}},{"line":250,"address":[5788494],"length":1,"stats":{"Line":0}},{"line":251,"address":[5598363],"length":1,"stats":{"Line":0}},{"line":255,"address":[3526406,3527359],"length":1,"stats":{"Line":0}},{"line":256,"address":[3256354,3256444,3256649],"length":1,"stats":{"Line":0}},{"line":257,"address":[3256454],"length":1,"stats":{"Line":0}},{"line":262,"address":[5480432],"length":1,"stats":{"Line":0}},{"line":266,"address":[5983073,5983245,5982662,5983131,5982814],"length":1,"stats":{"Line":0}},{"line":268,"address":[5982787,5983105,5982907,5982726,5982847],"length":1,"stats":{"Line":0}},{"line":269,"address":[3531584,3529413,3531607],"length":1,"stats":{"Line":0}},{"line":271,"address":[5791138,5791234,5791266],"length":1,"stats":{"Line":0}},{"line":272,"address":[5601373,5601024],"length":1,"stats":{"Line":0}},{"line":273,"address":[5792579,5791650],"length":1,"stats":{"Line":0}},{"line":276,"address":[3259013,3259113,3259167],"length":1,"stats":{"Line":0}},{"line":277,"address":[5792245],"length":1,"stats":{"Line":0}},{"line":283,"address":[3530527,3531284],"length":1,"stats":{"Line":0}},{"line":284,"address":[5792891],"length":1,"stats":{"Line":0}},{"line":288,"address":[3722538,3720464,3722510],"length":1,"stats":{"Line":1}},{"line":295,"address":[3720619],"length":1,"stats":{"Line":1}},{"line":297,"address":[6107200,6107230],"length":1,"stats":{"Line":2}},{"line":299,"address":[6220318,6220395],"length":1,"stats":{"Line":2}},{"line":300,"address":[5838563,5838317],"length":1,"stats":{"Line":2}},{"line":301,"address":[5481288,5480965],"length":1,"stats":{"Line":2}},{"line":302,"address":[2878265,2878579],"length":1,"stats":{"Line":2}},{"line":304,"address":[5669998,5670723,5669733],"length":1,"stats":{"Line":2}},{"line":305,"address":[5839571,5839453],"length":1,"stats":{"Line":2}},{"line":306,"address":[6222097,6221993],"length":1,"stats":{"Line":2}},{"line":307,"address":[6221546],"length":1,"stats":{"Line":1}},{"line":308,"address":[5670179,5670434],"length":1,"stats":{"Line":2}},{"line":309,"address":[3722202,3722264],"length":1,"stats":{"Line":2}},{"line":310,"address":[5839904],"length":1,"stats":{"Line":1}},{"line":313,"address":[5669985],"length":1,"stats":{"Line":0}},{"line":318,"address":[5482624,5482642],"length":1,"stats":{"Line":4}},{"line":319,"address":[5793586,5793685],"length":1,"stats":{"Line":2}},{"line":320,"address":[6368672,6368770],"length":1,"stats":{"Line":2}},{"line":322,"address":[5793882,5794007,5794066,5794376,5794436],"length":1,"stats":{"Line":5}},{"line":323,"address":[5603724],"length":1,"stats":{"Line":1}},{"line":324,"address":[5483223],"length":1,"stats":{"Line":3}},{"line":325,"address":[5986754,5986736],"length":1,"stats":{"Line":0}},{"line":329,"address":[5841237,5841188,5840224],"length":1,"stats":{"Line":1}},{"line":330,"address":[3722696],"length":1,"stats":{"Line":1}},{"line":332,"address":[5671029,5670981],"length":1,"stats":{"Line":2}},{"line":335,"address":[5483030,5483102],"length":1,"stats":{"Line":2}},{"line":336,"address":[5671338,5671482,5671414],"length":1,"stats":{"Line":3}},{"line":339,"address":[6369584,6369585],"length":1,"stats":{"Line":2}},{"line":340,"address":[5671441,5671538],"length":1,"stats":{"Line":3}},{"line":342,"address":[2880402],"length":1,"stats":{"Line":1}},{"line":345,"address":[3723664,3724694,3724732],"length":1,"stats":{"Line":1}},{"line":346,"address":[2880726],"length":1,"stats":{"Line":1}},{"line":348,"address":[3723897,3723967,3724094,3723829,3723764],"length":1,"stats":{"Line":4}},{"line":351,"address":[6369680,6369681],"length":1,"stats":{"Line":2}},{"line":352,"address":[3533222,3533200],"length":1,"stats":{"Line":2}},{"line":353,"address":[6223587,6223694,6224332,6223488,6223819],"length":1,"stats":{"Line":2}},{"line":355,"address":[5484298,5484462],"length":1,"stats":{"Line":2}},{"line":356,"address":[6223939],"length":1,"stats":{"Line":1}},{"line":360,"address":[5959392,5960306,5960748],"length":1,"stats":{"Line":0}},{"line":361,"address":[5842419],"length":1,"stats":{"Line":0}},{"line":363,"address":[5484889,5484961],"length":1,"stats":{"Line":0}},{"line":365,"address":[3724957],"length":1,"stats":{"Line":0}},{"line":366,"address":[5843662,5842690,5842617,5842814],"length":1,"stats":{"Line":0}},{"line":367,"address":[5485765,5485322],"length":1,"stats":{"Line":0}},{"line":368,"address":[3725945],"length":1,"stats":{"Line":0}},{"line":369,"address":[5843566,5843652],"length":1,"stats":{"Line":0}},{"line":373,"address":[6224955],"length":1,"stats":{"Line":0}},{"line":374,"address":[5842990,5843272],"length":1,"stats":{"Line":0}},{"line":376,"address":[5842956,5843026],"length":1,"stats":{"Line":0}},{"line":381,"address":[5843728,5844168,5844174],"length":1,"stats":{"Line":0}},{"line":382,"address":[5486207],"length":1,"stats":{"Line":0}},{"line":383,"address":[3726242,3726173],"length":1,"stats":{"Line":0}},{"line":385,"address":[3726280,3726347,3726409],"length":1,"stats":{"Line":0}},{"line":390,"address":[5961232],"length":1,"stats":{"Line":1}},{"line":391,"address":[5844220],"length":1,"stats":{"Line":1}},{"line":392,"address":[5486732,5486772],"length":1,"stats":{"Line":2}},{"line":393,"address":[3726790],"length":1,"stats":{"Line":1}},{"line":395,"address":[2883806],"length":1,"stats":{"Line":1}},{"line":396,"address":[5844541],"length":1,"stats":{"Line":1}},{"line":399,"address":[2884007],"length":1,"stats":{"Line":21}},{"line":400,"address":[5487088],"length":1,"stats":{"Line":1}}],"covered":126,"coverable":181},{"path":["/","home","imalison","Projects","lastfm-edit","src","parsing.rs"],"content":"//! HTML parsing utilities for Last.fm pages.\n//!\n//! This module contains all the HTML parsing logic for extracting track, album,\n//! and other data from Last.fm web pages. These functions are primarily pure\n//! functions that take HTML documents and return structured data.\n\nuse crate::{Album, AlbumPage, Artist, ArtistPage, LastFmError, Result, Track, TrackPage};\nuse scraper::{Html, Selector};\n\n/// Parser struct containing parsing methods for Last.fm HTML pages.\n///\n/// This struct holds the parsing logic that was previously embedded in the client.\n/// It's designed to be stateless and focused purely on HTML parsing.\n#[derive(Debug, Clone)]\npub struct LastFmParser;\n\nimpl LastFmParser {\n    /// Create a new parser instance.\n    pub fn new() -\u003e Self {\n        Self\n    }\n\n    /// Parse recent scrobbles from the user's library page\n    /// This extracts real scrobble data with timestamps for editing\n    pub fn parse_recent_scrobbles(\u0026self, document: \u0026Html) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        let mut tracks = Vec::new();\n\n        // Recent scrobbles are typically in chartlist tables - there can be multiple\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let row_selector = Selector::parse(\"tbody tr\").unwrap();\n\n        let tables: Vec\u003c_\u003e = document.select(\u0026table_selector).collect();\n        log::debug!(\"Found {} chartlist tables\", tables.len());\n\n        for table in tables {\n            for row in table.select(\u0026row_selector) {\n                if let Ok(track) = self.parse_recent_scrobble_row(\u0026row) {\n                    tracks.push(track);\n                }\n            }\n        }\n\n        if tracks.is_empty() {\n            log::debug!(\"No tracks found in recent scrobbles\");\n        }\n\n        log::debug!(\"Parsed {} recent scrobbles\", tracks.len());\n        Ok(tracks)\n    }\n\n    /// Parse a single row from the recent scrobbles table\n    fn parse_recent_scrobble_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cTrack\u003e {\n        // Extract track name\n        let name_selector = Selector::parse(\".chartlist-name a\").unwrap();\n        let name = row\n            .select(\u0026name_selector)\n            .next()\n            .ok_or(LastFmError::Parse(\"Missing track name\".to_string()))?\n            .text()\n            .collect::\u003cString\u003e()\n            .trim()\n            .to_string();\n\n        // Extract artist name\n        let artist_selector = Selector::parse(\".chartlist-artist a\").unwrap();\n        let artist = row\n            .select(\u0026artist_selector)\n            .next()\n            .ok_or(LastFmError::Parse(\"Missing artist name\".to_string()))?\n            .text()\n            .collect::\u003cString\u003e()\n            .trim()\n            .to_string();\n\n        // Extract timestamp from data attributes or hidden inputs\n        let timestamp = self.extract_scrobble_timestamp(row);\n\n        // Extract album from hidden inputs in edit form\n        let album = self.extract_scrobble_album(row);\n\n        // Extract album artist from hidden inputs in edit form\n        let album_artist = self.extract_scrobble_album_artist(row);\n\n        // For recent scrobbles, playcount is typically 1 since they're individual scrobbles\n        let playcount = 1;\n\n        Ok(Track {\n            name,\n            artist,\n            playcount,\n            timestamp,\n            album,\n            album_artist,\n        })\n    }\n\n    /// Extract timestamp from scrobble row elements\n    fn extract_scrobble_timestamp(\u0026self, row: \u0026scraper::ElementRef) -\u003e Option\u003cu64\u003e {\n        // Look for timestamp in various places:\n\n        // 1. Check for data-timestamp attribute\n        if let Some(timestamp_str) = row.value().attr(\"data-timestamp\") {\n            if let Ok(timestamp) = timestamp_str.parse::\u003cu64\u003e() {\n                return Some(timestamp);\n            }\n        }\n\n        // 2. Look for hidden timestamp input\n        let timestamp_input_selector = Selector::parse(\"input[name='timestamp']\").unwrap();\n        if let Some(input) = row.select(\u0026timestamp_input_selector).next() {\n            if let Some(value) = input.value().attr(\"value\") {\n                if let Ok(timestamp) = value.parse::\u003cu64\u003e() {\n                    return Some(timestamp);\n                }\n            }\n        }\n\n        // 3. Look for edit form with timestamp\n        let edit_form_selector =\n            Selector::parse(\"form[data-edit-scrobble] input[name='timestamp']\").unwrap();\n        if let Some(timestamp_input) = row.select(\u0026edit_form_selector).next() {\n            if let Some(value) = timestamp_input.value().attr(\"value\") {\n                if let Ok(timestamp) = value.parse::\u003cu64\u003e() {\n                    return Some(timestamp);\n                }\n            }\n        }\n\n        // Removed time element parsing - testing if needed\n\n        None\n    }\n\n    /// Extract album name from scrobble row elements\n    fn extract_scrobble_album(\u0026self, row: \u0026scraper::ElementRef) -\u003e Option\u003cString\u003e {\n        // Look for album_name in hidden inputs within edit forms\n        let album_input_selector =\n            Selector::parse(\"form[data-edit-scrobble] input[name='album_name']\").unwrap();\n\n        if let Some(album_input) = row.select(\u0026album_input_selector).next() {\n            if let Some(album_name) = album_input.value().attr(\"value\") {\n                if !album_name.is_empty() {\n                    return Some(album_name.to_string());\n                }\n            }\n        }\n\n        None\n    }\n\n    /// Extract album artist name from scrobble row elements\n    fn extract_scrobble_album_artist(\u0026self, row: \u0026scraper::ElementRef) -\u003e Option\u003cString\u003e {\n        // Look for album_artist_name in hidden inputs within edit forms\n        let album_artist_input_selector =\n            Selector::parse(\"form[data-edit-scrobble] input[name='album_artist_name']\").unwrap();\n\n        if let Some(album_artist_input) = row.select(\u0026album_artist_input_selector).next() {\n            if let Some(album_artist_name) = album_artist_input.value().attr(\"value\") {\n                if !album_artist_name.is_empty() {\n                    return Some(album_artist_name.to_string());\n                }\n            }\n        }\n\n        None\n    }\n\n    /// Parse a tracks page into a `TrackPage` structure\n    pub fn parse_tracks_page(\n        \u0026self,\n        document: \u0026Html,\n        page_number: u32,\n        artist: \u0026str,\n        album: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cTrackPage\u003e {\n        let tracks = self.extract_tracks_from_document(document, artist, album)?;\n\n        // Check for pagination\n        let (has_next_page, total_pages) = self.parse_pagination(document, page_number)?;\n\n        Ok(TrackPage {\n            tracks,\n            page_number,\n            has_next_page,\n            total_pages,\n        })\n    }\n\n    /// Extract tracks from HTML document\n    pub fn extract_tracks_from_document(\n        \u0026self,\n        document: \u0026Html,\n        artist: \u0026str,\n        album: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        let mut tracks = Vec::new();\n        let mut seen_tracks = std::collections::HashSet::new();\n\n        log::debug!(\"Starting track extraction for artist: {artist}, album: {album:?}\");\n\n        // JSON parsing removed - was not implemented and always failed\n\n        // Parse track data from data-track-name attributes (AJAX response)\n        let track_selector = Selector::parse(\"[data-track-name]\").unwrap();\n        let track_elements: Vec\u003c_\u003e = document.select(\u0026track_selector).collect();\n        log::debug!(\n            \"Found {} elements with data-track-name\",\n            track_elements.len()\n        );\n\n        for element in track_elements {\n            let track_name = element.value().attr(\"data-track-name\").unwrap_or(\"\");\n            if track_name.is_empty() {\n                continue;\n            }\n            if seen_tracks.contains(track_name) {\n                continue;\n            }\n            seen_tracks.insert(track_name.to_string());\n\n            match self.find_playcount_for_track(document, track_name) {\n                Ok(playcount) =\u003e {\n                    let timestamp = self.find_timestamp_for_track(document, track_name);\n                    let track = Track {\n                        name: track_name.to_string(),\n                        artist: artist.to_string(),\n                        playcount,\n                        timestamp,\n                        album: album.map(|a| a.to_string()),\n                        album_artist: None, // Not available in aggregate track listings\n                    };\n                    tracks.push(track);\n                    log::debug!(\"Added track '{track_name}' with {playcount} plays\");\n                }\n                Err(e) =\u003e {\n                    log::debug!(\"FAILED to find playcount for track '{track_name}': {e}\");\n                }\n            }\n        }\n\n        // Always try fallback parsing from chartlist tables to catch tracks without data-track-name\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let tables: Vec\u003c_\u003e = document.select(\u0026table_selector).collect();\n\n        for table in tables {\n            let row_selector = Selector::parse(\"tbody tr\").unwrap();\n            let rows: Vec\u003c_\u003e = table.select(\u0026row_selector).collect();\n\n            for row in rows.iter() {\n                // Try to parse as track row\n                if let Ok(mut track) = self.parse_track_row(row) {\n                    track.artist = artist.to_string();\n                    if let Some(album_name) = album {\n                        track.album = Some(album_name.to_string());\n                    }\n\n                    // Only add if we don't already have this track\n                    if !seen_tracks.contains(\u0026track.name) {\n                        seen_tracks.insert(track.name.clone());\n                        tracks.push(track);\n                    }\n                }\n            }\n        }\n\n        log::debug!(\"Successfully extracted {} unique tracks\", tracks.len());\n        Ok(tracks)\n    }\n\n    // Removed parse_tracks_from_rows - no longer needed\n\n    /// Parse a single track row from chartlist table\n    pub fn parse_track_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cTrack\u003e {\n        // Extract track name using shared method\n        let name = self.extract_name_from_row(row, \"track\")?;\n\n        // Parse play count using shared method\n        let playcount = self.extract_playcount_from_row(row);\n\n        let artist = \"\".to_string(); // Will be filled in by caller\n\n        Ok(Track {\n            name,\n            artist,\n            playcount,\n            timestamp: None,    // Not available in table parsing mode\n            album: None,        // Not available in table parsing mode\n            album_artist: None, // Not available in table parsing mode\n        })\n    }\n\n    /// Parse albums page into `AlbumPage` structure\n    pub fn parse_albums_page(\n        \u0026self,\n        document: \u0026Html,\n        page_number: u32,\n        artist: \u0026str,\n    ) -\u003e Result\u003cAlbumPage\u003e {\n        let mut albums = Vec::new();\n\n        // Try parsing album data from data attributes (AJAX response)\n        let album_selector = Selector::parse(\"[data-album-name]\").unwrap();\n        let album_elements: Vec\u003c_\u003e = document.select(\u0026album_selector).collect();\n\n        if !album_elements.is_empty() {\n            log::debug!(\n                \"Found {} album elements with data-album-name\",\n                album_elements.len()\n            );\n\n            // Use a set to track unique albums\n            let mut seen_albums = std::collections::HashSet::new();\n\n            for element in album_elements {\n                let album_name = element.value().attr(\"data-album-name\").unwrap_or(\"\");\n                if !album_name.is_empty() \u0026\u0026 !seen_albums.contains(album_name) {\n                    seen_albums.insert(album_name.to_string());\n\n                    if let Ok(playcount) = self.find_playcount_for_album(document, album_name) {\n                        let timestamp = self.find_timestamp_for_album(document, album_name);\n                        let album = Album {\n                            name: album_name.to_string(),\n                            artist: artist.to_string(),\n                            playcount,\n                            timestamp,\n                        };\n                        albums.push(album);\n                    }\n                }\n            }\n        } else {\n            // Fall back to parsing album rows from chartlist tables\n            albums = self.parse_albums_from_rows(document, artist)?;\n        }\n\n        let (has_next_page, total_pages) = self.parse_pagination(document, page_number)?;\n\n        Ok(AlbumPage {\n            albums,\n            page_number,\n            has_next_page,\n            total_pages,\n        })\n    }\n\n    /// Parse albums from chartlist table rows\n    fn parse_albums_from_rows(\u0026self, document: \u0026Html, artist: \u0026str) -\u003e Result\u003cVec\u003cAlbum\u003e\u003e {\n        let mut albums = Vec::new();\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let row_selector = Selector::parse(\"tbody tr\").unwrap();\n\n        for table in document.select(\u0026table_selector) {\n            for row in table.select(\u0026row_selector) {\n                if let Ok(mut album) = self.parse_album_row(\u0026row) {\n                    album.artist = artist.to_string();\n                    albums.push(album);\n                }\n            }\n        }\n        Ok(albums)\n    }\n\n    /// Parse a single album row from chartlist table\n    pub fn parse_album_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cAlbum\u003e {\n        // Extract album name using shared method\n        let name = self.extract_name_from_row(row, \"album\")?;\n\n        // Parse play count using shared method\n        let playcount = self.extract_playcount_from_row(row);\n\n        let artist = \"\".to_string(); // Will be filled in by caller\n\n        Ok(Album {\n            name,\n            artist,\n            playcount,\n            timestamp: None, // Not available in table parsing\n        })\n    }\n\n    // === SEARCH RESULTS PARSING ===\n\n    /// Parse track search results from AJAX response\n    ///\n    /// This parses the HTML returned by `/user/{username}/library/tracks/search?ajax=1\u0026query={query}`\n    /// which contains chartlist tables with track results.\n    pub fn parse_track_search_results(\u0026self, document: \u0026Html) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        let mut tracks = Vec::new();\n\n        // Search results use the same chartlist structure as library pages\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let row_selector = Selector::parse(\"tbody tr\").unwrap();\n\n        let tables: Vec\u003c_\u003e = document.select(\u0026table_selector).collect();\n        log::debug!(\"Found {} chartlist tables in search results\", tables.len());\n\n        for table in tables {\n            for row in table.select(\u0026row_selector) {\n                if let Ok(track) = self.parse_search_track_row(\u0026row) {\n                    tracks.push(track);\n                }\n            }\n        }\n\n        log::debug!(\"Parsed {} tracks from search results\", tracks.len());\n        Ok(tracks)\n    }\n\n    /// Parse album search results from AJAX response\n    ///\n    /// This parses the HTML returned by `/user/{username}/library/albums/search?ajax=1\u0026query={query}`\n    /// which contains chartlist tables with album results.\n    pub fn parse_album_search_results(\u0026self, document: \u0026Html) -\u003e Result\u003cVec\u003cAlbum\u003e\u003e {\n        let mut albums = Vec::new();\n\n        // Search results use the same chartlist structure as library pages\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let row_selector = Selector::parse(\"tbody tr\").unwrap();\n\n        let tables: Vec\u003c_\u003e = document.select(\u0026table_selector).collect();\n        log::debug!(\n            \"Found {} chartlist tables in album search results\",\n            tables.len()\n        );\n\n        for table in tables {\n            for row in table.select(\u0026row_selector) {\n                if let Ok(album) = self.parse_search_album_row(\u0026row) {\n                    albums.push(album);\n                }\n            }\n        }\n\n        log::debug!(\"Parsed {} albums from search results\", albums.len());\n        Ok(albums)\n    }\n\n    /// Parse a single track row from search results\n    fn parse_search_track_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cTrack\u003e {\n        // Extract track name using the standard chartlist structure\n        let name = self.extract_name_from_row(row, \"track\")?;\n\n        // Extract artist name from chartlist-artist column\n        let artist_selector = Selector::parse(\".chartlist-artist a\").unwrap();\n        let artist = row\n            .select(\u0026artist_selector)\n            .next()\n            .map(|el| el.text().collect::\u003cString\u003e().trim().to_string())\n            .ok_or_else(|| {\n                LastFmError::Parse(\"Missing artist name in search results\".to_string())\n            })?;\n\n        // Extract playcount from the bar value\n        let playcount = self.extract_playcount_from_row(row);\n\n        // Search results typically don't have timestamps since they're aggregated\n        let timestamp = None;\n\n        // Try to extract album information if available in the search results\n        let album = self.extract_album_from_search_row(row);\n        let album_artist = self.extract_album_artist_from_search_row(row);\n\n        Ok(Track {\n            name,\n            artist,\n            playcount,\n            timestamp,\n            album,\n            album_artist,\n        })\n    }\n\n    /// Parse a single album row from search results\n    fn parse_search_album_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cAlbum\u003e {\n        // Extract album name using the standard chartlist structure\n        let name = self.extract_name_from_row(row, \"album\")?;\n\n        // Extract artist name from chartlist-artist column\n        let artist_selector = Selector::parse(\".chartlist-artist a\").unwrap();\n        let artist = row\n            .select(\u0026artist_selector)\n            .next()\n            .map(|el| el.text().collect::\u003cString\u003e().trim().to_string())\n            .ok_or_else(|| {\n                LastFmError::Parse(\"Missing artist name in album search results\".to_string())\n            })?;\n\n        // Extract playcount from the bar value\n        let playcount = self.extract_playcount_from_row(row);\n\n        Ok(Album {\n            name,\n            artist,\n            playcount,\n            timestamp: None, // Search results don't have timestamps\n        })\n    }\n\n    /// Extract album information from search track row\n    fn extract_album_from_search_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Option\u003cString\u003e {\n        // Look for album information in hidden form inputs (similar to recent scrobbles)\n        let album_input_selector = Selector::parse(\"input[name='album']\").unwrap();\n        if let Some(input) = row.select(\u0026album_input_selector).next() {\n            if let Some(value) = input.value().attr(\"value\") {\n                let album = value.trim().to_string();\n                if !album.is_empty() {\n                    return Some(album);\n                }\n            }\n        }\n        None\n    }\n\n    /// Extract album artist information from search track row\n    fn extract_album_artist_from_search_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Option\u003cString\u003e {\n        // Look for album artist information in hidden form inputs\n        let album_artist_input_selector = Selector::parse(\"input[name='album_artist']\").unwrap();\n        if let Some(input) = row.select(\u0026album_artist_input_selector).next() {\n            if let Some(value) = input.value().attr(\"value\") {\n                let album_artist = value.trim().to_string();\n                if !album_artist.is_empty() {\n                    return Some(album_artist);\n                }\n            }\n        }\n        None\n    }\n\n    // === SHARED PARSING UTILITIES ===\n\n    /// Extract name from chartlist row (works for both tracks and albums)\n    fn extract_name_from_row(\u0026self, row: \u0026scraper::ElementRef, item_type: \u0026str) -\u003e Result\u003cString\u003e {\n        let name_selector = Selector::parse(\".chartlist-name a\").unwrap();\n        let name = row\n            .select(\u0026name_selector)\n            .next()\n            .map(|el| el.text().collect::\u003cString\u003e().trim().to_string())\n            .ok_or_else(|| LastFmError::Parse(format!(\"Missing {item_type} name\")))?;\n        Ok(name)\n    }\n\n    /// Extract playcount from chartlist row (works for both tracks and albums)\n    fn extract_playcount_from_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e u32 {\n        let playcount_selector = Selector::parse(\".chartlist-count-bar-value\").unwrap();\n        let mut playcount = 1; // default fallback\n\n        if let Some(element) = row.select(\u0026playcount_selector).next() {\n            let text = element.text().collect::\u003cString\u003e().trim().to_string();\n            // Extract just the number part (before \"scrobbles\" if present)\n            if let Some(number_part) = text.split_whitespace().next() {\n                if let Ok(count) = number_part.parse::\u003cu32\u003e() {\n                    playcount = count;\n                }\n            }\n        }\n        playcount\n    }\n\n    /// Parse pagination information from document\n    pub fn parse_pagination(\n        \u0026self,\n        document: \u0026Html,\n        _current_page: u32,\n    ) -\u003e Result\u003c(bool, Option\u003cu32\u003e)\u003e {\n        let pagination_selector = Selector::parse(\".pagination-list\").unwrap();\n\n        if let Some(pagination) = document.select(\u0026pagination_selector).next() {\n            // Try multiple possible selectors for next page link\n            let next_selectors = [\n                \"a[aria-label=\\\"Next\\\"]\",\n                \".pagination-next a\",\n                \"a:contains(\\\"Next\\\")\",\n                \".next a\",\n            ];\n\n            let mut has_next = false;\n            for selector_str in \u0026next_selectors {\n                if let Ok(selector) = Selector::parse(selector_str) {\n                    if pagination.select(\u0026selector).next().is_some() {\n                        has_next = true;\n                        break;\n                    }\n                }\n            }\n\n            // Try to extract total pages from pagination text\n            let total_pages = self.extract_total_pages_from_pagination(\u0026pagination);\n\n            Ok((has_next, total_pages))\n        } else {\n            // No pagination found - single page\n            Ok((false, Some(1)))\n        }\n    }\n\n    /// Helper functions for pagination parsing\n    fn extract_total_pages_from_pagination(\u0026self, pagination: \u0026scraper::ElementRef) -\u003e Option\u003cu32\u003e {\n        // Look for patterns like \"Page 1 of 42\"\n        let text = pagination.text().collect::\u003cString\u003e();\n        if let Some(of_pos) = text.find(\" of \") {\n            let after_of = \u0026text[of_pos + 4..];\n            if let Some(number_end) = after_of.find(|c: char| !c.is_ascii_digit()) {\n                if let Ok(total) = after_of[..number_end].parse::\u003cu32\u003e() {\n                    return Some(total);\n                }\n            } else if let Ok(total) = after_of.trim().parse::\u003cu32\u003e() {\n                return Some(total);\n            }\n        }\n        None\n    }\n\n    // === JSON PARSING METHODS ===\n    // Removed unused JSON parsing method\n\n    // === FIND HELPER METHODS ===\n\n    pub fn find_timestamp_for_track(\u0026self, _document: \u0026Html, _track_name: \u0026str) -\u003e Option\u003cu64\u003e {\n        // Implementation would search for timestamp data\n        None\n    }\n\n    pub fn find_playcount_for_track(\u0026self, document: \u0026Html, track_name: \u0026str) -\u003e Result\u003cu32\u003e {\n        // Look for chartlist-count-bar-value elements near the track\n        let count_selector = Selector::parse(\".chartlist-count-bar-value\").unwrap();\n        let link_selector = Selector::parse(\"a[href*=\\\"/music/\\\"]\").unwrap();\n\n        // Find all track links that match our track name\n        for link in document.select(\u0026link_selector) {\n            let link_text = link.text().collect::\u003cString\u003e().trim().to_string();\n            if link_text == track_name {\n                if let Some(row) = self.find_ancestor_row(link) {\n                    if let Some(count_element) = row.select(\u0026count_selector).next() {\n                        let text = count_element.text().collect::\u003cString\u003e().trim().to_string();\n                        if let Some(number_part) = text.split_whitespace().next() {\n                            if let Ok(count) = number_part.parse::\u003cu32\u003e() {\n                                return Ok(count);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        Err(LastFmError::Parse(format!(\n            \"Could not find playcount for track: {track_name}\"\n        )))\n    }\n\n    pub fn find_timestamp_for_album(\u0026self, _document: \u0026Html, _album_name: \u0026str) -\u003e Option\u003cu64\u003e {\n        // Implementation would search for timestamp data\n        None\n    }\n\n    pub fn find_playcount_for_album(\u0026self, document: \u0026Html, album_name: \u0026str) -\u003e Result\u003cu32\u003e {\n        // Look for chartlist-count-bar-value elements near the album\n        let count_selector = Selector::parse(\".chartlist-count-bar-value\").unwrap();\n        let link_selector = Selector::parse(\"a[href*=\\\"/music/\\\"]\").unwrap();\n\n        // Find all album links that match our album name\n        for link in document.select(\u0026link_selector) {\n            let link_text = link.text().collect::\u003cString\u003e().trim().to_string();\n            if link_text == album_name {\n                if let Some(row) = self.find_ancestor_row(link) {\n                    if let Some(count_element) = row.select(\u0026count_selector).next() {\n                        let text = count_element.text().collect::\u003cString\u003e().trim().to_string();\n                        if let Some(number_part) = text.split_whitespace().next() {\n                            if let Ok(count) = number_part.parse::\u003cu32\u003e() {\n                                return Ok(count);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        Err(LastFmError::Parse(format!(\n            \"Could not find playcount for album: {album_name}\"\n        )))\n    }\n\n    pub fn find_ancestor_row\u003c'a\u003e(\n        \u0026self,\n        element: scraper::ElementRef\u003c'a\u003e,\n    ) -\u003e Option\u003cscraper::ElementRef\u003c'a\u003e\u003e {\n        let mut current = element;\n        while let Some(parent) = current.parent() {\n            if let Some(parent_elem) = scraper::ElementRef::wrap(parent) {\n                if parent_elem.value().name() == \"tr\" {\n                    return Some(parent_elem);\n                }\n                current = parent_elem;\n            } else {\n                break;\n            }\n        }\n        None\n    }\n\n    /// Parse artists page from user's library\n    pub fn parse_artists_page(\u0026self, document: \u0026Html, page_number: u32) -\u003e Result\u003cArtistPage\u003e {\n        let mut artists = Vec::new();\n\n        // Parse artists from chartlist table rows\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let row_selector = Selector::parse(\"tr.js-link-block\").unwrap();\n\n        let tables: Vec\u003c_\u003e = document.select(\u0026table_selector).collect();\n        log::debug!(\"Found {} chartlist tables for artists\", tables.len());\n\n        for table in tables {\n            for row in table.select(\u0026row_selector) {\n                if let Ok(artist) = self.parse_artist_row(\u0026row) {\n                    artists.push(artist);\n                }\n            }\n        }\n\n        log::debug!(\"Parsed {} artists from page {}\", artists.len(), page_number);\n\n        let (has_next_page, total_pages) = self.parse_pagination(document, page_number)?;\n\n        Ok(ArtistPage {\n            artists,\n            page_number,\n            has_next_page,\n            total_pages,\n        })\n    }\n\n    /// Parse a single artist row from the artist library table\n    fn parse_artist_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cArtist\u003e {\n        // Extract artist name from the name column\n        let name_selector = Selector::parse(\"td.chartlist-name a\").unwrap();\n        let name = row\n            .select(\u0026name_selector)\n            .next()\n            .ok_or(LastFmError::Parse(\"Missing artist name\".to_string()))?\n            .text()\n            .collect::\u003cString\u003e()\n            .trim()\n            .to_string();\n\n        // Extract playcount from the count bar\n        let count_selector = Selector::parse(\".chartlist-count-bar\").unwrap();\n        let playcount = if let Some(count_element) = row.select(\u0026count_selector).next() {\n            let count_text = count_element.text().collect::\u003cString\u003e();\n            self.extract_number_from_count_text(\u0026count_text)\n                .unwrap_or(0)\n        } else {\n            0\n        };\n\n        // Artists in library listings typically don't have individual timestamps\n        let timestamp = None;\n\n        Ok(Artist {\n            name,\n            playcount,\n            timestamp,\n        })\n    }\n\n    /// Extract numeric value from count text like \"3,395 scrobbles\"\n    fn extract_number_from_count_text(\u0026self, text: \u0026str) -\u003e Option\u003cu32\u003e {\n        // Remove commas and extract the first numeric part\n        let cleaned = text.replace(',', \"\");\n        cleaned.split_whitespace().next()?.parse::\u003cu32\u003e().ok()\n    }\n}\n\nimpl Default for LastFmParser {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[{"line":19,"address":[20688156,20687874],"length":1,"stats":{"Line":0}},{"line":20,"address":[20688304,20688318],"length":1,"stats":{"Line":0}},{"line":25,"address":[20780933],"length":1,"stats":{"Line":1}},{"line":26,"address":[5780151],"length":1,"stats":{"Line":1}},{"line":29,"address":[5495416,5495488],"length":1,"stats":{"Line":2}},{"line":30,"address":[18486978],"length":1,"stats":{"Line":2}},{"line":32,"address":[5663570,5663499],"length":1,"stats":{"Line":2}},{"line":33,"address":[5495765,5495852,5495928],"length":1,"stats":{"Line":3}},{"line":35,"address":[3272050,3272418,3272545],"length":1,"stats":{"Line":3}},{"line":36,"address":[18487552],"length":1,"stats":{"Line":4}},{"line":37,"address":[5497612,5497539,5497510],"length":1,"stats":{"Line":3}},{"line":38,"address":[5329644,5329556],"length":1,"stats":{"Line":2}},{"line":43,"address":[21102588,21102542],"length":1,"stats":{"Line":2}},{"line":44,"address":[20634700],"length":1,"stats":{"Line":0}},{"line":47,"address":[5496519,5496838,5496953],"length":1,"stats":{"Line":8}},{"line":48,"address":[5664692],"length":1,"stats":{"Line":4}},{"line":52,"address":[20689423],"length":1,"stats":{"Line":1}},{"line":54,"address":[5782828],"length":1,"stats":{"Line":1}},{"line":55,"address":[5330278,5329937,5330008,5330151,5330504],"length":1,"stats":{"Line":4}},{"line":58,"address":[6048044,6048214],"length":1,"stats":{"Line":1}},{"line":65,"address":[5783654],"length":1,"stats":{"Line":1}},{"line":66,"address":[20844715],"length":1,"stats":{"Line":4}},{"line":67,"address":[21103210,21103345],"length":1,"stats":{"Line":0}},{"line":69,"address":[5666932,5667102],"length":1,"stats":{"Line":1}},{"line":76,"address":[3573126],"length":1,"stats":{"Line":1}},{"line":79,"address":[3573206],"length":1,"stats":{"Line":1}},{"line":82,"address":[5784594],"length":1,"stats":{"Line":1}},{"line":85,"address":[20689987,20690206],"length":1,"stats":{"Line":1}},{"line":87,"address":[5499980],"length":1,"stats":{"Line":1}},{"line":88,"address":[5784660],"length":1,"stats":{"Line":1}},{"line":89,"address":[18545799],"length":1,"stats":{"Line":1}},{"line":92,"address":[21103642],"length":1,"stats":{"Line":1}},{"line":93,"address":[21103677,21103231],"length":1,"stats":{"Line":0}},{"line":98,"address":[6050208,6051581,6051575],"length":1,"stats":{"Line":1}},{"line":102,"address":[5500473],"length":1,"stats":{"Line":1}},{"line":103,"address":[5668404,5668527],"length":1,"stats":{"Line":0}},{"line":104,"address":[5785484],"length":1,"stats":{"Line":0}},{"line":109,"address":[5500592],"length":1,"stats":{"Line":1}},{"line":110,"address":[5785560,5785628,5785444],"length":1,"stats":{"Line":3}},{"line":111,"address":[5785739,5785688],"length":1,"stats":{"Line":2}},{"line":112,"address":[3277185],"length":1,"stats":{"Line":1}},{"line":113,"address":[5668976],"length":1,"stats":{"Line":1}},{"line":119,"address":[5785972],"length":1,"stats":{"Line":0}},{"line":121,"address":[3277372,3277511,3277443],"length":1,"stats":{"Line":0}},{"line":122,"address":[5333275,5333326],"length":1,"stats":{"Line":0}},{"line":123,"address":[3575062],"length":1,"stats":{"Line":0}},{"line":124,"address":[5786481],"length":1,"stats":{"Line":0}},{"line":131,"address":[3575176],"length":1,"stats":{"Line":0}},{"line":135,"address":[6052230,6051600,6052236],"length":1,"stats":{"Line":1}},{"line":137,"address":[6051638],"length":1,"stats":{"Line":1}},{"line":140,"address":[5669829,5669764,5669897],"length":1,"stats":{"Line":3}},{"line":141,"address":[3575592,3575541],"length":1,"stats":{"Line":3}},{"line":142,"address":[5502299],"length":1,"stats":{"Line":1}},{"line":143,"address":[6052109],"length":1,"stats":{"Line":1}},{"line":148,"address":[6052204],"length":1,"stats":{"Line":0}},{"line":152,"address":[5503116,5502480,5503110],"length":1,"stats":{"Line":1}},{"line":154,"address":[5670358],"length":1,"stats":{"Line":1}},{"line":157,"address":[6052421,6052356,6052489],"length":1,"stats":{"Line":3}},{"line":158,"address":[5787557,5787608],"length":1,"stats":{"Line":2}},{"line":159,"address":[5334763],"length":1,"stats":{"Line":1}},{"line":160,"address":[3576413],"length":1,"stats":{"Line":1}},{"line":165,"address":[3279192],"length":1,"stats":{"Line":0}},{"line":169,"address":[5335723,5335717,5334944],"length":1,"stats":{"Line":1}},{"line":176,"address":[3576694],"length":1,"stats":{"Line":1}},{"line":179,"address":[5503481,5503541],"length":1,"stats":{"Line":2}},{"line":181,"address":[5788570],"length":1,"stats":{"Line":1}},{"line":182,"address":[5503747],"length":1,"stats":{"Line":2}},{"line":190,"address":[5340265,5335744,5342229],"length":1,"stats":{"Line":1}},{"line":196,"address":[5504031],"length":1,"stats":{"Line":1}},{"line":197,"address":[3577528],"length":1,"stats":{"Line":1}},{"line":199,"address":[3577721,3577681,3577588],"length":1,"stats":{"Line":3}},{"line":204,"address":[6054400,6054039],"length":1,"stats":{"Line":2}},{"line":205,"address":[6054458,6054529],"length":1,"stats":{"Line":2}},{"line":206,"address":[5789822],"length":1,"stats":{"Line":0}},{"line":211,"address":[6054663,6055063,6055198],"length":1,"stats":{"Line":3}},{"line":212,"address":[3284685,3281538],"length":1,"stats":{"Line":2}},{"line":213,"address":[5793600],"length":1,"stats":{"Line":1}},{"line":216,"address":[5793641],"length":1,"stats":{"Line":1}},{"line":219,"address":[3284878],"length":1,"stats":{"Line":1}},{"line":221,"address":[5793772],"length":1,"stats":{"Line":1}},{"line":222,"address":[3582568],"length":1,"stats":{"Line":1}},{"line":223,"address":[5676998],"length":1,"stats":{"Line":2}},{"line":225,"address":[3285193],"length":1,"stats":{"Line":2}},{"line":226,"address":[3582696],"length":1,"stats":{"Line":3}},{"line":229,"address":[5677191],"length":1,"stats":{"Line":5}},{"line":232,"address":[3583037],"length":1,"stats":{"Line":1}},{"line":233,"address":[5509647],"length":1,"stats":{"Line":2}},{"line":235,"address":[5340859],"length":1,"stats":{"Line":0}},{"line":236,"address":[6059838,6058859,6059866],"length":1,"stats":{"Line":0}},{"line":242,"address":[3578955],"length":1,"stats":{"Line":1}},{"line":243,"address":[5790404,5790475],"length":1,"stats":{"Line":2}},{"line":245,"address":[5505718,5505880],"length":1,"stats":{"Line":2}},{"line":246,"address":[5506552,5505940],"length":1,"stats":{"Line":2}},{"line":247,"address":[5506681,5506602],"length":1,"stats":{"Line":3}},{"line":249,"address":[3284657,3282808,3282728],"length":1,"stats":{"Line":6}},{"line":251,"address":[3284338,3283129,3283008,3283056],"length":1,"stats":{"Line":7}},{"line":252,"address":[5792172,5792077,5792153],"length":1,"stats":{"Line":3}},{"line":253,"address":[6057300,6057609],"length":1,"stats":{"Line":3}},{"line":254,"address":[6057419,6057363,6057470],"length":1,"stats":{"Line":3}},{"line":258,"address":[6057621,6057382],"length":1,"stats":{"Line":3}},{"line":259,"address":[6057673,6057627],"length":1,"stats":{"Line":2}},{"line":260,"address":[3283912],"length":1,"stats":{"Line":1}},{"line":266,"address":[5673833,5673992],"length":1,"stats":{"Line":3}},{"line":267,"address":[5506059],"length":1,"stats":{"Line":2}},{"line":273,"address":[5342272,5342973,5342979],"length":1,"stats":{"Line":1}},{"line":275,"address":[5795291],"length":1,"stats":{"Line":1}},{"line":278,"address":[5678612,5678556],"length":1,"stats":{"Line":3}},{"line":280,"address":[6060555],"length":1,"stats":{"Line":1}},{"line":282,"address":[3584327],"length":1,"stats":{"Line":1}},{"line":283,"address":[3584240],"length":1,"stats":{"Line":2}},{"line":286,"address":[3584279],"length":1,"stats":{"Line":1}},{"line":287,"address":[5510867],"length":1,"stats":{"Line":1}},{"line":288,"address":[3584309],"length":1,"stats":{"Line":2}},{"line":293,"address":[3584608,3587548,3586667],"length":1,"stats":{"Line":1}},{"line":299,"address":[6061061],"length":1,"stats":{"Line":1}},{"line":302,"address":[5343206,5343134],"length":1,"stats":{"Line":2}},{"line":303,"address":[3584880,3584951],"length":1,"stats":{"Line":2}},{"line":305,"address":[5343441,5345371,5343370],"length":1,"stats":{"Line":3}},{"line":306,"address":[5343549,5343577,5343447,5343698],"length":1,"stats":{"Line":0}},{"line":312,"address":[5796531],"length":1,"stats":{"Line":0}},{"line":314,"address":[5680041,5679930,5680176],"length":1,"stats":{"Line":0}},{"line":315,"address":[6062284,6062172],"length":1,"stats":{"Line":0}},{"line":316,"address":[5344429],"length":1,"stats":{"Line":0}},{"line":317,"address":[5512703],"length":1,"stats":{"Line":0}},{"line":319,"address":[5680615,5680710],"length":1,"stats":{"Line":0}},{"line":320,"address":[5344696,5344781],"length":1,"stats":{"Line":0}},{"line":322,"address":[5680845],"length":1,"stats":{"Line":0}},{"line":323,"address":[6062816],"length":1,"stats":{"Line":0}},{"line":327,"address":[3289064],"length":1,"stats":{"Line":0}},{"line":333,"address":[5343532,5345838,5345057,5345232],"length":1,"stats":{"Line":2}},{"line":336,"address":[5681856,5681408,5680321],"length":1,"stats":{"Line":2}},{"line":338,"address":[3289675],"length":1,"stats":{"Line":1}},{"line":339,"address":[3587207],"length":1,"stats":{"Line":1}},{"line":347,"address":[5515741,5514160,5515881],"length":1,"stats":{"Line":1}},{"line":348,"address":[3587653],"length":1,"stats":{"Line":1}},{"line":349,"address":[3290188,3290119],"length":1,"stats":{"Line":2}},{"line":350,"address":[6064235,6064166],"length":1,"stats":{"Line":2}},{"line":352,"address":[6064282,6064347,6064471],"length":1,"stats":{"Line":3}},{"line":353,"address":[3588362,3588179,3588486,3589281],"length":1,"stats":{"Line":4}},{"line":354,"address":[3290992,3291517,3290963,3291075],"length":1,"stats":{"Line":4}},{"line":355,"address":[3291179,3291239,3291258],"length":1,"stats":{"Line":2}},{"line":356,"address":[5347370],"length":1,"stats":{"Line":1}},{"line":360,"address":[5799601],"length":1,"stats":{"Line":1}},{"line":364,"address":[5801279,5800704,5801273],"length":1,"stats":{"Line":1}},{"line":366,"address":[3589387],"length":1,"stats":{"Line":1}},{"line":369,"address":[3292018,3291962],"length":1,"stats":{"Line":2}},{"line":371,"address":[3589659],"length":1,"stats":{"Line":1}},{"line":373,"address":[3589747],"length":1,"stats":{"Line":1}},{"line":374,"address":[3589696],"length":1,"stats":{"Line":1}},{"line":377,"address":[3292101],"length":1,"stats":{"Line":1}},{"line":387,"address":[3592155,3592244,3589936],"length":1,"stats":{"Line":1}},{"line":388,"address":[3589979],"length":1,"stats":{"Line":1}},{"line":391,"address":[3292464,3292392],"length":1,"stats":{"Line":2}},{"line":392,"address":[5348528,5348603],"length":1,"stats":{"Line":2}},{"line":394,"address":[5801628,5801699],"length":1,"stats":{"Line":2}},{"line":395,"address":[5348845,5348921,5348758],"length":1,"stats":{"Line":3}},{"line":397,"address":[3590843,3590467,3590978],"length":1,"stats":{"Line":3}},{"line":398,"address":[5685454,5686013,5686614,5686137],"length":1,"stats":{"Line":4}},{"line":399,"address":[3591802,3591831,3591904],"length":1,"stats":{"Line":3}},{"line":400,"address":[5518704,5518616],"length":1,"stats":{"Line":2}},{"line":405,"address":[5517829,5517671],"length":1,"stats":{"Line":2}},{"line":406,"address":[5517728],"length":1,"stats":{"Line":1}},{"line":413,"address":[5688875,5688964,5686704],"length":1,"stats":{"Line":1}},{"line":414,"address":[5350715],"length":1,"stats":{"Line":1}},{"line":417,"address":[6068804,6068732],"length":1,"stats":{"Line":2}},{"line":418,"address":[5519147,5519072],"length":1,"stats":{"Line":2}},{"line":420,"address":[5519196,5519267],"length":1,"stats":{"Line":2}},{"line":421,"address":[5351197,5351110,5351273,5351379],"length":1,"stats":{"Line":3}},{"line":426,"address":[5687235,5687746,5687611],"length":1,"stats":{"Line":3}},{"line":427,"address":[5520649,5519966,5520525,5521078],"length":1,"stats":{"Line":4}},{"line":428,"address":[5520832,5520730,5520759],"length":1,"stats":{"Line":3}},{"line":429,"address":[3296688,3296604],"length":1,"stats":{"Line":2}},{"line":434,"address":[3295715,3295873],"length":1,"stats":{"Line":2}},{"line":435,"address":[3593504],"length":1,"stats":{"Line":1}},{"line":439,"address":[5807384,5807319,5805952],"length":1,"stats":{"Line":1}},{"line":441,"address":[5805995],"length":1,"stats":{"Line":1}},{"line":444,"address":[5689338,5689266],"length":1,"stats":{"Line":2}},{"line":445,"address":[5806470,5806331,5806616,5806402],"length":1,"stats":{"Line":3}},{"line":448,"address":[6393232,6393249],"length":1,"stats":{"Line":2}},{"line":449,"address":[5807632],"length":1,"stats":{"Line":0}},{"line":450,"address":[5631614],"length":1,"stats":{"Line":0}},{"line":454,"address":[5689838],"length":1,"stats":{"Line":1}},{"line":457,"address":[5806814],"length":1,"stats":{"Line":1}},{"line":460,"address":[5806834],"length":1,"stats":{"Line":1}},{"line":461,"address":[5806859],"length":1,"stats":{"Line":1}},{"line":463,"address":[5354041],"length":1,"stats":{"Line":1}},{"line":464,"address":[5522135],"length":1,"stats":{"Line":1}},{"line":465,"address":[6071945],"length":1,"stats":{"Line":1}},{"line":468,"address":[3595625],"length":1,"stats":{"Line":1}},{"line":474,"address":[5355650,5355585,5354448],"length":1,"stats":{"Line":1}},{"line":476,"address":[6072459],"length":1,"stats":{"Line":1}},{"line":479,"address":[5354706,5354778],"length":1,"stats":{"Line":2}},{"line":480,"address":[5354827,5354898,5354966,5355112],"length":1,"stats":{"Line":3}},{"line":483,"address":[5631696,5631713],"length":1,"stats":{"Line":2}},{"line":484,"address":[6132656],"length":1,"stats":{"Line":0}},{"line":485,"address":[6132670],"length":1,"stats":{"Line":0}},{"line":489,"address":[5355278],"length":1,"stats":{"Line":1}},{"line":491,"address":[5808359],"length":1,"stats":{"Line":1}},{"line":492,"address":[5355305],"length":1,"stats":{"Line":1}},{"line":493,"address":[5808315],"length":1,"stats":{"Line":1}},{"line":495,"address":[5355371],"length":1,"stats":{"Line":1}},{"line":500,"address":[5809403,5809366,5808656],"length":1,"stats":{"Line":1}},{"line":502,"address":[5355718],"length":1,"stats":{"Line":1}},{"line":503,"address":[5691877,5691812,5691945],"length":1,"stats":{"Line":3}},{"line":504,"address":[3597589,3597640],"length":1,"stats":{"Line":0}},{"line":505,"address":[5809122],"length":1,"stats":{"Line":0}},{"line":506,"address":[5692291,5692232],"length":1,"stats":{"Line":0}},{"line":507,"address":[3597886],"length":1,"stats":{"Line":0}},{"line":511,"address":[5692433],"length":1,"stats":{"Line":1}},{"line":515,"address":[5525350,5524640,5525387],"length":1,"stats":{"Line":1}},{"line":517,"address":[6074454],"length":1,"stats":{"Line":1}},{"line":518,"address":[3598164,3598297,3598229],"length":1,"stats":{"Line":3}},{"line":519,"address":[5356741,5356792],"length":1,"stats":{"Line":0}},{"line":520,"address":[5692946],"length":1,"stats":{"Line":0}},{"line":521,"address":[5356968,5357027],"length":1,"stats":{"Line":0}},{"line":522,"address":[3300842],"length":1,"stats":{"Line":0}},{"line":526,"address":[5525361],"length":1,"stats":{"Line":1}},{"line":532,"address":[5357894,5357856,5357216],"length":1,"stats":{"Line":1}},{"line":533,"address":[3598879],"length":1,"stats":{"Line":1}},{"line":534,"address":[5810301,5810434,5810366,5810575],"length":1,"stats":{"Line":6}},{"line":537,"address":[3289168,3289185],"length":1,"stats":{"Line":2}},{"line":538,"address":[3599033,3599186,3599478,3599302],"length":1,"stats":{"Line":12}},{"line":539,"address":[3599366],"length":1,"stats":{"Line":1}},{"line":543,"address":[5358792,5357920,5358752],"length":1,"stats":{"Line":1}},{"line":544,"address":[5357948],"length":1,"stats":{"Line":1}},{"line":545,"address":[5358010],"length":1,"stats":{"Line":2}},{"line":547,"address":[6076122,6075989,6076054],"length":1,"stats":{"Line":6}},{"line":548,"address":[5694295,5694246],"length":1,"stats":{"Line":3}},{"line":550,"address":[5694518],"length":1,"stats":{"Line":1}},{"line":551,"address":[5526942,5526877,5526834],"length":1,"stats":{"Line":5}},{"line":552,"address":[5358743],"length":1,"stats":{"Line":2}},{"line":556,"address":[5694790],"length":1,"stats":{"Line":2}},{"line":560,"address":[3303877,3304026,3302576],"length":1,"stats":{"Line":2}},{"line":565,"address":[3600482],"length":1,"stats":{"Line":1}},{"line":567,"address":[5358936,5359370,5359069,5359001],"length":1,"stats":{"Line":5}},{"line":569,"address":[6077101],"length":1,"stats":{"Line":1}},{"line":576,"address":[5359241],"length":1,"stats":{"Line":1}},{"line":577,"address":[6077217,6078165,6077353],"length":1,"stats":{"Line":6}},{"line":578,"address":[5527677,5527734,5527807],"length":1,"stats":{"Line":6}},{"line":579,"address":[3303395,3303474],"length":1,"stats":{"Line":3}},{"line":580,"address":[5695968],"length":1,"stats":{"Line":2}},{"line":587,"address":[3303280,3303784],"length":1,"stats":{"Line":4}},{"line":589,"address":[6078018],"length":1,"stats":{"Line":2}},{"line":592,"address":[5812259],"length":1,"stats":{"Line":2}},{"line":597,"address":[5814103,5813280,5814097],"length":1,"stats":{"Line":2}},{"line":599,"address":[5360327],"length":1,"stats":{"Line":2}},{"line":600,"address":[6078361,6078444],"length":1,"stats":{"Line":4}},{"line":601,"address":[3304356,3304305],"length":1,"stats":{"Line":0}},{"line":602,"address":[3574784,3574797],"length":1,"stats":{"Line":0}},{"line":603,"address":[3602482,3602417],"length":1,"stats":{"Line":0}},{"line":604,"address":[3602565],"length":1,"stats":{"Line":0}},{"line":606,"address":[5813815,5813969],"length":1,"stats":{"Line":0}},{"line":607,"address":[3602692],"length":1,"stats":{"Line":0}},{"line":610,"address":[5528773],"length":1,"stats":{"Line":2}},{"line":618,"address":[5697184],"length":1,"stats":{"Line":1}},{"line":620,"address":[3602788],"length":1,"stats":{"Line":1}},{"line":623,"address":[3604870,3604876,3602816],"length":1,"stats":{"Line":1}},{"line":625,"address":[5529460],"length":1,"stats":{"Line":3}},{"line":626,"address":[5697388,5697456],"length":1,"stats":{"Line":6}},{"line":629,"address":[5814644,5814449,5814520],"length":1,"stats":{"Line":9}},{"line":630,"address":[6079696,6079996],"length":1,"stats":{"Line":6}},{"line":631,"address":[5362259],"length":1,"stats":{"Line":1}},{"line":632,"address":[3603926],"length":1,"stats":{"Line":1}},{"line":633,"address":[5698567,5698461],"length":1,"stats":{"Line":3}},{"line":634,"address":[5698676,5698627],"length":1,"stats":{"Line":3}},{"line":635,"address":[3604483],"length":1,"stats":{"Line":2}},{"line":636,"address":[3306727,3306764],"length":1,"stats":{"Line":2}},{"line":637,"address":[6081098],"length":1,"stats":{"Line":2}},{"line":644,"address":[5697809],"length":1,"stats":{"Line":0}},{"line":649,"address":[6081248],"length":1,"stats":{"Line":0}},{"line":651,"address":[5531492],"length":1,"stats":{"Line":0}},{"line":654,"address":[5533580,5531520,5533574],"length":1,"stats":{"Line":0}},{"line":656,"address":[5816372],"length":1,"stats":{"Line":0}},{"line":657,"address":[6081452,6081520],"length":1,"stats":{"Line":0}},{"line":660,"address":[6081569,6081764,6081640],"length":1,"stats":{"Line":0}},{"line":661,"address":[3307856,3307540],"length":1,"stats":{"Line":0}},{"line":662,"address":[3606003],"length":1,"stats":{"Line":0}},{"line":663,"address":[3606054],"length":1,"stats":{"Line":0}},{"line":664,"address":[5700695,5700589],"length":1,"stats":{"Line":0}},{"line":665,"address":[5700804,5700755],"length":1,"stats":{"Line":0}},{"line":666,"address":[6082963],"length":1,"stats":{"Line":0}},{"line":667,"address":[6083119,6083160],"length":1,"stats":{"Line":0}},{"line":668,"address":[6083226],"length":1,"stats":{"Line":0}},{"line":675,"address":[6081873],"length":1,"stats":{"Line":0}},{"line":680,"address":[3607024],"length":1,"stats":{"Line":2}},{"line":684,"address":[5365432],"length":1,"stats":{"Line":1}},{"line":685,"address":[6083732,6083426],"length":1,"stats":{"Line":3}},{"line":686,"address":[3607253,3607154],"length":1,"stats":{"Line":3}},{"line":687,"address":[6083638],"length":1,"stats":{"Line":2}},{"line":688,"address":[5533965],"length":1,"stats":{"Line":1}},{"line":690,"address":[5365731],"length":1,"stats":{"Line":1}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[5701657],"length":1,"stats":{"Line":0}},{"line":699,"address":[3311990,3312071,3309488],"length":1,"stats":{"Line":1}},{"line":700,"address":[5818853],"length":1,"stats":{"Line":1}},{"line":703,"address":[3607542,3607614],"length":1,"stats":{"Line":4}},{"line":704,"address":[6084010,6084085],"length":1,"stats":{"Line":4}},{"line":706,"address":[6084134,6084205],"length":1,"stats":{"Line":4}},{"line":707,"address":[6084403,6084240,6084327],"length":1,"stats":{"Line":6}},{"line":709,"address":[5702397,5702908,5702773],"length":1,"stats":{"Line":4}},{"line":710,"address":[6086005,6086402,6085881,6084904],"length":1,"stats":{"Line":5}},{"line":711,"address":[5821196,5821123,5821094],"length":1,"stats":{"Line":4}},{"line":712,"address":[6086244,6086332],"length":1,"stats":{"Line":4}},{"line":717,"address":[5367084,5366993],"length":1,"stats":{"Line":2}},{"line":719,"address":[5535622,5535247],"length":1,"stats":{"Line":3}},{"line":721,"address":[5367670],"length":1,"stats":{"Line":2}},{"line":722,"address":[3609246],"length":1,"stats":{"Line":2}},{"line":730,"address":[5538366,5536704,5538077],"length":1,"stats":{"Line":2}},{"line":732,"address":[5821531],"length":1,"stats":{"Line":2}},{"line":733,"address":[3312769,3312289,3312456,3312551,3312224],"length":1,"stats":{"Line":8}},{"line":736,"address":[3610377,3610547],"length":1,"stats":{"Line":2}},{"line":743,"address":[5369363],"length":1,"stats":{"Line":2}},{"line":744,"address":[3611296,3611198,3611059,3611130],"length":1,"stats":{"Line":6}},{"line":745,"address":[5705717,5705674],"length":1,"stats":{"Line":3}},{"line":746,"address":[3313292,3313368],"length":1,"stats":{"Line":2}},{"line":749,"address":[5537861],"length":1,"stats":{"Line":0}},{"line":753,"address":[5705928],"length":1,"stats":{"Line":1}},{"line":755,"address":[3313527],"length":1,"stats":{"Line":2}},{"line":756,"address":[5369908],"length":1,"stats":{"Line":1}},{"line":757,"address":[6087916],"length":1,"stats":{"Line":2}},{"line":763,"address":[5706688,5706694,5706224],"length":1,"stats":{"Line":1}},{"line":765,"address":[5370223],"length":1,"stats":{"Line":1}},{"line":766,"address":[6088231,6088307,6088603],"length":1,"stats":{"Line":2}},{"line":771,"address":[5370688],"length":1,"stats":{"Line":0}},{"line":772,"address":[3612305],"length":1,"stats":{"Line":0}}],"covered":257,"coverable":325},{"path":["/","home","imalison","Projects","lastfm-edit","src","retry.rs"],"content":"use crate::types::{LastFmError, RetryConfig, RetryResult};\nuse crate::Result;\nuse std::future::Future;\nuse std::time::{Instant, SystemTime, UNIX_EPOCH};\n\n/// Execute an async operation with retry logic for rate limiting\n///\n/// This function handles the common pattern of retrying operations that may fail\n/// due to rate limiting, with exponential backoff and configurable limits.\n///\n/// # Arguments\n/// * `config` - Retry configuration\n/// * `operation_name` - Name of the operation for logging\n/// * `operation` - Async function that returns a Result\n/// * `on_rate_limit` - Callback for rate limit events (delay in seconds, timestamp)\n/// * `on_rate_limit_end` - Optional callback for when rate limiting ends (total duration in seconds)\n///\n/// # Returns\n/// A `RetryResult` containing the successful result and retry statistics\npub async fn retry_with_backoff\u003cT, F, Fut, OnRateLimit, OnRateLimitEnd\u003e(\n    config: RetryConfig,\n    operation_name: \u0026str,\n    mut operation: F,\n    mut on_rate_limit: OnRateLimit,\n    mut on_rate_limit_end: OnRateLimitEnd,\n) -\u003e Result\u003cRetryResult\u003cT\u003e\u003e\nwhere\n    F: FnMut() -\u003e Fut,\n    Fut: Future\u003cOutput = Result\u003cT\u003e\u003e,\n    OnRateLimit: FnMut(u64, u64, \u0026str),\n    OnRateLimitEnd: FnMut(u64, \u0026str),\n{\n    let mut retries = 0;\n    let mut total_retry_time = 0;\n    let mut rate_limit_start_time: Option\u003cInstant\u003e = None;\n\n    loop {\n        match operation().await {\n            Ok(result) =\u003e {\n                // If we had rate limiting and now succeeded, emit rate limit end event\n                if let Some(start_time) = rate_limit_start_time {\n                    let total_duration = start_time.elapsed().as_secs();\n                    on_rate_limit_end(total_duration, operation_name);\n                }\n\n                return Ok(RetryResult {\n                    result,\n                    attempts_made: retries,\n                    total_retry_time,\n                });\n            }\n            Err(LastFmError::RateLimit { retry_after }) =\u003e {\n                // Track when rate limiting first occurs\n                if rate_limit_start_time.is_none() {\n                    rate_limit_start_time = Some(Instant::now());\n                }\n\n                if !config.enabled || retries \u003e= config.max_retries {\n                    if !config.enabled {\n                        log::debug!(\"Retries disabled for {operation_name} operation\");\n                    } else {\n                        log::warn!(\n                            \"Max retries ({}) exceeded for {operation_name} operation\",\n                            config.max_retries\n                        );\n                    }\n                    return Err(LastFmError::RateLimit { retry_after });\n                }\n\n                // Calculate delay with exponential backoff\n                let base_backoff = config.base_delay * 2_u64.pow(retries);\n                let delay = std::cmp::min(\n                    std::cmp::min(retry_after + base_backoff, config.max_delay),\n                    retry_after + (retries as u64 * 30), // Legacy backoff for compatibility\n                );\n\n                log::info!(\n                    \"{} rate limited. Waiting {} seconds before retry {} of {}\",\n                    operation_name,\n                    delay,\n                    retries + 1,\n                    config.max_retries\n                );\n\n                // Notify caller about rate limit\n                let timestamp = SystemTime::now()\n                    .duration_since(UNIX_EPOCH)\n                    .unwrap_or_default()\n                    .as_secs();\n                on_rate_limit(delay, timestamp, operation_name);\n\n                tokio::time::sleep(std::time::Duration::from_secs(delay)).await;\n                retries += 1;\n                total_retry_time += delay;\n            }\n            Err(other_error) =\u003e {\n                return Err(other_error);\n            }\n        }\n    }\n}\n\n/// Simplified retry function for operations that don't need custom rate limit handling\npub async fn retry_operation\u003cT, F, Fut\u003e(\n    config: RetryConfig,\n    operation_name: \u0026str,\n    operation: F,\n) -\u003e Result\u003cRetryResult\u003cT\u003e\u003e\nwhere\n    F: FnMut() -\u003e Fut,\n    Fut: Future\u003cOutput = Result\u003cT\u003e\u003e,\n{\n    retry_with_backoff(\n        config,\n        operation_name,\n        operation,\n        |delay, timestamp, op_name| {\n            log::debug!(\n                \"Rate limited during {op_name}: waiting {delay} seconds (at timestamp {timestamp})\"\n            );\n        },\n        |duration, op_name| {\n            log::debug!(\"Rate limiting ended for {op_name} after {duration} seconds\");\n        },\n    )\n    .await\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::sync::atomic::{AtomicU32, Ordering};\n    use std::sync::Arc;\n\n    #[tokio::test]\n    async fn test_successful_operation() {\n        let config = RetryConfig {\n            max_retries: 3,\n            base_delay: 1,\n            max_delay: 60,\n            enabled: true,\n        };\n\n        let result = retry_operation(config, \"test\", || async { Ok::\u003ci32, LastFmError\u003e(42) }).await;\n\n        assert!(result.is_ok());\n        let retry_result = result.unwrap();\n        assert_eq!(retry_result.result, 42);\n        assert_eq!(retry_result.attempts_made, 0);\n        assert_eq!(retry_result.total_retry_time, 0);\n    }\n\n    #[tokio::test]\n    async fn test_retry_on_rate_limit() {\n        let config = RetryConfig {\n            max_retries: 2,\n            base_delay: 1,\n            max_delay: 60,\n            enabled: true,\n        };\n\n        let call_count = Arc::new(AtomicU32::new(0));\n        let call_count_clone = call_count.clone();\n\n        let result = retry_operation(config, \"test\", move || {\n            let count = call_count_clone.fetch_add(1, Ordering::SeqCst);\n            async move {\n                if count \u003c 2 {\n                    Err(LastFmError::RateLimit { retry_after: 1 })\n                } else {\n                    Ok::\u003ci32, LastFmError\u003e(42)\n                }\n            }\n        })\n        .await;\n\n        assert!(result.is_ok());\n        let retry_result = result.unwrap();\n        assert_eq!(retry_result.result, 42);\n        assert_eq!(retry_result.attempts_made, 2);\n        assert!(retry_result.total_retry_time \u003e= 2); // At least 2 seconds of delay\n    }\n\n    #[tokio::test]\n    async fn test_max_retries_exceeded() {\n        let config = RetryConfig {\n            max_retries: 1,\n            base_delay: 1,\n            max_delay: 60,\n            enabled: true,\n        };\n\n        let result = retry_operation(config, \"test\", || async {\n            Err::\u003ci32, LastFmError\u003e(LastFmError::RateLimit { retry_after: 1 })\n        })\n        .await;\n\n        assert!(result.is_err());\n        match result.unwrap_err() {\n            LastFmError::RateLimit { .. } =\u003e {} // Expected\n            other =\u003e panic!(\"Expected rate limit error, got: {other:?}\"),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_retries_disabled() {\n        let config = RetryConfig::disabled();\n\n        let result = retry_operation(config, \"test\", || async {\n            Err::\u003ci32, LastFmError\u003e(LastFmError::RateLimit { retry_after: 1 })\n        })\n        .await;\n\n        assert!(result.is_err());\n        match result.unwrap_err() {\n            LastFmError::RateLimit { .. } =\u003e {} // Expected - should fail immediately\n            other =\u003e panic!(\"Expected rate limit error, got: {other:?}\"),\n        }\n    }\n}\n","traces":[{"line":20,"address":[5996416,5996752,5996608],"length":1,"stats":{"Line":9}},{"line":33,"address":[5985338,5994797,5989967],"length":1,"stats":{"Line":8}},{"line":34,"address":[3394666,3385452,3412924,3408428,3399228,3390033,3403903],"length":1,"stats":{"Line":12}},{"line":35,"address":[6006754,6001924,5997295],"length":1,"stats":{"Line":8}},{"line":37,"address":[5985390,5986039,5990683,5994852,5990019,5995503],"length":1,"stats":{"Line":15}},{"line":38,"address":[6269138,6260262,6264906,6264249,6260327,6264221,6264309,6269054,6264971,6259620,6259680,6259592,6269082,6269791,6269726],"length":1,"stats":{"Line":32}},{"line":39,"address":[5938448,5928981,5933665],"length":1,"stats":{"Line":8}},{"line":41,"address":[5883266,5878576,5888043],"length":1,"stats":{"Line":7}},{"line":42,"address":[5934015,5938737,5929261,5938548,5933762,5929072],"length":1,"stats":{"Line":4}},{"line":43,"address":[5934069,5929315,5938791],"length":1,"stats":{"Line":2}},{"line":46,"address":[5986633,5996109,5991357],"length":1,"stats":{"Line":6}},{"line":47,"address":[3759015],"length":1,"stats":{"Line":3}},{"line":48,"address":[5991313,5996080,5986604],"length":1,"stats":{"Line":7}},{"line":49,"address":[5933846,5938606,5929130],"length":1,"stats":{"Line":8}},{"line":52,"address":[],"length":0,"stats":{"Line":4}},{"line":54,"address":[5996624,5996741,5986961,5987251,5991724,5991928,5987140,5992039,5996441],"length":1,"stats":{"Line":12}},{"line":55,"address":[6266129,6261341,6270825],"length":1,"stats":{"Line":4}},{"line":58,"address":[],"length":0,"stats":{"Line":7}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[6000642,6010253,6010059,6000551,6005334,6005540,6000745,6005425,6010150],"length":1,"stats":{"Line":3}},{"line":62,"address":[6272789,6272357,6262849,6263278,6268069,6267632],"length":1,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[3765972,3761247,3756464],"length":1,"stats":{"Line":2}},{"line":71,"address":[5884177,5884297,5879389,5888879,5889002,5879509],"length":1,"stats":{"Line":3}},{"line":73,"address":[5929923,5934758,5929970,5934711,5939416,5939463],"length":1,"stats":{"Line":6}},{"line":74,"address":[3755238,3760173,3764881,3760026,3764734,3755385],"length":1,"stats":{"Line":3}},{"line":77,"address":[6271369,6262125,6262173,6266661,6266909,6266957,6271672,6266745,6271453,6261873,6271624,6261957],"length":1,"stats":{"Line":5}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":3}},{"line":92,"address":[3134936,3132504,3132984],"length":1,"stats":{"Line":9}},{"line":93,"address":[3758272,3758173,3762999,3753639,3763098,3753540],"length":1,"stats":{"Line":3}},{"line":94,"address":[5933009,5937910,5937835,5937959,5928451,5928376,5933136,5928499,5933084],"length":1,"stats":{"Line":6}},{"line":96,"address":[5986994,5991757,5996477],"length":1,"stats":{"Line":0}},{"line":97,"address":[6003760,6008468,5998984],"length":1,"stats":{"Line":0}},{"line":104,"address":[3417200,3417328,3417392,3417264],"length":1,"stats":{"Line":4}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[3421072,3419920,3420688,3420304],"length":1,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":4}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":14}}],"covered":37,"coverable":51},{"path":["/","home","imalison","Projects","lastfm-edit","src","session_persistence.rs"],"content":"use crate::types::{LastFmEditSession, LastFmError};\nuse crate::Result;\nuse std::fs;\nuse std::path::PathBuf;\n\n/// Configurable session manager for storing session data in XDG directories.\n///\n/// This struct allows customization of the application prefix for session storage.\n/// Sessions are stored per-user in the format:\n/// `~/.local/share/{app_name}/users/{username}/session.json`\n#[derive(Clone, Debug)]\npub struct SessionManager {\n    app_name: String,\n}\n\nimpl SessionManager {\n    /// Create a new session manager with a custom application name.\n    ///\n    /// # Arguments\n    /// * `app_name` - The application name to use as the directory prefix\n    pub fn new(app_name: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            app_name: app_name.into(),\n        }\n    }\n\n    /// Get the session file path for a given username using the configured app name.\n    ///\n    /// Returns a path like: `~/.local/share/{app_name}/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns the path where the session should be stored, or an error if\n    /// the XDG data directory cannot be determined.\n    pub fn get_session_path(\u0026self, username: \u0026str) -\u003e Result\u003cPathBuf\u003e {\n        let data_dir = dirs::data_dir()\n            .ok_or_else(|| LastFmError::Http(\"Cannot determine XDG data directory\".to_string()))?;\n\n        let session_dir = data_dir.join(\u0026self.app_name).join(\"users\").join(username);\n\n        Ok(session_dir.join(\"session.json\"))\n    }\n\n    /// Save a session to the XDG data directory.\n    ///\n    /// This creates the necessary directory structure and saves the session\n    /// as JSON to `~/.local/share/{app_name}/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `session` - The session to save\n    ///\n    /// # Returns\n    /// Returns Ok(()) on success, or an error if the save fails.\n    pub fn save_session(\u0026self, session: \u0026LastFmEditSession) -\u003e Result\u003c()\u003e {\n        let session_path = self.get_session_path(\u0026session.username)?;\n\n        // Create parent directories if they don't exist\n        if let Some(parent) = session_path.parent() {\n            fs::create_dir_all(parent).map_err(|e| {\n                LastFmError::Http(format!(\"Failed to create session directory: {e}\"))\n            })?;\n        }\n\n        // Serialize session to JSON\n        let session_json = session\n            .to_json()\n            .map_err(|e| LastFmError::Http(format!(\"Failed to serialize session: {e}\")))?;\n\n        // Write to file\n        fs::write(\u0026session_path, session_json)\n            .map_err(|e| LastFmError::Http(format!(\"Failed to write session file: {e}\")))?;\n\n        log::debug!(\"Session saved to: {}\", session_path.display());\n        Ok(())\n    }\n\n    /// Load a session from the XDG data directory.\n    ///\n    /// Attempts to load a session from `~/.local/share/{app_name}/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns the loaded session on success, or an error if the file doesn't exist\n    /// or cannot be parsed.\n    pub fn load_session(\u0026self, username: \u0026str) -\u003e Result\u003cLastFmEditSession\u003e {\n        let session_path = self.get_session_path(username)?;\n\n        if !session_path.exists() {\n            return Err(LastFmError::Http(format!(\n                \"No saved session found for user: {username}\"\n            )));\n        }\n\n        // Read and parse session file\n        let session_json = fs::read_to_string(\u0026session_path)\n            .map_err(|e| LastFmError::Http(format!(\"Failed to read session file: {e}\")))?;\n\n        let session = LastFmEditSession::from_json(\u0026session_json)\n            .map_err(|e| LastFmError::Http(format!(\"Failed to parse session JSON: {e}\")))?;\n\n        log::debug!(\"Session loaded from: {}\", session_path.display());\n        Ok(session)\n    }\n\n    /// Check if a saved session exists for the given username.\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns true if a session file exists, false otherwise.\n    pub fn session_exists(\u0026self, username: \u0026str) -\u003e bool {\n        match self.get_session_path(username) {\n            Ok(path) =\u003e path.exists(),\n            Err(_) =\u003e false,\n        }\n    }\n\n    /// Remove a saved session for the given username.\n    ///\n    /// This deletes the session file from the XDG data directory.\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns Ok(()) on success, or an error if the deletion fails.\n    pub fn remove_session(\u0026self, username: \u0026str) -\u003e Result\u003c()\u003e {\n        let session_path = self.get_session_path(username)?;\n\n        if session_path.exists() {\n            fs::remove_file(\u0026session_path)\n                .map_err(|e| LastFmError::Http(format!(\"Failed to remove session file: {e}\")))?;\n            log::debug!(\"Session removed from: {}\", session_path.display());\n        }\n\n        Ok(())\n    }\n\n    /// List all usernames that have saved sessions.\n    ///\n    /// Scans the XDG data directory for session files and returns the usernames.\n    ///\n    /// # Returns\n    /// Returns a vector of usernames that have saved sessions.\n    pub fn list_saved_users(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        let data_dir = dirs::data_dir()\n            .ok_or_else(|| LastFmError::Http(\"Cannot determine XDG data directory\".to_string()))?;\n\n        let users_dir = data_dir.join(\u0026self.app_name).join(\"users\");\n\n        if !users_dir.exists() {\n            return Ok(Vec::new());\n        }\n\n        let mut users = Vec::new();\n        let entries = fs::read_dir(\u0026users_dir)\n            .map_err(|e| LastFmError::Http(format!(\"Failed to read users directory: {e}\")))?;\n\n        for entry in entries {\n            let entry = entry\n                .map_err(|e| LastFmError::Http(format!(\"Failed to read directory entry: {e}\")))?;\n\n            if entry.file_type().map(|t| t.is_dir()).unwrap_or(false) {\n                let session_file = entry.path().join(\"session.json\");\n                if session_file.exists() {\n                    if let Some(username) = entry.file_name().to_str() {\n                        users.push(username.to_string());\n                    }\n                }\n            }\n        }\n\n        Ok(users)\n    }\n\n    /// Get the application name used by this session manager.\n    pub fn app_name(\u0026self) -\u003e \u0026str {\n        \u0026self.app_name\n    }\n}\n\n/// Session persistence utilities for managing session data in XDG directories.\n///\n/// This module provides functionality to save and load Last.fm session data\n/// using the XDG Base Directory Specification. Sessions are stored per-user\n/// in the format: `~/.local/share/lastfm-edit/users/{username}/session.json`\n///\n/// # Deprecated\n/// Use [`SessionManager`] instead for more flexibility and customization.\npub struct SessionPersistence;\n\nimpl SessionPersistence {\n    /// Get the default session manager for lastfm-edit.\n    fn default_manager() -\u003e SessionManager {\n        SessionManager::new(\"lastfm-edit\")\n    }\n\n    /// Get the session file path for a given username using XDG directories.\n    ///\n    /// Returns a path like: `~/.local/share/lastfm-edit/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns the path where the session should be stored, or an error if\n    /// the XDG data directory cannot be determined.\n    pub fn get_session_path(username: \u0026str) -\u003e Result\u003cPathBuf\u003e {\n        Self::default_manager().get_session_path(username)\n    }\n\n    /// Save a session to the XDG data directory.\n    ///\n    /// This creates the necessary directory structure and saves the session\n    /// as JSON to `~/.local/share/lastfm-edit/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `session` - The session to save\n    ///\n    /// # Returns\n    /// Returns Ok(()) on success, or an error if the save fails.\n    pub fn save_session(session: \u0026LastFmEditSession) -\u003e Result\u003c()\u003e {\n        Self::default_manager().save_session(session)\n    }\n\n    /// Load a session from the XDG data directory.\n    ///\n    /// Attempts to load a session from `~/.local/share/lastfm-edit/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns the loaded session on success, or an error if the file doesn't exist\n    /// or cannot be parsed.\n    pub fn load_session(username: \u0026str) -\u003e Result\u003cLastFmEditSession\u003e {\n        Self::default_manager().load_session(username)\n    }\n\n    /// Check if a saved session exists for the given username.\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns true if a session file exists, false otherwise.\n    pub fn session_exists(username: \u0026str) -\u003e bool {\n        Self::default_manager().session_exists(username)\n    }\n\n    /// Remove a saved session for the given username.\n    ///\n    /// This deletes the session file from the XDG data directory.\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns Ok(()) on success, or an error if the deletion fails.\n    pub fn remove_session(username: \u0026str) -\u003e Result\u003c()\u003e {\n        Self::default_manager().remove_session(username)\n    }\n\n    /// List all usernames that have saved sessions.\n    ///\n    /// Scans the XDG data directory for session files and returns the usernames.\n    ///\n    /// # Returns\n    /// Returns a vector of usernames that have saved sessions.\n    pub fn list_saved_users() -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        Self::default_manager().list_saved_users()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_session_path_generation() {\n        let path = SessionPersistence::get_session_path(\"testuser\").unwrap();\n        assert!(path\n            .to_string_lossy()\n            .contains(\"lastfm-edit/users/testuser/session.json\"));\n    }\n\n    #[test]\n    fn test_session_exists_nonexistent() {\n        let fake_username = format!(\"nonexistent_user_{}\", std::process::id());\n        assert!(!SessionPersistence::session_exists(\u0026fake_username));\n    }\n}\n","traces":[{"line":21,"address":[6011664],"length":1,"stats":{"Line":3}},{"line":23,"address":[6011687],"length":1,"stats":{"Line":3}},{"line":37,"address":[6025408,6026285,6026291],"length":1,"stats":{"Line":2}},{"line":38,"address":[3171361,3171208],"length":1,"stats":{"Line":2}},{"line":39,"address":[5727875],"length":1,"stats":{"Line":0}},{"line":41,"address":[3171452,3171525],"length":1,"stats":{"Line":6}},{"line":43,"address":[3171888],"length":1,"stats":{"Line":3}},{"line":56,"address":[5730331,5730323,5728624],"length":1,"stats":{"Line":1}},{"line":57,"address":[6026364],"length":1,"stats":{"Line":1}},{"line":60,"address":[5636021,5635950],"length":1,"stats":{"Line":2}},{"line":61,"address":[3180480,3180721,3180715],"length":1,"stats":{"Line":2}},{"line":62,"address":[6011878,6011943],"length":1,"stats":{"Line":0}},{"line":67,"address":[5636462,5636152,5636340,5637321],"length":1,"stats":{"Line":2}},{"line":69,"address":[5510886,5510864],"length":1,"stats":{"Line":0}},{"line":72,"address":[6027369,6027251,6027966,6027483],"length":1,"stats":{"Line":2}},{"line":73,"address":[5700704,5700726],"length":1,"stats":{"Line":0}},{"line":75,"address":[5811974,5811880],"length":1,"stats":{"Line":2}},{"line":76,"address":[5811940],"length":1,"stats":{"Line":1}},{"line":89,"address":[5639353,5639386,5637344],"length":1,"stats":{"Line":1}},{"line":90,"address":[5812441],"length":1,"stats":{"Line":1}},{"line":92,"address":[3174013,3174084],"length":1,"stats":{"Line":2}},{"line":93,"address":[3293756,3293813],"length":1,"stats":{"Line":0}},{"line":99,"address":[3294177,3293783,3294058,3295413],"length":1,"stats":{"Line":2}},{"line":100,"address":[5638113],"length":1,"stats":{"Line":0}},{"line":102,"address":[3294496,3294278,3294349],"length":1,"stats":{"Line":2}},{"line":103,"address":[5731440],"length":1,"stats":{"Line":0}},{"line":105,"address":[3295011,3294717,3294807],"length":1,"stats":{"Line":3}},{"line":106,"address":[3294822],"length":1,"stats":{"Line":1}},{"line":116,"address":[3176031,3176037,3175760],"length":1,"stats":{"Line":2}},{"line":117,"address":[5460687],"length":1,"stats":{"Line":2}},{"line":118,"address":[5814541],"length":1,"stats":{"Line":2}},{"line":119,"address":[5814531],"length":1,"stats":{"Line":0}},{"line":132,"address":[3177049,3177055,3176096],"length":1,"stats":{"Line":1}},{"line":133,"address":[5461033],"length":1,"stats":{"Line":1}},{"line":135,"address":[5640010,5640078],"length":1,"stats":{"Line":2}},{"line":136,"address":[3296159,3296296],"length":1,"stats":{"Line":1}},{"line":137,"address":[5815288],"length":1,"stats":{"Line":0}},{"line":138,"address":[5461541],"length":1,"stats":{"Line":1}},{"line":141,"address":[5815160],"length":1,"stats":{"Line":1}},{"line":150,"address":[5815792,5818289,5818191],"length":1,"stats":{"Line":1}},{"line":151,"address":[3296807,3296973],"length":1,"stats":{"Line":1}},{"line":152,"address":[5733885],"length":1,"stats":{"Line":0}},{"line":154,"address":[6031727,6031818],"length":1,"stats":{"Line":2}},{"line":156,"address":[5734345],"length":1,"stats":{"Line":1}},{"line":157,"address":[6032073,6032119],"length":1,"stats":{"Line":0}},{"line":160,"address":[3297436],"length":1,"stats":{"Line":1}},{"line":161,"address":[3177912,3177845,3178010,3179509],"length":1,"stats":{"Line":2}},{"line":162,"address":[5641657],"length":1,"stats":{"Line":0}},{"line":164,"address":[5641771,5641865,5641950],"length":1,"stats":{"Line":3}},{"line":165,"address":[3298044,3298221,3298319],"length":1,"stats":{"Line":2}},{"line":166,"address":[5463503],"length":1,"stats":{"Line":0}},{"line":168,"address":[3178713,3178800],"length":1,"stats":{"Line":4}},{"line":169,"address":[5817623],"length":1,"stats":{"Line":1}},{"line":170,"address":[3179073],"length":1,"stats":{"Line":1}},{"line":171,"address":[5735960,5735854],"length":1,"stats":{"Line":2}},{"line":172,"address":[5736066,5736107],"length":1,"stats":{"Line":2}},{"line":178,"address":[3298101],"length":1,"stats":{"Line":1}},{"line":182,"address":[5736256],"length":1,"stats":{"Line":1}},{"line":183,"address":[3179557],"length":1,"stats":{"Line":1}},{"line":199,"address":[5643264],"length":1,"stats":{"Line":2}},{"line":200,"address":[5643272],"length":1,"stats":{"Line":2}},{"line":213,"address":[5643429,5643296,5643435],"length":1,"stats":{"Line":1}},{"line":214,"address":[3299372],"length":1,"stats":{"Line":1}},{"line":227,"address":[3299612,3299606,3299488],"length":1,"stats":{"Line":0}},{"line":228,"address":[6034178],"length":1,"stats":{"Line":0}},{"line":241,"address":[3179872,3180002,3179996],"length":1,"stats":{"Line":0}},{"line":242,"address":[5818700],"length":1,"stats":{"Line":0}},{"line":252,"address":[5465135,5465129,5465008],"length":1,"stats":{"Line":1}},{"line":253,"address":[5818849],"length":1,"stats":{"Line":1}},{"line":265,"address":[3300069,3300075,3299936],"length":1,"stats":{"Line":0}},{"line":266,"address":[3299980],"length":1,"stats":{"Line":0}},{"line":275,"address":[5819229,5819120,5819223],"length":1,"stats":{"Line":0}},{"line":276,"address":[3300120],"length":1,"stats":{"Line":0}}],"covered":52,"coverable":73},{"path":["/","home","imalison","Projects","lastfm-edit","src","trait.rs"],"content":"use crate::iterator::AsyncPaginatedIterator;\nuse crate::types::{\n    Album, Artist, ArtistPage, ClientEvent, ClientEventReceiver, EditResponse, ExactScrobbleEdit,\n    LastFmEditSession, ScrobbleEdit, Track,\n};\nuse crate::Result;\nuse async_trait::async_trait;\n\n/// Trait for Last.fm client operations that can be mocked for testing.\n///\n/// This trait abstracts the core functionality needed for Last.fm scrobble editing\n/// to enable easy mocking and testing. All methods that perform network operations or\n/// state changes are included to support comprehensive test coverage.\n///\n/// # Mocking Support\n///\n/// When the `mock` feature is enabled, this crate provides `MockLastFmEditClient`\n/// that implements this trait using the `mockall` library.\n///\n#[cfg_attr(feature = \"mock\", mockall::automock)]\n#[async_trait(?Send)]\npub trait LastFmEditClient {\n    // =============================================================================\n    // CORE EDITING METHODS - Most important functionality\n    // =============================================================================\n\n    /// Edit scrobbles by discovering and updating all matching instances.\n    ///\n    /// This is the main editing method that automatically discovers all scrobble instances\n    /// that match the provided criteria and applies the specified changes to each one.\n    ///\n    /// # How it works\n    ///\n    /// 1. **Discovery**: Analyzes the `ScrobbleEdit` to determine what to search for:\n    ///    - If `track_name_original` is specified: finds all album variations of that track\n    ///    - If only `album_name_original` is specified: finds all tracks in that album\n    ///    - If neither is specified: finds all tracks by that artist\n    ///\n    /// 2. **Enrichment**: For each discovered scrobble, extracts complete metadata\n    ///    including album artist information from the user's library\n    ///\n    /// 3. **Editing**: Applies the requested changes to each discovered instance\n    ///\n    /// # Arguments\n    ///\n    /// * `edit` - A `ScrobbleEdit` specifying what to find and how to change it\n    ///\n    /// # Returns\n    ///\n    /// Returns an `EditResponse` containing results for all edited scrobbles, including:\n    /// - Overall success status\n    /// - Individual results for each scrobble instance\n    /// - Detailed error messages if any edits fail\n    ///\n    /// # Errors\n    ///\n    /// Returns `LastFmError::Parse` if no matching scrobbles are found, or other errors\n    /// for network/authentication issues.\n    ///\n    /// # Example\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, ScrobbleEdit, Result};\n    /// # async fn example(client: \u0026dyn LastFmEditClient) -\u003e Result\u003c()\u003e {\n    /// // Change track name for all instances of a track\n    /// let edit = ScrobbleEdit::from_track_and_artist(\"Old Track Name\", \"Artist\")\n    ///     .with_track_name(\"New Track Name\");\n    ///\n    /// let response = client.edit_scrobble(\u0026edit).await?;\n    /// if response.success() {\n    ///     println!(\"Successfully edited {} scrobbles\", response.total_edits());\n    /// }\n    /// # Ok(())\n    /// # }\n    /// ```\n    async fn edit_scrobble(\u0026self, edit: \u0026ScrobbleEdit) -\u003e Result\u003cEditResponse\u003e;\n\n    /// Edit a single scrobble with complete information and retry logic.\n    ///\n    /// This method performs a single edit operation on a fully-specified scrobble.\n    /// Unlike [`edit_scrobble`], this method does not perform discovery, enrichment,\n    /// or multiple edits - it edits exactly one scrobble instance.\n    ///\n    /// # Key Differences from `edit_scrobble`\n    ///\n    /// - **No discovery**: Requires a fully-specified `ExactScrobbleEdit`\n    /// - **Single edit**: Only edits one scrobble instance\n    /// - **No enrichment**: All fields must be provided upfront\n    /// - **Retry logic**: Automatically retries on rate limiting\n    ///\n    /// # Arguments\n    ///\n    /// * `exact_edit` - A fully-specified edit with all required fields populated,\n    ///   including original metadata and timestamps\n    /// * `max_retries` - Maximum number of retry attempts for rate limiting.\n    ///   The method will wait with exponential backoff between retries.\n    ///\n    /// # Returns\n    ///\n    /// Returns an `EditResponse` with a single result indicating success or failure.\n    /// If max retries are exceeded due to rate limiting, returns a failed response\n    /// rather than an error.\n    ///\n    /// # Example\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, ExactScrobbleEdit, Result};\n    /// # async fn example(client: \u0026dyn LastFmEditClient) -\u003e Result\u003c()\u003e {\n    /// let exact_edit = ExactScrobbleEdit::new(\n    ///     \"Original Track\".to_string(),\n    ///     \"Original Album\".to_string(),\n    ///     \"Artist\".to_string(),\n    ///     \"Artist\".to_string(),\n    ///     \"New Track Name\".to_string(),\n    ///     \"Original Album\".to_string(),\n    ///     \"Artist\".to_string(),\n    ///     \"Artist\".to_string(),\n    ///     1640995200, // timestamp\n    ///     false\n    /// );\n    ///\n    /// let response = client.edit_scrobble_single(\u0026exact_edit, 3).await?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    async fn edit_scrobble_single(\n        \u0026self,\n        exact_edit: \u0026ExactScrobbleEdit,\n        max_retries: u32,\n    ) -\u003e Result\u003cEditResponse\u003e;\n\n    /// Delete a scrobble by its identifying information.\n    ///\n    /// This method deletes a specific scrobble from the user's library using the\n    /// artist name, track name, and timestamp to uniquely identify it.\n    ///\n    /// # Arguments\n    ///\n    /// * `artist_name` - The artist name of the scrobble to delete\n    /// * `track_name` - The track name of the scrobble to delete\n    /// * `timestamp` - The unix timestamp of the scrobble to delete\n    ///\n    /// # Returns\n    ///\n    /// Returns `true` if the deletion was successful, `false` otherwise.\n    async fn delete_scrobble(\n        \u0026self,\n        artist_name: \u0026str,\n        track_name: \u0026str,\n        timestamp: u64,\n    ) -\u003e Result\u003cbool\u003e;\n\n    /// Create an incremental discovery iterator for scrobble editing.\n    ///\n    /// This returns the appropriate discovery iterator based on what fields are specified\n    /// in the ScrobbleEdit. The iterator yields `ExactScrobbleEdit` results incrementally,\n    /// which helps avoid rate limiting issues when discovering many scrobbles.\n    ///\n    /// Returns a `Box\u003cdyn AsyncDiscoveryIterator\u003cExactScrobbleEdit\u003e\u003e` to handle the different\n    /// discovery strategies uniformly.\n    fn discover_scrobbles(\n        \u0026self,\n        edit: ScrobbleEdit,\n    ) -\u003e Box\u003cdyn crate::AsyncDiscoveryIterator\u003ccrate::ExactScrobbleEdit\u003e\u003e;\n\n    // =============================================================================\n    // ITERATOR METHODS - Core library browsing functionality\n    // =============================================================================\n\n    /// Create an iterator for browsing all artists in the user's library.\n    fn artists(\u0026self) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cArtist\u003e\u003e;\n\n    /// Create an iterator for browsing an artist's tracks from the user's library.\n    fn artist_tracks(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for browsing an artist's tracks directly using the paginated endpoint.\n    ///\n    /// This alternative approach uses\n    /// `/user/{username}/library/music/{artist}/+tracks` directly with\n    /// pagination, which is more efficient than the album-based approach since\n    /// it doesn't need to iterate through albums first. The downside of this\n    /// approach is that the tracks will not come with album information, which\n    /// will need to get looked up eventually in the process of making edits.\n    fn artist_tracks_direct(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for browsing an artist's albums from the user's library.\n    fn artist_albums(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cAlbum\u003e\u003e;\n\n    /// Create an iterator for browsing tracks from a specific album.\n    fn album_tracks(\n        \u0026self,\n        album_name: \u0026str,\n        artist_name: \u0026str,\n    ) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for browsing the user's recent tracks/scrobbles.\n    fn recent_tracks(\u0026self) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for browsing the user's recent tracks starting from a specific page.\n    fn recent_tracks_from_page(\u0026self, starting_page: u32)\n        -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for searching tracks in the user's library.\n    ///\n    /// This returns an iterator that uses Last.fm's library search functionality\n    /// to find tracks matching the provided query string. The iterator handles\n    /// pagination automatically.\n    ///\n    /// # Arguments\n    ///\n    /// * `query` - The search query (e.g., \"remaster\", \"live\", artist name, etc.)\n    ///\n    /// # Returns\n    ///\n    /// Returns a `SearchTracksIterator` for streaming search results.\n    fn search_tracks(\u0026self, query: \u0026str) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for searching albums in the user's library.\n    ///\n    /// This returns an iterator that uses Last.fm's library search functionality\n    /// to find albums matching the provided query string. The iterator handles\n    /// pagination automatically.\n    ///\n    /// # Arguments\n    ///\n    /// * `query` - The search query (e.g., \"remaster\", \"deluxe\", artist name, etc.)\n    ///\n    /// # Returns\n    ///\n    /// Returns a `SearchAlbumsIterator` for streaming search results.\n    fn search_albums(\u0026self, query: \u0026str) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cAlbum\u003e\u003e;\n\n    // =============================================================================\n    // SEARCH METHODS - Library search functionality\n    // =============================================================================\n\n    /// Get a single page of track search results from the user's library.\n    ///\n    /// This performs a search using Last.fm's library search functionality,\n    /// returning one page of tracks that match the provided query string.\n    /// For iterator-based access, use [`search_tracks`](Self::search_tracks) instead.\n    ///\n    /// # Arguments\n    ///\n    /// * `query` - The search query (e.g., \"remaster\", \"live\", artist name, etc.)\n    /// * `page` - The page number to retrieve (1-based)\n    ///\n    /// # Returns\n    ///\n    /// Returns a `TrackPage` containing the search results with pagination information.\n    async fn search_tracks_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003ccrate::TrackPage\u003e;\n\n    /// Get a single page of album search results from the user's library.\n    ///\n    /// This performs a search using Last.fm's library search functionality,\n    /// returning one page of albums that match the provided query string.\n    /// For iterator-based access, use [`search_albums`](Self::search_albums) instead.\n    ///\n    /// # Arguments\n    ///\n    /// * `query` - The search query (e.g., \"remaster\", \"deluxe\", artist name, etc.)\n    /// * `page` - The page number to retrieve (1-based)\n    ///\n    /// # Returns\n    ///\n    /// Returns an `AlbumPage` containing the search results with pagination information.\n    async fn search_albums_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003ccrate::AlbumPage\u003e;\n\n    // =============================================================================\n    // CORE DATA METHODS - Essential data access\n    // =============================================================================\n\n    /// Get the currently authenticated username.\n    fn username(\u0026self) -\u003e String;\n\n    /// Find the most recent scrobble for a specific track.\n    async fn find_recent_scrobble_for_track(\n        \u0026self,\n        track_name: \u0026str,\n        artist_name: \u0026str,\n        max_pages: u32,\n    ) -\u003e Result\u003cOption\u003cTrack\u003e\u003e;\n\n    /// Get a page of artists from the user's library.\n    async fn get_artists_page(\u0026self, page: u32) -\u003e Result\u003cArtistPage\u003e;\n\n    /// Get a page of tracks from the user's library for the specified artist.\n    async fn get_artist_tracks_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003ccrate::TrackPage\u003e;\n\n    /// Get a page of albums from the user's library for the specified artist.\n    async fn get_artist_albums_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003ccrate::AlbumPage\u003e;\n\n    /// Get a page of tracks from a specific album in the user's library.\n    async fn get_album_tracks_page(\n        \u0026self,\n        album_name: \u0026str,\n        artist_name: \u0026str,\n        page: u32,\n    ) -\u003e Result\u003ccrate::TrackPage\u003e;\n\n    /// Get a page of tracks from the user's recent listening history.\n    async fn get_recent_tracks_page(\u0026self, page: u32) -\u003e Result\u003ccrate::TrackPage\u003e;\n\n    // =============================================================================\n    // CONVENIENCE METHODS - Higher-level helpers and shortcuts\n    // =============================================================================\n\n    /// Discover all scrobble edit variations based on the provided ScrobbleEdit template.\n    ///\n    /// This method analyzes what fields are specified in the input ScrobbleEdit and discovers\n    /// all relevant scrobble instances that match the criteria:\n    /// - If track_name_original is specified: discovers all album variations of that track\n    /// - If only album_name_original is specified: discovers all tracks in that album\n    /// - If neither is specified: discovers all tracks by that artist\n    ///\n    /// Returns fully-specified ExactScrobbleEdit instances with all metadata populated\n    /// from the user's library, ready for editing operations.\n    async fn discover_scrobble_edit_variations(\n        \u0026self,\n        edit: \u0026ScrobbleEdit,\n    ) -\u003e Result\u003cVec\u003cExactScrobbleEdit\u003e\u003e {\n        // Use the incremental iterator and collect all results\n        let mut discovery_iterator = self.discover_scrobbles(edit.clone());\n        discovery_iterator.collect_all().await\n    }\n\n    /// Edit album metadata by updating scrobbles with new album name.\n    async fn edit_album(\n        \u0026self,\n        old_album_name: \u0026str,\n        new_album_name: \u0026str,\n        artist_name: \u0026str,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        log::debug!(\"Editing album '{old_album_name}' -\u003e '{new_album_name}' by '{artist_name}'\");\n\n        let edit = ScrobbleEdit::for_album(old_album_name, artist_name, artist_name)\n            .with_album_name(new_album_name);\n\n        self.edit_scrobble(\u0026edit).await\n    }\n\n    /// Edit artist metadata by updating scrobbles with new artist name.\n    ///\n    /// This edits ALL tracks from the artist that are found in recent scrobbles.\n    async fn edit_artist(\n        \u0026self,\n        old_artist_name: \u0026str,\n        new_artist_name: \u0026str,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        log::debug!(\"Editing artist '{old_artist_name}' -\u003e '{new_artist_name}'\");\n\n        let edit = ScrobbleEdit::for_artist(old_artist_name, new_artist_name);\n\n        self.edit_scrobble(\u0026edit).await\n    }\n\n    /// Edit artist metadata for a specific track only.\n    ///\n    /// This edits only the specified track if found in recent scrobbles.\n    async fn edit_artist_for_track(\n        \u0026self,\n        track_name: \u0026str,\n        old_artist_name: \u0026str,\n        new_artist_name: \u0026str,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        log::debug!(\"Editing artist for track '{track_name}' from '{old_artist_name}' -\u003e '{new_artist_name}'\");\n\n        let edit = ScrobbleEdit::from_track_and_artist(track_name, old_artist_name)\n            .with_artist_name(new_artist_name);\n\n        self.edit_scrobble(\u0026edit).await\n    }\n\n    /// Edit artist metadata for all tracks in a specific album.\n    ///\n    /// This edits ALL tracks from the specified album that are found in recent scrobbles.\n    async fn edit_artist_for_album(\n        \u0026self,\n        album_name: \u0026str,\n        old_artist_name: \u0026str,\n        new_artist_name: \u0026str,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        log::debug!(\"Editing artist for album '{album_name}' from '{old_artist_name}' -\u003e '{new_artist_name}'\");\n\n        let edit = ScrobbleEdit::for_album(album_name, old_artist_name, old_artist_name)\n            .with_artist_name(new_artist_name);\n\n        self.edit_scrobble(\u0026edit).await\n    }\n\n    // =============================================================================\n    // SESSION \u0026 EVENT MANAGEMENT - Authentication and monitoring\n    // =============================================================================\n\n    /// Extract the current session state for persistence.\n    ///\n    /// This allows you to save the authentication state and restore it later\n    /// without requiring the user to log in again.\n    ///\n    /// # Returns\n    ///\n    /// Returns a [`LastFmEditSession`] that can be serialized and saved.\n    fn get_session(\u0026self) -\u003e LastFmEditSession;\n\n    /// Subscribe to internal client events.\n    ///\n    /// Returns a broadcast receiver that can be used to listen to events like rate limiting.\n    /// Multiple subscribers can listen simultaneously.\n    ///\n    /// # Example\n    /// ```rust,no_run\n    /// use lastfm_edit::{LastFmEditClientImpl, LastFmEditSession, ClientEvent};\n    ///\n    /// let http_client = http_client::native::NativeClient::new();\n    /// let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let client = LastFmEditClientImpl::from_session(Box::new(http_client), test_session);\n    /// let mut events = client.subscribe();\n    ///\n    /// // Listen for events in a background task\n    /// tokio::spawn(async move {\n    ///     while let Ok(event) = events.recv().await {\n    ///         match event {\n    ///             ClientEvent::RequestStarted { request } =\u003e {\n    ///                 println!(\"Request started: {}\", request.short_description());\n    ///             }\n    ///             ClientEvent::RequestCompleted { request, status_code, duration_ms } =\u003e {\n    ///                 println!(\"Request completed: {} - {} ({} ms)\", request.short_description(), status_code, duration_ms);\n    ///             }\n    ///             ClientEvent::RateLimited { delay_seconds, .. } =\u003e {\n    ///                 println!(\"Rate limited! Waiting {} seconds\", delay_seconds);\n    ///             }\n    ///             ClientEvent::RateLimitEnded { total_rate_limit_duration_seconds, .. } =\u003e {\n    ///                 println!(\"Rate limiting ended after {} seconds\", total_rate_limit_duration_seconds);\n    ///             }\n    ///             ClientEvent::EditAttempted { edit, success, .. } =\u003e {\n    ///                 println!(\"Edit attempt: '{}' -\u003e '{}' - {}\",\n    ///                          edit.track_name_original, edit.track_name,\n    ///                          if success { \"Success\" } else { \"Failed\" });\n    ///             }\n    ///         }\n    ///     }\n    /// });\n    /// ```\n    fn subscribe(\u0026self) -\u003e ClientEventReceiver;\n\n    /// Get the latest client event without subscribing to future events.\n    ///\n    /// This returns the most recent event that occurred, or `None` if no events have occurred yet.\n    /// Unlike `subscribe()`, this provides instant access to the current state without waiting.\n    ///\n    /// # Example\n    /// ```rust,no_run\n    /// use lastfm_edit::{LastFmEditClientImpl, LastFmEditSession, ClientEvent};\n    ///\n    /// let http_client = http_client::native::NativeClient::new();\n    /// let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let client = LastFmEditClientImpl::from_session(Box::new(http_client), test_session);\n    ///\n    /// if let Some(ClientEvent::RateLimited { delay_seconds, .. }) = client.latest_event() {\n    ///     println!(\"Currently rate limited for {} seconds\", delay_seconds);\n    /// }\n    /// ```\n    fn latest_event(\u0026self) -\u003e Option\u003cClientEvent\u003e;\n\n    /// Validate if the current session is still working.\n    ///\n    /// This method makes a test request to a protected Last.fm settings page to verify\n    /// that the current session is still valid. If the session has expired or become\n    /// invalid, Last.fm will redirect to the login page.\n    ///\n    /// This is useful for checking session validity before attempting operations that\n    /// require authentication, especially after loading a previously saved session.\n    ///\n    /// # Returns\n    ///\n    /// Returns `true` if the session is valid and can be used for authenticated operations,\n    /// `false` if the session is invalid or expired.\n    async fn validate_session(\u0026self) -\u003e bool;\n}\n","traces":[{"line":323,"address":[],"length":0,"stats":{"Line":2}},{"line":324,"address":[5465924],"length":1,"stats":{"Line":3}},{"line":334,"address":[3785635,3785739],"length":1,"stats":{"Line":0}},{"line":336,"address":[5948199,5948619],"length":1,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[5949703],"length":1,"stats":{"Line":0}},{"line":354,"address":[3342807],"length":1,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[6386775,6387186],"length":1,"stats":{"Line":0}},{"line":369,"address":[2837645],"length":1,"stats":{"Line":0}},{"line":371,"address":[5464759],"length":1,"stats":{"Line":0}},{"line":383,"address":[6009243,6009139],"length":1,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[5953006],"length":1,"stats":{"Line":0}},{"line":388,"address":[3789728,3790730,3790535,3790620],"length":1,"stats":{"Line":0}}],"covered":2,"coverable":17},{"path":["/","home","imalison","Projects","lastfm-edit","src","types.rs"],"content":"//! Data types for Last.fm music metadata and operations.\n//!\n//! This module contains all the core data structures used throughout the crate,\n//! including track and album metadata, edit operations, error types, session state,\n//! configuration, and event handling.\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fmt;\nuse thiserror::Error;\nuse tokio::sync::{broadcast, watch};\n\n// ================================================================================================\n// TRACK AND ALBUM METADATA\n// ================================================================================================\n\n/// Represents a music track with associated metadata.\n///\n/// This structure contains track information as parsed from Last.fm pages,\n/// including play count and optional timestamp data for scrobbles.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]\npub struct Track {\n    /// The track name/title\n    pub name: String,\n    /// The artist name\n    pub artist: String,\n    /// Number of times this track has been played/scrobbled\n    pub playcount: u32,\n    /// Unix timestamp of when this track was scrobbled (if available)\n    ///\n    /// This field is populated when tracks are retrieved from recent scrobbles\n    /// or individual scrobble data, but may be `None` for aggregate track listings.\n    pub timestamp: Option\u003cu64\u003e,\n    /// The album name (if available)\n    ///\n    /// This field is populated when tracks are retrieved from recent scrobbles\n    /// where album information is available in the edit forms. May be `None`\n    /// for aggregate track listings or when album information is not available.\n    pub album: Option\u003cString\u003e,\n    /// The album artist name (if available and different from track artist)\n    ///\n    /// This field is populated when tracks are retrieved from recent scrobbles\n    /// where album artist information is available. May be `None` for tracks\n    /// where the album artist is the same as the track artist, or when this\n    /// information is not available.\n    pub album_artist: Option\u003cString\u003e,\n}\n\nimpl fmt::Display for Track {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let album_part = if let Some(ref album) = self.album {\n            format!(\" [{album}]\")\n        } else {\n            String::new()\n        };\n        write!(f, \"{} - {}{}\", self.artist, self.name, album_part)\n    }\n}\n\n/// Represents a paginated collection of tracks.\n///\n/// This structure is returned by track listing methods and provides\n/// information about the current page and pagination state.\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]\npub struct TrackPage {\n    /// The tracks on this page\n    pub tracks: Vec\u003cTrack\u003e,\n    /// Current page number (1-indexed)\n    pub page_number: u32,\n    /// Whether there are more pages available\n    pub has_next_page: bool,\n    /// Total number of pages, if known\n    ///\n    /// This may be `None` if the total page count cannot be determined\n    /// from the Last.fm response.\n    pub total_pages: Option\u003cu32\u003e,\n}\n\n/// Represents a music album with associated metadata.\n///\n/// This structure contains album information as parsed from Last.fm pages,\n/// including play count and optional timestamp data for scrobbles.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]\npub struct Album {\n    /// The album name/title\n    pub name: String,\n    /// The artist name\n    pub artist: String,\n    /// Number of times this album has been played/scrobbled\n    pub playcount: u32,\n    /// Unix timestamp of when this album was last scrobbled (if available)\n    ///\n    /// This field is populated when albums are retrieved from recent scrobbles\n    /// or individual scrobble data, but may be `None` for aggregate album listings.\n    pub timestamp: Option\u003cu64\u003e,\n}\n\nimpl fmt::Display for Album {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{} - {}\", self.artist, self.name)\n    }\n}\n\n/// Represents a paginated collection of albums.\n///\n/// This structure is returned by album listing methods and provides\n/// information about the current page and pagination state.\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]\npub struct AlbumPage {\n    /// The albums on this page\n    pub albums: Vec\u003cAlbum\u003e,\n    /// Current page number (1-indexed)\n    pub page_number: u32,\n    /// Whether there are more pages available\n    pub has_next_page: bool,\n    /// Total number of pages, if known\n    ///\n    /// This may be `None` if the total page count cannot be determined\n    /// from the Last.fm response.\n    pub total_pages: Option\u003cu32\u003e,\n}\n\nimpl Album {\n    /// Convert the Unix timestamp to a human-readable datetime.\n    ///\n    /// Returns `None` if no timestamp is available or if the timestamp is invalid.\n    #[must_use]\n    pub fn scrobbled_at(\u0026self) -\u003e Option\u003cDateTime\u003cUtc\u003e\u003e {\n        self.timestamp\n            .and_then(|ts| DateTime::from_timestamp(i64::try_from(ts).ok()?, 0))\n    }\n}\n\n/// Represents a music artist with associated metadata.\n///\n/// This structure contains artist information as parsed from Last.fm pages,\n/// including the total number of scrobbles for this artist.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]\npub struct Artist {\n    /// The artist name\n    pub name: String,\n    /// Number of times this artist has been played/scrobbled\n    pub playcount: u32,\n    /// Unix timestamp of when this artist was last scrobbled (if available)\n    ///\n    /// This field is populated when artists are retrieved from recent scrobbles\n    /// or individual scrobble data, but may be `None` for aggregate artist listings.\n    pub timestamp: Option\u003cu64\u003e,\n}\n\nimpl fmt::Display for Artist {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.name)\n    }\n}\n\n/// Represents a paginated collection of artists.\n///\n/// This structure is returned by artist listing methods and provides\n/// information about the current page and pagination state.\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]\npub struct ArtistPage {\n    /// The artists on this page\n    pub artists: Vec\u003cArtist\u003e,\n    /// Current page number (1-indexed)\n    pub page_number: u32,\n    /// Whether there are more pages available\n    pub has_next_page: bool,\n    /// Total number of pages, if known\n    ///\n    /// This may be `None` if the total page count cannot be determined\n    /// from the Last.fm response.\n    pub total_pages: Option\u003cu32\u003e,\n}\n\nimpl Artist {\n    /// Convert the Unix timestamp to a human-readable datetime.\n    ///\n    /// Returns `None` if no timestamp is available or if the timestamp is invalid.\n    #[must_use]\n    pub fn scrobbled_at(\u0026self) -\u003e Option\u003cDateTime\u003cUtc\u003e\u003e {\n        self.timestamp\n            .and_then(|ts| DateTime::from_timestamp(i64::try_from(ts).ok()?, 0))\n    }\n}\n\n// ================================================================================================\n// EDIT OPERATIONS\n// ================================================================================================\n\n/// Represents a scrobble edit operation.\n///\n/// This structure contains all the information needed to edit a specific scrobble\n/// on Last.fm, including both the original and new metadata values.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]\npub struct ScrobbleEdit {\n    /// Original track name as it appears in the scrobble (optional - if None, edits all tracks)\n    pub track_name_original: Option\u003cString\u003e,\n    /// Original album name as it appears in the scrobble (optional)\n    pub album_name_original: Option\u003cString\u003e,\n    /// Original artist name as it appears in the scrobble (required)\n    pub artist_name_original: String,\n    /// Original album artist name as it appears in the scrobble (optional)\n    pub album_artist_name_original: Option\u003cString\u003e,\n\n    /// New track name to set (optional - if None, keeps original track names)\n    pub track_name: Option\u003cString\u003e,\n    /// New album name to set (optional - if None, keeps original album names)\n    pub album_name: Option\u003cString\u003e,\n    /// New artist name to set\n    pub artist_name: String,\n    /// New album artist name to set (optional - if None, keeps original album artist names)\n    pub album_artist_name: Option\u003cString\u003e,\n\n    /// Unix timestamp of the scrobble to edit (optional)\n    ///\n    /// This identifies the specific scrobble instance to modify.\n    /// If None, the client will attempt to find a representative timestamp.\n    pub timestamp: Option\u003cu64\u003e,\n    /// Whether to edit all instances or just this specific scrobble\n    ///\n    /// When `true`, Last.fm will update all scrobbles with matching metadata.\n    /// When `false`, only this specific scrobble (identified by timestamp) is updated.\n    pub edit_all: bool,\n}\n\nimpl fmt::Display for ScrobbleEdit {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let mut changes = Vec::new();\n\n        // Check if artist is being changed\n        if self.artist_name != self.artist_name_original {\n            changes.push(format!(\n                \"Artist: {} → {}\",\n                self.artist_name_original, self.artist_name\n            ));\n        }\n\n        // Check if track name is being changed\n        if let Some(ref new_track) = self.track_name {\n            if let Some(ref original_track) = self.track_name_original {\n                if new_track != original_track {\n                    changes.push(format!(\"Track: {original_track} → {new_track}\"));\n                }\n            } else {\n                changes.push(format!(\"Track: → {new_track}\"));\n            }\n        }\n\n        // Check if album name is being changed\n        if let Some(ref new_album) = self.album_name {\n            match \u0026self.album_name_original {\n                Some(ref original_album) if new_album != original_album =\u003e {\n                    changes.push(format!(\"Album: {original_album} → {new_album}\"));\n                }\n                None =\u003e {\n                    changes.push(format!(\"Album: → {new_album}\"));\n                }\n                _ =\u003e {} // No change\n            }\n        }\n\n        // Check if album artist is being changed\n        if let Some(ref new_album_artist) = self.album_artist_name {\n            match \u0026self.album_artist_name_original {\n                Some(ref original_album_artist) if new_album_artist != original_album_artist =\u003e {\n                    changes.push(format!(\n                        \"Album Artist: {original_album_artist} → {new_album_artist}\"\n                    ));\n                }\n                None =\u003e {\n                    changes.push(format!(\"Album Artist: → {new_album_artist}\"));\n                }\n                _ =\u003e {} // No change\n            }\n        }\n\n        if changes.is_empty() {\n            write!(f, \"No changes\")\n        } else {\n            let scope = if self.edit_all {\n                \" (all instances)\"\n            } else {\n                \"\"\n            };\n            write!(f, \"{}{}\", changes.join(\", \"), scope)\n        }\n    }\n}\n\n/// Response from a single scrobble edit operation.\n///\n/// This structure contains the result of attempting to edit a specific scrobble instance,\n/// including success status and any error messages.\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]\npub struct SingleEditResponse {\n    /// Whether this individual edit operation was successful\n    pub success: bool,\n    /// Optional message describing the result or any errors\n    pub message: Option\u003cString\u003e,\n    /// Information about which album variation was edited\n    pub album_info: Option\u003cString\u003e,\n    /// The exact scrobble edit that was performed\n    pub exact_scrobble_edit: ExactScrobbleEdit,\n}\n\n/// Response from a scrobble edit operation that may affect multiple album variations.\n///\n/// When editing a track that appears on multiple albums, this response contains\n/// the results of all individual edit operations performed.\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]\npub struct EditResponse {\n    /// Results of individual edit operations\n    pub individual_results: Vec\u003cSingleEditResponse\u003e,\n}\n\n/// Internal representation of a scrobble edit with all fields fully specified.\n///\n/// This type is used internally by the client after enriching metadata from\n/// Last.fm. Unlike `ScrobbleEdit`, all fields are required and non-optional,\n/// ensuring we have complete information before performing edit operations.\n///\n/// This type represents a fully-specified scrobble edit where all fields are known.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]\npub struct ExactScrobbleEdit {\n    /// Original track name as it appears in the scrobble\n    pub track_name_original: String,\n    /// Original album name as it appears in the scrobble\n    pub album_name_original: String,\n    /// Original artist name as it appears in the scrobble\n    pub artist_name_original: String,\n    /// Original album artist name as it appears in the scrobble\n    pub album_artist_name_original: String,\n\n    /// New track name to set\n    pub track_name: String,\n    /// New album name to set\n    pub album_name: String,\n    /// New artist name to set\n    pub artist_name: String,\n    /// New album artist name to set\n    pub album_artist_name: String,\n\n    /// Unix timestamp of the scrobble to edit\n    pub timestamp: u64,\n    /// Whether to edit all instances or just this specific scrobble\n    pub edit_all: bool,\n}\n\nimpl fmt::Display for ExactScrobbleEdit {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let mut changes = Vec::new();\n\n        // Check if artist is being changed\n        if self.artist_name != self.artist_name_original {\n            changes.push(format!(\n                \"Artist: {} → {}\",\n                self.artist_name_original, self.artist_name\n            ));\n        }\n\n        // Check if track name is being changed\n        if self.track_name != self.track_name_original {\n            changes.push(format!(\n                \"Track: {} → {}\",\n                self.track_name_original, self.track_name\n            ));\n        }\n\n        // Check if album name is being changed\n        if self.album_name != self.album_name_original {\n            changes.push(format!(\n                \"Album: {} → {}\",\n                self.album_name_original, self.album_name\n            ));\n        }\n\n        // Check if album artist is being changed\n        if self.album_artist_name != self.album_artist_name_original {\n            changes.push(format!(\n                \"Album Artist: {} → {}\",\n                self.album_artist_name_original, self.album_artist_name\n            ));\n        }\n\n        if changes.is_empty() {\n            write!(f, \"No changes\")\n        } else {\n            let scope = if self.edit_all {\n                \" (all instances)\"\n            } else {\n                \"\"\n            };\n            write!(f, \"{}{}\", changes.join(\", \"), scope)\n        }\n    }\n}\n\nimpl ScrobbleEdit {\n    /// Create a new [`ScrobbleEdit`] with all required fields.\n    ///\n    /// This is the most general constructor that allows setting all fields.\n    /// For convenience, consider using [`from_track_info`](Self::from_track_info) instead.\n    ///\n    /// # Arguments\n    ///\n    /// * `track_name_original` - The current track name in the scrobble\n    /// * `album_name_original` - The current album name in the scrobble\n    /// * `artist_name_original` - The current artist name in the scrobble\n    /// * `album_artist_name_original` - The current album artist name in the scrobble\n    /// * `track_name` - The new track name to set\n    /// * `album_name` - The new album name to set\n    /// * `artist_name` - The new artist name to set\n    /// * `album_artist_name` - The new album artist name to set\n    /// * `timestamp` - Unix timestamp identifying the scrobble\n    /// * `edit_all` - Whether to edit all matching scrobbles or just this one\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        track_name_original: Option\u003cString\u003e,\n        album_name_original: Option\u003cString\u003e,\n        artist_name_original: String,\n        album_artist_name_original: Option\u003cString\u003e,\n        track_name: Option\u003cString\u003e,\n        album_name: Option\u003cString\u003e,\n        artist_name: String,\n        album_artist_name: Option\u003cString\u003e,\n        timestamp: Option\u003cu64\u003e,\n        edit_all: bool,\n    ) -\u003e Self {\n        Self {\n            track_name_original,\n            album_name_original,\n            artist_name_original,\n            album_artist_name_original,\n            track_name,\n            album_name,\n            artist_name,\n            album_artist_name,\n            timestamp,\n            edit_all,\n        }\n    }\n\n    /// Create an edit request from track information (convenience constructor).\n    ///\n    /// This constructor creates a [`ScrobbleEdit`] with the new values initially\n    /// set to the same as the original values. Use the builder methods like\n    /// [`with_track_name`](Self::with_track_name) to specify what should be changed.\n    ///\n    /// # Arguments\n    ///\n    /// * `original_track` - The current track name\n    /// * `original_album` - The current album name\n    /// * `original_artist` - The current artist name\n    /// * `timestamp` - Unix timestamp identifying the scrobble\n    pub fn from_track_info(\n        original_track: \u0026str,\n        original_album: \u0026str,\n        original_artist: \u0026str,\n        timestamp: u64,\n    ) -\u003e Self {\n        Self::new(\n            Some(original_track.to_string()),\n            Some(original_album.to_string()),\n            original_artist.to_string(),\n            Some(original_artist.to_string()), // album_artist defaults to artist\n            Some(original_track.to_string()),\n            Some(original_album.to_string()),\n            original_artist.to_string(),\n            Some(original_artist.to_string()), // album_artist defaults to artist\n            Some(timestamp),\n            true, // edit_all defaults to true\n        )\n    }\n\n    /// Set the new track name.\n    pub fn with_track_name(mut self, track_name: \u0026str) -\u003e Self {\n        self.track_name = Some(track_name.to_string());\n        self\n    }\n\n    /// Set the new album name.\n    pub fn with_album_name(mut self, album_name: \u0026str) -\u003e Self {\n        self.album_name = Some(album_name.to_string());\n        self\n    }\n\n    /// Set the new artist name.\n    ///\n    /// This also sets the album artist name to the same value.\n    pub fn with_artist_name(mut self, artist_name: \u0026str) -\u003e Self {\n        self.artist_name = artist_name.to_string();\n        self.album_artist_name = Some(artist_name.to_string());\n        self\n    }\n\n    /// Set whether to edit all instances of this track.\n    ///\n    /// When `true`, Last.fm will update all scrobbles with the same metadata.\n    /// When `false` (default), only the specific scrobble is updated.\n    pub fn with_edit_all(mut self, edit_all: bool) -\u003e Self {\n        self.edit_all = edit_all;\n        self\n    }\n\n    /// Create an edit request with minimal information, letting the client look up missing metadata.\n    ///\n    /// This constructor is useful when you only know some of the original metadata and want\n    /// the client to automatically fill in missing information by looking up the scrobble.\n    ///\n    /// # Arguments\n    ///\n    /// * `track_name` - The new track name to set\n    /// * `artist_name` - The new artist name to set\n    /// * `album_name` - The new album name to set\n    /// * `timestamp` - Unix timestamp identifying the scrobble\n    pub fn with_minimal_info(\n        track_name: \u0026str,\n        artist_name: \u0026str,\n        album_name: \u0026str,\n        timestamp: u64,\n    ) -\u003e Self {\n        Self::new(\n            Some(track_name.to_string()),\n            Some(album_name.to_string()),\n            artist_name.to_string(),\n            Some(artist_name.to_string()),\n            Some(track_name.to_string()),\n            Some(album_name.to_string()),\n            artist_name.to_string(),\n            Some(artist_name.to_string()),\n            Some(timestamp),\n            true,\n        )\n    }\n    /// Create an edit request with just track and artist information.\n    ///\n    /// This constructor is useful when you only know the track and artist names.\n    /// The client will use these as both original and new values, and will\n    /// attempt to find a representative timestamp and album information.\n    ///\n    /// # Arguments\n    ///\n    /// * `track_name` - The track name (used as both original and new)\n    /// * `artist_name` - The artist name (used as both original and new)\n    pub fn from_track_and_artist(track_name: \u0026str, artist_name: \u0026str) -\u003e Self {\n        Self::new(\n            Some(track_name.to_string()),\n            None, // Client will look up original album name\n            artist_name.to_string(),\n            None, // Client will look up original album artist name\n            Some(track_name.to_string()),\n            None, // Will be filled by client or kept as original\n            artist_name.to_string(),\n            Some(artist_name.to_string()), // album_artist defaults to artist\n            None,                          // Client will find representative timestamp\n            true,\n        )\n    }\n\n    /// Create an edit request for all tracks by an artist.\n    ///\n    /// This constructor creates a [`ScrobbleEdit`] that will edit all tracks\n    /// by the specified artist, changing the artist name to the new value.\n    ///\n    /// # Arguments\n    ///\n    /// * `old_artist_name` - The current artist name to change from\n    /// * `new_artist_name` - The new artist name to change to\n    pub fn for_artist(old_artist_name: \u0026str, new_artist_name: \u0026str) -\u003e Self {\n        Self::new(\n            None, // No specific track - edit all tracks\n            None, // No specific album - edit all albums\n            old_artist_name.to_string(),\n            None, // Client will look up original album artist name\n            None, // No track name change - keep original track names\n            None, // Keep original album names (they can vary)\n            new_artist_name.to_string(),\n            Some(new_artist_name.to_string()), // album_artist also changes for global renames\n            None,                              // Client will find representative timestamp\n            true,                              // Edit all instances by default for artist changes\n        )\n    }\n\n    /// Create an edit request for all tracks in a specific album.\n    ///\n    /// This constructor creates a [`ScrobbleEdit`] that will edit all tracks\n    /// in the specified album by the specified artist.\n    ///\n    /// # Arguments\n    ///\n    /// * `album_name` - The album name containing tracks to edit\n    /// * `artist_name` - The artist name for the album\n    /// * `new_artist_name` - The new artist name to change to\n    pub fn for_album(album_name: \u0026str, old_artist_name: \u0026str, new_artist_name: \u0026str) -\u003e Self {\n        Self::new(\n            None, // No specific track - edit all tracks in album\n            Some(album_name.to_string()),\n            old_artist_name.to_string(),\n            Some(old_artist_name.to_string()),\n            None,                         // No track name change - keep original track names\n            Some(album_name.to_string()), // Keep same album name\n            new_artist_name.to_string(),\n            None, // Keep original album_artist names (they can vary)\n            None, // Client will find representative timestamp\n            true, // Edit all instances by default for album changes\n        )\n    }\n}\n\nimpl ExactScrobbleEdit {\n    /// Create a new [`ExactScrobbleEdit`] with all fields specified.\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        track_name_original: String,\n        album_name_original: String,\n        artist_name_original: String,\n        album_artist_name_original: String,\n        track_name: String,\n        album_name: String,\n        artist_name: String,\n        album_artist_name: String,\n        timestamp: u64,\n        edit_all: bool,\n    ) -\u003e Self {\n        Self {\n            track_name_original,\n            album_name_original,\n            artist_name_original,\n            album_artist_name_original,\n            track_name,\n            album_name,\n            artist_name,\n            album_artist_name,\n            timestamp,\n            edit_all,\n        }\n    }\n\n    /// Build the form data for submitting this scrobble edit.\n    ///\n    /// This creates a HashMap containing all the form fields needed to submit\n    /// the edit request to Last.fm, including the CSRF token and all metadata fields.\n    pub fn build_form_data(\u0026self, csrf_token: \u0026str) -\u003e HashMap\u003c\u0026str, String\u003e {\n        let mut form_data = HashMap::new();\n\n        // Add fresh CSRF token (required)\n        form_data.insert(\"csrfmiddlewaretoken\", csrf_token.to_string());\n\n        // Include ALL form fields (using ExactScrobbleEdit which has all required fields)\n        form_data.insert(\"track_name_original\", self.track_name_original.clone());\n        form_data.insert(\"track_name\", self.track_name.clone());\n        form_data.insert(\"artist_name_original\", self.artist_name_original.clone());\n        form_data.insert(\"artist_name\", self.artist_name.clone());\n        form_data.insert(\"album_name_original\", self.album_name_original.clone());\n        form_data.insert(\"album_name\", self.album_name.clone());\n        form_data.insert(\n            \"album_artist_name_original\",\n            self.album_artist_name_original.clone(),\n        );\n        form_data.insert(\"album_artist_name\", self.album_artist_name.clone());\n\n        // Include timestamp (ExactScrobbleEdit always has a timestamp)\n        form_data.insert(\"timestamp\", self.timestamp.to_string());\n\n        // Edit flags\n        if self.edit_all {\n            form_data.insert(\"edit_all\", \"1\".to_string());\n        }\n        form_data.insert(\"submit\", \"edit-scrobble\".to_string());\n        form_data.insert(\"ajax\", \"1\".to_string());\n\n        form_data\n    }\n\n    /// Convert this exact edit back to a public ScrobbleEdit.\n    ///\n    /// This is useful when you need to expose the edit data through the public API.\n    pub fn to_scrobble_edit(\u0026self) -\u003e ScrobbleEdit {\n        ScrobbleEdit::new(\n            Some(self.track_name_original.clone()),\n            Some(self.album_name_original.clone()),\n            self.artist_name_original.clone(),\n            Some(self.album_artist_name_original.clone()),\n            Some(self.track_name.clone()),\n            Some(self.album_name.clone()),\n            self.artist_name.clone(),\n            Some(self.album_artist_name.clone()),\n            Some(self.timestamp),\n            self.edit_all,\n        )\n    }\n}\n\nimpl EditResponse {\n    /// Create a new EditResponse from a single result.\n    pub fn single(\n        success: bool,\n        message: Option\u003cString\u003e,\n        album_info: Option\u003cString\u003e,\n        exact_scrobble_edit: ExactScrobbleEdit,\n    ) -\u003e Self {\n        Self {\n            individual_results: vec![SingleEditResponse {\n                success,\n                message,\n                album_info,\n                exact_scrobble_edit,\n            }],\n        }\n    }\n\n    /// Create a new EditResponse from multiple results.\n    pub fn from_results(results: Vec\u003cSingleEditResponse\u003e) -\u003e Self {\n        Self {\n            individual_results: results,\n        }\n    }\n\n    /// Check if all individual edit operations were successful.\n    pub fn all_successful(\u0026self) -\u003e bool {\n        !self.individual_results.is_empty() \u0026\u0026 self.individual_results.iter().all(|r| r.success)\n    }\n\n    /// Check if any individual edit operations were successful.\n    pub fn any_successful(\u0026self) -\u003e bool {\n        self.individual_results.iter().any(|r| r.success)\n    }\n\n    /// Get the total number of edit operations performed.\n    pub fn total_edits(\u0026self) -\u003e usize {\n        self.individual_results.len()\n    }\n\n    /// Get the number of successful edit operations.\n    pub fn successful_edits(\u0026self) -\u003e usize {\n        self.individual_results.iter().filter(|r| r.success).count()\n    }\n\n    /// Get the number of failed edit operations.\n    pub fn failed_edits(\u0026self) -\u003e usize {\n        self.individual_results\n            .iter()\n            .filter(|r| !r.success)\n            .count()\n    }\n\n    /// Generate a summary message describing the overall result.\n    pub fn summary_message(\u0026self) -\u003e String {\n        let total = self.total_edits();\n        let successful = self.successful_edits();\n        let failed = self.failed_edits();\n\n        if total == 0 {\n            return \"No edit operations performed\".to_string();\n        }\n\n        if successful == total {\n            if total == 1 {\n                \"Edit completed successfully\".to_string()\n            } else {\n                format!(\"All {total} edits completed successfully\")\n            }\n        } else if successful == 0 {\n            if total == 1 {\n                \"Edit failed\".to_string()\n            } else {\n                format!(\"All {total} edits failed\")\n            }\n        } else {\n            format!(\"{successful} of {total} edits succeeded, {failed} failed\")\n        }\n    }\n\n    /// Get detailed messages from all edit operations.\n    pub fn detailed_messages(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.individual_results\n            .iter()\n            .enumerate()\n            .map(|(i, result)| {\n                let album_info = result\n                    .album_info\n                    .as_deref()\n                    .map(|info| format!(\" ({info})\"))\n                    .unwrap_or_default();\n\n                match \u0026result.message {\n                    Some(msg) =\u003e format!(\"{}: {}{}\", i + 1, msg, album_info),\n                    None =\u003e {\n                        if result.success {\n                            format!(\"{}: Success{}\", i + 1, album_info)\n                        } else {\n                            format!(\"{}: Failed{}\", i + 1, album_info)\n                        }\n                    }\n                }\n            })\n            .collect()\n    }\n\n    /// Check if this response represents a single edit (for backward compatibility).\n    pub fn is_single_edit(\u0026self) -\u003e bool {\n        self.individual_results.len() == 1\n    }\n\n    /// Check if all edits succeeded (for backward compatibility).\n    pub fn success(\u0026self) -\u003e bool {\n        self.all_successful()\n    }\n\n    /// Get a single message for backward compatibility.\n    /// Returns the summary message.\n    pub fn message(\u0026self) -\u003e Option\u003cString\u003e {\n        Some(self.summary_message())\n    }\n}\n\n// ================================================================================================\n// ERROR TYPES\n// ================================================================================================\n\n/// Error types for Last.fm operations.\n///\n/// This enum covers all possible errors that can occur when interacting with Last.fm,\n/// including network issues, authentication failures, parsing errors, and rate limiting.\n#[derive(Error, Debug)]\npub enum LastFmError {\n    /// HTTP/network related errors.\n    ///\n    /// This includes connection failures, timeouts, DNS errors, and other\n    /// low-level networking issues.\n    #[error(\"HTTP error: {0}\")]\n    Http(String),\n\n    /// Authentication failures.\n    ///\n    /// This occurs when login credentials are invalid, sessions expire,\n    /// or authentication is required but not provided.\n    ///\n    /// # Common Causes\n    /// - Invalid username/password\n    /// - Expired session cookies\n    /// - Account locked or suspended\n    /// - Two-factor authentication required\n    #[error(\"Authentication failed: {0}\")]\n    Auth(String),\n\n    /// CSRF token not found in response.\n    ///\n    /// This typically indicates that Last.fm's page structure has changed\n    /// or that the request was blocked.\n    #[error(\"CSRF token not found\")]\n    CsrfNotFound,\n\n    /// Failed to parse Last.fm's response.\n    ///\n    /// This can happen when Last.fm changes their HTML structure or\n    /// returns unexpected data formats.\n    #[error(\"Failed to parse response: {0}\")]\n    Parse(String),\n\n    /// Rate limiting from Last.fm.\n    ///\n    /// Last.fm has rate limits to prevent abuse. When hit, the client\n    /// should wait before making more requests.\n    ///\n    /// The `retry_after` field indicates how many seconds to wait before\n    /// the next request attempt.\n    #[error(\"Rate limited, retry after {retry_after} seconds\")]\n    RateLimit {\n        /// Number of seconds to wait before retrying\n        retry_after: u64,\n    },\n\n    /// Scrobble edit operation failed.\n    ///\n    /// This is returned when an edit request is properly formatted and sent,\n    /// but Last.fm rejects it for business logic reasons.\n    #[error(\"Edit failed: {0}\")]\n    EditFailed(String),\n\n    /// File system I/O errors.\n    ///\n    /// This can occur when saving debug responses or other file operations.\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n}\n\n// ================================================================================================\n// SESSION MANAGEMENT\n// ================================================================================================\n\n/// Serializable client session state that can be persisted and restored.\n///\n/// This contains all the authentication state needed to resume a Last.fm session\n/// without requiring the user to log in again.\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct LastFmEditSession {\n    /// The authenticated username\n    pub username: String,\n    /// Session cookies required for authenticated requests\n    pub cookies: Vec\u003cString\u003e,\n    /// CSRF token for form submissions\n    pub csrf_token: Option\u003cString\u003e,\n    /// Base URL for the Last.fm instance\n    pub base_url: String,\n}\n\nimpl LastFmEditSession {\n    /// Create a new client session with the provided state\n    pub fn new(\n        username: String,\n        session_cookies: Vec\u003cString\u003e,\n        csrf_token: Option\u003cString\u003e,\n        base_url: String,\n    ) -\u003e Self {\n        Self {\n            username,\n            cookies: session_cookies,\n            csrf_token,\n            base_url,\n        }\n    }\n\n    /// Check if this session appears to be valid\n    ///\n    /// This performs basic validation but doesn't guarantee the session\n    /// is still active on the server.\n    pub fn is_valid(\u0026self) -\u003e bool {\n        !self.username.is_empty()\n            \u0026\u0026 !self.cookies.is_empty()\n            \u0026\u0026 self.csrf_token.is_some()\n            \u0026\u0026 self\n                .cookies\n                .iter()\n                .any(|cookie| cookie.starts_with(\"sessionid=\") \u0026\u0026 cookie.len() \u003e 50)\n    }\n\n    /// Serialize session to JSON string\n    pub fn to_json(\u0026self) -\u003e Result\u003cString, serde_json::Error\u003e {\n        serde_json::to_string(self)\n    }\n\n    /// Deserialize session from JSON string\n    pub fn from_json(json: \u0026str) -\u003e Result\u003cSelf, serde_json::Error\u003e {\n        serde_json::from_str(json)\n    }\n}\n\n// ================================================================================================\n// CLIENT CONFIGURATION\n// ================================================================================================\n\n/// Configuration for rate limit detection behavior\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct RateLimitConfig {\n    /// Whether to detect rate limits by HTTP status codes (429, 403)\n    pub detect_by_status: bool,\n    /// Whether to detect rate limits by response body patterns\n    pub detect_by_patterns: bool,\n    /// Patterns to look for in response bodies (used when detect_by_patterns is true)\n    pub patterns: Vec\u003cString\u003e,\n    /// Additional custom patterns to look for in response bodies\n    pub custom_patterns: Vec\u003cString\u003e,\n}\n\nimpl Default for RateLimitConfig {\n    fn default() -\u003e Self {\n        Self {\n            detect_by_status: true,\n            detect_by_patterns: true,\n            patterns: vec![\n                \"you've tried to log in too many times\".to_string(),\n                \"you're requesting too many pages\".to_string(),\n                \"slow down\".to_string(),\n                \"too fast\".to_string(),\n                \"rate limit\".to_string(),\n                \"throttled\".to_string(),\n                \"temporarily blocked\".to_string(),\n                \"temporarily restricted\".to_string(),\n                \"captcha\".to_string(),\n                \"verify you're human\".to_string(),\n                \"prove you're not a robot\".to_string(),\n                \"security check\".to_string(),\n                \"service temporarily unavailable\".to_string(),\n                \"quota exceeded\".to_string(),\n                \"limit exceeded\".to_string(),\n                \"daily limit\".to_string(),\n            ],\n            custom_patterns: vec![],\n        }\n    }\n}\n\nimpl RateLimitConfig {\n    /// Create config with all detection disabled\n    pub fn disabled() -\u003e Self {\n        Self {\n            detect_by_status: false,\n            detect_by_patterns: false,\n            patterns: vec![],\n            custom_patterns: vec![],\n        }\n    }\n\n    /// Create config with only status code detection\n    pub fn status_only() -\u003e Self {\n        Self {\n            detect_by_status: true,\n            detect_by_patterns: false,\n            patterns: vec![],\n            custom_patterns: vec![],\n        }\n    }\n\n    /// Create config with only default pattern detection\n    pub fn patterns_only() -\u003e Self {\n        Self {\n            detect_by_status: false,\n            detect_by_patterns: true,\n            ..Default::default()\n        }\n    }\n\n    /// Create config with custom patterns only (no default patterns)\n    pub fn custom_patterns_only(patterns: Vec\u003cString\u003e) -\u003e Self {\n        Self {\n            detect_by_status: false,\n            detect_by_patterns: false,\n            patterns: vec![],\n            custom_patterns: patterns,\n        }\n    }\n\n    /// Create config with both default and custom patterns\n    pub fn with_custom_patterns(mut self, patterns: Vec\u003cString\u003e) -\u003e Self {\n        self.custom_patterns = patterns;\n        self\n    }\n\n    /// Create config with custom patterns (replaces built-in patterns)\n    pub fn with_patterns(mut self, patterns: Vec\u003cString\u003e) -\u003e Self {\n        self.patterns = patterns;\n        self\n    }\n}\n\n/// Configuration for operational delays between requests\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct OperationalDelayConfig {\n    /// Delay between multiple edit operations (in milliseconds)\n    pub edit_delay_ms: u64,\n    /// Delay between delete operations (in milliseconds)\n    pub delete_delay_ms: u64,\n}\n\nimpl Default for OperationalDelayConfig {\n    fn default() -\u003e Self {\n        Self {\n            edit_delay_ms: 1000,   // 1 second\n            delete_delay_ms: 1000, // 1 second\n        }\n    }\n}\n\nimpl OperationalDelayConfig {\n    /// Create config with no delays (useful for testing)\n    pub fn no_delays() -\u003e Self {\n        Self {\n            edit_delay_ms: 0,\n            delete_delay_ms: 0,\n        }\n    }\n\n    /// Create config with custom delays\n    pub fn with_delays(edit_delay_ms: u64, delete_delay_ms: u64) -\u003e Self {\n        Self {\n            edit_delay_ms,\n            delete_delay_ms,\n        }\n    }\n}\n\n/// Unified configuration for retry behavior and rate limiting\n#[derive(Debug, Clone, PartialEq, Eq, Default)]\npub struct ClientConfig {\n    /// Retry configuration\n    pub retry: RetryConfig,\n    /// Rate limit detection configuration\n    pub rate_limit: RateLimitConfig,\n    /// Operational delay configuration\n    pub operational_delays: OperationalDelayConfig,\n}\n\nimpl ClientConfig {\n    /// Create a new config with default settings\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Create config with retries disabled\n    pub fn with_retries_disabled() -\u003e Self {\n        Self {\n            retry: RetryConfig::disabled(),\n            rate_limit: RateLimitConfig::default(),\n            operational_delays: OperationalDelayConfig::default(),\n        }\n    }\n\n    /// Create config with rate limit detection disabled\n    pub fn with_rate_limiting_disabled() -\u003e Self {\n        Self {\n            retry: RetryConfig::default(),\n            rate_limit: RateLimitConfig::disabled(),\n            operational_delays: OperationalDelayConfig::default(),\n        }\n    }\n\n    /// Create config with both retries and rate limiting disabled\n    pub fn minimal() -\u003e Self {\n        Self {\n            retry: RetryConfig::disabled(),\n            rate_limit: RateLimitConfig::disabled(),\n            operational_delays: OperationalDelayConfig::default(),\n        }\n    }\n\n    /// Create config optimized for testing (rate limit detection enabled, retries enabled but no delays)\n    pub fn for_testing() -\u003e Self {\n        Self {\n            retry: RetryConfig {\n                max_retries: 3,\n                base_delay: 0, // No delay for fast tests\n                max_delay: 0,  // No delay for fast tests\n                enabled: true,\n            },\n            rate_limit: RateLimitConfig::default(), // Keep detection enabled\n            operational_delays: OperationalDelayConfig::no_delays(),\n        }\n    }\n\n    /// Set custom retry configuration\n    pub fn with_retry_config(mut self, retry_config: RetryConfig) -\u003e Self {\n        self.retry = retry_config;\n        self\n    }\n\n    /// Set custom rate limit configuration\n    pub fn with_rate_limit_config(mut self, rate_limit_config: RateLimitConfig) -\u003e Self {\n        self.rate_limit = rate_limit_config;\n        self\n    }\n\n    /// Set custom operational delay configuration\n    pub fn with_operational_delays(mut self, operational_delays: OperationalDelayConfig) -\u003e Self {\n        self.operational_delays = operational_delays;\n        self\n    }\n\n    /// Set custom retry count\n    pub fn with_max_retries(mut self, max_retries: u32) -\u003e Self {\n        self.retry.max_retries = max_retries;\n        self.retry.enabled = max_retries \u003e 0;\n        self\n    }\n\n    /// Set custom retry delays\n    pub fn with_retry_delays(mut self, base_delay: u64, max_delay: u64) -\u003e Self {\n        self.retry.base_delay = base_delay;\n        self.retry.max_delay = max_delay;\n        self\n    }\n\n    /// Add custom rate limit patterns\n    pub fn with_custom_rate_limit_patterns(mut self, patterns: Vec\u003cString\u003e) -\u003e Self {\n        self.rate_limit.custom_patterns = patterns;\n        self\n    }\n\n    /// Enable/disable HTTP status code rate limit detection\n    pub fn with_status_detection(mut self, enabled: bool) -\u003e Self {\n        self.rate_limit.detect_by_status = enabled;\n        self\n    }\n\n    /// Enable/disable response pattern rate limit detection\n    pub fn with_pattern_detection(mut self, enabled: bool) -\u003e Self {\n        self.rate_limit.detect_by_patterns = enabled;\n        self\n    }\n}\n\n/// Configuration for retry behavior\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct RetryConfig {\n    /// Maximum number of retry attempts (set to 0 to disable retries)\n    pub max_retries: u32,\n    /// Base delay for exponential backoff (in seconds)\n    pub base_delay: u64,\n    /// Maximum delay cap (in seconds)\n    pub max_delay: u64,\n    /// Whether retries are enabled at all\n    pub enabled: bool,\n}\n\nimpl Default for RetryConfig {\n    fn default() -\u003e Self {\n        Self {\n            max_retries: 3,\n            base_delay: 5,\n            max_delay: 300, // 5 minutes\n            enabled: true,\n        }\n    }\n}\n\nimpl RetryConfig {\n    /// Create a config with retries disabled\n    pub fn disabled() -\u003e Self {\n        Self {\n            max_retries: 0,\n            base_delay: 5,\n            max_delay: 300,\n            enabled: false,\n        }\n    }\n\n    /// Create a config with custom retry count\n    pub fn with_retries(max_retries: u32) -\u003e Self {\n        Self {\n            max_retries,\n            enabled: max_retries \u003e 0,\n            ..Default::default()\n        }\n    }\n\n    /// Create a config with custom delays\n    pub fn with_delays(base_delay: u64, max_delay: u64) -\u003e Self {\n        Self {\n            base_delay,\n            max_delay,\n            ..Default::default()\n        }\n    }\n}\n\n/// Result of a retry operation with context\n#[derive(Debug)]\npub struct RetryResult\u003cT\u003e {\n    /// The successful result\n    pub result: T,\n    /// Number of retry attempts made\n    pub attempts_made: u32,\n    /// Total time spent retrying (in seconds)\n    pub total_retry_time: u64,\n}\n\n// ================================================================================================\n// EVENT SYSTEM\n// ================================================================================================\n\n/// Request information for client events\n#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct RequestInfo {\n    /// The HTTP method (GET, POST, etc.)\n    pub method: String,\n    /// The full URI being requested\n    pub uri: String,\n    /// Query parameters as key-value pairs\n    pub query_params: Vec\u003c(String, String)\u003e,\n    /// Path without query parameters\n    pub path: String,\n}\n\nimpl RequestInfo {\n    /// Create RequestInfo from a URL string and method\n    pub fn from_url_and_method(url: \u0026str, method: \u0026str) -\u003e Self {\n        // Parse URL manually to avoid adding dependencies\n        let (path, query_params) = if let Some(query_start) = url.find('?') {\n            let path = url[..query_start].to_string();\n            let query_string = \u0026url[query_start + 1..];\n\n            let query_params: Vec\u003c(String, String)\u003e = query_string\n                .split('\u0026')\n                .filter_map(|pair| {\n                    if let Some(eq_pos) = pair.find('=') {\n                        let key = \u0026pair[..eq_pos];\n                        let value = \u0026pair[eq_pos + 1..];\n                        Some((key.to_string(), value.to_string()))\n                    } else if !pair.is_empty() {\n                        Some((pair.to_string(), String::new()))\n                    } else {\n                        None\n                    }\n                })\n                .collect();\n\n            (path, query_params)\n        } else {\n            (url.to_string(), Vec::new())\n        };\n\n        // Extract just the path part if it's a full URL\n        let path = if path.starts_with(\"http://\") || path.starts_with(\"https://\") {\n            if let Some(third_slash) = path[8..].find('/') {\n                path[8 + third_slash..].to_string()\n            } else {\n                \"/\".to_string()\n            }\n        } else {\n            path\n        };\n\n        Self {\n            method: method.to_string(),\n            uri: url.to_string(),\n            query_params,\n            path,\n        }\n    }\n\n    /// Get a short description of the request for logging\n    pub fn short_description(\u0026self) -\u003e String {\n        let mut desc = format!(\"{} {}\", self.method, self.path);\n        if !self.query_params.is_empty() {\n            let params: Vec\u003cString\u003e = self\n                .query_params\n                .iter()\n                .map(|(k, v)| format!(\"{k}={v}\"))\n                .collect();\n            if params.len() \u003c= 2 {\n                desc.push_str(\u0026format!(\"?{}\", params.join(\"\u0026\")));\n            } else {\n                desc.push_str(\u0026format!(\"?{}...\", params[0]));\n            }\n        }\n        desc\n    }\n}\n\n/// Type of rate limiting detected\n#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum RateLimitType {\n    /// HTTP 429 Too Many Requests\n    Http429,\n    /// HTTP 403 Forbidden (likely rate limiting)\n    Http403,\n    /// Rate limit patterns detected in response body\n    ResponsePattern,\n}\n\n/// Event type to describe internal HTTP client activity\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub enum ClientEvent {\n    /// Request started\n    RequestStarted {\n        /// Request details\n        request: RequestInfo,\n    },\n    /// Request completed successfully\n    RequestCompleted {\n        /// Request details\n        request: RequestInfo,\n        /// HTTP status code\n        status_code: u16,\n        /// Duration of the request in milliseconds\n        duration_ms: u64,\n    },\n    /// Rate limiting detected with backoff duration in seconds\n    RateLimited {\n        /// Duration to wait in seconds\n        delay_seconds: u64,\n        /// Request that triggered the rate limit (if available)\n        request: Option\u003cRequestInfo\u003e,\n        /// Type of rate limiting detected\n        rate_limit_type: RateLimitType,\n        /// Timestamp when the rate limit was detected (seconds since Unix epoch)\n        rate_limit_timestamp: u64,\n    },\n    /// Rate limiting period has ended and normal operation resumed\n    RateLimitEnded {\n        /// Request that successfully completed after rate limiting\n        request: RequestInfo,\n        /// Type of rate limiting that ended\n        rate_limit_type: RateLimitType,\n        /// Total duration the rate limiting was active in seconds\n        total_rate_limit_duration_seconds: u64,\n    },\n    /// Scrobble edit attempt completed\n    EditAttempted {\n        /// The exact scrobble edit that was attempted\n        edit: ExactScrobbleEdit,\n        /// Whether the edit was successful\n        success: bool,\n        /// Optional error message if the edit failed\n        error_message: Option\u003cString\u003e,\n        /// Duration of the edit operation in milliseconds\n        duration_ms: u64,\n    },\n}\n\n/// Type alias for the broadcast receiver\npub type ClientEventReceiver = broadcast::Receiver\u003cClientEvent\u003e;\n\n/// Type alias for the watch receiver\npub type ClientEventWatcher = watch::Receiver\u003cOption\u003cClientEvent\u003e\u003e;\n\n/// Shared event broadcasting state that persists across client clones\n#[derive(Clone)]\npub struct SharedEventBroadcaster {\n    event_tx: broadcast::Sender\u003cClientEvent\u003e,\n    last_event_tx: watch::Sender\u003cOption\u003cClientEvent\u003e\u003e,\n}\n\nimpl SharedEventBroadcaster {\n    /// Create a new shared event broadcaster\n    pub fn new() -\u003e Self {\n        let (event_tx, _) = broadcast::channel(100);\n        let (last_event_tx, _) = watch::channel(None);\n\n        Self {\n            event_tx,\n            last_event_tx,\n        }\n    }\n\n    /// Broadcast an event to all subscribers\n    pub fn broadcast_event(\u0026self, event: ClientEvent) {\n        let _ = self.event_tx.send(event.clone());\n        let _ = self.last_event_tx.send(Some(event));\n    }\n\n    /// Subscribe to events\n    pub fn subscribe(\u0026self) -\u003e ClientEventReceiver {\n        self.event_tx.subscribe()\n    }\n\n    /// Get the latest event\n    pub fn latest_event(\u0026self) -\u003e Option\u003cClientEvent\u003e {\n        self.last_event_tx.borrow().clone()\n    }\n}\n\nimpl Default for SharedEventBroadcaster {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl std::fmt::Debug for SharedEventBroadcaster {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"SharedEventBroadcaster\")\n            .field(\"subscribers\", \u0026self.event_tx.receiver_count())\n            .finish()\n    }\n}\n\n// ================================================================================================\n// TESTS\n// ================================================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_session_validity() {\n        let valid_session = LastFmEditSession::new(\n            \"testuser\".to_string(),\n            vec![\"sessionid=.eJy1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\".to_string()],\n            Some(\"csrf_token_123\".to_string()),\n            \"https://www.last.fm\".to_string(),\n        );\n        assert!(valid_session.is_valid());\n\n        let invalid_session = LastFmEditSession::new(\n            \"\".to_string(),\n            vec![],\n            None,\n            \"https://www.last.fm\".to_string(),\n        );\n        assert!(!invalid_session.is_valid());\n    }\n\n    #[test]\n    fn test_session_serialization() {\n        let session = LastFmEditSession::new(\n            \"testuser\".to_string(),\n            vec![\n                \"sessionid=.test123\".to_string(),\n                \"csrftoken=abc\".to_string(),\n            ],\n            Some(\"csrf_token_123\".to_string()),\n            \"https://www.last.fm\".to_string(),\n        );\n\n        let json = session.to_json().unwrap();\n        let restored_session = LastFmEditSession::from_json(\u0026json).unwrap();\n\n        assert_eq!(session.username, restored_session.username);\n        assert_eq!(session.cookies, restored_session.cookies);\n        assert_eq!(session.csrf_token, restored_session.csrf_token);\n        assert_eq!(session.base_url, restored_session.base_url);\n    }\n}\n","traces":[{"line":51,"address":[6286512,6286964,6286970],"length":1,"stats":{"Line":1}},{"line":52,"address":[3183425],"length":1,"stats":{"Line":1}},{"line":53,"address":[6286592],"length":1,"stats":{"Line":1}},{"line":55,"address":[3183582],"length":1,"stats":{"Line":1}},{"line":57,"address":[3495186],"length":1,"stats":{"Line":2}},{"line":99,"address":[3550197],"length":1,"stats":{"Line":0}},{"line":100,"address":[3183872],"length":1,"stats":{"Line":1}},{"line":101,"address":[5712711],"length":1,"stats":{"Line":1}},{"line":129,"address":[6287168],"length":1,"stats":{"Line":0}},{"line":130,"address":[5522692],"length":1,"stats":{"Line":0}},{"line":131,"address":[5679504,5679534],"length":1,"stats":{"Line":0}},{"line":153,"address":[6287216],"length":1,"stats":{"Line":1}},{"line":154,"address":[5522744],"length":1,"stats":{"Line":1}},{"line":182,"address":[3184208],"length":1,"stats":{"Line":0}},{"line":183,"address":[3184228],"length":1,"stats":{"Line":0}},{"line":184,"address":[6070430,6070400],"length":1,"stats":{"Line":0}},{"line":229,"address":[6025120,6027587,6027545],"length":1,"stats":{"Line":1}},{"line":230,"address":[6025153],"length":1,"stats":{"Line":1}},{"line":233,"address":[6025172,6025243],"length":1,"stats":{"Line":2}},{"line":234,"address":[6025304],"length":1,"stats":{"Line":1}},{"line":241,"address":[6025254,6025506],"length":1,"stats":{"Line":2}},{"line":242,"address":[3184659,3184749],"length":1,"stats":{"Line":2}},{"line":243,"address":[3184761,3184826],"length":1,"stats":{"Line":2}},{"line":244,"address":[6025699],"length":1,"stats":{"Line":1}},{"line":247,"address":[6025905,6025656],"length":1,"stats":{"Line":0}},{"line":252,"address":[5713982,5713499],"length":1,"stats":{"Line":2}},{"line":253,"address":[5713999],"length":1,"stats":{"Line":1}},{"line":254,"address":[5523925,5524142],"length":1,"stats":{"Line":2}},{"line":255,"address":[3187591],"length":1,"stats":{"Line":1}},{"line":258,"address":[5714151],"length":1,"stats":{"Line":0}},{"line":265,"address":[6026115,6026602],"length":1,"stats":{"Line":1}},{"line":266,"address":[6288875],"length":1,"stats":{"Line":0}},{"line":267,"address":[6289167,6288950],"length":1,"stats":{"Line":0}},{"line":268,"address":[6289176],"length":1,"stats":{"Line":0}},{"line":273,"address":[6289000],"length":1,"stats":{"Line":0}},{"line":279,"address":[3188330,3187866],"length":1,"stats":{"Line":2}},{"line":280,"address":[3186288,3186700],"length":1,"stats":{"Line":2}},{"line":282,"address":[3186277,3186342],"length":1,"stats":{"Line":2}},{"line":283,"address":[5907272],"length":1,"stats":{"Line":1}},{"line":285,"address":[5524941],"length":1,"stats":{"Line":1}},{"line":287,"address":[3188435,3188574],"length":1,"stats":{"Line":2}},{"line":352,"address":[3188305,3186736,3188263],"length":1,"stats":{"Line":1}},{"line":353,"address":[5525393],"length":1,"stats":{"Line":1}},{"line":356,"address":[6289908,6289982],"length":1,"stats":{"Line":2}},{"line":357,"address":[3186903],"length":1,"stats":{"Line":1}},{"line":364,"address":[6289993,6290221],"length":1,"stats":{"Line":2}},{"line":365,"address":[6290266],"length":1,"stats":{"Line":1}},{"line":372,"address":[5525973,5525736],"length":1,"stats":{"Line":2}},{"line":373,"address":[6290517],"length":1,"stats":{"Line":1}},{"line":380,"address":[6290480,6290724],"length":1,"stats":{"Line":2}},{"line":381,"address":[5716438],"length":1,"stats":{"Line":1}},{"line":387,"address":[5526234,5526472],"length":1,"stats":{"Line":2}},{"line":388,"address":[6290990,6291402],"length":1,"stats":{"Line":2}},{"line":390,"address":[5716724,5716659],"length":1,"stats":{"Line":2}},{"line":391,"address":[5716726],"length":1,"stats":{"Line":1}},{"line":393,"address":[5526523],"length":1,"stats":{"Line":1}},{"line":395,"address":[6028956,6028817],"length":1,"stats":{"Line":2}},{"line":419,"address":[5717120],"length":1,"stats":{"Line":1}},{"line":457,"address":[6029520,6030729,6030845],"length":1,"stats":{"Line":0}},{"line":464,"address":[5717572],"length":1,"stats":{"Line":0}},{"line":465,"address":[5717768,5717713],"length":1,"stats":{"Line":0}},{"line":466,"address":[5527632,5527699],"length":1,"stats":{"Line":0}},{"line":467,"address":[5717950,5717883],"length":1,"stats":{"Line":0}},{"line":468,"address":[6292377,6292310],"length":1,"stats":{"Line":0}},{"line":469,"address":[6292484,6292417],"length":1,"stats":{"Line":0}},{"line":470,"address":[3189404,3189471],"length":1,"stats":{"Line":0}},{"line":471,"address":[3189479,3189546],"length":1,"stats":{"Line":0}},{"line":472,"address":[5528202],"length":1,"stats":{"Line":0}},{"line":478,"address":[5910944,5911230],"length":1,"stats":{"Line":1}},{"line":479,"address":[5911061,5911002],"length":1,"stats":{"Line":2}},{"line":480,"address":[3190275],"length":1,"stats":{"Line":1}},{"line":484,"address":[5719120,5719406],"length":1,"stats":{"Line":1}},{"line":485,"address":[3192442,3192501],"length":1,"stats":{"Line":2}},{"line":486,"address":[5719383],"length":1,"stats":{"Line":1}},{"line":492,"address":[3192688,3193108],"length":1,"stats":{"Line":0}},{"line":493,"address":[6293865,6293803],"length":1,"stats":{"Line":0}},{"line":494,"address":[6293968],"length":1,"stats":{"Line":0}},{"line":495,"address":[3191017],"length":1,"stats":{"Line":0}},{"line":502,"address":[6294192],"length":1,"stats":{"Line":1}},{"line":503,"address":[6294215],"length":1,"stats":{"Line":1}},{"line":504,"address":[5912031],"length":1,"stats":{"Line":1}},{"line":518,"address":[3194525,3193200,3194409],"length":1,"stats":{"Line":0}},{"line":525,"address":[3193316],"length":1,"stats":{"Line":0}},{"line":526,"address":[5912376,5912321],"length":1,"stats":{"Line":0}},{"line":527,"address":[6032419,6032352],"length":1,"stats":{"Line":0}},{"line":528,"address":[3191563,3191630],"length":1,"stats":{"Line":0}},{"line":529,"address":[6294857,6294790],"length":1,"stats":{"Line":0}},{"line":530,"address":[3193841,3193908],"length":1,"stats":{"Line":0}},{"line":531,"address":[6032815,6032748],"length":1,"stats":{"Line":0}},{"line":532,"address":[3194090,3194023],"length":1,"stats":{"Line":0}},{"line":533,"address":[5720858],"length":1,"stats":{"Line":0}},{"line":547,"address":[6295616,6296522,6296671],"length":1,"stats":{"Line":2}},{"line":549,"address":[3194629],"length":1,"stats":{"Line":2}},{"line":550,"address":[6295815],"length":1,"stats":{"Line":2}},{"line":551,"address":[5531408,5531353],"length":1,"stats":{"Line":3}},{"line":552,"address":[5913720],"length":1,"stats":{"Line":1}},{"line":553,"address":[3194882,3194952],"length":1,"stats":{"Line":2}},{"line":554,"address":[5531552],"length":1,"stats":{"Line":1}},{"line":555,"address":[6033888,6033818],"length":1,"stats":{"Line":2}},{"line":556,"address":[3195158,3195096],"length":1,"stats":{"Line":2}},{"line":557,"address":[6296246],"length":1,"stats":{"Line":1}},{"line":571,"address":[6034448,6035180,6035332],"length":1,"stats":{"Line":1}},{"line":573,"address":[3195707],"length":1,"stats":{"Line":1}},{"line":574,"address":[5532346],"length":1,"stats":{"Line":1}},{"line":575,"address":[5532429,5532359],"length":1,"stats":{"Line":2}},{"line":576,"address":[6296933],"length":1,"stats":{"Line":1}},{"line":577,"address":[3195903],"length":1,"stats":{"Line":1}},{"line":578,"address":[5722655],"length":1,"stats":{"Line":1}},{"line":579,"address":[6034735,6034805],"length":1,"stats":{"Line":2}},{"line":580,"address":[5722749,5722811],"length":1,"stats":{"Line":2}},{"line":581,"address":[5532667],"length":1,"stats":{"Line":1}},{"line":596,"address":[3196576,3197624,3197518],"length":1,"stats":{"Line":1}},{"line":598,"address":[3196679],"length":1,"stats":{"Line":1}},{"line":599,"address":[3196820,3196750],"length":1,"stats":{"Line":2}},{"line":600,"address":[5723663,5723596],"length":1,"stats":{"Line":2}},{"line":601,"address":[3194922,3194855],"length":1,"stats":{"Line":2}},{"line":602,"address":[6298098],"length":1,"stats":{"Line":1}},{"line":603,"address":[3194988,3195058],"length":1,"stats":{"Line":2}},{"line":604,"address":[6035978],"length":1,"stats":{"Line":1}},{"line":605,"address":[3197250],"length":1,"stats":{"Line":2}},{"line":606,"address":[5533818],"length":1,"stats":{"Line":2}},{"line":615,"address":[6036464],"length":1,"stats":{"Line":1}},{"line":645,"address":[6038112,6038118,6036768],"length":1,"stats":{"Line":1}},{"line":646,"address":[3195949],"length":1,"stats":{"Line":1}},{"line":649,"address":[5534608,5534665],"length":1,"stats":{"Line":2}},{"line":652,"address":[6299220],"length":1,"stats":{"Line":1}},{"line":653,"address":[6299307],"length":1,"stats":{"Line":1}},{"line":654,"address":[5725078],"length":1,"stats":{"Line":1}},{"line":655,"address":[3198433],"length":1,"stats":{"Line":1}},{"line":656,"address":[6299583],"length":1,"stats":{"Line":2}},{"line":657,"address":[5917482],"length":1,"stats":{"Line":2}},{"line":658,"address":[3198732],"length":1,"stats":{"Line":2}},{"line":660,"address":[5917573],"length":1,"stats":{"Line":2}},{"line":662,"address":[3196680],"length":1,"stats":{"Line":2}},{"line":665,"address":[3196770],"length":1,"stats":{"Line":2}},{"line":668,"address":[6037788],"length":1,"stats":{"Line":2}},{"line":669,"address":[5917892],"length":1,"stats":{"Line":2}},{"line":671,"address":[5917986,5917861],"length":1,"stats":{"Line":4}},{"line":672,"address":[5535745],"length":1,"stats":{"Line":2}},{"line":674,"address":[3199284],"length":1,"stats":{"Line":2}},{"line":680,"address":[3198426,3197200,3198310],"length":1,"stats":{"Line":0}},{"line":682,"address":[5918238],"length":1,"stats":{"Line":0}},{"line":683,"address":[6038287,6038349],"length":1,"stats":{"Line":0}},{"line":684,"address":[5536149,5536215],"length":1,"stats":{"Line":0}},{"line":685,"address":[6038529,6038463],"length":1,"stats":{"Line":0}},{"line":686,"address":[6038635,6038569],"length":1,"stats":{"Line":0}},{"line":687,"address":[6038675,6038741],"length":1,"stats":{"Line":0}},{"line":688,"address":[5536541,5536610],"length":1,"stats":{"Line":0}},{"line":689,"address":[3197914,3197988],"length":1,"stats":{"Line":0}},{"line":690,"address":[5919028],"length":1,"stats":{"Line":0}},{"line":691,"address":[3200191],"length":1,"stats":{"Line":0}},{"line":698,"address":[6039408,6040055,6040021],"length":1,"stats":{"Line":2}},{"line":705,"address":[3198754,3198512],"length":1,"stats":{"Line":4}},{"line":715,"address":[3199136],"length":1,"stats":{"Line":1}},{"line":722,"address":[6302384],"length":1,"stats":{"Line":2}},{"line":723,"address":[5537901],"length":1,"stats":{"Line":6}},{"line":727,"address":[5537984],"length":1,"stats":{"Line":0}},{"line":728,"address":[5728169],"length":1,"stats":{"Line":0}},{"line":732,"address":[5728224],"length":1,"stats":{"Line":1}},{"line":733,"address":[3201493],"length":1,"stats":{"Line":1}},{"line":737,"address":[3201504],"length":1,"stats":{"Line":1}},{"line":738,"address":[5920373],"length":1,"stats":{"Line":3}},{"line":742,"address":[5728304],"length":1,"stats":{"Line":1}},{"line":743,"address":[3199397],"length":1,"stats":{"Line":1}},{"line":745,"address":[6070624,6070634],"length":1,"stats":{"Line":4}},{"line":750,"address":[3201632],"length":1,"stats":{"Line":1}},{"line":751,"address":[5538230],"length":1,"stats":{"Line":1}},{"line":752,"address":[5728422],"length":1,"stats":{"Line":1}},{"line":753,"address":[6302758],"length":1,"stats":{"Line":1}},{"line":755,"address":[6302769],"length":1,"stats":{"Line":2}},{"line":756,"address":[5538286],"length":1,"stats":{"Line":0}},{"line":759,"address":[5538306],"length":1,"stats":{"Line":2}},{"line":760,"address":[5920647],"length":1,"stats":{"Line":1}},{"line":761,"address":[5921066],"length":1,"stats":{"Line":1}},{"line":763,"address":[5728961],"length":1,"stats":{"Line":0}},{"line":765,"address":[5920637],"length":1,"stats":{"Line":1}},{"line":766,"address":[6040600],"length":1,"stats":{"Line":1}},{"line":767,"address":[6303105],"length":1,"stats":{"Line":1}},{"line":769,"address":[6303128],"length":1,"stats":{"Line":0}},{"line":772,"address":[5920681],"length":1,"stats":{"Line":0}},{"line":777,"address":[5729088],"length":1,"stats":{"Line":0}},{"line":778,"address":[5729120],"length":1,"stats":{"Line":0}},{"line":781,"address":[6071633,6070715,6071639,6070656],"length":1,"stats":{"Line":0}},{"line":782,"address":[5679963],"length":1,"stats":{"Line":0}},{"line":785,"address":[6071664,6071691],"length":1,"stats":{"Line":0}},{"line":788,"address":[6070779],"length":1,"stats":{"Line":0}},{"line":789,"address":[6070840,6071401],"length":1,"stats":{"Line":0}},{"line":791,"address":[5333593],"length":1,"stats":{"Line":0}},{"line":792,"address":[3323710,3323420],"length":1,"stats":{"Line":0}},{"line":794,"address":[6070935,6070887,6071031],"length":1,"stats":{"Line":0}},{"line":803,"address":[5921328],"length":1,"stats":{"Line":0}},{"line":804,"address":[3202469],"length":1,"stats":{"Line":0}},{"line":808,"address":[5921360],"length":1,"stats":{"Line":2}},{"line":809,"address":[5539061],"length":1,"stats":{"Line":2}},{"line":814,"address":[3200304],"length":1,"stats":{"Line":1}},{"line":815,"address":[6041331],"length":1,"stats":{"Line":1}},{"line":912,"address":[5539152],"length":1,"stats":{"Line":12}},{"line":930,"address":[3202688],"length":1,"stats":{"Line":1}},{"line":931,"address":[3200522,3200493],"length":1,"stats":{"Line":2}},{"line":932,"address":[5729450],"length":1,"stats":{"Line":1}},{"line":933,"address":[5729477],"length":1,"stats":{"Line":1}},{"line":934,"address":[6041561],"length":1,"stats":{"Line":1}},{"line":937,"address":[5334558,5334528],"length":1,"stats":{"Line":2}},{"line":941,"address":[6303888],"length":1,"stats":{"Line":2}},{"line":942,"address":[6041649],"length":1,"stats":{"Line":2}},{"line":946,"address":[5921744],"length":1,"stats":{"Line":2}},{"line":947,"address":[5539461],"length":1,"stats":{"Line":2}},{"line":969,"address":[5729664,5731521,5731527],"length":1,"stats":{"Line":12}},{"line":973,"address":[6304011,6305042,6305114,6305155,6304970,6305702,6305860,6304118,6304466,6304394,6304049,6304184,6304538,6304610,6304322,6304253,6304754,6304826,6304898,6304682],"length":1,"stats":{"Line":18}},{"line":991,"address":[3204627],"length":1,"stats":{"Line":10}},{"line":998,"address":[5731705,5731711,5731552],"length":1,"stats":{"Line":0}},{"line":1002,"address":[3204829],"length":1,"stats":{"Line":0}},{"line":1003,"address":[6043658],"length":1,"stats":{"Line":0}},{"line":1008,"address":[5731881,5731887,5731728],"length":1,"stats":{"Line":0}},{"line":1012,"address":[3202781],"length":1,"stats":{"Line":0}},{"line":1013,"address":[5923898],"length":1,"stats":{"Line":0}},{"line":1018,"address":[5541728],"length":1,"stats":{"Line":0}},{"line":1027,"address":[5924144,5924318],"length":1,"stats":{"Line":0}},{"line":1031,"address":[3203074],"length":1,"stats":{"Line":0}},{"line":1037,"address":[5732208,5732365],"length":1,"stats":{"Line":0}},{"line":1038,"address":[3203280,3203358],"length":1,"stats":{"Line":0}},{"line":1039,"address":[3205609],"length":1,"stats":{"Line":0}},{"line":1043,"address":[5542208,5542359],"length":1,"stats":{"Line":0}},{"line":1044,"address":[5924544,5924621],"length":1,"stats":{"Line":0}},{"line":1045,"address":[5732515],"length":1,"stats":{"Line":0}},{"line":1059,"address":[6306880],"length":1,"stats":{"Line":5}},{"line":1069,"address":[5542400],"length":1,"stats":{"Line":6}},{"line":1077,"address":[3203632],"length":1,"stats":{"Line":0}},{"line":1098,"address":[5924752],"length":1,"stats":{"Line":0}},{"line":1099,"address":[6306952],"length":1,"stats":{"Line":0}},{"line":1103,"address":[3206104,3205920,3206110],"length":1,"stats":{"Line":0}},{"line":1105,"address":[5924801],"length":1,"stats":{"Line":0}},{"line":1106,"address":[3203728],"length":1,"stats":{"Line":0}},{"line":1107,"address":[3203733],"length":1,"stats":{"Line":0}},{"line":1112,"address":[5924992,5925176,5925182],"length":1,"stats":{"Line":0}},{"line":1114,"address":[6307201],"length":1,"stats":{"Line":0}},{"line":1115,"address":[6044959],"length":1,"stats":{"Line":0}},{"line":1116,"address":[6044973],"length":1,"stats":{"Line":0}},{"line":1121,"address":[5543080,5543086,5542896],"length":1,"stats":{"Line":0}},{"line":1123,"address":[5733089],"length":1,"stats":{"Line":0}},{"line":1124,"address":[3204112],"length":1,"stats":{"Line":0}},{"line":1125,"address":[5733117],"length":1,"stats":{"Line":0}},{"line":1130,"address":[5925615,5925408,5925609],"length":1,"stats":{"Line":3}},{"line":1132,"address":[6045361],"length":1,"stats":{"Line":6}},{"line":1138,"address":[3206592],"length":1,"stats":{"Line":6}},{"line":1139,"address":[5733342],"length":1,"stats":{"Line":2}},{"line":1144,"address":[5733504],"length":1,"stats":{"Line":0}},{"line":1145,"address":[5733512],"length":1,"stats":{"Line":0}},{"line":1146,"address":[3204511],"length":1,"stats":{"Line":0}},{"line":1150,"address":[3204680,3204528],"length":1,"stats":{"Line":0}},{"line":1151,"address":[5733584,5733672],"length":1,"stats":{"Line":0}},{"line":1152,"address":[5733692],"length":1,"stats":{"Line":0}},{"line":1156,"address":[3206992],"length":1,"stats":{"Line":0}},{"line":1157,"address":[5733749],"length":1,"stats":{"Line":0}},{"line":1158,"address":[3204733],"length":1,"stats":{"Line":0}},{"line":1162,"address":[6308096],"length":1,"stats":{"Line":0}},{"line":1163,"address":[5543616],"length":1,"stats":{"Line":0}},{"line":1164,"address":[5543619],"length":1,"stats":{"Line":0}},{"line":1165,"address":[3204782],"length":1,"stats":{"Line":0}},{"line":1169,"address":[3207104],"length":1,"stats":{"Line":0}},{"line":1170,"address":[5925989],"length":1,"stats":{"Line":0}},{"line":1171,"address":[5925993],"length":1,"stats":{"Line":0}},{"line":1172,"address":[5733869],"length":1,"stats":{"Line":0}},{"line":1176,"address":[3205017,3204864],"length":1,"stats":{"Line":0}},{"line":1177,"address":[5734002,5733920],"length":1,"stats":{"Line":0}},{"line":1178,"address":[6046089],"length":1,"stats":{"Line":0}},{"line":1182,"address":[5734064],"length":1,"stats":{"Line":0}},{"line":1183,"address":[5734087],"length":1,"stats":{"Line":0}},{"line":1184,"address":[5543916],"length":1,"stats":{"Line":0}},{"line":1188,"address":[3205088],"length":1,"stats":{"Line":0}},{"line":1189,"address":[6046199],"length":1,"stats":{"Line":0}},{"line":1190,"address":[5734140],"length":1,"stats":{"Line":0}},{"line":1208,"address":[5543984],"length":1,"stats":{"Line":6}},{"line":1220,"address":[5734192],"length":1,"stats":{"Line":1}},{"line":1230,"address":[6308544],"length":1,"stats":{"Line":0}},{"line":1233,"address":[3205221],"length":1,"stats":{"Line":0}},{"line":1239,"address":[5734320],"length":1,"stats":{"Line":0}},{"line":1278,"address":[6309510,6308736,6309516],"length":1,"stats":{"Line":9}},{"line":1280,"address":[6308845,6309410,6309666],"length":1,"stats":{"Line":7}},{"line":1281,"address":[5734614],"length":1,"stats":{"Line":8}},{"line":1282,"address":[3208014,3208116,3207916],"length":1,"stats":{"Line":12}},{"line":1284,"address":[3205844],"length":1,"stats":{"Line":8}},{"line":1286,"address":[5334640,5335159,5335165],"length":1,"stats":{"Line":2}},{"line":1287,"address":[5681219],"length":1,"stats":{"Line":8}},{"line":1288,"address":[3468863],"length":1,"stats":{"Line":2}},{"line":1289,"address":[5681326,5681494,5681389],"length":1,"stats":{"Line":10}},{"line":1290,"address":[5681446,5681507],"length":1,"stats":{"Line":8}},{"line":1291,"address":[5334844,5335238,5335400],"length":1,"stats":{"Line":0}},{"line":1292,"address":[5760052,5760104],"length":1,"stats":{"Line":0}},{"line":1294,"address":[5681737],"length":1,"stats":{"Line":0}},{"line":1299,"address":[3205914],"length":1,"stats":{"Line":2}},{"line":1301,"address":[3207951,3208473],"length":1,"stats":{"Line":1}},{"line":1305,"address":[5545345,5545229,5544994],"length":1,"stats":{"Line":5}},{"line":1306,"address":[6309787,6309982],"length":1,"stats":{"Line":3}},{"line":1307,"address":[5735796,5735744],"length":1,"stats":{"Line":3}},{"line":1309,"address":[5735760,5735887],"length":1,"stats":{"Line":0}},{"line":1312,"address":[6047622],"length":1,"stats":{"Line":0}},{"line":1316,"address":[3206598],"length":1,"stats":{"Line":1}},{"line":1317,"address":[6310272],"length":1,"stats":{"Line":2}},{"line":1324,"address":[3210859,3209616,3210505],"length":1,"stats":{"Line":0}},{"line":1325,"address":[3207364],"length":1,"stats":{"Line":0}},{"line":1326,"address":[5736577,5736650],"length":1,"stats":{"Line":0}},{"line":1327,"address":[5928792,5928883],"length":1,"stats":{"Line":0}},{"line":1330,"address":[6072720,6072688],"length":1,"stats":{"Line":0}},{"line":1332,"address":[5928964,5929037],"length":1,"stats":{"Line":0}},{"line":1333,"address":[5736950,5737257],"length":1,"stats":{"Line":0}},{"line":1335,"address":[5546739,5546811],"length":1,"stats":{"Line":0}},{"line":1338,"address":[6048766],"length":1,"stats":{"Line":0}},{"line":1418,"address":[3208772,3208576,3208766],"length":1,"stats":{"Line":10}},{"line":1419,"address":[5929751],"length":1,"stats":{"Line":11}},{"line":1420,"address":[5547547],"length":1,"stats":{"Line":10}},{"line":1429,"address":[5930276,5930305,5929984],"length":1,"stats":{"Line":9}},{"line":1430,"address":[3211145,3211222],"length":1,"stats":{"Line":13}},{"line":1431,"address":[3208944],"length":1,"stats":{"Line":4}},{"line":1435,"address":[3209120],"length":1,"stats":{"Line":2}},{"line":1436,"address":[3209125],"length":1,"stats":{"Line":2}},{"line":1440,"address":[5738358,5738208,5738364],"length":1,"stats":{"Line":1}},{"line":1441,"address":[6312558,6312646],"length":1,"stats":{"Line":3}},{"line":1446,"address":[5548208],"length":1,"stats":{"Line":0}},{"line":1447,"address":[3209297],"length":1,"stats":{"Line":0}},{"line":1452,"address":[3209312],"length":1,"stats":{"Line":0}},{"line":1453,"address":[3211683,3211722],"length":1,"stats":{"Line":0}},{"line":1454,"address":[3211711],"length":1,"stats":{"Line":0}}],"covered":179,"coverable":323},{"path":["/","home","imalison","Projects","lastfm-edit","src","vcr_form_data.rs"],"content":"use std::collections::HashMap;\n\n/// Parse URL-encoded form data into key-value pairs\npub fn parse_form_data(data: \u0026str) -\u003e HashMap\u003cString, String\u003e {\n    let mut params = HashMap::new();\n\n    for pair in data.split('\u0026') {\n        if let Some((key, value)) = pair.split_once('=') {\n            // URL decode the key and value\n            let decoded_key = urlencoding::decode(key).unwrap_or_else(|_| key.into());\n            let decoded_value = urlencoding::decode(value).unwrap_or_else(|_| value.into());\n            params.insert(decoded_key.to_string(), decoded_value.to_string());\n        }\n    }\n\n    params\n}\n\n/// Encode form data back to URL-encoded string\npub fn encode_form_data(params: \u0026HashMap\u003cString, String\u003e) -\u003e String {\n    params\n        .iter()\n        .map(|(key, value)| {\n            format!(\n                \"{}={}\",\n                urlencoding::encode(key),\n                urlencoding::encode(value)\n            )\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\"\u0026\")\n}\n","traces":[{"line":4,"address":[3579328,3580273,3580267],"length":1,"stats":{"Line":0}},{"line":5,"address":[3579371],"length":1,"stats":{"Line":0}},{"line":7,"address":[3579403,3579468],"length":1,"stats":{"Line":0}},{"line":8,"address":[3579696,3579639],"length":1,"stats":{"Line":0}},{"line":10,"address":[6079590],"length":1,"stats":{"Line":0}},{"line":11,"address":[3579882,3579955],"length":1,"stats":{"Line":0}},{"line":12,"address":[6079840,6079875,6080029,6079769],"length":1,"stats":{"Line":0}},{"line":16,"address":[3579668],"length":1,"stats":{"Line":0}},{"line":20,"address":[3580503,3580497,3580288],"length":1,"stats":{"Line":0}},{"line":21,"address":[6080249,6080104],"length":1,"stats":{"Line":0}},{"line":23,"address":[3563184,3563617,3563243,3563611],"length":1,"stats":{"Line":0}},{"line":24,"address":[3563290,3563398],"length":1,"stats":{"Line":0}},{"line":26,"address":[3230907],"length":1,"stats":{"Line":0}},{"line":27,"address":[3563358],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","home","imalison","Projects","lastfm-edit","src","vcr_matcher.rs"],"content":"use http_client::Request;\nuse http_client_vcr::{RequestMatcher, SerializableRequest};\nuse std::fmt::Debug;\n\n/// Last.fm Edit VCR matcher that handles authentication flows properly\n/// Ignores cookies and session-related headers that change between test runs\n#[derive(Debug)]\npub struct LastFmEditVcrMatcher {\n    match_method: bool,\n    match_url: bool,\n    match_body: bool,\n}\n\nimpl LastFmEditVcrMatcher {\n    pub fn new() -\u003e Self {\n        Self {\n            match_method: true,\n            match_url: true,\n            match_body: false,\n        }\n    }\n\n    pub fn with_body(mut self, match_body: bool) -\u003e Self {\n        self.match_body = match_body;\n        self\n    }\n}\n\nimpl RequestMatcher for LastFmEditVcrMatcher {\n    fn matches(\u0026self, request: \u0026Request, recorded_request: \u0026SerializableRequest) -\u003e bool {\n        log::debug!(\n            \"Matching request: {} {} against recorded: {} {}\",\n            request.method(),\n            request.url(),\n            recorded_request.method,\n            recorded_request.url\n        );\n\n        if self.match_method \u0026\u0026 request.method().to_string() != recorded_request.method {\n            log::debug!(\n                \"Method mismatch: {} != {}\",\n                request.method(),\n                recorded_request.method\n            );\n            return false;\n        }\n\n        if self.match_url \u0026\u0026 request.url().to_string() != recorded_request.url {\n            log::debug!(\n                \"URL mismatch: {} != {}\",\n                request.url(),\n                recorded_request.url\n            );\n            return false;\n        }\n\n        // For Last.fm, we explicitly ignore unstable headers that change between sessions\n        // This includes cookies, session tokens, CSRF tokens, and other ephemeral data\n        let unstable_headers = [\n            \"cookie\",\n            \"set-cookie\",\n            \"authorization\",\n            \"x-csrf-token\",\n            \"csrf-token\",\n            \"sessionid\",\n            \"session\",\n            \"x-session-id\",\n            \"x-auth-token\",\n            \"auth-token\",\n        ];\n\n        // Match on all headers EXCEPT the unstable ones\n        log::debug!(\"Checking headers (ignoring unstable ones)\");\n        for (header_name, recorded_values) in \u0026recorded_request.headers {\n            let header_lower = header_name.to_lowercase();\n\n            // Skip unstable headers\n            if unstable_headers\n                .iter()\n                .any(|unstable| header_lower.contains(unstable))\n            {\n                log::debug!(\"Skipping unstable header: {header_name}\");\n                continue;\n            }\n\n            let request_header = request.header(header_name.as_str());\n            log::debug!(\n                \"Comparing stable header '{header_name}': request={:?}, recorded={recorded_values:?}\",\n                request_header.map(|v| v.iter().map(|h| h.as_str()).collect::\u003cVec\u003c_\u003e\u003e())\n            );\n\n            match request_header {\n                Some(req_val) =\u003e {\n                    let req_values: Vec\u003cString\u003e =\n                        req_val.iter().map(|v| v.as_str().to_string()).collect();\n                    if \u0026req_values != recorded_values {\n                        log::debug!(\n                            \"Header '{header_name}' values mismatch: {req_values:?} != {recorded_values:?}\"\n                        );\n                        return false;\n                    }\n                }\n                None =\u003e {\n                    // If the recorded request has a header but the current request doesn't,\n                    // that's a mismatch (unless it's an unstable header we're ignoring)\n                    log::debug!(\"Header '{header_name}' missing from request\");\n                    return false;\n                }\n            }\n        }\n\n        log::debug!(\"Request matched successfully\");\n\n        true\n    }\n\n    fn matches_serializable(\n        \u0026self,\n        request: \u0026SerializableRequest,\n        recorded_request: \u0026SerializableRequest,\n    ) -\u003e bool {\n        log::debug!(\n            \"Matching serializable request: {} {} vs {} {}\",\n            request.method,\n            request.url,\n            recorded_request.method,\n            recorded_request.url\n        );\n        if self.match_method \u0026\u0026 request.method != recorded_request.method {\n            return false;\n        }\n\n        if self.match_url \u0026\u0026 request.url != recorded_request.url {\n            return false;\n        }\n\n        // Same logic as above - ignore unstable headers\n        let unstable_headers = [\n            \"cookie\",\n            \"set-cookie\",\n            \"authorization\",\n            \"x-csrf-token\",\n            \"csrf-token\",\n            \"sessionid\",\n            \"session\",\n            \"x-session-id\",\n            \"x-auth-token\",\n            \"auth-token\",\n        ];\n\n        // Match on all headers EXCEPT the unstable ones\n        log::debug!(\n            \"Checking {} recorded headers\",\n            recorded_request.headers.len()\n        );\n        for (header_name, recorded_values) in \u0026recorded_request.headers {\n            let header_lower = header_name.to_lowercase();\n\n            // Skip unstable headers\n            if unstable_headers\n                .iter()\n                .any(|unstable| header_lower.contains(unstable))\n            {\n                log::debug!(\"Skipping unstable header: {header_name}\");\n                continue;\n            }\n\n            log::debug!(\"Checking stable header: {header_name} = {recorded_values:?}\");\n\n            let request_header = request.headers.get(header_name);\n\n            match request_header {\n                Some(req_values) =\u003e {\n                    log::debug!(\n                        \"Comparing header '{header_name}': request={req_values:?} vs recorded={recorded_values:?}\"\n                    );\n                    if req_values != recorded_values {\n                        log::debug!(\n                            \"Header '{header_name}' MISMATCH! request={req_values:?} != {recorded_values:?}\"\n                        );\n                        return false;\n                    }\n                }\n                None =\u003e {\n                    // Some headers like content-type are automatically added by HTTP clients\n                    // but may not be present during replay. For GET requests, content-type is often optional.\n                    if header_name.to_lowercase() == \"content-type\" \u0026\u0026 request.method == \"GET\" {\n                        log::debug!(\"Ignoring missing content-type header for GET request\");\n                        continue;\n                    }\n\n                    // If the recorded request has a header but the current request doesn't,\n                    // that's a mismatch (unless it's an unstable header we're ignoring)\n                    log::debug!(\n                        \"Header '{header_name}' missing from current request (recorded has: {recorded_values:?})\"\n                    );\n                    return false;\n                }\n            }\n        }\n\n        true\n    }\n}\n\nimpl Default for LastFmEditVcrMatcher {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[{"line":23,"address":[3245040],"length":1,"stats":{"Line":0}},{"line":24,"address":[5497549],"length":1,"stats":{"Line":0}},{"line":25,"address":[3245089],"length":1,"stats":{"Line":0}},{"line":30,"address":[3245136,3249251,3248949],"length":1,"stats":{"Line":0}},{"line":31,"address":[3245342],"length":1,"stats":{"Line":0}},{"line":39,"address":[3245724,3245236],"length":1,"stats":{"Line":0}},{"line":40,"address":[5502084,5502146,5498361],"length":1,"stats":{"Line":0}},{"line":45,"address":[3249591],"length":1,"stats":{"Line":0}},{"line":48,"address":[5498165,5498731],"length":1,"stats":{"Line":0}},{"line":49,"address":[3246432,3249340,3249277],"length":1,"stats":{"Line":0}},{"line":54,"address":[5501744],"length":1,"stats":{"Line":0}},{"line":59,"address":[3245943],"length":1,"stats":{"Line":0}},{"line":73,"address":[5498999,5498677],"length":1,"stats":{"Line":0}},{"line":74,"address":[5499171,5498950],"length":1,"stats":{"Line":0}},{"line":75,"address":[3246800],"length":1,"stats":{"Line":0}},{"line":78,"address":[3247175,3246833],"length":1,"stats":{"Line":0}},{"line":80,"address":[3254480,3254498],"length":1,"stats":{"Line":0}},{"line":82,"address":[3248962,3248987,3247265],"length":1,"stats":{"Line":0}},{"line":86,"address":[3247337,3247234],"length":1,"stats":{"Line":0}},{"line":87,"address":[6052656,6052681,6052777,6052752],"length":1,"stats":{"Line":0}},{"line":92,"address":[3247418],"length":1,"stats":{"Line":0}},{"line":93,"address":[3247942],"length":1,"stats":{"Line":0}},{"line":94,"address":[5834176,5834211],"length":1,"stats":{"Line":0}},{"line":96,"address":[5500951,5500864],"length":1,"stats":{"Line":0}},{"line":97,"address":[3248561,3248597,3248496],"length":1,"stats":{"Line":0}},{"line":100,"address":[3248567],"length":1,"stats":{"Line":0}},{"line":106,"address":[3248045,3247980],"length":1,"stats":{"Line":0}},{"line":107,"address":[3248032],"length":1,"stats":{"Line":0}},{"line":112,"address":[3246876,3246926],"length":1,"stats":{"Line":0}},{"line":114,"address":[3246913],"length":1,"stats":{"Line":0}},{"line":117,"address":[3253004,3249920,3254138],"length":1,"stats":{"Line":1}},{"line":122,"address":[3249975,3250034],"length":1,"stats":{"Line":2}},{"line":129,"address":[3250020,3250474],"length":1,"stats":{"Line":2}},{"line":130,"address":[5502966],"length":1,"stats":{"Line":0}},{"line":133,"address":[5502926,5503304],"length":1,"stats":{"Line":2}},{"line":134,"address":[5503327],"length":1,"stats":{"Line":0}},{"line":138,"address":[5502979],"length":1,"stats":{"Line":1}},{"line":152,"address":[5503446],"length":1,"stats":{"Line":0}},{"line":156,"address":[3250868,3251176],"length":1,"stats":{"Line":2}},{"line":157,"address":[3251269],"length":1,"stats":{"Line":1}},{"line":160,"address":[3251302,3251427],"length":1,"stats":{"Line":2}},{"line":162,"address":[5834256,5834274],"length":1,"stats":{"Line":2}},{"line":164,"address":[3251531,3253862],"length":1,"stats":{"Line":13}},{"line":168,"address":[3251586,3251634,3251486],"length":1,"stats":{"Line":3}},{"line":170,"address":[5504085,5504454],"length":1,"stats":{"Line":2}},{"line":172,"address":[5504462],"length":1,"stats":{"Line":1}},{"line":173,"address":[3252008],"length":1,"stats":{"Line":1}},{"line":174,"address":[3252024,3253017,3253057],"length":1,"stats":{"Line":3}},{"line":177,"address":[5505898,5505508],"length":1,"stats":{"Line":2}},{"line":178,"address":[5505923,5505988],"length":1,"stats":{"Line":0}},{"line":181,"address":[3253490],"length":1,"stats":{"Line":0}},{"line":187,"address":[3252072,3252315],"length":1,"stats":{"Line":2}},{"line":188,"address":[3252789,3252349,3252764],"length":1,"stats":{"Line":3}},{"line":194,"address":[3252262,3252423,3252404],"length":1,"stats":{"Line":0}},{"line":197,"address":[3252410],"length":1,"stats":{"Line":0}},{"line":202,"address":[3251342],"length":1,"stats":{"Line":1}},{"line":207,"address":[3254160],"length":1,"stats":{"Line":0}},{"line":208,"address":[3254161],"length":1,"stats":{"Line":0}}],"covered":19,"coverable":58},{"path":["/","home","imalison","Projects","lastfm-edit","src","vcr_test_utils.rs"],"content":"use crate::vcr_form_data::{encode_form_data, parse_form_data};\nuse http_client_vcr::{Filter, FilterChain, SerializableRequest, SerializableResponse};\n\n/// Last.fm-specific utilities for test cassette management.\n/// These helpers understand the Last.fm authentication flow and handle credential replacement appropriately.\n/// A custom filter that only filters passwords while preserving usernames and CSRF tokens\n#[derive(Debug)]\npub struct LastFmPasswordOnlyFilter;\n\nimpl Filter for LastFmPasswordOnlyFilter {\n    fn filter_request(\u0026self, request: \u0026mut SerializableRequest) {\n        // Filter passwords in form data\n        if let Some(body) = \u0026mut request.body {\n            if body.contains('=') \u0026\u0026 (body.contains('\u0026') || !body.contains(' ')) {\n                let mut params = parse_form_data(body);\n\n                // Only filter password field - keep username and CSRF token for request matching\n                if params.contains_key(\"password\") {\n                    params.insert(\"password\".to_string(), \"test_password\".to_string());\n                    *body = encode_form_data(\u0026params);\n                }\n            }\n        }\n\n        // Filter session cookies in request headers\n        if let Some(cookie_values) = request.headers.get_mut(\"cookie\") {\n            for cookie_header in cookie_values.iter_mut() {\n                *cookie_header = self.filter_session_cookies(cookie_header);\n            }\n        }\n    }\n\n    fn filter_response(\u0026self, response: \u0026mut SerializableResponse) {\n        // Filter session cookies in response set-cookie headers\n        if let Some(set_cookie_values) = response.headers.get_mut(\"set-cookie\") {\n            for set_cookie_header in set_cookie_values.iter_mut() {\n                if set_cookie_header.contains(\"sessionid=\") {\n                    *set_cookie_header = self.filter_set_cookie_session(set_cookie_header);\n                }\n            }\n        }\n    }\n}\n\nimpl LastFmPasswordOnlyFilter {\n    /// Filter session cookies from a cookie header string\n    fn filter_session_cookies(\u0026self, cookie_header: \u0026str) -\u003e String {\n        let mut filtered_cookies = Vec::new();\n\n        for cookie in cookie_header.split(';') {\n            let cookie = cookie.trim();\n            if cookie.starts_with(\"sessionid=\") {\n                // Replace session ID with test value\n                filtered_cookies.push(\"sessionid=test_session_id\");\n            } else {\n                filtered_cookies.push(cookie);\n            }\n        }\n\n        filtered_cookies.join(\"; \")\n    }\n\n    /// Filter session cookies from a set-cookie header string\n    fn filter_set_cookie_session(\u0026self, set_cookie_header: \u0026str) -\u003e String {\n        if set_cookie_header.starts_with(\"sessionid=\") {\n            // Extract everything after the session value up to the first semicolon or end\n            if let Some(semicolon_pos) = set_cookie_header.find(';') {\n                let attributes = \u0026set_cookie_header[semicolon_pos..];\n                format!(\"sessionid=test_session_id{attributes}\")\n            } else {\n                \"sessionid=test_session_id\".to_string()\n            }\n        } else {\n            set_cookie_header.to_string()\n        }\n    }\n}\n\n/// Create a Last.fm test filter chain that:\n/// - Keeps usernames and CSRF tokens intact (needed for proper request matching)\n/// - Filters passwords from request bodies with predictable test values\n/// - Filters session tokens with predictable test values\npub fn create_lastfm_test_filter_chain() -\u003e Result\u003cFilterChain, regex::Error\u003e {\n    let filter_chain = FilterChain::new().add_filter(Box::new(LastFmPasswordOnlyFilter));\n    Ok(filter_chain)\n}\n","traces":[{"line":11,"address":[5992528,5993279,5993285],"length":1,"stats":{"Line":0}},{"line":13,"address":[3062497],"length":1,"stats":{"Line":0}},{"line":14,"address":[3062563,3062668],"length":1,"stats":{"Line":0}},{"line":15,"address":[3062734],"length":1,"stats":{"Line":0}},{"line":18,"address":[5992831,5992903,5993252],"length":1,"stats":{"Line":0}},{"line":19,"address":[3063180,3062852,3062922],"length":1,"stats":{"Line":0}},{"line":20,"address":[3063045,3063073],"length":1,"stats":{"Line":0}},{"line":26,"address":[3062594,3063221],"length":1,"stats":{"Line":0}},{"line":27,"address":[3063291,3063523,3063237],"length":1,"stats":{"Line":0}},{"line":28,"address":[3063364,3063421],"length":1,"stats":{"Line":0}},{"line":33,"address":[3063536,3063859],"length":1,"stats":{"Line":0}},{"line":35,"address":[3063571],"length":1,"stats":{"Line":0}},{"line":36,"address":[3063635,3063683],"length":1,"stats":{"Line":0}},{"line":37,"address":[3063919,3063741],"length":1,"stats":{"Line":0}},{"line":38,"address":[3063781,3063893,3063833],"length":1,"stats":{"Line":0}},{"line":47,"address":[3063936,3064506,3064512],"length":1,"stats":{"Line":0}},{"line":48,"address":[3063987],"length":1,"stats":{"Line":0}},{"line":50,"address":[3064011,3064076],"length":1,"stats":{"Line":0}},{"line":51,"address":[5994443,5994327],"length":1,"stats":{"Line":0}},{"line":52,"address":[3064391],"length":1,"stats":{"Line":0}},{"line":54,"address":[5994585,5994545],"length":1,"stats":{"Line":0}},{"line":56,"address":[3064496,3064438],"length":1,"stats":{"Line":0}},{"line":60,"address":[5994344],"length":1,"stats":{"Line":0}},{"line":64,"address":[3064528],"length":1,"stats":{"Line":0}},{"line":65,"address":[3064593],"length":1,"stats":{"Line":0}},{"line":67,"address":[3064646,3064705],"length":1,"stats":{"Line":0}},{"line":68,"address":[3064718],"length":1,"stats":{"Line":0}},{"line":69,"address":[3064741],"length":1,"stats":{"Line":0}},{"line":71,"address":[3064859],"length":1,"stats":{"Line":0}},{"line":74,"address":[3064629],"length":1,"stats":{"Line":0}},{"line":83,"address":[3064896,3065063,3065089],"length":1,"stats":{"Line":0}},{"line":84,"address":[3064946,3064910,3065073],"length":1,"stats":{"Line":0}},{"line":85,"address":[3065024],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":33},{"path":["/","home","imalison","Projects","lastfm-edit","tests","event_broadcasting.rs"],"content":"use http_client_vcr::NoOpClient;\nuse lastfm_edit::{LastFmEditClientImpl, LastFmEditSession};\nuse std::time::Duration;\nuse tokio::time::timeout;\n\nfn create_test_session() -\u003e LastFmEditSession {\n    LastFmEditSession::new(\n        \"test_user\".to_string(),\n        vec![\"sessionid=.test_session_id_12345\".to_string()],\n        Some(\"test_csrf_token\".to_string()),\n        \"https://www.last.fm\".to_string(),\n    )\n}\n\n#[test_log::test(tokio::test)]\nasync fn test_shared_broadcaster_across_clients() {\n    // Create the first client\n    let http_client1 = NoOpClient::new();\n    let client1 = LastFmEditClientImpl::from_session(Box::new(http_client1), create_test_session());\n\n    // Create second client that shares the broadcaster with client1\n    let http_client2 = NoOpClient::new();\n    let client2 = client1.with_shared_broadcaster(Box::new(http_client2));\n\n    // Create third client with independent broadcaster\n    let http_client3 = NoOpClient::new();\n    let session = client1.get_session();\n    let client3 = LastFmEditClientImpl::from_session(Box::new(http_client3), session);\n\n    // Subscribe to events from all clients\n    let mut events1 = client1.subscribe();\n    let mut events2 = client2.subscribe();\n    let mut events3 = client3.subscribe();\n\n    // Test that clients start with no events\n    assert!(client1.latest_event().is_none());\n    assert!(client2.latest_event().is_none());\n    assert!(client3.latest_event().is_none());\n\n    // In a real scenario, rate limit events would be broadcast automatically\n    // when HTTP requests encounter rate limiting. Since we can't easily simulate\n    // that in a unit test, we verify the structure is correct by checking that:\n\n    // 1. Clients with shared broadcasters have the same latest event state\n    // 2. Clients with independent broadcasters maintain separate state\n\n    // For now, we can only test that the event subscriptions are properly set up\n    // and that no events are present initially (which is correct)\n\n    // Test that subscriptions don't immediately have events\n    let no_event_1 = timeout(Duration::from_millis(10), events1.recv()).await;\n    let no_event_2 = timeout(Duration::from_millis(10), events2.recv()).await;\n    let no_event_3 = timeout(Duration::from_millis(10), events3.recv()).await;\n\n    // All should timeout (no events received)\n    assert!(no_event_1.is_err());\n    assert!(no_event_2.is_err());\n    assert!(no_event_3.is_err());\n}\n\n#[test_log::test(tokio::test)]\nasync fn test_session_sharing_vs_broadcaster_sharing() {\n    // Create first client\n    let http_client1 = NoOpClient::new();\n    let client1 = LastFmEditClientImpl::from_session(Box::new(http_client1), create_test_session());\n\n    // Client2: shares session but NOT broadcaster\n    let http_client2 = NoOpClient::new();\n    let session = client1.get_session();\n    let client2 = LastFmEditClientImpl::from_session(Box::new(http_client2), session);\n\n    // Client3: shares BOTH session and broadcaster\n    let http_client3 = NoOpClient::new();\n    let client3 = client1.with_shared_broadcaster(Box::new(http_client3));\n\n    // Verify session sharing\n    assert_eq!(\n        client1.get_session().base_url,\n        client2.get_session().base_url\n    );\n    assert_eq!(\n        client1.get_session().base_url,\n        client3.get_session().base_url\n    );\n\n    // All clients should start with no events\n    assert!(client1.latest_event().is_none());\n    assert!(client2.latest_event().is_none());\n    assert!(client3.latest_event().is_none());\n\n    // Subscribe to verify broadcast setup\n    let _events1 = client1.subscribe();\n    let _events2 = client2.subscribe();\n    let _events3 = client3.subscribe();\n\n    // Test passes if no panics occur - the broadcaster sharing is working correctly\n    // In real usage, when client1 or client3 encounter rate limits, both would see the events\n    // while client2 would not (since it has an independent broadcaster)\n}\n\n#[test_log::test]\nfn test_client_creation_patterns() {\n    // Pattern 1: Independent clients\n    let http_client1 = NoOpClient::new();\n    let client1 = LastFmEditClientImpl::from_session(Box::new(http_client1), create_test_session());\n\n    let http_client2 = NoOpClient::new();\n    let session = client1.get_session();\n    let client2 = LastFmEditClientImpl::from_session(Box::new(http_client2), session);\n\n    // These should be independent - same session but different broadcasters\n    assert_eq!(\n        client1.get_session().base_url,\n        client2.get_session().base_url\n    );\n\n    // Pattern 2: Shared broadcaster\n    let http_client3 = NoOpClient::new();\n    let client3 = client1.with_shared_broadcaster(Box::new(http_client3));\n\n    // These should share both session and broadcaster\n    assert_eq!(\n        client1.get_session().base_url,\n        client3.get_session().base_url\n    );\n\n    // Test that we can create subscriptions without issues\n    let _sub1 = client1.subscribe();\n    let _sub2 = client2.subscribe();\n    let _sub3 = client3.subscribe();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","tests","mock_client.rs"],"content":"#[cfg(feature = \"mock\")]\nmod mock_tests {\n    use lastfm_edit::{\n        Album, AlbumPage, EditResponse, ExactScrobbleEdit, LastFmEditClient, MockLastFmEditClient,\n        Result, ScrobbleEdit, Track, TrackPage,\n    };\n    use mockall::predicate::*; // for eq(), any(), etc.\n\n    #[test_log::test(tokio::test)]\n    async fn test_mock_basic_functionality() -\u003e Result\u003c()\u003e {\n        let mut mock_client = MockLastFmEditClient::new();\n\n        mock_client\n            .expect_username()\n            .times(1)\n            .returning(|| \"testuser\".to_string());\n\n        // Use the mock as a trait object\n        let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n\n        // Test username retrieval\n        assert_eq!(client.username(), \"testuser\");\n\n        Ok(())\n    }\n\n    #[test_log::test(tokio::test)]\n    async fn test_mock_edit_scrobble() -\u003e Result\u003c()\u003e {\n        let mut mock_client = MockLastFmEditClient::new();\n\n        let edit = ScrobbleEdit::new(\n            Some(\"Old Track\".to_string()),\n            Some(\"Old Album\".to_string()),\n            \"Old Artist\".to_string(),\n            Some(\"Old Artist\".to_string()),\n            Some(\"New Track\".to_string()),\n            Some(\"New Album\".to_string()),\n            \"New Artist\".to_string(),\n            Some(\"New Artist\".to_string()),\n            Some(1640995200),\n            false,\n        );\n\n        let expected_exact_edit = ExactScrobbleEdit::new(\n            \"Old Track\".to_string(),\n            \"Old Album\".to_string(),\n            \"Old Artist\".to_string(),\n            \"Old Artist\".to_string(),\n            \"New Track\".to_string(),\n            \"New Album\".to_string(),\n            \"New Artist\".to_string(),\n            \"New Artist\".to_string(),\n            1640995200,\n            false,\n        );\n\n        let expected_response = EditResponse::single(\n            true,\n            Some(\"Edit completed successfully\".to_string()),\n            None,\n            expected_exact_edit,\n        );\n\n        // Set up expectation for edit_scrobble\n        mock_client\n            .expect_edit_scrobble()\n            .with(eq(edit.clone()))\n            .times(1)\n            .returning(move |_| Ok(expected_response.clone()));\n\n        // Use the mock\n        let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n        let response = client.edit_scrobble(\u0026edit).await?;\n\n        assert!(response.success());\n        assert_eq!(\n            response.message(),\n            Some(\"Edit completed successfully\".to_string())\n        );\n\n        Ok(())\n    }\n\n    #[test_log::test(tokio::test)]\n    async fn test_mock_get_recent_scrobbles() -\u003e Result\u003c()\u003e {\n        let mut mock_client = MockLastFmEditClient::new();\n\n        let expected_tracks = vec![\n            Track {\n                name: \"Test Track 1\".to_string(),\n                artist: \"Test Artist 1\".to_string(),\n                album: Some(\"Test Album 1\".to_string()),\n                album_artist: Some(\"Test Artist 1\".to_string()),\n                playcount: 5,\n                timestamp: Some(1640995200),\n            },\n            Track {\n                name: \"Test Track 2\".to_string(),\n                artist: \"Test Artist 2\".to_string(),\n                album: Some(\"Test Album 2\".to_string()),\n                album_artist: Some(\"Test Artist 2\".to_string()),\n                playcount: 3,\n                timestamp: Some(1640995100),\n            },\n        ];\n\n        // Set up expectation\n        mock_client\n            .expect_get_recent_tracks_page()\n            .with(eq(1))\n            .times(1)\n            .returning(move |page| {\n                Ok(TrackPage {\n                    tracks: expected_tracks.clone(),\n                    page_number: page,\n                    has_next_page: false,\n                    total_pages: Some(1),\n                })\n            });\n\n        // Use the mock\n        let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n        let page = client.get_recent_tracks_page(1).await?;\n\n        assert_eq!(page.tracks.len(), 2);\n        assert_eq!(page.tracks[0].name, \"Test Track 1\");\n        assert_eq!(page.tracks[1].name, \"Test Track 2\");\n        assert_eq!(page.page_number, 1);\n\n        Ok(())\n    }\n\n    #[test_log::test(tokio::test)]\n    async fn test_mock_iterator_concept() -\u003e Result\u003c()\u003e {\n        // Note: Due to Rust's lifetime system, mocking iterators that borrow from\n        // the client is complex. In practice, you would typically mock the underlying\n        // pagination methods (like get_artist_tracks_page) rather than the iterators themselves.\n\n        let mut mock_client = MockLastFmEditClient::new();\n\n        // Mock the underlying pagination method that iterators use\n        mock_client\n            .expect_get_artist_tracks_page()\n            .with(eq(\"test_artist\"), eq(1))\n            .returning(|_, _| {\n                Ok(TrackPage {\n                    tracks: vec![Track {\n                        name: \"Mocked Track\".to_string(),\n                        artist: \"Mocked Artist\".to_string(),\n                        album: Some(\"Mocked Album\".to_string()),\n                        album_artist: Some(\"Mocked Artist\".to_string()),\n                        playcount: 10,\n                        timestamp: Some(1640995200),\n                    }],\n                    page_number: 1,\n                    has_next_page: false,\n                    total_pages: Some(1),\n                })\n            });\n\n        let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n\n        // Test that the underlying method works correctly\n        let page = client.get_artist_tracks_page(\"test_artist\", 1).await?;\n        assert_eq!(page.tracks.len(), 1);\n        assert_eq!(page.tracks[0].name, \"Mocked Track\");\n\n        Ok(())\n    }\n\n    #[test_log::test(tokio::test)]\n    async fn test_mock_iterator_trait_objects() -\u003e Result\u003c()\u003e {\n        // This test demonstrates that iterator methods return trait objects\n        // that can be used polymorphically, even though mocking the iterators\n        // themselves is complex due to lifetime constraints.\n\n        let mut mock_client = MockLastFmEditClient::new();\n\n        // Mock the underlying methods that the iterators use\n        mock_client\n            .expect_get_artist_tracks_page()\n            .with(eq(\"test_artist\"), eq(1))\n            .returning(|_, _| {\n                Ok(TrackPage {\n                    tracks: vec![Track {\n                        name: \"Iterator Track 1\".to_string(),\n                        artist: \"test_artist\".to_string(),\n                        album: Some(\"Test Album\".to_string()),\n                        album_artist: Some(\"test_artist\".to_string()),\n                        playcount: 5,\n                        timestamp: Some(1640995200),\n                    }],\n                    page_number: 1,\n                    has_next_page: false,\n                    total_pages: Some(1),\n                })\n            });\n\n        mock_client\n            .expect_get_recent_tracks_page()\n            .with(eq(1))\n            .returning(|page| {\n                Ok(TrackPage {\n                    tracks: vec![Track {\n                        name: \"Recent Track 1\".to_string(),\n                        artist: \"Recent Artist\".to_string(),\n                        album: Some(\"Recent Album\".to_string()),\n                        album_artist: Some(\"Recent Artist\".to_string()),\n                        playcount: 1,\n                        timestamp: Some(1640995300),\n                    }],\n                    page_number: page,\n                    has_next_page: false,\n                    total_pages: Some(1),\n                })\n            });\n\n        mock_client\n            .expect_get_artist_albums_page()\n            .with(eq(\"test_artist\"), eq(1))\n            .returning(|_, _| {\n                Ok(AlbumPage {\n                    albums: vec![Album {\n                        name: \"Test Album\".to_string(),\n                        artist: \"test_artist\".to_string(),\n                        playcount: 10,\n                        timestamp: Some(1640995200),\n                    }],\n                    page_number: 1,\n                    has_next_page: false,\n                    total_pages: Some(1),\n                })\n            });\n\n        let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n\n        // Note: Iterator methods are now implemented on the concrete client type,\n        // not the trait. For testing purposes, we can cast back to the concrete type.\n        // In real code, you would typically create iterators using the concrete client.\n\n        // This demonstrates that the underlying pagination methods work\n        let tracks_page = client.get_artist_tracks_page(\"test_artist\", 1).await?;\n        assert_eq!(tracks_page.tracks.len(), 1);\n        assert_eq!(tracks_page.tracks[0].name, \"Iterator Track 1\");\n\n        let recent_page = client.get_recent_tracks_page(1).await?;\n        assert_eq!(recent_page.tracks.len(), 1);\n        assert_eq!(recent_page.tracks[0].name, \"Recent Track 1\");\n\n        let albums_page = client.get_artist_albums_page(\"test_artist\", 1).await?;\n        assert_eq!(albums_page.albums.len(), 1);\n        assert_eq!(albums_page.albums[0].name, \"Test Album\");\n\n        Ok(())\n    }\n}\n\n#[cfg(not(feature = \"mock\"))]\nmod no_mock_tests {\n    #[test]\n    fn test_mock_feature_disabled() {\n        // This test ensures the code compiles even when the mock feature is disabled\n        log::debug!(\"Mock feature is disabled - MockLastFmEditClient is not available\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","tests","parsing_send_sync.rs"],"content":"use http_client_vcr::NoOpClient;\nuse lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession};\n\nfn create_test_session() -\u003e LastFmEditSession {\n    LastFmEditSession::new(\n        \"test_user\".to_string(),\n        vec![\"sessionid=.test_session_id_12345\".to_string()],\n        Some(\"test_csrf_token\".to_string()),\n        \"https://www.last.fm\".to_string(),\n    )\n}\n\n/// Test to check if the parsing methods (non-async) are Send + Sync\n#[test_log::test]\nfn test_parsing_methods_are_send_sync() {\n    fn assert_send_sync\u003cT: Send + Sync\u003e(_: T) {}\n\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // Test that the client itself is Send + Sync (should be now that parsing is separate)\n    assert_send_sync(lastfm_client);\n}\n\n/// Test just the iterator creation without calling next() to isolate HTTP client issues\n#[test_log::test]\nfn test_iterator_creation_is_send_sync() {\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // Create iterators one at a time to avoid borrowing issues\n    let recent_tracks = lastfm_client.recent_tracks();\n    drop(recent_tracks);\n\n    let artist_tracks = lastfm_client.artist_tracks(\"test\");\n    drop(artist_tracks);\n\n    let artist_albums = lastfm_client.artist_albums(\"test\");\n    drop(artist_albums);\n}\n\n/// Test that the client itself is Send + Sync (structure-wise)\n#[test_log::test]\nfn test_client_is_send_sync() {\n    fn assert_send_sync\u003cT: Send + Sync + 'static\u003e(_: T) {}\n\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // The client should be Send + Sync at the structural level\n    assert_send_sync(lastfm_client);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","tests","thread_safety.rs"],"content":"use http_client_vcr::NoOpClient;\nuse lastfm_edit::{LastFmEditClientImpl, LastFmEditSession};\n\nfn create_test_session() -\u003e LastFmEditSession {\n    LastFmEditSession::new(\n        \"test_user\".to_string(),\n        vec![\"sessionid=.test_session_id_12345\".to_string()],\n        Some(\"test_csrf_token\".to_string()),\n        \"https://www.last.fm\".to_string(),\n    )\n}\n\n/// Test that futures from client operations are Send.\n/// This ensures they can be used across await boundaries in async contexts.\n#[test_log::test(tokio::test)]\nasync fn test_client_futures_are_send() {\n    fn assert_send\u003cT: Send\u003e(_: T) {}\n\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // Test that client get_recent_tracks_page future is Send\n    let get_recent_tracks_future = lastfm_client.get_recent_tracks_page(1);\n    assert_send(get_recent_tracks_future);\n\n    // Test that client get_artist_tracks_page future is Send\n    let get_tracks_future = lastfm_client.get_artist_tracks_page(\"test\", 1);\n    assert_send(get_tracks_future);\n}\n\n/// Test that iterator futures are Send.\n/// This ensures they can be used across await boundaries.\n/// Note: Current iterator implementation holds references to the client,\n/// so they are not Send. This is intentional for lifetime safety.\n#[test_log::test(tokio::test)]\nasync fn test_iterator_futures_are_send() {\n    // This test is commented out because iterators now hold references\n    // to the client, making them not Send. This is expected behavior.\n\n    // To use iterators across threads, create the iterator on the same\n    // thread where it will be used, or use the underlying pagination\n    // methods directly which are Send.\n}\n\n/// Test that we can spawn tasks with these futures.\n/// This is the most important practical test - futures must be Send to use with tokio::spawn.\n#[test_log::test(tokio::test)]\nasync fn test_futures_can_be_spawned() {\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // This should compile if futures are Send\n    let handle = tokio::spawn(async move {\n        let _ = lastfm_client.get_recent_tracks_page(1).await;\n        let _ = lastfm_client.get_artist_tracks_page(\"test\", 1).await;\n    });\n\n    // Don't actually await the handle since it will fail without proper credentials\n    handle.abort();\n}\n\n/// Test that pagination methods work across await boundaries.\n/// Note: Iterators are not Send due to holding client references.\n/// Use pagination methods directly for Send behavior.\n#[test_log::test(tokio::test)]\nasync fn test_pagination_methods_across_await_boundaries() {\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // This demonstrates using the underlying pagination methods which are Send\n    let handle = tokio::spawn(async move {\n        // Simulate some async work\n        tokio::time::sleep(std::time::Duration::from_millis(1)).await;\n\n        // Use pagination methods directly - these are Send\n        let _ = lastfm_client.get_recent_tracks_page(1).await;\n        let _ = lastfm_client.get_artist_tracks_page(\"test\", 1).await;\n    });\n\n    // Don't actually await since it will fail without credentials\n    handle.abort();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","tests","types.rs"],"content":"use lastfm_edit::types::{Album, Artist, ExactScrobbleEdit, ScrobbleEdit, Track};\n\n#[test]\nfn test_display_implementations() {\n    // Test Artist Display\n    let artist = Artist {\n        name: \"The Beatles\".to_string(),\n        playcount: 100,\n        timestamp: Some(1234567890),\n    };\n    assert_eq!(format!(\"{artist}\"), \"The Beatles\");\n\n    // Test Album Display\n    let album = Album {\n        name: \"Abbey Road\".to_string(),\n        artist: \"The Beatles\".to_string(),\n        playcount: 50,\n        timestamp: Some(1234567890),\n    };\n    assert_eq!(format!(\"{album}\"), \"The Beatles - Abbey Road\");\n\n    // Test Track Display with album\n    let track_with_album = Track {\n        name: \"Come Together\".to_string(),\n        artist: \"The Beatles\".to_string(),\n        playcount: 10,\n        timestamp: Some(1234567890),\n        album: Some(\"Abbey Road\".to_string()),\n        album_artist: None,\n    };\n    assert_eq!(\n        format!(\"{track_with_album}\"),\n        \"The Beatles - Come Together [Abbey Road]\"\n    );\n\n    // Test Track Display without album\n    let track_without_album = Track {\n        name: \"Yesterday\".to_string(),\n        artist: \"The Beatles\".to_string(),\n        playcount: 15,\n        timestamp: Some(1234567890),\n        album: None,\n        album_artist: None,\n    };\n    assert_eq!(format!(\"{track_without_album}\"), \"The Beatles - Yesterday\");\n\n    // Test ScrobbleEdit Display - no changes\n    let no_changes_edit = ScrobbleEdit {\n        track_name_original: Some(\"Yesterday\".to_string()),\n        album_name_original: Some(\"Help!\".to_string()),\n        artist_name_original: \"The Beatles\".to_string(),\n        album_artist_name_original: None,\n        track_name: Some(\"Yesterday\".to_string()),\n        album_name: Some(\"Help!\".to_string()),\n        artist_name: \"The Beatles\".to_string(),\n        album_artist_name: None,\n        timestamp: Some(1234567890),\n        edit_all: false,\n    };\n    assert_eq!(format!(\"{no_changes_edit}\"), \"No changes\");\n\n    // Test ScrobbleEdit Display - artist change only\n    let artist_edit = ScrobbleEdit {\n        track_name_original: Some(\"Yesterday\".to_string()),\n        album_name_original: Some(\"Help!\".to_string()),\n        artist_name_original: \"The Beatles\".to_string(),\n        album_artist_name_original: None,\n        track_name: Some(\"Yesterday\".to_string()),\n        album_name: Some(\"Help!\".to_string()),\n        artist_name: \"Beatles, The\".to_string(),\n        album_artist_name: None,\n        timestamp: Some(1234567890),\n        edit_all: false,\n    };\n    assert_eq!(\n        format!(\"{artist_edit}\"),\n        \"Artist: The Beatles → Beatles, The\"\n    );\n\n    // Test ScrobbleEdit Display - multiple field changes\n    let multi_edit = ScrobbleEdit {\n        track_name_original: Some(\"Yesterday\".to_string()),\n        album_name_original: Some(\"Help!\".to_string()),\n        artist_name_original: \"The Beatles\".to_string(),\n        album_artist_name_original: None,\n        track_name: Some(\"Yesterday (Remastered)\".to_string()),\n        album_name: Some(\"Help! (Deluxe Edition)\".to_string()),\n        artist_name: \"Beatles, The\".to_string(),\n        album_artist_name: None,\n        timestamp: Some(1234567890),\n        edit_all: false,\n    };\n    assert_eq!(format!(\"{multi_edit}\"), \"Artist: The Beatles → Beatles, The, Track: Yesterday → Yesterday (Remastered), Album: Help! → Help! (Deluxe Edition)\");\n\n    // Test ScrobbleEdit Display - with edit_all flag\n    let edit_all = ScrobbleEdit {\n        track_name_original: Some(\"Yesterday\".to_string()),\n        album_name_original: Some(\"Help!\".to_string()),\n        artist_name_original: \"The Beatles\".to_string(),\n        album_artist_name_original: None,\n        track_name: Some(\"Yesterday\".to_string()),\n        album_name: Some(\"Help!\".to_string()),\n        artist_name: \"Beatles, The\".to_string(),\n        album_artist_name: None,\n        timestamp: Some(1234567890),\n        edit_all: true,\n    };\n    assert_eq!(\n        format!(\"{edit_all}\"),\n        \"Artist: The Beatles → Beatles, The (all instances)\"\n    );\n\n    // Test ExactScrobbleEdit Display - no changes\n    let exact_no_changes = ExactScrobbleEdit {\n        track_name_original: \"Yesterday\".to_string(),\n        album_name_original: \"Help!\".to_string(),\n        artist_name_original: \"The Beatles\".to_string(),\n        album_artist_name_original: \"The Beatles\".to_string(),\n        track_name: \"Yesterday\".to_string(),\n        album_name: \"Help!\".to_string(),\n        artist_name: \"The Beatles\".to_string(),\n        album_artist_name: \"The Beatles\".to_string(),\n        timestamp: 1234567890,\n        edit_all: false,\n    };\n    assert_eq!(format!(\"{exact_no_changes}\"), \"No changes\");\n\n    // Test ExactScrobbleEdit Display - artist change\n    let exact_artist_change = ExactScrobbleEdit {\n        track_name_original: \"Yesterday\".to_string(),\n        album_name_original: \"Help!\".to_string(),\n        artist_name_original: \"The Beatles\".to_string(),\n        album_artist_name_original: \"The Beatles\".to_string(),\n        track_name: \"Yesterday\".to_string(),\n        album_name: \"Help!\".to_string(),\n        artist_name: \"Beatles, The\".to_string(),\n        album_artist_name: \"The Beatles\".to_string(),\n        timestamp: 1234567890,\n        edit_all: false,\n    };\n    assert_eq!(\n        format!(\"{exact_artist_change}\"),\n        \"Artist: The Beatles → Beatles, The\"\n    );\n\n    // Test ExactScrobbleEdit Display - multiple changes with edit_all\n    let exact_multi_changes = ExactScrobbleEdit {\n        track_name_original: \"Yesterday\".to_string(),\n        album_name_original: \"Help!\".to_string(),\n        artist_name_original: \"The Beatles\".to_string(),\n        album_artist_name_original: \"The Beatles\".to_string(),\n        track_name: \"Yesterday (Remastered)\".to_string(),\n        album_name: \"Help! (Deluxe Edition)\".to_string(),\n        artist_name: \"Beatles, The\".to_string(),\n        album_artist_name: \"Beatles, The\".to_string(),\n        timestamp: 1234567890,\n        edit_all: true,\n    };\n    assert_eq!(format!(\"{exact_multi_changes}\"), \"Artist: The Beatles → Beatles, The, Track: Yesterday → Yesterday (Remastered), Album: Help! → Help! (Deluxe Edition), Album Artist: The Beatles → Beatles, The (all instances)\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","tests","vcr_tests.rs"],"content":"mod vcr;\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","imalison","Projects","lastfm-edit","examples","artist_tracks_direct.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    let artist = \"The Beatles\";\n\n    println!(\"=== Artist Tracks Direct Example ===\\n\");\n    println!(\"🎵 Comparing album-based vs direct approach for: {artist}\");\n\n    // Test the direct approach\n    println!(\"\\n📄 Using direct paginated endpoint:\");\n    let mut direct_tracks = client.artist_tracks_direct(artist);\n    let direct_tracks_list = direct_tracks.take(10).await?;\n\n    println!(\n        \"✅ Found {} tracks using direct approach:\",\n        direct_tracks_list.len()\n    );\n    for (i, track) in direct_tracks_list.iter().enumerate() {\n        println!(\n            \"  {}. {} (played {} times)\",\n            i + 1,\n            track.name,\n            track.playcount\n        );\n        if let Some(album) = \u0026track.album {\n            println!(\"     Album: {album}\");\n        }\n    }\n\n    // Compare with album-based approach\n    println!(\"\\n📀 Using album-based approach:\");\n    let mut album_tracks = client.artist_tracks(artist);\n    let album_tracks_list = album_tracks.take(10).await?;\n\n    println!(\n        \"✅ Found {} tracks using album-based approach:\",\n        album_tracks_list.len()\n    );\n    for (i, track) in album_tracks_list.iter().enumerate() {\n        println!(\n            \"  {}. {} (played {} times)\",\n            i + 1,\n            track.name,\n            track.playcount\n        );\n        if let Some(album) = \u0026track.album {\n            println!(\"     Album: {album}\");\n        }\n    }\n\n    println!(\"\\n💡 The direct approach is more efficient as it uses:\");\n    println!(\n        \"   /user/{{username}}/library/music/{}/+tracks?page=N\u0026ajax=true\",\n        artist.replace(\" \", \"+\")\n    );\n    println!(\"   Instead of iterating through albums first.\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","clean_artist_tracks.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\nuse regex::Regex;\nuse std::collections::HashSet;\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let args: Vec\u003cString\u003e = env::args().collect();\n\n    if args.len() != 3 {\n        eprintln!(\n            \"Usage: cargo run --example clean_artist_tracks -- \\\"Artist Name\\\" \\\"Regex Pattern\\\"\"\n        );\n        eprintln!(\"Examples:\");\n        eprintln!(\"  # Remove remastered suffixes:\");\n        eprintln!(\"  cargo run --example clean_artist_tracks -- \\\"The Beatles\\\" \\\" - Remastered( \\\\d{{4}})?$\\\"\");\n        eprintln!(\"  # Remove live suffixes:\");\n        eprintln!(\"  cargo run --example clean_artist_tracks -- \\\"Pink Floyd\\\" \\\" \\\\(Live\\\\)$\\\"\");\n        eprintln!(\"  # Remove explicit tags:\");\n        eprintln!(\"  cargo run --example clean_artist_tracks -- \\\"Eminem\\\" \\\" \\\\(Explicit\\\\)$\\\"\");\n        std::process::exit(1);\n    }\n\n    let artist = \u0026args[1];\n    let pattern = \u0026args[2];\n\n    let regex = match Regex::new(pattern) {\n        Ok(r) =\u003e r,\n        Err(e) =\u003e {\n            eprintln!(\"❌ Invalid regex pattern '{pattern}': {e}\");\n            std::process::exit(1);\n        }\n    };\n\n    let client = common::setup_client().await?;\n\n    println!(\"=== Artist Catalog Cleanup Tool ===\\n\");\n    println!(\"🎨 ARTIST: {artist}\");\n    println!(\"🔍 PATTERN: {pattern}\");\n    println!(\"📝 This will clean track names by removing text matching the regex pattern\");\n    println!(\"\\n🚀 Starting catalog scan...\\n\");\n\n    // Track statistics\n    let mut total_tracks_scanned = 0;\n    let mut matching_tracks_found = 0;\n    let mut tracks_successfully_cleaned = 0;\n    let mut tracks_failed_to_clean = 0;\n    let mut already_cleaned_tracks = HashSet::new();\n\n    // Step 1: Collect all matching tracks first\n    println!(\"🔍 Step 1: Scanning entire {artist} catalog for matching tracks...\");\n    let mut all_matching_tracks = Vec::new();\n    let mut page = 1;\n\n    loop {\n        match client.get_artist_tracks_page(artist, page).await {\n            Ok(track_page) =\u003e {\n                if track_page.tracks.is_empty() {\n                    println!(\n                        \"📚 Reached end of {artist} catalog - scanned {total_tracks_scanned} tracks total\"\n                    );\n                    break;\n                }\n\n                for track in track_page.tracks {\n                    total_tracks_scanned += 1;\n\n                    // Print progress every 50 tracks\n                    if total_tracks_scanned % 50 == 0 {\n                        println!(\"📖 Scanned {total_tracks_scanned} tracks so far...\");\n                    }\n\n                    // Check if this track matches our pattern\n                    if regex.is_match(\u0026track.name) {\n                        let base_name = regex.replace(\u0026track.name, \"\").to_string();\n                        if !already_cleaned_tracks.contains(\u0026base_name) {\n                            all_matching_tracks.push(track);\n                            already_cleaned_tracks.insert(base_name);\n                            matching_tracks_found += 1;\n                        }\n                    }\n                }\n\n                if !track_page.has_next_page {\n                    println!(\n                        \"📚 Reached end of {artist} catalog - scanned {total_tracks_scanned} tracks total\"\n                    );\n                    break;\n                }\n\n                page += 1;\n            }\n            Err(e) =\u003e {\n                println!(\"❌ Error fetching tracks page {page}: {e}\");\n                break;\n            }\n        }\n    }\n\n    // Step 2: Process all found matching tracks\n    if all_matching_tracks.is_empty() {\n        println!(\"\\n🎉 No matching tracks found! Your {artist} catalog is already clean.\");\n        return Ok(());\n    }\n\n    println!(\n        \"\\n🎯 Step 2: Processing {} matching tracks...\",\n        all_matching_tracks.len()\n    );\n    already_cleaned_tracks.clear(); // Reset for actual processing\n\n    for (index, track) in all_matching_tracks.iter().enumerate() {\n        let clean_name = regex.replace(\u0026track.name, \"\").to_string();\n\n        println!(\n            \"\\n🎵 [{}/{}] Cleaning: '{}' → '{}'\",\n            index + 1,\n            all_matching_tracks.len(),\n            track.name,\n            clean_name\n        );\n\n        // Skip if we've already processed this track name in this session\n        if already_cleaned_tracks.contains(\u0026clean_name) {\n            println!(\"   ⏭️  Skipping - already processed in this session\");\n            continue;\n        }\n\n        // Load real edit form values from the track page\n        let edit_template = lastfm_edit::ScrobbleEdit::from_track_and_artist(\u0026track.name, artist);\n        match client\n            .discover_scrobble_edit_variations(\u0026edit_template)\n            .await\n        {\n            Ok(exact_edit_vec) =\u003e {\n                if let Some(exact_edit) = exact_edit_vec.into_iter().next() {\n                    let mut edit_data = exact_edit.to_scrobble_edit();\n                    println!(\n                        \"   📋 Loaded edit form data - Album: '{}'\",\n                        edit_data\n                            .album_name_original\n                            .as_deref()\n                            .unwrap_or(\"unknown\")\n                    );\n\n                    // Update the track name to the cleaned version\n                    edit_data.track_name = Some(clean_name.clone());\n\n                    println!(\"   🔧 Submitting edit...\");\n\n                    // Perform the edit\n                    match client.edit_scrobble(\u0026edit_data).await {\n                        Ok(_response) =\u003e {\n                            println!(\"   ✅ Successfully cleaned: '{clean_name}'\");\n                            tracks_successfully_cleaned += 1;\n                            already_cleaned_tracks.insert(clean_name);\n                        }\n                        Err(e) =\u003e {\n                            println!(\"   ❌ Error editing '{}': {}\", track.name, e);\n                            tracks_failed_to_clean += 1;\n                        }\n                    }\n                } else {\n                    println!(\"   ⚠️  No edit data found for track\");\n                    tracks_failed_to_clean += 1;\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"   ⚠️  Couldn't load edit form for '{}': {}\", track.name, e);\n                println!(\"      This track might not be in your recent scrobbles\");\n                tracks_failed_to_clean += 1;\n            }\n        }\n\n        // Add a small delay to be respectful to Last.fm servers\n        println!(\"   ⏳ Waiting 1.2s before next track...\");\n        tokio::time::sleep(tokio::time::Duration::from_millis(1200)).await;\n    }\n\n    // Print final statistics\n    println!(\"\\n{}\", \"=\".repeat(60));\n    println!(\"🎼 {} CATALOG CLEANUP COMPLETE\", artist.to_uppercase());\n    println!(\"{}\", \"=\".repeat(60));\n    println!(\"📊 STATISTICS:\");\n    println!(\"   • Total tracks scanned: {total_tracks_scanned}\");\n    println!(\"   • Matching tracks found: {matching_tracks_found}\");\n    println!(\"   • Tracks successfully cleaned: {tracks_successfully_cleaned}\");\n    println!(\"   • Tracks failed to clean: {tracks_failed_to_clean}\");\n\n    if tracks_successfully_cleaned \u003e 0 {\n        println!(\n            \"\\n✨ Your {artist} catalog is now cleaner! Pattern '{pattern}' has been removed from track names.\"\n        );\n    }\n\n    if tracks_failed_to_clean \u003e 0 {\n        println!(\"\\n⚠️  Some tracks couldn't be cleaned. This usually happens when:\");\n        println!(\"   • The track hasn't been scrobbled recently\");\n        println!(\"   • The track data isn't in your listening history\");\n        println!(\"   • There were temporary server issues\");\n        println!(\"\\n💡 You can re-run this script later to try cleaning the remaining tracks.\");\n    }\n\n    println!(\"\\n🎵 {artist} catalog cleanup completed!\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","custom_session_manager.rs"],"content":"/// Example demonstrating how to use SessionManager with custom app names.\n///\n/// This example shows how other libraries can use SessionManager to store\n/// Last.fm sessions with their own application prefix in XDG directories.\n///\n/// Usage:\n///   direnv exec . cargo run --example custom_session_manager\nuse lastfm_edit::{LastFmEditClientImpl, SessionManager};\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    env_logger::init();\n\n    println!(\"🎵 Custom SessionManager Example\");\n    println!(\"=================================\\n\");\n\n    // Create a custom session manager for your application\n    let session_manager = SessionManager::new(\"my-music-app\");\n    println!(\"📁 Using app name: '{}'\", session_manager.app_name());\n    println!(\"📂 Sessions will be stored in: ~/.local/share/my-music-app/users/{{username}}/session.json\\n\");\n\n    let username = env::var(\"LASTFM_EDIT_USERNAME\")\n        .expect(\"LASTFM_EDIT_USERNAME environment variable not set\");\n    let password = env::var(\"LASTFM_EDIT_PASSWORD\")\n        .expect(\"LASTFM_EDIT_PASSWORD environment variable not set\");\n\n    // Check if we have a saved session with our custom manager\n    if session_manager.session_exists(\u0026username) {\n        println!(\"📁 Found existing session for user '{username}', attempting to restore...\");\n\n        match session_manager.load_session(\u0026username) {\n            Ok(session) =\u003e {\n                println!(\"📥 Session loaded successfully\");\n\n                // Create client with loaded session\n                let http_client = http_client::native::NativeClient::new();\n                let client = LastFmEditClientImpl::from_session(Box::new(http_client), session);\n\n                // Validate the session\n                println!(\"🔍 Validating session...\");\n                if client.validate_session().await {\n                    println!(\"✅ Session is valid, using saved session\");\n\n                    // Test the session by fetching recent tracks\n                    println!(\"🎧 Testing session by fetching recent tracks...\");\n                    let tracks = client.get_recent_scrobbles(1).await?;\n                    let recent_tracks: Vec\u003c_\u003e = tracks.into_iter().take(3).collect();\n                    println!(\"📊 Found {} recent tracks:\", recent_tracks.len());\n\n                    for track in recent_tracks {\n                        println!(\"   🎵 {} - {}\", track.artist, track.name);\n                    }\n\n                    return Ok(());\n                } else {\n                    println!(\"❌ Session is invalid or expired\");\n                    // Remove invalid session file\n                    let _ = session_manager.remove_session(\u0026username);\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"❌ Failed to load session: {e}\");\n                // Remove corrupted session file\n                let _ = session_manager.remove_session(\u0026username);\n            }\n        }\n    }\n\n    // No valid session found, perform fresh login\n    println!(\"🔐 No valid session found, performing fresh login...\");\n    let http_client = http_client::native::NativeClient::new();\n    let client =\n        LastFmEditClientImpl::login_with_credentials(Box::new(http_client), \u0026username, \u0026password)\n            .await?;\n\n    // Save the new session with our custom manager\n    println!(\"💾 Saving session with custom session manager...\");\n    let session = client.get_session();\n    if let Err(e) = session_manager.save_session(\u0026session) {\n        println!(\"⚠️  Warning: Failed to save session: {e}\");\n        println!(\"   (You'll need to login again next time)\");\n    } else {\n        println!(\"✅ Session saved to custom location\");\n\n        // Show the session path\n        let session_path = session_manager.get_session_path(\u0026username)?;\n        println!(\"📂 Session saved to: {}\", session_path.display());\n    }\n\n    // Test the new session\n    println!(\"🎧 Testing session by fetching recent tracks...\");\n    let tracks = client.get_recent_scrobbles(1).await?;\n    let recent_tracks: Vec\u003c_\u003e = tracks.into_iter().take(3).collect();\n    println!(\"📊 Found {} recent tracks:\", recent_tracks.len());\n\n    for track in recent_tracks {\n        println!(\"   🎵 {} - {}\", track.artist, track.name);\n    }\n\n    // Demonstrate listing saved users\n    println!(\"\\n👥 Listing all saved users for this app:\");\n    let saved_users = session_manager.list_saved_users()?;\n    if saved_users.is_empty() {\n        println!(\"   No saved users found\");\n    } else {\n        for user in saved_users {\n            println!(\"   - {user}\");\n        }\n    }\n\n    println!(\"\\n🎉 Example completed!\");\n    println!(\"💡 Your custom session is saved separately from the default lastfm-edit sessions.\");\n    println!(\n        \"💡 Other apps using SessionManager with different names won't interfere with each other.\"\n    );\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","debug_album_url.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::Result;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    let artist = \"Radiohead\";\n    let album = \"In Rainbows\";\n\n    println!(\"=== Debug Album URL Test ===\\n\");\n    println!(\"🔍 Testing URL construction for album tracks...\");\n    println!(\"Artist: {artist}\");\n    println!(\"Album: {album}\\n\");\n\n    // First, let's see if the artist has albums at all\n    println!(\"1. Testing artist albums page...\");\n    match client.get_artist_albums_page(artist, 1).await {\n        Ok(albums_page) =\u003e {\n            println!(\"✅ Found {} albums for {artist}\", albums_page.albums.len());\n            for (i, album_item) in albums_page.albums.iter().enumerate().take(5) {\n                println!(\n                    \"   [{i}] '{}' ({} plays)\",\n                    album_item.name, album_item.playcount\n                );\n            }\n        }\n        Err(e) =\u003e {\n            println!(\"❌ Error getting albums: {e}\");\n            return Ok(());\n        }\n    }\n\n    println!(\"\\n2. Testing album tracks page...\");\n    match client.get_album_tracks_page(album, artist, 1).await {\n        Ok(tracks_page) =\u003e {\n            println!(\n                \"✅ Album tracks page returned {} tracks\",\n                tracks_page.tracks.len()\n            );\n            println!(\"   Has next page: {}\", tracks_page.has_next_page);\n            println!(\"   Total pages: {:?}\", tracks_page.total_pages);\n            for (i, track) in tracks_page.tracks.iter().enumerate().take(10) {\n                println!(\n                    \"   [{i}] '{}' - Album: '{}'\",\n                    track.name,\n                    track.album.as_deref().unwrap_or(\"(none)\")\n                );\n            }\n        }\n        Err(e) =\u003e {\n            println!(\"❌ Error getting album tracks: {e}\");\n        }\n    }\n\n    // Let's also test with an album we know exists from the albums list\n    println!(\"\\n3. Testing with first album from albums list...\");\n    match client.get_artist_albums_page(artist, 1).await {\n        Ok(albums_page) =\u003e {\n            if let Some(first_album) = albums_page.albums.first() {\n                println!(\"Testing with album: '{}'\", first_album.name);\n                match client\n                    .get_album_tracks_page(\u0026first_album.name, artist, 1)\n                    .await\n                {\n                    Ok(tracks_page) =\u003e {\n                        println!(\n                            \"✅ Found {} tracks for '{}'\",\n                            tracks_page.tracks.len(),\n                            first_album.name\n                        );\n                        for (i, track) in tracks_page.tracks.iter().enumerate().take(5) {\n                            println!(\"   [{i}] '{}'\", track.name);\n                        }\n                    }\n                    Err(e) =\u003e {\n                        println!(\"❌ Error: {e}\");\n                    }\n                }\n            } else {\n                println!(\"No albums found in list\");\n            }\n        }\n        Err(e) =\u003e {\n            println!(\"❌ Error getting albums: {e}\");\n        }\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","list_artist_tracks.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    let artist = std::env::args()\n        .nth(1)\n        .unwrap_or_else(|| \"Queen\".to_string());\n\n    println!(\"=== Artist Tracks Listing (using Iterator) ===\\n\");\n    println!(\"🎵 Listing all tracks for artist: {artist}\\n\");\n\n    // Use the iterator the same way as Case 4: Artist-specific discovery\n    let mut tracks_iterator = client.artist_tracks(\u0026artist);\n    let mut track_count = 0;\n\n    println!(\"🔍 Fetching tracks using iterator...\\n\");\n\n    while let Some(track) = tracks_iterator.next().await? {\n        track_count += 1;\n        println!(\n            \"[{:4}] '{}' | Album: '{}' | Plays: {} | Timestamp: {:?}\",\n            track_count,\n            track.name,\n            track.album.as_deref().unwrap_or(\"(no album)\"),\n            track.playcount,\n            track.timestamp\n        );\n\n        // Limit output for testing to avoid overwhelming output\n        if track_count \u003e= 50 {\n            println!(\"\\n⚠️  Limiting output to first 50 tracks for testing...\");\n            break;\n        }\n    }\n\n    println!(\"\\n=== Summary ===\");\n    println!(\"📊 Total tracks displayed: {track_count}\");\n\n    if let Some(total_pages) = tracks_iterator.total_pages() {\n        println!(\"📄 Total pages available: {total_pages}\");\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","list_recent_tracks.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    // Parse command line arguments\n    let args: Vec\u003cString\u003e = env::args().collect();\n    let num_tracks: usize = args.get(1).and_then(|s| s.parse().ok()).unwrap_or(20);\n    let starting_page: u32 = args.get(2).and_then(|s| s.parse().ok()).unwrap_or(1);\n\n    println!(\"Fetching {num_tracks} recent tracks starting from page {starting_page}...\");\n    println!();\n\n    // Create iterator starting from the specified page\n    let mut recent_tracks = client.recent_tracks_from_page(starting_page);\n    let mut count = 0;\n\n    // Use the iterator to fetch tracks\n    while count \u003c num_tracks {\n        match recent_tracks.next().await? {\n            Some(track) =\u003e {\n                let timestamp_str = if let Some(ts) = track.timestamp {\n                    format!(\n                        \" ({})\",\n                        chrono::DateTime::from_timestamp(ts as i64, 0)\n                            .map(|dt| dt.format(\"%Y-%m-%d %H:%M:%S\").to_string())\n                            .unwrap_or_else(|| format!(\"timestamp: {ts}\"))\n                    )\n                } else {\n                    \" (no timestamp)\".to_string()\n                };\n\n                let album_str = if let Some(album) = \u0026track.album {\n                    format!(\" [{album}]\")\n                } else {\n                    \"\".to_string()\n                };\n\n                println!(\n                    \"{}. {} - {}{}{}\",\n                    count + 1,\n                    track.artist,\n                    track.name,\n                    album_str,\n                    timestamp_str\n                );\n\n                count += 1;\n            }\n            None =\u003e {\n                println!(\"No more tracks available.\");\n                break;\n            }\n        }\n    }\n\n    println!();\n    println!(\"Fetched {count} tracks total.\");\n\n    println!();\n    println!(\"Usage: cargo run --example list_recent_tracks [num_tracks] [starting_page]\");\n    println!(\"  num_tracks    - Number of tracks to fetch (default: 20)\");\n    println!(\"  starting_page - Page number to start from (default: 1)\");\n    println!();\n    println!(\"Examples:\");\n    println!(\"  cargo run --example list_recent_tracks 50     # Fetch 50 tracks from page 1\");\n    println!(\n        \"  cargo run --example list_recent_tracks 20 5   # Fetch 20 tracks starting from page 5\"\n    );\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","rate_limit_monitoring.rs"],"content":"use lastfm_edit::{ClientEvent, LastFmEditClientImpl};\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    env_logger::init();\n\n    let username =\n        env::var(\"LASTFM_EDIT_USERNAME\").expect(\"Set LASTFM_EDIT_USERNAME environment variable\");\n    let password =\n        env::var(\"LASTFM_EDIT_PASSWORD\").expect(\"Set LASTFM_EDIT_PASSWORD environment variable\");\n\n    // Login and create client\n    let http_client = http_client::native::NativeClient::new();\n    println!(\"Logging in as {username}...\");\n    let client =\n        LastFmEditClientImpl::login_with_credentials(Box::new(http_client), \u0026username, \u0026password)\n            .await?;\n\n    // Subscribe to client events before any operations\n    let mut events = client.subscribe();\n\n    // Spawn a background task to monitor events\n    let event_monitor = tokio::spawn(async move {\n        println!(\"🔍 Monitoring client events...\");\n        while let Ok(event) = events.recv().await {\n            match event {\n                ClientEvent::RequestStarted { request } =\u003e {\n                    println!(\"🚀 Starting request: {}\", request.short_description());\n                }\n                ClientEvent::RequestCompleted {\n                    request,\n                    status_code,\n                    duration_ms,\n                } =\u003e {\n                    println!(\n                        \"✅ Completed request: {} - {} ({} ms)\",\n                        request.short_description(),\n                        status_code,\n                        duration_ms\n                    );\n                }\n                ClientEvent::RateLimited {\n                    delay_seconds,\n                    request,\n                    rate_limit_type,\n                    rate_limit_timestamp,\n                } =\u003e {\n                    let req_desc = request\n                        .as_ref()\n                        .map(|r| r.short_description())\n                        .unwrap_or_else(|| \"unknown request\".to_string());\n                    println!(\n                        \"⏳ Rate limited ({rate_limit_type:?})! {req_desc} - Waiting {delay_seconds} seconds (at timestamp {rate_limit_timestamp})\"\n                    );\n                }\n                ClientEvent::RateLimitEnded {\n                    request,\n                    rate_limit_type,\n                    total_rate_limit_duration_seconds,\n                } =\u003e {\n                    println!(\n                        \"🎉 Rate limiting ended ({rate_limit_type:?}) after {total_rate_limit_duration_seconds} seconds - {}\",\n                        request.short_description()\n                    );\n                }\n                ClientEvent::EditAttempted {\n                    edit,\n                    success,\n                    error_message,\n                    duration_ms,\n                } =\u003e {\n                    if success {\n                        println!(\n                            \"✅ Edit succeeded: '{}' -\u003e '{}' ({duration_ms} ms)\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    } else {\n                        let error_msg = error_message\n                            .as_ref()\n                            .map(|s| format!(\" - {s}\"))\n                            .unwrap_or_default();\n                        println!(\n                            \"❌ Edit failed: '{}' -\u003e '{}' ({duration_ms} ms){error_msg}\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    }\n                }\n            }\n        }\n    });\n\n    println!(\"✅ Successfully logged in as: {}\", client.username());\n\n    // Check latest event after login\n    if let Some(event) = client.latest_event() {\n        match event {\n            ClientEvent::RequestStarted { request } =\u003e {\n                println!(\n                    \"📊 Latest event: Started request {}\",\n                    request.short_description()\n                );\n            }\n            ClientEvent::RequestCompleted {\n                request,\n                status_code,\n                duration_ms,\n            } =\u003e {\n                println!(\n                    \"📊 Latest event: Completed request {} - {} ({} ms)\",\n                    request.short_description(),\n                    status_code,\n                    duration_ms\n                );\n            }\n            ClientEvent::RateLimited {\n                delay_seconds,\n                request,\n                rate_limit_type,\n                rate_limit_timestamp,\n            } =\u003e {\n                let req_desc = request\n                    .as_ref()\n                    .map(|r| r.short_description())\n                    .unwrap_or_else(|| \"unknown request\".to_string());\n                println!(\n                    \"📊 Latest event: Rate limited ({rate_limit_type:?}) for {delay_seconds} seconds - {req_desc} (at timestamp {rate_limit_timestamp})\"\n                );\n            }\n            ClientEvent::RateLimitEnded {\n                request,\n                rate_limit_type,\n                total_rate_limit_duration_seconds,\n            } =\u003e {\n                println!(\n                    \"📊 Latest event: Rate limiting ended ({rate_limit_type:?}) after {total_rate_limit_duration_seconds} seconds - {}\",\n                    request.short_description()\n                );\n            }\n            ClientEvent::EditAttempted {\n                edit,\n                success,\n                error_message,\n                duration_ms,\n            } =\u003e {\n                if success {\n                    println!(\n                        \"📊 Latest event: Edit succeeded '{}' -\u003e '{}' ({duration_ms} ms)\",\n                        edit.track_name_original, edit.track_name\n                    );\n                } else {\n                    let error_msg = error_message\n                        .as_ref()\n                        .map(|s| format!(\" - {s}\"))\n                        .unwrap_or_default();\n                    println!(\n                        \"📊 Latest event: Edit failed '{}' -\u003e '{}' ({duration_ms} ms){error_msg}\",\n                        edit.track_name_original, edit.track_name\n                    );\n                }\n            }\n        }\n    } else {\n        println!(\"📊 No events have occurred yet\");\n    }\n\n    // Make some requests that might trigger rate limiting\n    println!(\"🎵 Fetching recent tracks to potentially trigger rate limiting...\");\n\n    for page in 1..=3 {\n        println!(\"📄 Fetching page {page}...\");\n        match client.get_recent_scrobbles(page).await {\n            Ok(tracks) =\u003e {\n                println!(\"✅ Got {} tracks from page {page}\", tracks.len());\n            }\n            Err(e) =\u003e {\n                println!(\"❌ Error on page {page}: {e}\");\n            }\n        }\n\n        // Check if we're currently rate limited\n        if let Some(ClientEvent::RateLimited { delay_seconds, .. }) = client.latest_event() {\n            println!(\n                \"🛑 Currently rate limited for {delay_seconds} seconds according to latest event\"\n            );\n        }\n\n        // Small delay between requests\n        tokio::time::sleep(std::time::Duration::from_millis(500)).await;\n    }\n\n    println!(\"🏁 Done! Event monitor will continue running...\");\n\n    // Let the event monitor run for a bit longer to catch any final events\n    tokio::time::sleep(std::time::Duration::from_secs(2)).await;\n\n    // Cancel the event monitor\n    event_monitor.abort();\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","remove_remaster.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\nuse regex::Regex;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    println!(\"=== Remaster \u0026 Year Removal Tool ===\\n\");\n    println!(\"🎯 This will remove 'remastered' text and year suffixes from track names\");\n    println!(\"📝 Patterns include: '- 2009', '(2009)', '[2009]', '- Remaster', etc.\\n\");\n\n    let artist = std::env::args()\n        .nth(1)\n        .unwrap_or_else(|| \"The Beatles\".to_string());\n\n    println!(\"🎵 Processing tracks for artist: {artist}\\n\");\n\n    // Regex patterns to clean up remaster text and year suffixes\n    // Note: Order matters! More specific patterns should come first\n    let remaster_patterns = vec![\n        // Patterns with \"remaster\" word (most specific)\n        // \"Track Name - 2009 Remaster\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*-\\s*\\d{4}\\s*remaster(ed)?.*$\").unwrap(),\n        // \"Track Name - Remaster\" or \"Track Name - Remastered\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*-\\s*remaster(ed)?.*$\").unwrap(),\n        // \"Track Name (2009 Remaster)\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*\\(\\d{4}\\s*remaster(ed)?.*\\)\\s*$\").unwrap(),\n        // \"Track Name (Remaster)\" or \"Track Name (Remastered)\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*\\(remaster(ed)?.*\\)\\s*$\").unwrap(),\n        // \"Track Name [2009 Remaster]\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*\\[\\d{4}\\s*remaster(ed)?.*\\]\\s*$\").unwrap(),\n        // \"Track Name [Remaster]\" or \"Track Name [Remastered]\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*\\[remaster(ed)?.*\\]\\s*$\").unwrap(),\n        // \"Track Name Remastered\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*remaster(ed)?\\s*(\\d{4})?\\s*$\").unwrap(),\n        // Years that are likely remaster years (1980-2030) - be more conservative\n        // \"Track Name - 2009\" -\u003e \"Track Name\" (only for likely remaster years)\n        Regex::new(r\"(?i)\\s*-\\s*(19[8-9]\\d|20[0-3]\\d)\\s*$\").unwrap(),\n        // \"Track Name (2009)\" -\u003e \"Track Name\" (only for likely remaster years)\n        Regex::new(r\"(?i)\\s*\\((19[8-9]\\d|20[0-3]\\d)\\)\\s*$\").unwrap(),\n        // \"Track Name [2009]\" -\u003e \"Track Name\" (only for likely remaster years)\n        Regex::new(r\"(?i)\\s*\\[(19[8-9]\\d|20[0-3]\\d)\\]\\s*$\").unwrap(),\n        // Other common suffixes that should be removed\n        // \"Track Name - 2019 Mix\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*-\\s*\\d{4}\\s*mix.*$\").unwrap(),\n        // \"Track Name - Mix\" -\u003e \"Track Name\"\n        Regex::new(r\"(?i)\\s*-\\s*mix.*$\").unwrap(),\n    ];\n\n    // First, collect some tracks to process\n    let mut tracks_to_process = Vec::new();\n    let mut fetched_count = 0;\n    let mut page = 1;\n\n    loop {\n        match client.get_artist_tracks_page(\u0026artist, page).await {\n            Ok(track_page) =\u003e {\n                if track_page.tracks.is_empty() {\n                    println!(\"\\n📚 Fetched all {fetched_count} tracks for {artist}\");\n                    break;\n                }\n\n                for track in track_page.tracks {\n                    fetched_count += 1;\n                    println!(\"🔍 [{:3}] Found track: '{}'\", fetched_count, track.name);\n\n                    // Check if track name contains remaster text\n                    let mut cleaned_name = track.name.clone();\n                    let mut needs_cleaning = false;\n\n                    for pattern in \u0026remaster_patterns {\n                        if pattern.is_match(\u0026cleaned_name) {\n                            cleaned_name = pattern.replace(\u0026cleaned_name, \"\").trim().to_string();\n                            needs_cleaning = true;\n                        }\n                    }\n\n                    if needs_cleaning \u0026\u0026 !cleaned_name.is_empty() {\n                        tracks_to_process.push((track, cleaned_name));\n                    }\n                }\n\n                if !track_page.has_next_page {\n                    println!(\"\\n📚 Fetched all {fetched_count} tracks for {artist}\");\n                    break;\n                }\n\n                page += 1;\n            }\n            Err(e) =\u003e {\n                println!(\"❌ Error fetching tracks page {page}: {e}\");\n                break;\n            }\n        }\n    }\n\n    println!(\n        \"\\n🧹 Starting remaster removal on {} tracks...\\n\",\n        tracks_to_process.len()\n    );\n\n    let mut processed_count = 0;\n    let mut edits_made = 0;\n    let mut rate_limit_hits = 0;\n\n    // Now process the collected tracks\n    for (track, cleaned_name) in tracks_to_process {\n        processed_count += 1;\n        println!(\n            \"🔧 [{:3}] Processing: '{}' -\u003e '{}'\",\n            processed_count, track.name, cleaned_name\n        );\n        println!(\"   🔄 Applying change...\");\n\n        // Load edit form - this makes an HTTP request\n        let edit_template =\n            lastfm_edit::ScrobbleEdit::from_track_and_artist(\u0026track.name, \u0026track.artist);\n        match client\n            .discover_scrobble_edit_variations(\u0026edit_template)\n            .await\n        {\n            Ok(exact_edit_vec) =\u003e {\n                if let Some(exact_edit) = exact_edit_vec.into_iter().next() {\n                    let mut edit_data = exact_edit.to_scrobble_edit();\n                    // Update track name\n                    edit_data.track_name = Some(cleaned_name.clone());\n\n                    // Submit edit - another HTTP request\n                    match client.edit_scrobble(\u0026edit_data).await {\n                        Ok(_) =\u003e {\n                            edits_made += 1;\n                            println!(\"   ✅ Successfully cleaned track\");\n                        }\n                        Err(e) =\u003e {\n                            println!(\"   ❌ Error editing track: {e}\");\n                            if e.to_string().contains(\"RateLimit\") {\n                                rate_limit_hits += 1;\n                                log::info!(\"Rate limit encountered during edit operation for track '{}' by '{}'\", track.name, track.artist);\n                                println!(\"   🚨 RATE LIMIT DETECTED during edit operation!\");\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    println!(\"   ⚠️  No edit data found for track\");\n                }\n            }\n            Err(e) =\u003e {\n                println!(\"   ⚠️  Couldn't load edit form: {e}\");\n                if e.to_string().contains(\"RateLimit\") {\n                    rate_limit_hits += 1;\n                    log::info!(\n                        \"Rate limit encountered during form load for track '{}' by '{}'\",\n                        track.name,\n                        track.artist\n                    );\n                    println!(\"   🚨 RATE LIMIT DETECTED during form load!\");\n                    break;\n                }\n            }\n        }\n    }\n\n    println!(\"\\n=== Summary ===\");\n    println!(\"📊 Tracks processed: {processed_count}\");\n    println!(\"✏️  Edits made: {edits_made}\");\n    println!(\"🚨 Rate limit hits: {rate_limit_hits}\");\n\n    if rate_limit_hits \u003e 0 {\n        println!(\"\\n🎯 Rate limiting was triggered.\");\n    } else {\n        println!(\"\\n✨ All changes completed successfully!\");\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","rename_album.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let args: Vec\u003cString\u003e = env::args().collect();\n\n    if args.len() != 4 {\n        eprintln!(\"Usage: cargo run --example rename_album -- \\\"Old Album Name\\\" \\\"New Album Name\\\" \\\"Artist Name\\\"\");\n        eprintln!(\"Example: cargo run --example rename_album -- \\\"Abbey Road - Remastered 2019\\\" \\\"Abbey Road\\\" \\\"The Beatles\\\"\");\n        std::process::exit(1);\n    }\n\n    let old_album_name = \u0026args[1];\n    let new_album_name = \u0026args[2];\n    let artist_name = \u0026args[3];\n\n    let client = common::setup_client().await?;\n\n    println!(\"=== Album Rename Tool ===\\n\");\n    println!(\"🎨 Artist: {artist_name}\");\n    println!(\"💿 Renaming: '{old_album_name}' → '{new_album_name}'\");\n    println!();\n\n    println!(\"🔍 Loading album edit form data...\");\n    match client\n        .edit_album(old_album_name, new_album_name, artist_name)\n        .await\n    {\n        Ok(_response) =\u003e {\n            println!(\"✅ Successfully renamed album!\");\n            println!(\"   From: '{old_album_name}'\");\n            println!(\"   To:   '{new_album_name}'\");\n            println!(\"   Artist: {artist_name}\");\n            println!(\n                \"\\n💡 All scrobbles from this album have been updated with the new album name.\"\n            );\n        }\n        Err(e) =\u003e {\n            println!(\"❌ Failed to rename album: {e}\");\n            println!(\"\\nThis might happen if:\");\n            println!(\"   • The album hasn't been scrobbled recently\");\n            println!(\"   • The album name doesn't match exactly\");\n            println!(\"   • There are temporary server issues\");\n        }\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","rename_artist.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::Result;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let mut client = common::setup_client().await?;\n\n    let args: Vec\u003cString\u003e = std::env::args().collect();\n    if args.len() \u003c 4 {\n        eprintln!(\"Usage:\");\n        eprintln!(\"  {} all \u003cold_artist\u003e \u003cnew_artist\u003e\", args[0]);\n        eprintln!(\"  {} track \u003ctrack_name\u003e \u003cold_artist\u003e \u003cnew_artist\u003e\", args[0]);\n        eprintln!(\"  {} album \u003calbum_name\u003e \u003cold_artist\u003e \u003cnew_artist\u003e\", args[0]);\n        eprintln!();\n        eprintln!(\"Examples:\");\n        eprintln!(\"  {} all \\\"The Beatles\\\" \\\"Beatles\\\"\", args[0]);\n        eprintln!(\n            \"  {} track \\\"Hey Jude\\\" \\\"The Beatles\\\" \\\"Beatles\\\"\",\n            args[0]\n        );\n        eprintln!(\n            \"  {} album \\\"Abbey Road\\\" \\\"The Beatles\\\" \\\"Beatles\\\"\",\n            args[0]\n        );\n        std::process::exit(1);\n    }\n\n    let mode = \u0026args[1];\n\n    match mode.as_str() {\n        \"all\" =\u003e {\n            if args.len() != 4 {\n                eprintln!(\"Usage: {} all \u003cold_artist\u003e \u003cnew_artist\u003e\", args[0]);\n                std::process::exit(1);\n            }\n            let old_artist = \u0026args[2];\n            let new_artist = \u0026args[3];\n            rename_all_tracks(\u0026mut client, old_artist, new_artist).await\n        }\n        \"track\" =\u003e {\n            if args.len() != 5 {\n                eprintln!(\n                    \"Usage: {} track \u003ctrack_name\u003e \u003cold_artist\u003e \u003cnew_artist\u003e\",\n                    args[0]\n                );\n                std::process::exit(1);\n            }\n            let track_name = \u0026args[2];\n            let old_artist = \u0026args[3];\n            let new_artist = \u0026args[4];\n            rename_single_track(\u0026mut client, track_name, old_artist, new_artist).await\n        }\n        \"album\" =\u003e {\n            if args.len() != 5 {\n                eprintln!(\n                    \"Usage: {} album \u003calbum_name\u003e \u003cold_artist\u003e \u003cnew_artist\u003e\",\n                    args[0]\n                );\n                std::process::exit(1);\n            }\n            let album_name = \u0026args[2];\n            let old_artist = \u0026args[3];\n            let new_artist = \u0026args[4];\n            rename_album_tracks(\u0026mut client, album_name, old_artist, new_artist).await\n        }\n        _ =\u003e {\n            eprintln!(\"Invalid mode '{mode}'. Use 'all', 'track', or 'album'\");\n            std::process::exit(1);\n        }\n    }\n}\n\nasync fn rename_all_tracks(\n    client: \u0026mut dyn lastfm_edit::LastFmEditClient,\n    old_artist: \u0026str,\n    new_artist: \u0026str,\n) -\u003e Result\u003c()\u003e {\n    println!(\"=== Artist Rename Tool - All Tracks ===\\n\");\n    println!(\"🎯 This will rename ALL tracks from one artist to another\");\n    println!(\"📝 Old artist: '{old_artist}'\");\n    println!(\"📝 New artist: '{new_artist}'\");\n    println!(\"⚠️  This will edit ALL tracks that are found in your recent scrobbles!\\n\");\n\n    if !confirm_operation()? {\n        return Ok(());\n    }\n\n    println!(\"\\n🔍 Starting artist rename operation...\\n\");\n\n    match client.edit_artist(old_artist, new_artist).await {\n        Ok(response) =\u003e print_result(response),\n        Err(e) =\u003e println!(\"❌ Error during artist rename: {e}\"),\n    }\n\n    Ok(())\n}\n\nasync fn rename_single_track(\n    client: \u0026mut dyn lastfm_edit::LastFmEditClient,\n    track_name: \u0026str,\n    old_artist: \u0026str,\n    new_artist: \u0026str,\n) -\u003e Result\u003c()\u003e {\n    println!(\"=== Artist Rename Tool - Single Track ===\\n\");\n    println!(\"🎯 This will rename the artist for a specific track\");\n    println!(\"🎵 Track: '{track_name}'\");\n    println!(\"📝 Old artist: '{old_artist}'\");\n    println!(\"📝 New artist: '{new_artist}'\");\n    println!(\"⚠️  This will only edit this specific track if found in recent scrobbles!\\n\");\n\n    if !confirm_operation()? {\n        return Ok(());\n    }\n\n    println!(\"\\n🔍 Starting track artist rename...\\n\");\n\n    match client\n        .edit_artist_for_track(track_name, old_artist, new_artist)\n        .await\n    {\n        Ok(response) =\u003e print_result(response),\n        Err(e) =\u003e println!(\"❌ Error during track artist rename: {e}\"),\n    }\n\n    Ok(())\n}\n\nasync fn rename_album_tracks(\n    client: \u0026mut dyn lastfm_edit::LastFmEditClient,\n    album_name: \u0026str,\n    old_artist: \u0026str,\n    new_artist: \u0026str,\n) -\u003e Result\u003c()\u003e {\n    println!(\"=== Artist Rename Tool - Album Tracks ===\\n\");\n    println!(\"🎯 This will rename the artist for all tracks in a specific album\");\n    println!(\"💿 Album: '{album_name}'\");\n    println!(\"📝 Old artist: '{old_artist}'\");\n    println!(\"📝 New artist: '{new_artist}'\");\n    println!(\"⚠️  This will edit all tracks in this album that are found in recent scrobbles!\\n\");\n\n    if !confirm_operation()? {\n        return Ok(());\n    }\n\n    println!(\"\\n🔍 Starting album artist rename...\\n\");\n\n    match client\n        .edit_artist_for_album(album_name, old_artist, new_artist)\n        .await\n    {\n        Ok(response) =\u003e print_result(response),\n        Err(e) =\u003e println!(\"❌ Error during album artist rename: {e}\"),\n    }\n\n    Ok(())\n}\n\nfn confirm_operation() -\u003e Result\u003cbool\u003e {\n    print!(\"Are you sure you want to continue? [y/N]: \");\n    std::io::Write::flush(\u0026mut std::io::stdout()).unwrap();\n\n    let mut input = String::new();\n    std::io::stdin().read_line(\u0026mut input).unwrap();\n    let response = input.trim().to_lowercase();\n\n    if response != \"y\" \u0026\u0026 response != \"yes\" {\n        println!(\"Operation cancelled.\");\n        return Ok(false);\n    }\n\n    Ok(true)\n}\n\nfn print_result(response: lastfm_edit::EditResponse) {\n    if response.success() {\n        println!(\"✅ Success!\");\n        if let Some(message) = response.message() {\n            println!(\"📋 {message}\");\n        }\n    } else {\n        println!(\"❌ Operation failed\");\n        if let Some(message) = response.message() {\n            println!(\"📋 {message}\");\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","save_album_response.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::Result;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    // Test the URL construction manually to see what's wrong\n    let artist = \"Radiohead\";\n    let album = \"In Rainbows\";\n\n    // Get the session details to construct URLs manually\n    let session = client.get_session();\n    println!(\"Username: {}\", session.username);\n    println!(\"Base URL: {}\", session.base_url);\n\n    // Construct the URL we're using\n    let url = format!(\n        \"{}/user/{}/library/music/{}/{}/+tracks?page=1\u0026ajax=true\",\n        session.base_url,\n        session.username,\n        artist.replace(\" \", \"+\"),\n        album.replace(\" \", \"+\")\n    );\n\n    println!(\"Constructed URL: {url}\");\n\n    // Let's also try some variations (manually encoded):\n    let artist_encoded = artist.replace(\" \", \"%20\");\n    let album_encoded = album.replace(\" \", \"%20\");\n    let url_encoded = format!(\n        \"{}/user/{}/library/music/{}/{}/+tracks?page=1\u0026ajax=true\",\n        session.base_url, session.username, artist_encoded, album_encoded\n    );\n\n    println!(\"URL encoded version: {url_encoded}\");\n\n    // Test with a manually constructed HTTP client to see what we get\n    println!(\"\\nMaking direct HTTP request to see response...\");\n\n    // Make the request using the client's internal HTTP client\n    // We'll access this by making the client call directly and examining response\n    match client.get_album_tracks_page(album, artist, 1).await {\n        Ok(tracks_page) =\u003e {\n            println!(\"Success: {} tracks\", tracks_page.tracks.len());\n        }\n        Err(e) =\u003e {\n            println!(\"Error: {e}\");\n        }\n    }\n\n    // Let's also check what a working artist tracks URL looks like for comparison\n    let artist_tracks_url = format!(\n        \"{}/user/{}/library/music/{}/+tracks?page=1\u0026ajax=true\",\n        session.base_url,\n        session.username,\n        artist.replace(\" \", \"+\")\n    );\n    println!(\"Artist tracks URL (working): {artist_tracks_url}\");\n\n    // And albums URL\n    let artist_albums_url = format!(\n        \"{}/user/{}/library/music/{}/+albums?page=1\u0026ajax=true\",\n        session.base_url,\n        session.username,\n        artist.replace(\" \", \"+\")\n    );\n    println!(\"Artist albums URL (working): {artist_albums_url}\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","session_event_sharing.rs"],"content":"use lastfm_edit::{ClientEvent, LastFmEditClientImpl};\nuse std::env;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    env_logger::init();\n\n    let username =\n        env::var(\"LASTFM_EDIT_USERNAME\").expect(\"Set LASTFM_EDIT_USERNAME environment variable\");\n    let password =\n        env::var(\"LASTFM_EDIT_PASSWORD\").expect(\"Set LASTFM_EDIT_PASSWORD environment variable\");\n\n    println!(\"🔧 Demonstrating shared event broadcasting between clients...\");\n\n    // Create HTTP client and login to create first client\n    let http_client = http_client::native::NativeClient::new();\n    println!(\"🔐 Logging in with client1...\");\n    let client1 =\n        LastFmEditClientImpl::login_with_credentials(Box::new(http_client), \u0026username, \u0026password)\n            .await?;\n    println!(\"✅ Successfully logged in as: {}\", client1.username());\n\n    // Create a second client that shares the broadcaster with client1\n    let http_client2 = http_client::native::NativeClient::new();\n    let client2 = client1.with_shared_broadcaster(Box::new(http_client2));\n    println!(\"🔄 Created client2 with shared broadcaster from client1\");\n\n    // Subscribe to events from both clients\n    let mut events1 = client1.subscribe();\n    let mut events2 = client2.subscribe();\n    println!(\"📡 Subscribed to events from both clients\");\n\n    // Spawn background tasks to monitor events from each client\n    let monitor1 = tokio::spawn(async move {\n        println!(\"🔍 Client1 monitor started\");\n        while let Ok(event) = events1.recv().await {\n            match event {\n                ClientEvent::RequestStarted { request } =\u003e {\n                    println!(\n                        \"🚀 Client1 monitor: Started request {}\",\n                        request.short_description()\n                    );\n                }\n                ClientEvent::RequestCompleted {\n                    request,\n                    status_code,\n                    duration_ms,\n                } =\u003e {\n                    println!(\n                        \"✅ Client1 monitor: Completed {} - {} ({} ms)\",\n                        request.short_description(),\n                        status_code,\n                        duration_ms\n                    );\n                }\n                ClientEvent::RateLimited {\n                    delay_seconds,\n                    request,\n                    rate_limit_type,\n                    rate_limit_timestamp,\n                } =\u003e {\n                    let req_desc = request\n                        .as_ref()\n                        .map(|r| r.short_description())\n                        .unwrap_or_else(|| \"unknown request\".to_string());\n                    println!(\n                        \"⏳ Client1 monitor: Rate limited ({rate_limit_type:?}) for {delay_seconds} seconds - {req_desc} (at timestamp {rate_limit_timestamp})\"\n                    );\n                }\n                ClientEvent::RateLimitEnded {\n                    request,\n                    rate_limit_type,\n                    total_rate_limit_duration_seconds,\n                } =\u003e {\n                    println!(\n                        \"🎉 Client1 monitor: Rate limiting ended ({rate_limit_type:?}) after {total_rate_limit_duration_seconds} seconds - {}\",\n                        request.short_description()\n                    );\n                }\n                ClientEvent::EditAttempted {\n                    edit,\n                    success,\n                    error_message,\n                    duration_ms,\n                } =\u003e {\n                    if success {\n                        println!(\n                            \"✅ Client1 monitor: Edit succeeded '{}' -\u003e '{}' ({duration_ms} ms)\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    } else {\n                        let error_msg = error_message\n                            .as_ref()\n                            .map(|s| format!(\" - {s}\"))\n                            .unwrap_or_default();\n                        println!(\n                            \"❌ Client1 monitor: Edit failed '{}' -\u003e '{}' ({duration_ms} ms){error_msg}\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    }\n                }\n            }\n        }\n    });\n\n    let monitor2 = tokio::spawn(async move {\n        println!(\"🔍 Client2 monitor started\");\n        while let Ok(event) = events2.recv().await {\n            match event {\n                ClientEvent::RequestStarted { request } =\u003e {\n                    println!(\n                        \"🚀 Client2 monitor: Started request {}\",\n                        request.short_description()\n                    );\n                }\n                ClientEvent::RequestCompleted {\n                    request,\n                    status_code,\n                    duration_ms,\n                } =\u003e {\n                    println!(\n                        \"✅ Client2 monitor: Completed {} - {} ({} ms)\",\n                        request.short_description(),\n                        status_code,\n                        duration_ms\n                    );\n                }\n                ClientEvent::RateLimited {\n                    delay_seconds,\n                    request,\n                    rate_limit_type,\n                    rate_limit_timestamp,\n                } =\u003e {\n                    let req_desc = request\n                        .as_ref()\n                        .map(|r| r.short_description())\n                        .unwrap_or_else(|| \"unknown request\".to_string());\n                    println!(\n                        \"⏳ Client2 monitor: Rate limited ({rate_limit_type:?}) for {delay_seconds} seconds - {req_desc} (at timestamp {rate_limit_timestamp})\"\n                    );\n                }\n                ClientEvent::RateLimitEnded {\n                    request,\n                    rate_limit_type,\n                    total_rate_limit_duration_seconds,\n                } =\u003e {\n                    println!(\n                        \"🎉 Client2 monitor: Rate limiting ended ({rate_limit_type:?}) after {total_rate_limit_duration_seconds} seconds - {}\",\n                        request.short_description()\n                    );\n                }\n                ClientEvent::EditAttempted {\n                    edit,\n                    success,\n                    error_message,\n                    duration_ms,\n                } =\u003e {\n                    if success {\n                        println!(\n                            \"✅ Client2 monitor: Edit succeeded '{}' -\u003e '{}' ({duration_ms} ms)\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    } else {\n                        let error_msg = error_message\n                            .as_ref()\n                            .map(|s| format!(\" - {s}\"))\n                            .unwrap_or_default();\n                        println!(\n                            \"❌ Client2 monitor: Edit failed '{}' -\u003e '{}' ({duration_ms} ms){error_msg}\",\n                            edit.track_name_original, edit.track_name\n                        );\n                    }\n                }\n            }\n        }\n    });\n\n    // Make a request with client1 that might trigger rate limiting\n    println!(\"📡 Making request with client1...\");\n    match client1.get_recent_scrobbles(1).await {\n        Ok(tracks) =\u003e {\n            println!(\"✅ Client1 got {} tracks\", tracks.len());\n        }\n        Err(e) =\u003e {\n            println!(\"⚠️ Client1 error: {e}\");\n        }\n    }\n\n    // Check latest event from both clients (should be the same due to shared broadcaster)\n    let event1 = client1.latest_event();\n    let event2 = client2.latest_event();\n\n    match (event1, event2) {\n        (\n            Some(ClientEvent::RateLimited {\n                delay_seconds: delay1,\n                ..\n            }),\n            Some(ClientEvent::RateLimited {\n                delay_seconds: delay2,\n                ..\n            }),\n        ) =\u003e {\n            println!(\"🎯 Both clients show rate limiting: {delay1}s and {delay2}s\");\n            if delay1 == delay2 {\n                println!(\n                    \"✅ SUCCESS: Both clients report the same delay (shared broadcaster working!)\"\n                );\n            } else {\n                println!(\"❌ UNEXPECTED: Different delays reported\");\n            }\n        }\n        (\n            Some(ClientEvent::RequestCompleted { .. }),\n            Some(ClientEvent::RequestCompleted { .. }),\n        ) =\u003e {\n            println!(\"✅ Both clients show completed requests (shared broadcaster working!)\");\n        }\n        (\n            Some(ClientEvent::EditAttempted {\n                success: success1, ..\n            }),\n            Some(ClientEvent::EditAttempted {\n                success: success2, ..\n            }),\n        ) =\u003e {\n            if success1 == success2 {\n                println!(\"✅ Both clients show same edit result (shared broadcaster working!)\");\n            } else {\n                println!(\"❌ UNEXPECTED: Different edit results reported\");\n            }\n        }\n        (None, None) =\u003e {\n            println!(\"📊 No events occurred yet - this is normal\");\n            println!(\"    In real usage, both clients would see the same events when they occur\");\n        }\n        _ =\u003e {\n            println!(\"📊 Different event states between clients (could be due to timing)\");\n        }\n    }\n\n    // Let monitors run for a bit\n    tokio::time::sleep(std::time::Duration::from_secs(1)).await;\n\n    // Clean up\n    monitor1.abort();\n    monitor2.abort();\n\n    println!(\"🏁 Demo completed!\");\n\n    println!(\"\\n📄 Key Points:\");\n    println!(\"  • client1.with_shared_broadcaster() creates clients that share event broadcasting\");\n    println!(\"  • When any shared client encounters rate limiting, all see the same events\");\n    println!(\"  • Use this pattern when you need multiple HTTP clients but want unified rate limit handling\");\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","session_management.rs"],"content":"/// Example demonstrating both login and session restore initialization methods.\n///\n/// This example shows how to:\n/// 1. Initialize a client with username/password login\n/// 2. Save the session state to a file\n/// 3. Restore the session from the saved file\n/// 4. Use both initialization patterns\n///\n/// Usage:\n///   # First run - will prompt for credentials and save session\n///   direnv exec . cargo run --example session_management\n///\n///   # Subsequent runs - will use saved session\n///   direnv exec . cargo run --example session_management\nuse lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, Result};\nuse std::env;\nuse std::fs;\nuse std::io::{self, Write};\nuse std::path::Path;\n\nconst SESSION_FILE: \u0026str = \"session.json\";\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    env_logger::init();\n\n    println!(\"🎵 Last.fm Session Management Example\");\n    println!(\"=====================================\\n\");\n\n    // Try to load existing session first\n    if Path::new(SESSION_FILE).exists() {\n        println!(\"📁 Found existing session file, attempting to restore...\");\n        match restore_from_session().await {\n            Ok(client) =\u003e {\n                println!(\"✅ Session restored successfully!\");\n                println!(\"👤 Logged in as: {}\", client.username());\n\n                // Test the restored session by fetching recent tracks\n                println!(\"🎧 Testing session by fetching recent tracks...\");\n                let tracks = client.get_recent_scrobbles(1).await?;\n                let recent_tracks: Vec\u003c_\u003e = tracks.into_iter().take(3).collect();\n                println!(\"📊 Found {} recent tracks:\", recent_tracks.len());\n\n                for track in recent_tracks {\n                    println!(\"   🎵 {} - {}\", track.artist, track.name);\n                }\n\n                return Ok(());\n            }\n            Err(e) =\u003e {\n                println!(\"❌ Failed to restore session: {e}\");\n                println!(\"🔄 Falling back to fresh login...\\n\");\n                // Remove invalid session file\n                let _ = fs::remove_file(SESSION_FILE);\n            }\n        }\n    }\n\n    // No valid session found, perform fresh login\n    println!(\"🔑 No valid session found, performing fresh login...\");\n    let client = login_with_credentials().await?;\n    println!(\"✅ Login successful!\");\n    println!(\"👤 Logged in as: {}\", client.username());\n\n    // Save session for future use\n    println!(\"💾 Saving session to {SESSION_FILE}...\");\n    save_session(\u0026client)?;\n    println!(\"✅ Session saved!\");\n\n    // Test the new session\n    println!(\"🎧 Testing session by fetching recent tracks...\");\n    let tracks = client.get_recent_scrobbles(1).await?;\n    let recent_tracks: Vec\u003c_\u003e = tracks.into_iter().take(3).collect();\n    println!(\"📊 Found {} recent tracks:\", recent_tracks.len());\n\n    for track in recent_tracks {\n        println!(\"   🎵 {} - {}\", track.artist, track.name);\n    }\n\n    println!(\"\\n🎉 Example completed!\");\n    println!(\"💡 Next time you run this example, it will use the saved session automatically.\");\n\n    Ok(())\n}\n\n/// Restore client from saved session file\nasync fn restore_from_session() -\u003e Result\u003cLastFmEditClientImpl\u003e {\n    let session_json = fs::read_to_string(SESSION_FILE)\n        .map_err(|e| lastfm_edit::LastFmError::Http(format!(\"Failed to read session file: {e}\")))?;\n\n    let session = LastFmEditSession::from_json(\u0026session_json)\n        .map_err(|e| lastfm_edit::LastFmError::Http(format!(\"Failed to parse session: {e}\")))?;\n\n    if !session.is_valid() {\n        return Err(lastfm_edit::LastFmError::Auth(\n            \"Invalid session data\".to_string(),\n        ));\n    }\n\n    let http_client = http_client::native::NativeClient::new();\n    Ok(LastFmEditClientImpl::from_session(\n        Box::new(http_client),\n        session,\n    ))\n}\n\n/// Perform fresh login with credentials\nasync fn login_with_credentials() -\u003e Result\u003cLastFmEditClientImpl\u003e {\n    println!(\"🔧 Using login with credentials pattern...\");\n    let username = get_username();\n    let password = get_password();\n\n    let http_client = http_client::native::NativeClient::new();\n    LastFmEditClientImpl::login_with_credentials(Box::new(http_client), \u0026username, \u0026password).await\n}\n\n/// Save current session to file\nfn save_session(client: \u0026dyn LastFmEditClient) -\u003e Result\u003c()\u003e {\n    let session = client.get_session();\n    let session_json = session\n        .to_json()\n        .map_err(|e| lastfm_edit::LastFmError::Http(format!(\"Failed to serialize session: {e}\")))?;\n\n    fs::write(SESSION_FILE, session_json).map_err(|e| {\n        lastfm_edit::LastFmError::Http(format!(\"Failed to write session file: {e}\"))\n    })?;\n\n    Ok(())\n}\n\n/// Get username from environment variable or prompt\nfn get_username() -\u003e String {\n    env::var(\"LASTFM_EDIT_USERNAME\").unwrap_or_else(|_| {\n        print!(\"Last.fm username: \");\n        io::stdout().flush().unwrap();\n        let mut input = String::new();\n        io::stdin().read_line(\u0026mut input).unwrap();\n        input.trim().to_string()\n    })\n}\n\n/// Get password from environment variable or prompt\nfn get_password() -\u003e String {\n    env::var(\"LASTFM_EDIT_PASSWORD\").unwrap_or_else(|_| {\n        print!(\"Last.fm password: \");\n        io::stdout().flush().unwrap();\n        let mut input = String::new();\n        io::stdin().read_line(\u0026mut input).unwrap();\n        input.trim().to_string()\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","shared","common.rs"],"content":"use lastfm_edit::{LastFmEditClientImpl, Result};\nuse std::env;\n\npub async fn setup_client() -\u003e Result\u003cLastFmEditClientImpl\u003e {\n    // Initialize logger to handle log::debug! calls\n    env_logger::init();\n\n    let username = env::var(\"LASTFM_EDIT_USERNAME\")\n        .expect(\"LASTFM_EDIT_USERNAME environment variable not set\");\n    let password = env::var(\"LASTFM_EDIT_PASSWORD\")\n        .expect(\"LASTFM_EDIT_PASSWORD environment variable not set\");\n\n    // Login and create client\n    let http_client = http_client::native::NativeClient::new();\n    println!(\"Logging in as {username}...\");\n    let client =\n        LastFmEditClientImpl::login_with_credentials(Box::new(http_client), \u0026username, \u0026password)\n            .await?;\n    println!(\"✓ Logged in successfully\");\n\n    Ok(client)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","smart_scrobble_display.rs"],"content":"use lastfm_edit::{ExactScrobbleEdit, ScrobbleEdit};\n\nfn main() {\n    println!(\"=== Smart ScrobbleEdit Display Examples ===\\n\");\n\n    // Example 1: Only changing the artist name\n    let edit1 = ScrobbleEdit {\n        artist_name_original: \"The Beatles\".to_string(),\n        track_name_original: Some(\"Yesterday\".to_string()),\n        album_name_original: Some(\"Help!\".to_string()),\n        album_artist_name_original: None,\n\n        artist_name: \"Beatles, The\".to_string(),   // Changed\n        track_name: Some(\"Yesterday\".to_string()), // Same\n        album_name: Some(\"Help!\".to_string()),     // Same\n        album_artist_name: None,                   // Same\n\n        timestamp: None,\n        edit_all: false,\n    };\n    println!(\"📝 Artist name change:\");\n    println!(\"   {edit1}\");\n\n    // Example 2: Changing track and album names\n    let edit2 = ScrobbleEdit {\n        artist_name_original: \"Pink Floyd\".to_string(),\n        track_name_original: Some(\"Shine on You Crazy Diamond\".to_string()),\n        album_name_original: Some(\"Wish You Were Here\".to_string()),\n        album_artist_name_original: None,\n\n        artist_name: \"Pink Floyd\".to_string(), // Same\n        track_name: Some(\"Shine On You Crazy Diamond\".to_string()), // Changed\n        album_name: Some(\"Wish You Were Here (Remastered)\".to_string()), // Changed\n        album_artist_name: None,               // Same\n\n        timestamp: Some(1640995200),\n        edit_all: true,\n    };\n    println!(\"\\n📝 Track and album changes:\");\n    println!(\"   {edit2}\");\n\n    // Example 3: Adding album artist information\n    let edit3 = ScrobbleEdit {\n        artist_name_original: \"Various Artists\".to_string(),\n        track_name_original: Some(\"Hotel California\".to_string()),\n        album_name_original: Some(\"Greatest Hits Collection\".to_string()),\n        album_artist_name_original: None,\n\n        artist_name: \"Eagles\".to_string(),                // Changed\n        track_name: Some(\"Hotel California\".to_string()), // Same\n        album_name: Some(\"Hotel California\".to_string()), // Changed\n        album_artist_name: Some(\"Eagles\".to_string()),    // Added\n\n        timestamp: None,\n        edit_all: false,\n    };\n    println!(\"\\n📝 Multiple changes including adding album artist:\");\n    println!(\"   {edit3}\");\n\n    // Example 4: No changes (should show \"No changes\")\n    let edit4 = ScrobbleEdit {\n        artist_name_original: \"Radiohead\".to_string(),\n        track_name_original: Some(\"Paranoid Android\".to_string()),\n        album_name_original: Some(\"OK Computer\".to_string()),\n        album_artist_name_original: Some(\"Radiohead\".to_string()),\n\n        artist_name: \"Radiohead\".to_string(),             // Same\n        track_name: Some(\"Paranoid Android\".to_string()), // Same\n        album_name: Some(\"OK Computer\".to_string()),      // Same\n        album_artist_name: Some(\"Radiohead\".to_string()), // Same\n\n        timestamp: None,\n        edit_all: false,\n    };\n    println!(\"\\n📝 No changes:\");\n    println!(\"   {edit4}\");\n\n    // Example 5: ExactScrobbleEdit (all fields required)\n    let exact_edit = ExactScrobbleEdit {\n        artist_name_original: \"Led Zeppelin\".to_string(),\n        track_name_original: \"Stairway to Heaven\".to_string(),\n        album_name_original: \"Led Zeppelin IV\".to_string(),\n        album_artist_name_original: \"Led Zeppelin\".to_string(),\n\n        artist_name: \"Led Zeppelin\".to_string(),      // Same\n        track_name: \"Stairway To Heaven\".to_string(), // Changed (capitalization)\n        album_name: \"Led Zeppelin IV (Remaster)\".to_string(), // Changed\n        album_artist_name: \"Led Zeppelin\".to_string(), // Same\n\n        timestamp: 1640995200,\n        edit_all: true,\n    };\n    println!(\"\\n📝 ExactScrobbleEdit changes:\");\n    println!(\"   {exact_edit}\");\n\n    println!(\"\\n✨ Features demonstrated:\");\n    println!(\"   • Only shows fields that are actually changing\");\n    println!(\"   • Uses → arrow to show old → new values\");\n    println!(\"   • Handles optional fields (None to Some transitions)\");\n    println!(\"   • Shows scope with '(all instances)' when edit_all is true\");\n    println!(\"   • Shows 'No changes' when nothing is being modified\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","test_album_tracks.rs"],"content":"#[path = \"shared/common.rs\"]\nmod common;\n\nuse lastfm_edit::{LastFmEditClient, Result};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let client = common::setup_client().await?;\n\n    let artist = std::env::args()\n        .nth(1)\n        .unwrap_or_else(|| \"The Beatles\".to_string());\n    let album = std::env::args()\n        .nth(2)\n        .unwrap_or_else(|| \"Abbey Road\".to_string());\n\n    println!(\"=== Album Tracks Test ===\\n\");\n    println!(\"🎵 Testing get_album_tracks() with: '{album}' by '{artist}'\\n\");\n\n    // Test the album_tracks iterator method\n    let mut tracks_iterator = client.album_tracks(\u0026album, \u0026artist);\n    let mut tracks = Vec::new();\n\n    while let Some(track) = tracks_iterator.next().await.transpose() {\n        match track {\n            Ok(track) =\u003e tracks.push(track),\n            Err(e) =\u003e {\n                println!(\"❌ ERROR: Failed to get track: {e}\");\n                break;\n            }\n        }\n    }\n\n    println!(\"✅ SUCCESS: Got {} tracks\", tracks.len());\n    if tracks.is_empty() {\n        println!(\"   (Album not found in your library, but no crash!)\");\n    } else {\n        println!(\"   Tracks:\");\n        for (i, track) in tracks.iter().enumerate().take(10) {\n            println!(\"   [{:2}] {}\", i + 1, track.name);\n        }\n        if tracks.len() \u003e 10 {\n            println!(\"   ... and {} more tracks\", tracks.len() - 10);\n        }\n    }\n\n    // Also test the iterator directly\n    println!(\"\\n=== Album Tracks Iterator Test ===\");\n    let mut tracks_iterator = client.album_tracks(\u0026album, \u0026artist);\n    let mut count = 0;\n\n    println!(\"🔍 Testing iterator...\");\n    while let Some(track) = tracks_iterator.next().await? {\n        count += 1;\n        if count \u003c= 5 {\n            println!(\"   [{count}] {}\", track.name);\n        }\n        if count \u003e= 5 {\n            break;\n        }\n    }\n\n    if count == 0 {\n        println!(\"   No tracks found via iterator (album not in library)\");\n    } else {\n        println!(\"   Iterator works - got {count} tracks\");\n    }\n\n    println!(\"\\n🎉 Both methods completed without crashing!\");\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","examples","test_artist_tracks_with_albums.rs"],"content":"use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    println!(\"=== Testing Artist Tracks with Album Information ===\\n\");\n\n    // Create a test session (this won't work without real credentials)\n    let test_session = LastFmEditSession::new(\n        \"test\".to_string(),\n        vec![\"sessionid=.test123\".to_string()],\n        Some(\"csrf\".to_string()),\n        \"https://www.last.fm\".to_string(),\n    );\n\n    let client = LastFmEditClientImpl::from_session(\n        Box::new(http_client::native::NativeClient::new()),\n        test_session,\n    );\n\n    println!(\"🎵 Testing artist tracks iteration (album-based approach)\");\n    println!(\"   This will get tracks by iterating through albums first\");\n    println!(\"   Each track should now have album information populated\");\n\n    let mut tracks_iterator = client.artist_tracks(\"The Beatles\");\n\n    // Get first 5 tracks\n    for i in 0..5 {\n        match tracks_iterator.next().await {\n            Ok(Some(track)) =\u003e {\n                let album_info = track.album.as_deref().unwrap_or(\"No album info\");\n                let album_artist_info = track\n                    .album_artist\n                    .as_deref()\n                    .unwrap_or(\"Same as track artist\");\n\n                println!(\n                    \"  [{:2}] {} - {} [{}]\",\n                    i + 1,\n                    track.artist,\n                    track.name,\n                    album_info\n                );\n                println!(\n                    \"       Album Artist: {} | Play Count: {}\",\n                    album_artist_info, track.playcount\n                );\n\n                if let Some(timestamp) = track.timestamp {\n                    println!(\"       Last Played: {timestamp}\");\n                }\n                println!();\n            }\n            Ok(None) =\u003e {\n                println!(\"  No more tracks found\");\n                break;\n            }\n            Err(e) =\u003e {\n                println!(\"  ❌ Error: {e}\");\n                break;\n            }\n        }\n    }\n\n    println!(\"✨ Key improvements:\");\n    println!(\"   • Tracks now include complete album information\");\n    println!(\"   • Album artist information is available when different from track artist\");\n    println!(\"   • Implementation iterates through albums first, then gets tracks per album\");\n    println!(\"   • This provides richer metadata compared to the previous direct track approach\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","src","client.rs"],"content":"use crate::edit_analysis;\nuse crate::headers;\nuse crate::login::extract_cookies_from_response;\nuse crate::parsing::LastFmParser;\nuse crate::r#trait::LastFmEditClient;\nuse crate::retry;\nuse crate::types::{\n    AlbumPage, ClientConfig, ClientEvent, ClientEventReceiver, EditResponse, ExactScrobbleEdit,\n    LastFmEditSession, LastFmError, OperationalDelayConfig, RateLimitConfig, RateLimitType,\n    RequestInfo, RetryConfig, ScrobbleEdit, SharedEventBroadcaster, SingleEditResponse, Track,\n    TrackPage,\n};\nuse crate::Result;\nuse async_trait::async_trait;\nuse http_client::{HttpClient, Request, Response};\nuse http_types::{Method, Url};\nuse scraper::{Html, Selector};\nuse std::sync::{Arc, Mutex};\n\n#[derive(Clone)]\npub struct LastFmEditClientImpl {\n    client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n    session: Arc\u003cMutex\u003cLastFmEditSession\u003e\u003e,\n    parser: LastFmParser,\n    broadcaster: Arc\u003cSharedEventBroadcaster\u003e,\n    config: ClientConfig,\n}\n\nimpl LastFmEditClientImpl {\n    /// Custom URL encoding for Last.fm paths\n    fn lastfm_encode(\u0026self, input: \u0026str) -\u003e String {\n        urlencoding::encode(input).to_string()\n    }\n\n    pub fn from_session(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n    ) -\u003e Self {\n        Self::from_session_with_arc(Arc::from(client), session)\n    }\n\n    fn from_session_with_arc(\n        client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n    ) -\u003e Self {\n        Self::from_session_with_broadcaster_arc(\n            client,\n            session,\n            Arc::new(SharedEventBroadcaster::new()),\n        )\n    }\n\n    pub fn from_session_with_rate_limit_patterns(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        rate_limit_patterns: Vec\u003cString\u003e,\n    ) -\u003e Self {\n        let config = ClientConfig::default()\n            .with_rate_limit_config(RateLimitConfig::default().with_patterns(rate_limit_patterns));\n        Self::from_session_with_client_config(client, session, config)\n    }\n\n    pub async fn login_with_credentials(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        username: \u0026str,\n        password: \u0026str,\n    ) -\u003e Result\u003cSelf\u003e {\n        let client_arc: Arc\u003cdyn HttpClient + Send + Sync\u003e = Arc::from(client);\n        let login_manager =\n            crate::login::LoginManager::new(client_arc.clone(), \"https://www.last.fm\".to_string());\n        let session = login_manager.login(username, password).await?;\n        Ok(Self::from_session_with_arc(client_arc, session))\n    }\n\n    pub fn from_session_with_client_config(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        config: ClientConfig,\n    ) -\u003e Self {\n        Self::from_session_with_client_config_arc(Arc::from(client), session, config)\n    }\n\n    pub async fn login_with_credentials_and_client_config(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        username: \u0026str,\n        password: \u0026str,\n        config: ClientConfig,\n    ) -\u003e Result\u003cSelf\u003e {\n        let client_arc: Arc\u003cdyn HttpClient + Send + Sync\u003e = Arc::from(client);\n        let login_manager =\n            crate::login::LoginManager::new(client_arc.clone(), \"https://www.last.fm\".to_string());\n        let session = login_manager.login(username, password).await?;\n        Ok(Self::from_session_with_client_config_arc(\n            client_arc, session, config,\n        ))\n    }\n\n    pub fn from_session_with_config(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        retry_config: RetryConfig,\n        rate_limit_config: RateLimitConfig,\n    ) -\u003e Self {\n        Self::from_session_with_config_arc(\n            Arc::from(client),\n            session,\n            retry_config,\n            rate_limit_config,\n        )\n    }\n\n    pub async fn login_with_credentials_and_config(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        username: \u0026str,\n        password: \u0026str,\n        retry_config: RetryConfig,\n        rate_limit_config: RateLimitConfig,\n    ) -\u003e Result\u003cSelf\u003e {\n        let client_arc: Arc\u003cdyn HttpClient + Send + Sync\u003e = Arc::from(client);\n        let login_manager =\n            crate::login::LoginManager::new(client_arc.clone(), \"https://www.last.fm\".to_string());\n        let session = login_manager.login(username, password).await?;\n        Ok(Self::from_session_with_config_arc(\n            client_arc,\n            session,\n            retry_config,\n            rate_limit_config,\n        ))\n    }\n\n    fn from_session_with_broadcaster(\n        client: Box\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        broadcaster: Arc\u003cSharedEventBroadcaster\u003e,\n    ) -\u003e Self {\n        Self::from_session_with_broadcaster_arc(Arc::from(client), session, broadcaster)\n    }\n\n    fn from_session_with_client_config_arc(\n        client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        config: ClientConfig,\n    ) -\u003e Self {\n        Self::from_session_with_client_config_and_broadcaster_arc(\n            client,\n            session,\n            config,\n            Arc::new(SharedEventBroadcaster::new()),\n        )\n    }\n\n    fn from_session_with_config_arc(\n        client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        retry_config: RetryConfig,\n        rate_limit_config: RateLimitConfig,\n    ) -\u003e Self {\n        let config = ClientConfig {\n            retry: retry_config,\n            rate_limit: rate_limit_config,\n            operational_delays: OperationalDelayConfig::default(),\n        };\n        Self::from_session_with_client_config_arc(client, session, config)\n    }\n\n    fn from_session_with_broadcaster_arc(\n        client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        broadcaster: Arc\u003cSharedEventBroadcaster\u003e,\n    ) -\u003e Self {\n        Self::from_session_with_client_config_and_broadcaster_arc(\n            client,\n            session,\n            ClientConfig::default(),\n            broadcaster,\n        )\n    }\n\n    fn from_session_with_client_config_and_broadcaster_arc(\n        client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n        session: LastFmEditSession,\n        config: ClientConfig,\n        broadcaster: Arc\u003cSharedEventBroadcaster\u003e,\n    ) -\u003e Self {\n        Self {\n            client,\n            session: Arc::new(Mutex::new(session)),\n            parser: LastFmParser::new(),\n            broadcaster,\n            config,\n        }\n    }\n\n    pub fn get_session(\u0026self) -\u003e LastFmEditSession {\n        self.session.lock().unwrap().clone()\n    }\n\n    pub fn with_shared_broadcaster(\u0026self, client: Box\u003cdyn HttpClient + Send + Sync\u003e) -\u003e Self {\n        let session = self.get_session();\n        Self::from_session_with_broadcaster(client, session, self.broadcaster.clone())\n    }\n\n    pub fn username(\u0026self) -\u003e String {\n        self.session.lock().unwrap().username.clone()\n    }\n\n    pub async fn validate_session(\u0026self) -\u003e bool {\n        let test_url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/settings/subscription/automatic-edits/tracks\",\n                session.base_url\n            )\n        };\n\n        let mut request = Request::new(Method::Get, test_url.parse::\u003cUrl\u003e().unwrap());\n\n        {\n            let session = self.session.lock().unwrap();\n            headers::add_cookies(\u0026mut request, \u0026session.cookies);\n        }\n\n        headers::add_get_headers(\u0026mut request, false, None);\n\n        match self.client.send(request).await {\n            Ok(response) =\u003e {\n                if response.status() == 302 || response.status() == 301 {\n                    if let Some(location) = response.header(\"location\") {\n                        if let Some(redirect_url) = location.get(0) {\n                            let redirect_url_str = redirect_url.as_str();\n                            let is_valid = !redirect_url_str.contains(\"/login\");\n\n                            return is_valid;\n                        }\n                    }\n                }\n                true\n            }\n            Err(_e) =\u003e false,\n        }\n    }\n\n    pub async fn delete_scrobble(\n        \u0026self,\n        artist_name: \u0026str,\n        track_name: \u0026str,\n        timestamp: u64,\n    ) -\u003e Result\u003cbool\u003e {\n        let config = RetryConfig {\n            max_retries: 3,\n            base_delay: 5,\n            max_delay: 300,\n            enabled: true,\n        };\n\n        let artist_name = artist_name.to_string();\n        let track_name = track_name.to_string();\n        let client = self.clone();\n\n        match retry::retry_with_backoff(\n            config,\n            \"Delete scrobble\",\n            || client.delete_scrobble_impl(\u0026artist_name, \u0026track_name, timestamp),\n            |delay, rate_limit_timestamp, operation_name| {\n                self.broadcast_event(ClientEvent::RateLimited {\n                    delay_seconds: delay,\n                    request: None,\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    rate_limit_timestamp,\n                });\n                log::debug!(\"{operation_name} rate limited, waiting {delay} seconds\");\n            },\n            |total_duration, _operation_name| {\n                self.broadcast_event(ClientEvent::RateLimitEnded {\n                    request: crate::types::RequestInfo::from_url_and_method(\n                        \u0026format!(\"delete_scrobble/{artist_name}/{track_name}/{timestamp}\"),\n                        \"POST\",\n                    ),\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    total_rate_limit_duration_seconds: total_duration,\n                });\n            },\n        )\n        .await\n        {\n            Ok(retry_result) =\u003e Ok(retry_result.result),\n            Err(_) =\u003e Ok(false),\n        }\n    }\n\n    async fn delete_scrobble_impl(\n        \u0026self,\n        artist_name: \u0026str,\n        track_name: \u0026str,\n        timestamp: u64,\n    ) -\u003e Result\u003cbool\u003e {\n        let delete_url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/delete\",\n                session.base_url, session.username\n            )\n        };\n\n        log::debug!(\"Getting fresh CSRF token for delete\");\n        let library_url = {\n            let session = self.session.lock().unwrap();\n            format!(\"{}/user/{}/library\", session.base_url, session.username)\n        };\n\n        let mut response = self.get(\u0026library_url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        let document = Html::parse_document(\u0026content);\n        let fresh_csrf_token = self.extract_csrf_token(\u0026document)?;\n\n        log::debug!(\"Submitting delete request with fresh token\");\n\n        let mut request = Request::new(Method::Post, delete_url.parse::\u003cUrl\u003e().unwrap());\n\n        let referer_url = {\n            let session = self.session.lock().unwrap();\n            headers::add_cookies(\u0026mut request, \u0026session.cookies);\n            format!(\"{}/user/{}\", session.base_url, session.username)\n        };\n\n        headers::add_edit_headers(\u0026mut request, \u0026referer_url);\n\n        let form_data = [\n            (\"csrfmiddlewaretoken\", fresh_csrf_token.as_str()),\n            (\"artist_name\", artist_name),\n            (\"track_name\", track_name),\n            (\"timestamp\", \u0026timestamp.to_string()),\n            (\"ajax\", \"1\"),\n        ];\n\n        let form_string: String = form_data\n            .iter()\n            .map(|(k, v)| format!(\"{}={}\", urlencoding::encode(k), urlencoding::encode(v)))\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\u0026\");\n\n        request.set_body(form_string);\n\n        log::debug!(\n            \"Deleting scrobble: '{track_name}' by '{artist_name}' with timestamp {timestamp}\"\n        );\n\n        let request_info = RequestInfo::from_url_and_method(\u0026delete_url, \"POST\");\n        let request_start = std::time::Instant::now();\n\n        self.broadcast_event(ClientEvent::RequestStarted {\n            request: request_info.clone(),\n        });\n\n        let mut response = self\n            .client\n            .send(request)\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        self.broadcast_event(ClientEvent::RequestCompleted {\n            request: request_info.clone(),\n            status_code: response.status().into(),\n            duration_ms: request_start.elapsed().as_millis() as u64,\n        });\n\n        log::debug!(\"Delete response status: {}\", response.status());\n\n        let response_text = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        let success = response.status().is_success();\n\n        if success {\n            log::debug!(\"Successfully deleted scrobble\");\n        } else {\n            log::debug!(\"Delete failed with response: {response_text}\");\n        }\n\n        Ok(success)\n    }\n\n    pub fn subscribe(\u0026self) -\u003e ClientEventReceiver {\n        self.broadcaster.subscribe()\n    }\n\n    pub fn latest_event(\u0026self) -\u003e Option\u003cClientEvent\u003e {\n        self.broadcaster.latest_event()\n    }\n\n    fn broadcast_event(\u0026self, event: ClientEvent) {\n        self.broadcaster.broadcast_event(event);\n    }\n\n    pub async fn get_recent_scrobbles(\u0026self, page: u32) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library?page={}\",\n                session.base_url, session.username, page\n            )\n        };\n\n        log::debug!(\"Fetching recent scrobbles page {page}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"Recent scrobbles response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        let document = Html::parse_document(\u0026content);\n        self.parser.parse_recent_scrobbles(\u0026document)\n    }\n\n    pub async fn get_recent_tracks_page(\u0026self, page: u32) -\u003e Result\u003cTrackPage\u003e {\n        let tracks = self.get_recent_scrobbles(page).await?;\n\n        let has_next_page = !tracks.is_empty();\n\n        Ok(TrackPage {\n            tracks,\n            page_number: page,\n            has_next_page,\n            total_pages: None,\n        })\n    }\n\n    pub async fn find_recent_scrobble_for_track(\n        \u0026self,\n        track_name: \u0026str,\n        artist_name: \u0026str,\n        max_pages: u32,\n    ) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        log::debug!(\"Searching for recent scrobble: '{track_name}' by '{artist_name}'\");\n\n        for page in 1..=max_pages {\n            let scrobbles = self.get_recent_scrobbles(page).await?;\n\n            for scrobble in scrobbles {\n                if scrobble.name == track_name \u0026\u0026 scrobble.artist == artist_name {\n                    log::debug!(\n                        \"Found recent scrobble: '{}' with timestamp {:?}\",\n                        scrobble.name,\n                        scrobble.timestamp\n                    );\n                    return Ok(Some(scrobble));\n                }\n            }\n        }\n\n        log::debug!(\n            \"No recent scrobble found for '{track_name}' by '{artist_name}' in {max_pages} pages\"\n        );\n        Ok(None)\n    }\n\n    pub async fn edit_scrobble(\u0026self, edit: \u0026ScrobbleEdit) -\u003e Result\u003cEditResponse\u003e {\n        let discovered_edits = self.discover_scrobble_edit_variations(edit).await?;\n\n        if discovered_edits.is_empty() {\n            let context = match (\u0026edit.track_name_original, \u0026edit.album_name_original) {\n                (Some(track_name), _) =\u003e {\n                    format!(\"track '{}' by '{}'\", track_name, edit.artist_name_original)\n                }\n                (None, Some(album_name)) =\u003e {\n                    format!(\"album '{}' by '{}'\", album_name, edit.artist_name_original)\n                }\n                (None, None) =\u003e format!(\"artist '{}'\", edit.artist_name_original),\n            };\n            return Err(LastFmError::Parse(format!(\n                \"No scrobbles found for {context}. Make sure the names are correct and that you have scrobbled recently.\"\n            )));\n        }\n\n        log::info!(\n            \"Discovered {} scrobble instances to edit\",\n            discovered_edits.len()\n        );\n\n        let mut all_results = Vec::new();\n\n        for (index, discovered_edit) in discovered_edits.iter().enumerate() {\n            log::debug!(\n                \"Processing scrobble {}/{}: '{}' from '{}'\",\n                index + 1,\n                discovered_edits.len(),\n                discovered_edit.track_name_original,\n                discovered_edit.album_name_original\n            );\n\n            let mut modified_exact_edit = discovered_edit.clone();\n\n            if let Some(new_track_name) = \u0026edit.track_name {\n                modified_exact_edit.track_name = new_track_name.clone();\n            }\n            if let Some(new_album_name) = \u0026edit.album_name {\n                modified_exact_edit.album_name = new_album_name.clone();\n            }\n            modified_exact_edit.artist_name = edit.artist_name.clone();\n            if let Some(new_album_artist_name) = \u0026edit.album_artist_name {\n                modified_exact_edit.album_artist_name = new_album_artist_name.clone();\n            }\n            modified_exact_edit.edit_all = edit.edit_all;\n\n            let album_info = format!(\n                \"{} by {}\",\n                modified_exact_edit.album_name_original,\n                modified_exact_edit.album_artist_name_original\n            );\n\n            let single_response = self.edit_scrobble_single(\u0026modified_exact_edit, 3).await?;\n            let success = single_response.success();\n            let message = single_response.message();\n\n            all_results.push(SingleEditResponse {\n                success,\n                message,\n                album_info: Some(album_info),\n                exact_scrobble_edit: modified_exact_edit.clone(),\n            });\n\n            if index \u003c discovered_edits.len() - 1\n                \u0026\u0026 self.config.operational_delays.edit_delay_ms \u003e 0\n            {\n                tokio::time::sleep(std::time::Duration::from_millis(\n                    self.config.operational_delays.edit_delay_ms,\n                ))\n                .await;\n            }\n        }\n\n        Ok(EditResponse::from_results(all_results))\n    }\n\n    pub async fn edit_scrobble_single(\n        \u0026self,\n        exact_edit: \u0026ExactScrobbleEdit,\n        max_retries: u32,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        let config = RetryConfig {\n            max_retries,\n            base_delay: 5,\n            max_delay: 300,\n            enabled: true,\n        };\n\n        let edit_clone = exact_edit.clone();\n        let client = self.clone();\n\n        match retry::retry_with_backoff(\n            config,\n            \"Edit scrobble\",\n            || client.edit_scrobble_impl(\u0026edit_clone),\n            |delay, rate_limit_timestamp, operation_name| {\n                self.broadcast_event(ClientEvent::RateLimited {\n                    delay_seconds: delay,\n                    request: None, // No specific request context in retry callback\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    rate_limit_timestamp,\n                });\n                log::debug!(\"{operation_name} rate limited, waiting {delay} seconds\");\n            },\n            |total_duration, _operation_name| {\n                self.broadcast_event(ClientEvent::RateLimitEnded {\n                    request: crate::types::RequestInfo::from_url_and_method(\n                        \u0026format!(\n                            \"edit_scrobble/{}/{}\",\n                            edit_clone.artist_name, edit_clone.track_name\n                        ),\n                        \"POST\",\n                    ),\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    total_rate_limit_duration_seconds: total_duration,\n                });\n            },\n        )\n        .await\n        {\n            Ok(retry_result) =\u003e Ok(EditResponse::single(\n                retry_result.result,\n                None,\n                None,\n                exact_edit.clone(),\n            )),\n            Err(LastFmError::RateLimit { .. }) =\u003e Ok(EditResponse::single(\n                false,\n                Some(format!(\"Rate limit exceeded after {max_retries} retries\")),\n                None,\n                exact_edit.clone(),\n            )),\n            Err(other_error) =\u003e Ok(EditResponse::single(\n                false,\n                Some(other_error.to_string()),\n                None,\n                exact_edit.clone(),\n            )),\n        }\n    }\n\n    async fn edit_scrobble_impl(\u0026self, exact_edit: \u0026ExactScrobbleEdit) -\u003e Result\u003cbool\u003e {\n        let start_time = std::time::Instant::now();\n        let result = self.edit_scrobble_impl_internal(exact_edit).await;\n        let duration_ms = start_time.elapsed().as_millis() as u64;\n\n        match \u0026result {\n            Ok(success) =\u003e {\n                self.broadcast_event(ClientEvent::EditAttempted {\n                    edit: exact_edit.clone(),\n                    success: *success,\n                    error_message: None,\n                    duration_ms,\n                });\n            }\n            Err(error) =\u003e {\n                self.broadcast_event(ClientEvent::EditAttempted {\n                    edit: exact_edit.clone(),\n                    success: false,\n                    error_message: Some(error.to_string()),\n                    duration_ms,\n                });\n            }\n        }\n\n        result\n    }\n\n    async fn edit_scrobble_impl_internal(\u0026self, exact_edit: \u0026ExactScrobbleEdit) -\u003e Result\u003cbool\u003e {\n        let edit_url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/edit?edited-variation=library-track-scrobble\",\n                session.base_url, session.username\n            )\n        };\n\n        log::debug!(\"Getting fresh CSRF token for edit\");\n        let form_html = self.get_edit_form_html(\u0026edit_url).await?;\n\n        let form_document = Html::parse_document(\u0026form_html);\n        let fresh_csrf_token = self.extract_csrf_token(\u0026form_document)?;\n\n        log::debug!(\"Submitting edit with fresh token\");\n\n        let form_data = exact_edit.build_form_data(\u0026fresh_csrf_token);\n\n        log::debug!(\n            \"Editing scrobble: '{}' -\u003e '{}'\",\n            exact_edit.track_name_original,\n            exact_edit.track_name\n        );\n        {\n            let session = self.session.lock().unwrap();\n            log::trace!(\"Session cookies count: {}\", session.cookies.len());\n        }\n\n        let mut request = Request::new(Method::Post, edit_url.parse::\u003cUrl\u003e().unwrap());\n\n        let referer_url = {\n            let session = self.session.lock().unwrap();\n            headers::add_cookies(\u0026mut request, \u0026session.cookies);\n            format!(\"{}/user/{}/library\", session.base_url, session.username)\n        };\n\n        headers::add_edit_headers(\u0026mut request, \u0026referer_url);\n\n        let form_string: String = form_data\n            .iter()\n            .map(|(k, v)| format!(\"{}={}\", urlencoding::encode(k), urlencoding::encode(v)))\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\u0026\");\n\n        request.set_body(form_string);\n\n        let request_info = RequestInfo::from_url_and_method(\u0026edit_url, \"POST\");\n        let request_start = std::time::Instant::now();\n\n        self.broadcast_event(ClientEvent::RequestStarted {\n            request: request_info.clone(),\n        });\n\n        let mut response = self\n            .client\n            .send(request)\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        self.broadcast_event(ClientEvent::RequestCompleted {\n            request: request_info.clone(),\n            status_code: response.status().into(),\n            duration_ms: request_start.elapsed().as_millis() as u64,\n        });\n\n        log::debug!(\"Edit response status: {}\", response.status());\n\n        let response_text = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        let analysis = edit_analysis::analyze_edit_response(\u0026response_text, response.status());\n\n        Ok(analysis.success)\n    }\n\n    async fn get_edit_form_html(\u0026self, edit_url: \u0026str) -\u003e Result\u003cString\u003e {\n        let mut form_response = self.get(edit_url).await?;\n        let form_html = form_response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\"Edit form response status: {}\", form_response.status());\n        Ok(form_html)\n    }\n\n    pub async fn load_edit_form_values_internal(\n        \u0026self,\n        track_name: \u0026str,\n        artist_name: \u0026str,\n    ) -\u003e Result\u003cVec\u003cExactScrobbleEdit\u003e\u003e {\n        log::debug!(\"Loading edit form values for '{track_name}' by '{artist_name}'\");\n\n        let base_track_url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/music/+noredirect/{}/_/{}\",\n                session.base_url,\n                session.username,\n                urlencoding::encode(artist_name),\n                urlencoding::encode(track_name)\n            )\n        };\n\n        log::debug!(\"Fetching track page: {base_track_url}\");\n\n        let mut response = self.get(\u0026base_track_url).await?;\n        let html = response\n            .body_string()\n            .await\n            .map_err(|e| crate::LastFmError::Http(e.to_string()))?;\n\n        let document = Html::parse_document(\u0026html);\n\n        let mut all_scrobble_edits = Vec::new();\n        let mut unique_albums = std::collections::HashSet::new();\n        let max_pages = 5;\n\n        let page_edits = self.extract_scrobble_edits_from_page(\n            \u0026document,\n            track_name,\n            artist_name,\n            \u0026mut unique_albums,\n        )?;\n        all_scrobble_edits.extend(page_edits);\n\n        log::debug!(\n            \"Page 1: found {} unique album variations\",\n            all_scrobble_edits.len()\n        );\n\n        let pagination_selector = Selector::parse(\".pagination .pagination-next\").unwrap();\n        let mut has_next_page = document.select(\u0026pagination_selector).next().is_some();\n        let mut page = 2;\n\n        while has_next_page \u0026\u0026 page \u003c= max_pages {\n            let page_url = {\n                let session = self.session.lock().unwrap();\n                format!(\n                    \"{}/user/{}/library/music/{}/_/{}?page={page}\",\n                    session.base_url,\n                    session.username,\n                    urlencoding::encode(artist_name),\n                    urlencoding::encode(track_name)\n                )\n            };\n\n            log::debug!(\"Fetching page {page} for additional album variations\");\n\n            let mut response = self.get(\u0026page_url).await?;\n            let html = response\n                .body_string()\n                .await\n                .map_err(|e| crate::LastFmError::Http(e.to_string()))?;\n\n            let document = Html::parse_document(\u0026html);\n\n            let page_edits = self.extract_scrobble_edits_from_page(\n                \u0026document,\n                track_name,\n                artist_name,\n                \u0026mut unique_albums,\n            )?;\n\n            let initial_count = all_scrobble_edits.len();\n            all_scrobble_edits.extend(page_edits);\n            let found_new_unique_albums = all_scrobble_edits.len() \u003e initial_count;\n\n            has_next_page = document.select(\u0026pagination_selector).next().is_some();\n\n            log::debug!(\n                \"Page {page}: found {} total unique albums ({})\",\n                all_scrobble_edits.len(),\n                if found_new_unique_albums {\n                    \"new albums found\"\n                } else {\n                    \"no new unique albums\"\n                }\n            );\n\n            page += 1;\n        }\n\n        if all_scrobble_edits.is_empty() {\n            return Err(crate::LastFmError::Parse(format!(\n                \"No scrobble forms found for track '{track_name}' by '{artist_name}'\"\n            )));\n        }\n\n        log::debug!(\n            \"Final result: found {} unique album variations for '{track_name}' by '{artist_name}'\",\n            all_scrobble_edits.len(),\n        );\n\n        Ok(all_scrobble_edits)\n    }\n\n    fn extract_scrobble_edits_from_page(\n        \u0026self,\n        document: \u0026Html,\n        expected_track: \u0026str,\n        expected_artist: \u0026str,\n        unique_albums: \u0026mut std::collections::HashSet\u003c(String, String)\u003e,\n    ) -\u003e Result\u003cVec\u003cExactScrobbleEdit\u003e\u003e {\n        let mut scrobble_edits = Vec::new();\n        let table_selector =\n            Selector::parse(\"table.chartlist:not(.chartlist__placeholder)\").unwrap();\n        let table = document.select(\u0026table_selector).next().ok_or_else(|| {\n            crate::LastFmError::Parse(\"No chartlist table found on track page\".to_string())\n        })?;\n\n        let row_selector = Selector::parse(\"tr\").unwrap();\n        for row in table.select(\u0026row_selector) {\n            let count_bar_link_selector = Selector::parse(\".chartlist-count-bar-link\").unwrap();\n            if row.select(\u0026count_bar_link_selector).next().is_some() {\n                log::debug!(\"Found count bar link, skipping aggregated row\");\n                continue;\n            }\n\n            let form_selector = Selector::parse(\"form[data-edit-scrobble]\").unwrap();\n            if let Some(form) = row.select(\u0026form_selector).next() {\n                let extract_form_value = |name: \u0026str| -\u003e Option\u003cString\u003e {\n                    let selector = Selector::parse(\u0026format!(\"input[name='{name}']\")).unwrap();\n                    form.select(\u0026selector)\n                        .next()\n                        .and_then(|input| input.value().attr(\"value\"))\n                        .map(|s| s.to_string())\n                };\n\n                let form_track = extract_form_value(\"track_name\").unwrap_or_default();\n                let form_artist = extract_form_value(\"artist_name\").unwrap_or_default();\n                let form_album = extract_form_value(\"album_name\").unwrap_or_default();\n                let form_album_artist =\n                    extract_form_value(\"album_artist_name\").unwrap_or_else(|| form_artist.clone());\n                let form_timestamp = extract_form_value(\"timestamp\").unwrap_or_default();\n\n                if form_track == expected_track \u0026\u0026 form_artist == expected_artist {\n                    let album_key = (form_album.clone(), form_album_artist.clone());\n                    if unique_albums.insert(album_key) {\n                        let timestamp = if form_timestamp.is_empty() {\n                            None\n                        } else {\n                            form_timestamp.parse::\u003cu64\u003e().ok()\n                        };\n\n                        if let Some(timestamp) = timestamp {\n                            let scrobble_edit = ExactScrobbleEdit::new(\n                                form_track.clone(),\n                                form_album.clone(),\n                                form_artist.clone(),\n                                form_album_artist.clone(),\n                                form_track,\n                                form_album,\n                                form_artist,\n                                form_album_artist,\n                                timestamp,\n                                true,\n                            );\n                            scrobble_edits.push(scrobble_edit);\n                        } else {\n                            log::warn!(\n                                \"⚠️ Skipping form without valid timestamp: '{form_album}' by '{form_album_artist}'\"\n                            );\n                        }\n                    }\n                }\n            }\n        }\n\n        Ok(scrobble_edits)\n    }\n\n    pub async fn get_artist_tracks_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003cTrackPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/music/{}/+tracks?page={}\u0026ajax=true\",\n                session.base_url,\n                session.username,\n                urlencoding::encode(artist),\n                page\n            )\n        };\n\n        log::debug!(\"Fetching tracks page {page} for artist: {artist}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"AJAX response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        log::debug!(\"Parsing HTML response from AJAX endpoint\");\n        let document = Html::parse_document(\u0026content);\n        self.parser.parse_tracks_page(\u0026document, page, artist, None)\n    }\n\n    pub fn extract_tracks_from_document(\n        \u0026self,\n        document: \u0026Html,\n        artist: \u0026str,\n        album: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        self.parser\n            .extract_tracks_from_document(document, artist, album)\n    }\n\n    pub fn parse_tracks_page(\n        \u0026self,\n        document: \u0026Html,\n        page_number: u32,\n        artist: \u0026str,\n        album: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cTrackPage\u003e {\n        self.parser\n            .parse_tracks_page(document, page_number, artist, album)\n    }\n\n    fn extract_csrf_token(\u0026self, document: \u0026Html) -\u003e Result\u003cString\u003e {\n        let csrf_selector = Selector::parse(\"input[name=\\\"csrfmiddlewaretoken\\\"]\").unwrap();\n\n        document\n            .select(\u0026csrf_selector)\n            .next()\n            .and_then(|input| input.value().attr(\"value\"))\n            .map(|token| token.to_string())\n            .ok_or(LastFmError::CsrfNotFound)\n    }\n\n    pub async fn get(\u0026self, url: \u0026str) -\u003e Result\u003cResponse\u003e {\n        self.get_with_retry(url).await\n    }\n\n    async fn get_with_retry(\u0026self, url: \u0026str) -\u003e Result\u003cResponse\u003e {\n        let config = self.config.retry.clone();\n\n        let url_string = url.to_string();\n        let client = self.clone();\n\n        let retry_result = retry::retry_with_backoff(\n            config,\n            \u0026format!(\"GET {url}\"),\n            || async {\n                let mut response = client.get_with_redirects(\u0026url_string, 0).await?;\n\n                let body = client\n                    .extract_response_body(\u0026url_string, \u0026mut response)\n                    .await?;\n\n                if response.status().is_success() \u0026\u0026 client.is_rate_limit_response(\u0026body) {\n                    log::debug!(\"Response body contains rate limit patterns\");\n                    return Err(LastFmError::RateLimit { retry_after: 60 });\n                }\n\n                let mut new_response = http_types::Response::new(response.status());\n                for (name, values) in response.iter() {\n                    for value in values {\n                        let _ = new_response.insert_header(name.clone(), value.clone());\n                    }\n                }\n                new_response.set_body(body);\n\n                Ok(new_response)\n            },\n            |delay, rate_limit_timestamp, operation_name| {\n                self.broadcast_event(ClientEvent::RateLimited {\n                    delay_seconds: delay,\n                    request: None, // No specific request context in retry callback\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    rate_limit_timestamp,\n                });\n                log::debug!(\"{operation_name} rate limited, waiting {delay} seconds\");\n            },\n            |total_duration, _operation_name| {\n                self.broadcast_event(ClientEvent::RateLimitEnded {\n                    request: crate::types::RequestInfo::from_url_and_method(\u0026url_string, \"GET\"),\n                    rate_limit_type: RateLimitType::ResponsePattern,\n                    total_rate_limit_duration_seconds: total_duration,\n                });\n            },\n        )\n        .await?;\n\n        Ok(retry_result.result)\n    }\n\n    async fn get_with_redirects(\u0026self, url: \u0026str, redirect_count: u32) -\u003e Result\u003cResponse\u003e {\n        if redirect_count \u003e 5 {\n            return Err(LastFmError::Http(\"Too many redirects\".to_string()));\n        }\n\n        let mut request = Request::new(Method::Get, url.parse::\u003cUrl\u003e().unwrap());\n\n        {\n            let session = self.session.lock().unwrap();\n            headers::add_cookies(\u0026mut request, \u0026session.cookies);\n            if session.cookies.is_empty() \u0026\u0026 url.contains(\"page=\") {\n                log::debug!(\"No cookies available for paginated request!\");\n            }\n        }\n\n        let is_ajax = url.contains(\"ajax=true\");\n        let referer_url = if url.contains(\"page=\") {\n            Some(url.split('?').next().unwrap_or(url))\n        } else {\n            None\n        };\n\n        headers::add_get_headers(\u0026mut request, is_ajax, referer_url);\n\n        let request_info = RequestInfo::from_url_and_method(url, \"GET\");\n        let request_start = std::time::Instant::now();\n\n        self.broadcast_event(ClientEvent::RequestStarted {\n            request: request_info.clone(),\n        });\n\n        let response = self\n            .client\n            .send(request)\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        self.broadcast_event(ClientEvent::RequestCompleted {\n            request: request_info.clone(),\n            status_code: response.status().into(),\n            duration_ms: request_start.elapsed().as_millis() as u64,\n        });\n\n        self.extract_cookies(\u0026response);\n\n        if response.status() == 302 || response.status() == 301 {\n            if let Some(location) = response.header(\"location\") {\n                if let Some(redirect_url) = location.get(0) {\n                    let redirect_url_str = redirect_url.as_str();\n                    if url.contains(\"page=\") {\n                        log::debug!(\"Following redirect from {url} to {redirect_url_str}\");\n\n                        if redirect_url_str.contains(\"/login\") {\n                            log::debug!(\"Redirect to login page - authentication failed for paginated request\");\n                            return Err(LastFmError::Auth(\n                                \"Session expired or invalid for paginated request\".to_string(),\n                            ));\n                        }\n                    }\n\n                    let full_redirect_url = if redirect_url_str.starts_with('/') {\n                        let base_url = self.session.lock().unwrap().base_url.clone();\n                        format!(\"{base_url}{redirect_url_str}\")\n                    } else if redirect_url_str.starts_with(\"http\") {\n                        redirect_url_str.to_string()\n                    } else {\n                        let base_url = url\n                            .rsplit('/')\n                            .skip(1)\n                            .collect::\u003cVec\u003c_\u003e\u003e()\n                            .into_iter()\n                            .rev()\n                            .collect::\u003cVec\u003c_\u003e\u003e()\n                            .join(\"/\");\n                        format!(\"{base_url}/{redirect_url_str}\")\n                    };\n\n                    return Box::pin(\n                        self.get_with_redirects(\u0026full_redirect_url, redirect_count + 1),\n                    )\n                    .await;\n                }\n            }\n        }\n\n        if self.config.rate_limit.detect_by_status \u0026\u0026 response.status() == 429 {\n            let retry_after = response\n                .header(\"retry-after\")\n                .and_then(|h| h.get(0))\n                .and_then(|v| v.as_str().parse::\u003cu64\u003e().ok())\n                .unwrap_or(60);\n            self.broadcast_event(ClientEvent::RateLimited {\n                delay_seconds: retry_after,\n                request: Some(request_info.clone()),\n                rate_limit_type: RateLimitType::Http429,\n                rate_limit_timestamp: std::time::SystemTime::now()\n                    .duration_since(std::time::UNIX_EPOCH)\n                    .unwrap_or_default()\n                    .as_secs(),\n            });\n            return Err(LastFmError::RateLimit { retry_after });\n        }\n\n        if self.config.rate_limit.detect_by_status \u0026\u0026 response.status() == 403 {\n            log::debug!(\"Got 403 response, checking if it's a rate limit\");\n            {\n                let session = self.session.lock().unwrap();\n                if !session.cookies.is_empty() {\n                    log::debug!(\"403 on authenticated request - likely rate limit\");\n                    self.broadcast_event(ClientEvent::RateLimited {\n                        delay_seconds: 60,\n                        request: Some(request_info.clone()),\n                        rate_limit_type: RateLimitType::Http403,\n                        rate_limit_timestamp: std::time::SystemTime::now()\n                            .duration_since(std::time::UNIX_EPOCH)\n                            .unwrap_or_default()\n                            .as_secs(),\n                    });\n                    return Err(LastFmError::RateLimit { retry_after: 60 });\n                }\n            }\n        }\n\n        Ok(response)\n    }\n\n    fn is_rate_limit_response(\u0026self, response_body: \u0026str) -\u003e bool {\n        let rate_limit_config = \u0026self.config.rate_limit;\n\n        if !rate_limit_config.detect_by_patterns \u0026\u0026 rate_limit_config.custom_patterns.is_empty() {\n            return false;\n        }\n\n        let body_lower = response_body.to_lowercase();\n\n        for pattern in \u0026rate_limit_config.custom_patterns {\n            if body_lower.contains(\u0026pattern.to_lowercase()) {\n                log::debug!(\"Rate limit detected (custom pattern: '{pattern}')\");\n                return true;\n            }\n        }\n\n        if rate_limit_config.detect_by_patterns {\n            for pattern in \u0026rate_limit_config.patterns {\n                let pattern_lower = pattern.to_lowercase();\n                if body_lower.contains(\u0026pattern_lower) {\n                    log::debug!(\"Rate limit detected (pattern: '{pattern}')\");\n                    return true;\n                }\n            }\n        }\n\n        false\n    }\n\n    fn extract_cookies(\u0026self, response: \u0026Response) {\n        let mut session = self.session.lock().unwrap();\n        extract_cookies_from_response(response, \u0026mut session.cookies);\n    }\n\n    async fn extract_response_body(\u0026self, _url: \u0026str, response: \u0026mut Response) -\u003e Result\u003cString\u003e {\n        let body = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        Ok(body)\n    }\n\n    pub async fn get_artists_page(\u0026self, page: u32) -\u003e Result\u003ccrate::ArtistPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/artists?page={}\",\n                session.base_url, session.username, page\n            )\n        };\n\n        log::debug!(\"Fetching artists page {page}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"Artist library response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        log::debug!(\"Parsing HTML response from artist library endpoint\");\n        let document = Html::parse_document(\u0026content);\n        self.parser.parse_artists_page(\u0026document, page)\n    }\n\n    pub async fn get_artist_albums_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003cAlbumPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/music/{}/+albums?page={}\u0026ajax=true\",\n                session.base_url,\n                session.username,\n                urlencoding::encode(artist),\n                page\n            )\n        };\n\n        log::debug!(\"Fetching albums page {page} for artist: {artist}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"AJAX response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        log::debug!(\"Parsing HTML response from AJAX endpoint\");\n        let document = Html::parse_document(\u0026content);\n        self.parser.parse_albums_page(\u0026document, page, artist)\n    }\n\n    pub async fn get_album_tracks_page(\n        \u0026self,\n        album_name: \u0026str,\n        artist_name: \u0026str,\n        page: u32,\n    ) -\u003e Result\u003cTrackPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/music/{}/{}?page={}\u0026ajax=true\",\n                session.base_url,\n                session.username,\n                self.lastfm_encode(artist_name),\n                self.lastfm_encode(album_name),\n                page\n            )\n        };\n\n        log::debug!(\"Fetching tracks page {page} for album '{album_name}' by '{artist_name}'\");\n        log::debug!(\"🔗 Album URL: {url}\");\n\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"AJAX response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        log::debug!(\"Parsing HTML response from AJAX endpoint\");\n        let document = Html::parse_document(\u0026content);\n        let result =\n            self.parser\n                .parse_tracks_page(\u0026document, page, artist_name, Some(album_name))?;\n\n        // Debug logging for albums that return 0 tracks\n        if result.tracks.is_empty() {\n            if content.contains(\"404\") || content.contains(\"Not Found\") {\n                log::warn!(\"🚨 404 ERROR for album '{album_name}' by '{artist_name}': {url}\");\n            } else if content.contains(\"no tracks\") || content.contains(\"no music\") {\n                log::debug!(\"ℹ️  Album '{album_name}' by '{artist_name}' explicitly has no tracks in user's library\");\n            } else {\n                log::warn!(\n                    \"🚨 UNKNOWN EMPTY RESPONSE for album '{album_name}' by '{artist_name}': {url}\"\n                );\n                log::debug!(\"🔍 Response length: {} chars\", content.len());\n                log::debug!(\n                    \"🔍 Response preview (first 200 chars): {}\",\n                    \u0026content.chars().take(200).collect::\u003cString\u003e()\n                );\n            }\n        } else {\n            log::debug!(\n                \"✅ SUCCESS: Album '{album_name}' by '{artist_name}' returned {} tracks\",\n                result.tracks.len()\n            );\n        }\n\n        Ok(result)\n    }\n\n    pub async fn search_tracks_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003cTrackPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/tracks/search?page={}\u0026query={}\u0026ajax=1\",\n                session.base_url,\n                session.username,\n                page,\n                urlencoding::encode(query)\n            )\n        };\n\n        log::debug!(\"Searching tracks for query '{query}' on page {page}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"Track search response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        let document = Html::parse_document(\u0026content);\n        let tracks = self.parser.parse_track_search_results(\u0026document)?;\n\n        // For search results, we need to determine pagination differently\n        // since we don't have the same pagination structure as regular library pages\n        let (has_next_page, total_pages) = self.parser.parse_pagination(\u0026document, page)?;\n\n        Ok(TrackPage {\n            tracks,\n            page_number: page,\n            has_next_page,\n            total_pages,\n        })\n    }\n\n    pub async fn search_albums_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003cAlbumPage\u003e {\n        let url = {\n            let session = self.session.lock().unwrap();\n            format!(\n                \"{}/user/{}/library/albums/search?page={}\u0026query={}\u0026ajax=1\",\n                session.base_url,\n                session.username,\n                page,\n                urlencoding::encode(query)\n            )\n        };\n\n        log::debug!(\"Searching albums for query '{query}' on page {page}\");\n        let mut response = self.get(\u0026url).await?;\n        let content = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"Album search response: {} status, {} chars\",\n            response.status(),\n            content.len()\n        );\n\n        let document = Html::parse_document(\u0026content);\n        let albums = self.parser.parse_album_search_results(\u0026document)?;\n\n        // For search results, we need to determine pagination differently\n        let (has_next_page, total_pages) = self.parser.parse_pagination(\u0026document, page)?;\n\n        Ok(AlbumPage {\n            albums,\n            page_number: page,\n            has_next_page,\n            total_pages,\n        })\n    }\n\n    /// Expose the inner HTTP client for advanced use cases like VCR cassette management\n    pub fn inner_client(\u0026self) -\u003e Arc\u003cdyn HttpClient + Send + Sync\u003e {\n        self.client.clone()\n    }\n}\n\n#[async_trait(?Send)]\nimpl LastFmEditClient for LastFmEditClientImpl {\n    fn username(\u0026self) -\u003e String {\n        self.username()\n    }\n\n    async fn find_recent_scrobble_for_track(\n        \u0026self,\n        track_name: \u0026str,\n        artist_name: \u0026str,\n        max_pages: u32,\n    ) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        self.find_recent_scrobble_for_track(track_name, artist_name, max_pages)\n            .await\n    }\n\n    async fn edit_scrobble(\u0026self, edit: \u0026ScrobbleEdit) -\u003e Result\u003cEditResponse\u003e {\n        self.edit_scrobble(edit).await\n    }\n\n    async fn edit_scrobble_single(\n        \u0026self,\n        exact_edit: \u0026ExactScrobbleEdit,\n        max_retries: u32,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        self.edit_scrobble_single(exact_edit, max_retries).await\n    }\n\n    fn get_session(\u0026self) -\u003e LastFmEditSession {\n        self.get_session()\n    }\n\n    fn subscribe(\u0026self) -\u003e ClientEventReceiver {\n        self.subscribe()\n    }\n\n    fn latest_event(\u0026self) -\u003e Option\u003cClientEvent\u003e {\n        self.latest_event()\n    }\n\n    fn discover_scrobbles(\n        \u0026self,\n        edit: ScrobbleEdit,\n    ) -\u003e Box\u003cdyn crate::AsyncDiscoveryIterator\u003ccrate::ExactScrobbleEdit\u003e\u003e {\n        let track_name = edit.track_name_original.clone();\n        let album_name = edit.album_name_original.clone();\n\n        match (\u0026track_name, \u0026album_name) {\n            (Some(track_name), Some(album_name)) =\u003e Box::new(crate::ExactMatchDiscovery::new(\n                self.clone(),\n                edit,\n                track_name.clone(),\n                album_name.clone(),\n            )),\n\n            (Some(track_name), None) =\u003e Box::new(crate::TrackVariationsDiscovery::new(\n                self.clone(),\n                edit,\n                track_name.clone(),\n            )),\n\n            (None, Some(album_name)) =\u003e Box::new(crate::AlbumTracksDiscovery::new(\n                self.clone(),\n                edit,\n                album_name.clone(),\n            )),\n\n            (None, None) =\u003e Box::new(crate::ArtistTracksDiscovery::new(self.clone(), edit)),\n        }\n    }\n\n    async fn get_artists_page(\u0026self, page: u32) -\u003e Result\u003ccrate::ArtistPage\u003e {\n        self.get_artists_page(page).await\n    }\n\n    async fn get_artist_tracks_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003cTrackPage\u003e {\n        self.get_artist_tracks_page(artist, page).await\n    }\n\n    async fn get_artist_albums_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003cAlbumPage\u003e {\n        self.get_artist_albums_page(artist, page).await\n    }\n\n    async fn get_album_tracks_page(\n        \u0026self,\n        album_name: \u0026str,\n        artist_name: \u0026str,\n        page: u32,\n    ) -\u003e Result\u003cTrackPage\u003e {\n        self.get_album_tracks_page(album_name, artist_name, page)\n            .await\n    }\n\n    async fn get_recent_tracks_page(\u0026self, page: u32) -\u003e Result\u003cTrackPage\u003e {\n        self.get_recent_tracks_page(page).await\n    }\n\n    fn artists(\u0026self) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003ccrate::Artist\u003e\u003e {\n        Box::new(crate::iterator::ArtistsIterator::new(self.clone()))\n    }\n\n    fn artist_tracks(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::ArtistTracksIterator::new(\n            self.clone(),\n            artist.to_string(),\n        ))\n    }\n\n    fn artist_tracks_direct(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::iterator::ArtistTracksDirectIterator::new(\n            self.clone(),\n            artist.to_string(),\n        ))\n    }\n\n    fn artist_albums(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003ccrate::Album\u003e\u003e {\n        Box::new(crate::ArtistAlbumsIterator::new(\n            self.clone(),\n            artist.to_string(),\n        ))\n    }\n\n    fn album_tracks(\n        \u0026self,\n        album_name: \u0026str,\n        artist_name: \u0026str,\n    ) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::AlbumTracksIterator::new(\n            self.clone(),\n            album_name.to_string(),\n            artist_name.to_string(),\n        ))\n    }\n\n    fn recent_tracks(\u0026self) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::RecentTracksIterator::new(self.clone()))\n    }\n\n    fn recent_tracks_from_page(\n        \u0026self,\n        starting_page: u32,\n    ) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::RecentTracksIterator::with_starting_page(\n            self.clone(),\n            starting_page,\n        ))\n    }\n\n    fn search_tracks(\u0026self, query: \u0026str) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003cTrack\u003e\u003e {\n        Box::new(crate::SearchTracksIterator::new(\n            self.clone(),\n            query.to_string(),\n        ))\n    }\n\n    fn search_albums(\u0026self, query: \u0026str) -\u003e Box\u003cdyn crate::AsyncPaginatedIterator\u003ccrate::Album\u003e\u003e {\n        Box::new(crate::SearchAlbumsIterator::new(\n            self.clone(),\n            query.to_string(),\n        ))\n    }\n\n    async fn search_tracks_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003ccrate::TrackPage\u003e {\n        self.search_tracks_page(query, page).await\n    }\n\n    async fn search_albums_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003ccrate::AlbumPage\u003e {\n        self.search_albums_page(query, page).await\n    }\n\n    async fn validate_session(\u0026self) -\u003e bool {\n        self.validate_session().await\n    }\n\n    async fn delete_scrobble(\n        \u0026self,\n        artist_name: \u0026str,\n        track_name: \u0026str,\n        timestamp: u64,\n    ) -\u003e Result\u003cbool\u003e {\n        self.delete_scrobble(artist_name, track_name, timestamp)\n            .await\n    }\n}\n","traces":[{"line":31,"address":[5952238,5952096,5952244],"length":1,"stats":{"Line":1}},{"line":32,"address":[5572767],"length":1,"stats":{"Line":1}},{"line":35,"address":[3555059,3554784,3555034],"length":1,"stats":{"Line":8}},{"line":39,"address":[3554848,3554942],"length":1,"stats":{"Line":17}},{"line":42,"address":[3555384,3555072],"length":1,"stats":{"Line":9}},{"line":47,"address":[5248049],"length":1,"stats":{"Line":8}},{"line":48,"address":[5687635],"length":1,"stats":{"Line":9}},{"line":49,"address":[3519798,3519867],"length":1,"stats":{"Line":16}},{"line":53,"address":[5952928,5953425,5953486],"length":1,"stats":{"Line":0}},{"line":58,"address":[5405291,5405044],"length":1,"stats":{"Line":0}},{"line":59,"address":[5248532,5248717,5248859],"length":1,"stats":{"Line":0}},{"line":60,"address":[5688277],"length":1,"stats":{"Line":0}},{"line":63,"address":[5405600],"length":1,"stats":{"Line":0}},{"line":68,"address":[5508183,5508032],"length":1,"stats":{"Line":0}},{"line":69,"address":[2928787,2928435,2928532,2928406],"length":1,"stats":{"Line":0}},{"line":71,"address":[5773680,5773529,5773088,5773445],"length":1,"stats":{"Line":0}},{"line":72,"address":[5774277,5774480],"length":1,"stats":{"Line":0}},{"line":75,"address":[3556112,3556496],"length":1,"stats":{"Line":1}},{"line":80,"address":[5688842,5688724],"length":1,"stats":{"Line":9}},{"line":83,"address":[5954080],"length":1,"stats":{"Line":1}},{"line":89,"address":[20795314],"length":1,"stats":{"Line":3}},{"line":90,"address":[5775848,5775434,5775398,5775534],"length":1,"stats":{"Line":1}},{"line":92,"address":[5510293,5510669,5510943,5510762],"length":1,"stats":{"Line":2}},{"line":93,"address":[5848150,5848074],"length":1,"stats":{"Line":2}},{"line":94,"address":[2931640],"length":1,"stats":{"Line":1}},{"line":98,"address":[20586329],"length":1,"stats":{"Line":1}},{"line":105,"address":[5574890],"length":1,"stats":{"Line":0}},{"line":106,"address":[5406486],"length":1,"stats":{"Line":0}},{"line":107,"address":[20640633],"length":1,"stats":{"Line":1}},{"line":108,"address":[5689484],"length":1,"stats":{"Line":0}},{"line":112,"address":[3557072],"length":1,"stats":{"Line":0}},{"line":119,"address":[5512804,5512962],"length":1,"stats":{"Line":0}},{"line":120,"address":[5401354,5400904,5401040,5400940],"length":1,"stats":{"Line":0}},{"line":122,"address":[5702119,5702769,5702495,5702588],"length":1,"stats":{"Line":0}},{"line":123,"address":[5779480,5779396],"length":1,"stats":{"Line":0}},{"line":124,"address":[2934138],"length":1,"stats":{"Line":0}},{"line":125,"address":[5402099],"length":1,"stats":{"Line":0}},{"line":126,"address":[2934279],"length":1,"stats":{"Line":0}},{"line":127,"address":[3346065],"length":1,"stats":{"Line":0}},{"line":131,"address":[3521904,3522218],"length":1,"stats":{"Line":3}},{"line":136,"address":[5575476,5575589],"length":1,"stats":{"Line":6}},{"line":139,"address":[5690607,5690160,5690641],"length":1,"stats":{"Line":5}},{"line":145,"address":[5955185],"length":1,"stats":{"Line":3}},{"line":146,"address":[5407307],"length":1,"stats":{"Line":6}},{"line":147,"address":[5407374],"length":1,"stats":{"Line":3}},{"line":148,"address":[3522483,3522555],"length":1,"stats":{"Line":7}},{"line":152,"address":[5955664,5956161,5956127],"length":1,"stats":{"Line":0}},{"line":161,"address":[5690790],"length":1,"stats":{"Line":0}},{"line":163,"address":[5408039],"length":1,"stats":{"Line":0}},{"line":166,"address":[5691200,5691560,5691526],"length":1,"stats":{"Line":9}},{"line":172,"address":[5956230],"length":1,"stats":{"Line":8}},{"line":173,"address":[5251736],"length":1,"stats":{"Line":9}},{"line":174,"address":[5956352],"length":1,"stats":{"Line":8}},{"line":175,"address":[3523506],"length":1,"stats":{"Line":9}},{"line":179,"address":[5252392,5252354,5252048],"length":1,"stats":{"Line":12}},{"line":187,"address":[3559031,3559080],"length":1,"stats":{"Line":23}},{"line":188,"address":[5577354],"length":1,"stats":{"Line":12}},{"line":194,"address":[18496888,18496807],"length":1,"stats":{"Line":3}},{"line":195,"address":[20586860],"length":1,"stats":{"Line":7}},{"line":198,"address":[3559937,3559913,3559488],"length":1,"stats":{"Line":1}},{"line":199,"address":[5252664],"length":1,"stats":{"Line":1}},{"line":200,"address":[5409532,5409651,5409382,5409691],"length":1,"stats":{"Line":3}},{"line":203,"address":[5957857,5957863,5957664],"length":1,"stats":{"Line":1}},{"line":204,"address":[3524798,3524929],"length":1,"stats":{"Line":2}},{"line":207,"address":[2935185,2935023,2934992,2936451,2935142],"length":1,"stats":{"Line":4}},{"line":209,"address":[2935251,2935123],"length":1,"stats":{"Line":2}},{"line":210,"address":[5403370],"length":1,"stats":{"Line":1}},{"line":212,"address":[18439920,18440080],"length":1,"stats":{"Line":1}},{"line":216,"address":[2935540,2935655],"length":1,"stats":{"Line":2}},{"line":219,"address":[2935759,2935842],"length":1,"stats":{"Line":2}},{"line":220,"address":[5705337,5705238],"length":1,"stats":{"Line":2}},{"line":223,"address":[5516174],"length":1,"stats":{"Line":1}},{"line":225,"address":[5451463],"length":1,"stats":{"Line":3}},{"line":226,"address":[3348707],"length":1,"stats":{"Line":1}},{"line":227,"address":[5405068,5404890,5404955],"length":1,"stats":{"Line":3}},{"line":228,"address":[5405151,5405027],"length":1,"stats":{"Line":0}},{"line":229,"address":[20796629,20796541],"length":1,"stats":{"Line":0}},{"line":230,"address":[20734457],"length":1,"stats":{"Line":0}},{"line":231,"address":[5706665],"length":1,"stats":{"Line":0}},{"line":233,"address":[5405379],"length":1,"stats":{"Line":0}},{"line":237,"address":[3348940],"length":1,"stats":{"Line":1}},{"line":239,"address":[5853124],"length":1,"stats":{"Line":0}},{"line":243,"address":[5692928],"length":1,"stats":{"Line":1}},{"line":256,"address":[5517900],"length":1,"stats":{"Line":1}},{"line":257,"address":[5783009],"length":1,"stats":{"Line":1}},{"line":258,"address":[3349828],"length":1,"stats":{"Line":1}},{"line":260,"address":[5518296,5518423,5518830,5518701],"length":1,"stats":{"Line":4}},{"line":263,"address":[3349891,3351056,3351080],"length":1,"stats":{"Line":3}},{"line":264,"address":[5708688],"length":1,"stats":{"Line":0}},{"line":265,"address":[5519517,5519483],"length":1,"stats":{"Line":0}},{"line":267,"address":[3351235],"length":1,"stats":{"Line":0}},{"line":268,"address":[3351253],"length":1,"stats":{"Line":0}},{"line":271,"address":[5855916,5855871],"length":1,"stats":{"Line":0}},{"line":273,"address":[5856768,5854497,5856208,5856762],"length":1,"stats":{"Line":1}},{"line":274,"address":[5856256,5856600],"length":1,"stats":{"Line":0}},{"line":275,"address":[5856551],"length":1,"stats":{"Line":0}},{"line":276,"address":[5520008],"length":1,"stats":{"Line":0}},{"line":279,"address":[2940188],"length":1,"stats":{"Line":0}},{"line":284,"address":[5783445,5783754,5783548,5782939,5783388],"length":1,"stats":{"Line":3}},{"line":286,"address":[5406797],"length":1,"stats":{"Line":1}},{"line":287,"address":[5855111],"length":1,"stats":{"Line":0}},{"line":291,"address":[5693024],"length":1,"stats":{"Line":1}},{"line":298,"address":[2940896,2940687],"length":1,"stats":{"Line":2}},{"line":299,"address":[5521207,5521265],"length":1,"stats":{"Line":2}},{"line":301,"address":[2940980,2941074],"length":1,"stats":{"Line":2}},{"line":305,"address":[5409449,5409496,5409346],"length":1,"stats":{"Line":3}},{"line":307,"address":[5858073,5857791],"length":1,"stats":{"Line":2}},{"line":308,"address":[5409908,5409829],"length":1,"stats":{"Line":2}},{"line":311,"address":[5787472,5787327,5785894,5787199,5788086],"length":1,"stats":{"Line":2}},{"line":312,"address":[5859599,5863754,5859541,5859283,5859713,5859171],"length":1,"stats":{"Line":4}},{"line":314,"address":[3334452],"length":1,"stats":{"Line":3}},{"line":315,"address":[2950487,2943185,2950464],"length":1,"stats":{"Line":0}},{"line":317,"address":[5788661,5788556],"length":1,"stats":{"Line":2}},{"line":318,"address":[5527467,5523787,5523695],"length":1,"stats":{"Line":2}},{"line":320,"address":[5860395,5860340,5860237],"length":1,"stats":{"Line":3}},{"line":322,"address":[5789082,5789422],"length":1,"stats":{"Line":2}},{"line":325,"address":[5789626,5789532],"length":1,"stats":{"Line":2}},{"line":326,"address":[5860982,5861083],"length":1,"stats":{"Line":2}},{"line":327,"address":[5412813],"length":1,"stats":{"Line":1}},{"line":330,"address":[2944851,2944981],"length":1,"stats":{"Line":2}},{"line":332,"address":[5790745],"length":1,"stats":{"Line":1}},{"line":333,"address":[2944988],"length":1,"stats":{"Line":1}},{"line":334,"address":[5525385],"length":1,"stats":{"Line":1}},{"line":335,"address":[5413370],"length":1,"stats":{"Line":1}},{"line":336,"address":[5714904,5714763],"length":1,"stats":{"Line":2}},{"line":337,"address":[5790691],"length":1,"stats":{"Line":1}},{"line":340,"address":[3357736,3357638,3357893],"length":1,"stats":{"Line":3}},{"line":342,"address":[3362720,3362753],"length":1,"stats":{"Line":2}},{"line":346,"address":[5791255],"length":1,"stats":{"Line":1}},{"line":348,"address":[5862595,5862694],"length":1,"stats":{"Line":2}},{"line":352,"address":[5414765,5414317],"length":1,"stats":{"Line":2}},{"line":353,"address":[3358628,3358750],"length":1,"stats":{"Line":2}},{"line":355,"address":[2946745,2946692],"length":1,"stats":{"Line":2}},{"line":356,"address":[5792027],"length":1,"stats":{"Line":1}},{"line":359,"address":[2948614,2947000,2947523,2947389,2947083,2946874,2947433],"length":1,"stats":{"Line":5}},{"line":361,"address":[5415164],"length":1,"stats":{"Line":1}},{"line":362,"address":[5863624,5863785,5863975,5857200,5863689],"length":1,"stats":{"Line":3}},{"line":363,"address":[5419330,5419312,5415747],"length":1,"stats":{"Line":0}},{"line":365,"address":[5527991,5528331],"length":1,"stats":{"Line":2}},{"line":366,"address":[5528014],"length":1,"stats":{"Line":1}},{"line":367,"address":[5717412,5717335],"length":1,"stats":{"Line":2}},{"line":368,"address":[5416198,5416110],"length":1,"stats":{"Line":2}},{"line":371,"address":[2948128,2948217],"length":1,"stats":{"Line":2}},{"line":373,"address":[3360276,3360960,3360902,3360650,3361074],"length":1,"stats":{"Line":4}},{"line":375,"address":[2940817,2948523,2948583,2948641,2948830],"length":1,"stats":{"Line":3}},{"line":376,"address":[5419456,5417218,5419474],"length":1,"stats":{"Line":0}},{"line":378,"address":[5794503,5794423],"length":1,"stats":{"Line":2}},{"line":380,"address":[3361302],"length":1,"stats":{"Line":1}},{"line":381,"address":[5417896,5417524],"length":1,"stats":{"Line":2}},{"line":383,"address":[5417573,5417626,5417482],"length":1,"stats":{"Line":0}},{"line":386,"address":[5865919],"length":1,"stats":{"Line":1}},{"line":389,"address":[3525232],"length":1,"stats":{"Line":2}},{"line":390,"address":[5253589],"length":1,"stats":{"Line":1}},{"line":393,"address":[3525264],"length":1,"stats":{"Line":1}},{"line":394,"address":[3560464],"length":1,"stats":{"Line":1}},{"line":397,"address":[5693404,5693433,5693248],"length":1,"stats":{"Line":8}},{"line":398,"address":[5693343,5693268],"length":1,"stats":{"Line":13}},{"line":401,"address":[5579040,5579052],"length":1,"stats":{"Line":4}},{"line":403,"address":[5868089,5868243],"length":1,"stats":{"Line":2}},{"line":404,"address":[5868414,5868472],"length":1,"stats":{"Line":2}},{"line":406,"address":[3363925,3363823],"length":1,"stats":{"Line":2}},{"line":410,"address":[5797413,5797569,5797513],"length":1,"stats":{"Line":3}},{"line":411,"address":[5622735],"length":1,"stats":{"Line":2}},{"line":412,"address":[5869665,5869771,5870189,5870075,5870017],"length":1,"stats":{"Line":4}},{"line":414,"address":[3365537,3365351,3365232,3365292,3363663],"length":1,"stats":{"Line":3}},{"line":415,"address":[5871266,5871248,5870157],"length":1,"stats":{"Line":0}},{"line":417,"address":[5422245,5422044,5422185,5421954,5422078],"length":1,"stats":{"Line":3}},{"line":423,"address":[5534138,5534551],"length":1,"stats":{"Line":2}},{"line":424,"address":[5799562],"length":1,"stats":{"Line":1}},{"line":427,"address":[5423056,5423244,5423370,5423091,5423207,5424066],"length":1,"stats":{"Line":6}},{"line":428,"address":[2954935,2955664,2954862,2955016,2954809],"length":1,"stats":{"Line":2}},{"line":430,"address":[5725153,5725088],"length":1,"stats":{"Line":4}},{"line":432,"address":[5800972],"length":1,"stats":{"Line":2}},{"line":433,"address":[5423839],"length":1,"stats":{"Line":2}},{"line":434,"address":[5800950],"length":1,"stats":{"Line":2}},{"line":436,"address":[5423889],"length":1,"stats":{"Line":2}},{"line":440,"address":[5579104],"length":1,"stats":{"Line":2}},{"line":446,"address":[3368252,3368299,3368116],"length":1,"stats":{"Line":3}},{"line":448,"address":[5536872,5536514,5537930],"length":1,"stats":{"Line":2}},{"line":449,"address":[5626471],"length":1,"stats":{"Line":4}},{"line":451,"address":[2957058,2956954,2957185],"length":1,"stats":{"Line":3}},{"line":452,"address":[5727925,5727897,5727125],"length":1,"stats":{"Line":5}},{"line":453,"address":[20587948,20588214],"length":1,"stats":{"Line":2}},{"line":458,"address":[5875030],"length":1,"stats":{"Line":2}},{"line":463,"address":[20588511],"length":1,"stats":{"Line":1}},{"line":466,"address":[3369816],"length":1,"stats":{"Line":0}},{"line":469,"address":[5729302,5731593,5729052,5729137,5728784,5728861],"length":1,"stats":{"Line":4}},{"line":470,"address":[5282404],"length":1,"stats":{"Line":2}},{"line":472,"address":[5729740,5729831],"length":1,"stats":{"Line":2}},{"line":473,"address":[2960050,2960894],"length":1,"stats":{"Line":0}},{"line":474,"address":[3373204],"length":1,"stats":{"Line":0}},{"line":475,"address":[5429396,5429841],"length":1,"stats":{"Line":0}},{"line":477,"address":[5730794],"length":1,"stats":{"Line":0}},{"line":478,"address":[3373306,3373506],"length":1,"stats":{"Line":0}},{"line":480,"address":[5541592],"length":1,"stats":{"Line":1}},{"line":482,"address":[5542124,5541732],"length":1,"stats":{"Line":0}},{"line":483,"address":[18498918,18497877,18499111,18499153,18498983],"length":1,"stats":{"Line":1}},{"line":487,"address":[5729837,5729992,5730027,5730155],"length":1,"stats":{"Line":1}},{"line":492,"address":[5805742],"length":1,"stats":{"Line":1}},{"line":494,"address":[5732110,5730521,5730403,5730663],"length":1,"stats":{"Line":4}},{"line":495,"address":[18502064,18501668,18500217,18501257,18499844,18502464,18501931,18501129,18500089,18500500,18502212,18501809,18499972,18502334,18500750,18500619,18501012,18501520,18501392,18500352,18500878],"length":1,"stats":{"Line":0}},{"line":503,"address":[2962549],"length":1,"stats":{"Line":1}},{"line":505,"address":[20739776],"length":1,"stats":{"Line":2}},{"line":506,"address":[5808952,5808792,5808929],"length":1,"stats":{"Line":2}},{"line":508,"address":[5733548,5733330,5733067],"length":1,"stats":{"Line":3}},{"line":509,"address":[5733338,5733398,5733421],"length":1,"stats":{"Line":2}},{"line":511,"address":[5809323,5809297,5809101],"length":1,"stats":{"Line":2}},{"line":512,"address":[5734029,5733712],"length":1,"stats":{"Line":2}},{"line":513,"address":[3376392,3376366,3376286],"length":1,"stats":{"Line":2}},{"line":515,"address":[2963909],"length":1,"stats":{"Line":1}},{"line":517,"address":[5733836,5734076],"length":1,"stats":{"Line":2}},{"line":523,"address":[2959307,2964441,2964345,2961823],"length":1,"stats":{"Line":2}},{"line":524,"address":[5433433],"length":1,"stats":{"Line":1}},{"line":525,"address":[5433476],"length":1,"stats":{"Line":2}},{"line":527,"address":[5882053,5881846],"length":1,"stats":{"Line":2}},{"line":529,"address":[5433529],"length":1,"stats":{"Line":1}},{"line":530,"address":[5881897],"length":1,"stats":{"Line":1}},{"line":531,"address":[5545726],"length":1,"stats":{"Line":1}},{"line":534,"address":[3377677],"length":1,"stats":{"Line":1}},{"line":535,"address":[5735288],"length":1,"stats":{"Line":1}},{"line":537,"address":[5735411,5735333],"length":1,"stats":{"Line":0}},{"line":538,"address":[5433986],"length":1,"stats":{"Line":0}},{"line":540,"address":[2961856,2961886,2965496,2965456,2959328],"length":1,"stats":{"Line":0}},{"line":544,"address":[5543004],"length":1,"stats":{"Line":1}},{"line":547,"address":[5693648],"length":1,"stats":{"Line":1}},{"line":559,"address":[5434568],"length":1,"stats":{"Line":1}},{"line":560,"address":[5811752],"length":1,"stats":{"Line":1}},{"line":562,"address":[5883569,5883175,5883709,5883301],"length":1,"stats":{"Line":4}},{"line":565,"address":[5437136,5437156,5434746],"length":1,"stats":{"Line":3}},{"line":566,"address":[5814256],"length":1,"stats":{"Line":0}},{"line":567,"address":[5885563,5885597],"length":1,"stats":{"Line":0}},{"line":569,"address":[3381059],"length":1,"stats":{"Line":0}},{"line":570,"address":[2968517],"length":1,"stats":{"Line":0}},{"line":573,"address":[3381228,3381183],"length":1,"stats":{"Line":0}},{"line":575,"address":[5739024,5736125,5739542,5739536],"length":1,"stats":{"Line":1}},{"line":576,"address":[5437744,5438046],"length":1,"stats":{"Line":0}},{"line":577,"address":[5437997],"length":1,"stats":{"Line":0}},{"line":578,"address":[2969016],"length":1,"stats":{"Line":0}},{"line":584,"address":[5815110],"length":1,"stats":{"Line":0}},{"line":589,"address":[5287799],"length":1,"stats":{"Line":3}},{"line":591,"address":[3379455,3379239,3379374],"length":1,"stats":{"Line":3}},{"line":592,"address":[5736756],"length":1,"stats":{"Line":1}},{"line":593,"address":[5812511],"length":1,"stats":{"Line":1}},{"line":594,"address":[5435465],"length":1,"stats":{"Line":1}},{"line":595,"address":[5883817],"length":1,"stats":{"Line":1}},{"line":597,"address":[21073952,21073963],"length":1,"stats":{"Line":0}},{"line":599,"address":[21073957],"length":1,"stats":{"Line":0}},{"line":600,"address":[5436084],"length":1,"stats":{"Line":0}},{"line":601,"address":[5548190],"length":1,"stats":{"Line":0}},{"line":603,"address":[3379666,3380388,3380465],"length":1,"stats":{"Line":0}},{"line":605,"address":[3380257,3379703],"length":1,"stats":{"Line":0}},{"line":606,"address":[5737801],"length":1,"stats":{"Line":0}},{"line":607,"address":[5436499],"length":1,"stats":{"Line":0}},{"line":612,"address":[5693696,5693709],"length":1,"stats":{"Line":4}},{"line":613,"address":[5438533,5438392],"length":1,"stats":{"Line":2}},{"line":614,"address":[5284999],"length":1,"stats":{"Line":1}},{"line":615,"address":[5551091,5551006],"length":1,"stats":{"Line":4}},{"line":617,"address":[2970284],"length":1,"stats":{"Line":1}},{"line":618,"address":[5740475],"length":1,"stats":{"Line":1}},{"line":619,"address":[5551248,5551346],"length":1,"stats":{"Line":2}},{"line":620,"address":[2970405],"length":1,"stats":{"Line":1}},{"line":621,"address":[5740537],"length":1,"stats":{"Line":1}},{"line":622,"address":[3383049],"length":1,"stats":{"Line":1}},{"line":626,"address":[5887436],"length":1,"stats":{"Line":1}},{"line":627,"address":[5551713,5551188],"length":1,"stats":{"Line":0}},{"line":628,"address":[5439125],"length":1,"stats":{"Line":0}},{"line":630,"address":[5887904,5887833],"length":1,"stats":{"Line":0}},{"line":631,"address":[20802048],"length":1,"stats":{"Line":0}},{"line":636,"address":[5887699],"length":1,"stats":{"Line":1}},{"line":639,"address":[5888141,5888064,5888321,5888406,5889392],"length":1,"stats":{"Line":4}},{"line":640,"address":[21060584],"length":1,"stats":{"Line":0}},{"line":641,"address":[2971332,2971144],"length":1,"stats":{"Line":2}},{"line":642,"address":[5817371,5817429],"length":1,"stats":{"Line":2}},{"line":644,"address":[2971510,2971416],"length":1,"stats":{"Line":2}},{"line":648,"address":[5552598,5552763,5552701],"length":1,"stats":{"Line":3}},{"line":649,"address":[5291074],"length":1,"stats":{"Line":2}},{"line":651,"address":[5441605,5441500],"length":1,"stats":{"Line":2}},{"line":652,"address":[5557548,5553711,5553803],"length":1,"stats":{"Line":2}},{"line":654,"address":[5442082,5442020,5441917],"length":1,"stats":{"Line":3}},{"line":656,"address":[5743670,5743354],"length":1,"stats":{"Line":2}},{"line":658,"address":[5743693,5743793,5743840],"length":1,"stats":{"Line":3}},{"line":664,"address":[5744193,5743799],"length":1,"stats":{"Line":2}},{"line":665,"address":[5891389,5891417,5891293],"length":1,"stats":{"Line":3}},{"line":668,"address":[5744767,5744871],"length":1,"stats":{"Line":2}},{"line":671,"address":[2974745,2974843],"length":1,"stats":{"Line":2}},{"line":672,"address":[5745268,5745167],"length":1,"stats":{"Line":2}},{"line":673,"address":[5892342],"length":1,"stats":{"Line":1}},{"line":676,"address":[5892726,5892596],"length":1,"stats":{"Line":2}},{"line":678,"address":[2975660,2975453,2975535],"length":1,"stats":{"Line":3}},{"line":680,"address":[5896558,5896512],"length":1,"stats":{"Line":2}},{"line":684,"address":[3388561],"length":1,"stats":{"Line":1}},{"line":686,"address":[5821885],"length":1,"stats":{"Line":1}},{"line":687,"address":[5821971,5822086],"length":1,"stats":{"Line":2}},{"line":689,"address":[5822138,5822092],"length":1,"stats":{"Line":2}},{"line":690,"address":[5746379],"length":1,"stats":{"Line":1}},{"line":693,"address":[5445746,5445412,5446958,5445718,5445199,5445860,5445329],"length":1,"stats":{"Line":5}},{"line":695,"address":[2976266],"length":1,"stats":{"Line":1}},{"line":696,"address":[5625768],"length":1,"stats":{"Line":3}},{"line":697,"address":[5557908,5560722,5560704],"length":1,"stats":{"Line":0}},{"line":699,"address":[3389810,3390143],"length":1,"stats":{"Line":2}},{"line":700,"address":[2977026],"length":1,"stats":{"Line":1}},{"line":701,"address":[5747480,5747403],"length":1,"stats":{"Line":2}},{"line":702,"address":[5894602,5894514],"length":1,"stats":{"Line":2}},{"line":705,"address":[5558637,5558548],"length":1,"stats":{"Line":2}},{"line":707,"address":[3390963,3391135,3390718,3391021,3390344],"length":1,"stats":{"Line":4}},{"line":709,"address":[5625790],"length":1,"stats":{"Line":3}},{"line":710,"address":[3392610,3391103,3392592],"length":1,"stats":{"Line":0}},{"line":712,"address":[2978397,2978478],"length":1,"stats":{"Line":2}},{"line":714,"address":[5447569],"length":1,"stats":{"Line":2}},{"line":717,"address":[3525872,3525890],"length":1,"stats":{"Line":4}},{"line":718,"address":[3107375],"length":1,"stats":{"Line":2}},{"line":719,"address":[5751368,5751423,5750983,5751537,5751083],"length":1,"stats":{"Line":4}},{"line":721,"address":[5449118,5449785,5450072,5449728,5449898],"length":1,"stats":{"Line":3}},{"line":722,"address":[2981783,2981760,2981097],"length":1,"stats":{"Line":0}},{"line":724,"address":[5898646,5898736,5898841],"length":1,"stats":{"Line":3}},{"line":725,"address":[3394230],"length":1,"stats":{"Line":1}},{"line":728,"address":[5579424],"length":1,"stats":{"Line":1}},{"line":733,"address":[2982416,2982165,2982376],"length":1,"stats":{"Line":3}},{"line":736,"address":[5828919,5828542],"length":1,"stats":{"Line":2}},{"line":737,"address":[5452076,5452126,5452018,5452227],"length":1,"stats":{"Line":4}},{"line":739,"address":[2982847],"length":1,"stats":{"Line":1}},{"line":740,"address":[3395865],"length":1,"stats":{"Line":2}},{"line":741,"address":[5452095],"length":1,"stats":{"Line":2}},{"line":742,"address":[5452197],"length":1,"stats":{"Line":2}},{"line":746,"address":[2983488,2983544,2983388],"length":1,"stats":{"Line":5}},{"line":748,"address":[5451331,5453731,5452972,5453117,5452610],"length":1,"stats":{"Line":4}},{"line":749,"address":[5904130,5902427,5902000,5901888,5902313,5902255],"length":1,"stats":{"Line":4}},{"line":751,"address":[5565839,5565717,5565777,5566031,5563432],"length":1,"stats":{"Line":3}},{"line":752,"address":[5909666,5902395,5909648],"length":1,"stats":{"Line":0}},{"line":754,"address":[5755526,5755631],"length":1,"stats":{"Line":2}},{"line":756,"address":[5454329],"length":1,"stats":{"Line":1}},{"line":757,"address":[3398245],"length":1,"stats":{"Line":1}},{"line":758,"address":[3398328],"length":1,"stats":{"Line":1}},{"line":760,"address":[2985495,2985354,2985562,2985395,2986551],"length":1,"stats":{"Line":3}},{"line":761,"address":[5902870],"length":1,"stats":{"Line":1}},{"line":762,"address":[5831616],"length":1,"stats":{"Line":1}},{"line":763,"address":[3398375],"length":1,"stats":{"Line":1}},{"line":764,"address":[5566639],"length":1,"stats":{"Line":1}},{"line":766,"address":[5903194],"length":1,"stats":{"Line":1}},{"line":768,"address":[5756487],"length":1,"stats":{"Line":2}},{"line":773,"address":[5455415,5455047],"length":1,"stats":{"Line":2}},{"line":774,"address":[5567570,5567665],"length":1,"stats":{"Line":2}},{"line":775,"address":[5455714],"length":1,"stats":{"Line":1}},{"line":777,"address":[5835159,5832804],"length":1,"stats":{"Line":2}},{"line":779,"address":[5760689,5759445],"length":1,"stats":{"Line":2}},{"line":780,"address":[5459566,5459717,5459514,5459616],"length":1,"stats":{"Line":4}},{"line":782,"address":[5459441],"length":1,"stats":{"Line":1}},{"line":783,"address":[3403361],"length":1,"stats":{"Line":1}},{"line":784,"address":[5571665],"length":1,"stats":{"Line":1}},{"line":785,"address":[5761015],"length":1,"stats":{"Line":1}},{"line":789,"address":[5908383,5908479],"length":1,"stats":{"Line":2}},{"line":791,"address":[3339389],"length":1,"stats":{"Line":3}},{"line":792,"address":[5904615,5904501,5909268,5904392,5909329,5909492],"length":1,"stats":{"Line":4}},{"line":794,"address":[2991642,2991702,2986654,2986880,2982306,2986688],"length":1,"stats":{"Line":4}},{"line":795,"address":[3400071,3405280,3405298],"length":1,"stats":{"Line":0}},{"line":797,"address":[5833543,5833460],"length":1,"stats":{"Line":2}},{"line":799,"address":[5833593,5833682,5833562,5833769],"length":1,"stats":{"Line":5}},{"line":801,"address":[5568582],"length":1,"stats":{"Line":2}},{"line":802,"address":[3400333],"length":1,"stats":{"Line":2}},{"line":803,"address":[2987297],"length":1,"stats":{"Line":2}},{"line":806,"address":[5905142,5905225],"length":1,"stats":{"Line":2}},{"line":807,"address":[5758225],"length":1,"stats":{"Line":1}},{"line":808,"address":[5456978],"length":1,"stats":{"Line":1}},{"line":810,"address":[3400873],"length":1,"stats":{"Line":1}},{"line":812,"address":[5834560],"length":1,"stats":{"Line":4}},{"line":822,"address":[5906245,5905617,5906204],"length":1,"stats":{"Line":4}},{"line":825,"address":[5906390,5906498],"length":1,"stats":{"Line":2}},{"line":826,"address":[5836125,5835285],"length":1,"stats":{"Line":0}},{"line":831,"address":[2989207],"length":1,"stats":{"Line":3}},{"line":836,"address":[5458260],"length":1,"stats":{"Line":1}},{"line":839,"address":[5693888,5697490,5698592],"length":1,"stats":{"Line":1}},{"line":846,"address":[5411063],"length":1,"stats":{"Line":1}},{"line":847,"address":[3561324,3561396],"length":1,"stats":{"Line":2}},{"line":849,"address":[5959341,5959463,5959273,5959202],"length":1,"stats":{"Line":3}},{"line":850,"address":[5573694],"length":1,"stats":{"Line":0}},{"line":853,"address":[5580183],"length":1,"stats":{"Line":1}},{"line":854,"address":[5411736,5411939,5411815],"length":1,"stats":{"Line":3}},{"line":855,"address":[5960113,5959919],"length":1,"stats":{"Line":2}},{"line":856,"address":[5255698,5255619],"length":1,"stats":{"Line":2}},{"line":857,"address":[3530408,3530334],"length":1,"stats":{"Line":0}},{"line":861,"address":[3562610],"length":1,"stats":{"Line":1}},{"line":862,"address":[5695558,5698000,5695479,5695629],"length":1,"stats":{"Line":4}},{"line":863,"address":[5581297],"length":1,"stats":{"Line":2}},{"line":864,"address":[5763064],"length":1,"stats":{"Line":1}},{"line":865,"address":[5574136,5574228],"length":1,"stats":{"Line":2}},{"line":867,"address":[2992960,2992961],"length":1,"stats":{"Line":2}},{"line":868,"address":[5462390,5462368],"length":1,"stats":{"Line":2}},{"line":871,"address":[3527801,3527858],"length":1,"stats":{"Line":2}},{"line":872,"address":[3563001,3563093],"length":1,"stats":{"Line":2}},{"line":873,"address":[5413053,5412980],"length":1,"stats":{"Line":2}},{"line":874,"address":[5574496,5574513],"length":1,"stats":{"Line":4}},{"line":876,"address":[3563331,3563423],"length":1,"stats":{"Line":2}},{"line":878,"address":[5581920,5581964,5581858],"length":1,"stats":{"Line":3}},{"line":879,"address":[3528487],"length":1,"stats":{"Line":1}},{"line":880,"address":[5696561],"length":1,"stats":{"Line":1}},{"line":881,"address":[5582281,5582211],"length":1,"stats":{"Line":1}},{"line":882,"address":[3563853],"length":1,"stats":{"Line":0}},{"line":884,"address":[5257147,5257094],"length":1,"stats":{"Line":2}},{"line":887,"address":[5696779],"length":1,"stats":{"Line":1}},{"line":889,"address":[5696814,5696886],"length":1,"stats":{"Line":2}},{"line":890,"address":[3564078,3564146],"length":1,"stats":{"Line":2}},{"line":891,"address":[3564219,3564154],"length":1,"stats":{"Line":2}},{"line":892,"address":[5257491],"length":1,"stats":{"Line":1}},{"line":893,"address":[5414185],"length":1,"stats":{"Line":1}},{"line":894,"address":[3529249],"length":1,"stats":{"Line":1}},{"line":895,"address":[5962185],"length":1,"stats":{"Line":1}},{"line":896,"address":[3564417],"length":1,"stats":{"Line":1}},{"line":900,"address":[5697429],"length":1,"stats":{"Line":1}},{"line":902,"address":[3564720,3564025],"length":1,"stats":{"Line":0}},{"line":911,"address":[5959980],"length":1,"stats":{"Line":1}},{"line":914,"address":[5698647,5698624],"length":1,"stats":{"Line":6}},{"line":916,"address":[3406465,3406619],"length":1,"stats":{"Line":2}},{"line":917,"address":[5764402,5764294,5764352],"length":1,"stats":{"Line":3}},{"line":919,"address":[5574967],"length":1,"stats":{"Line":1}},{"line":920,"address":[5462989],"length":1,"stats":{"Line":1}},{"line":921,"address":[3406867],"length":1,"stats":{"Line":1}},{"line":926,"address":[5911858,5911802,5911702],"length":1,"stats":{"Line":3}},{"line":927,"address":[5841673,5839778,5840953,5840544,5841092],"length":1,"stats":{"Line":2}},{"line":928,"address":[5912767,5913183,5913125,5913297,5912873],"length":1,"stats":{"Line":4}},{"line":930,"address":[5912846,5913157,5912906,5912965,5911063],"length":1,"stats":{"Line":3}},{"line":931,"address":[2996887,2995501,2996864],"length":1,"stats":{"Line":0}},{"line":933,"address":[5766673],"length":1,"stats":{"Line":3}},{"line":939,"address":[5577238,5577670,5577704],"length":1,"stats":{"Line":4}},{"line":940,"address":[3409428,3409673],"length":1,"stats":{"Line":4}},{"line":941,"address":[5914204],"length":1,"stats":{"Line":1}},{"line":944,"address":[5698672],"length":1,"stats":{"Line":0}},{"line":950,"address":[5259167],"length":1,"stats":{"Line":0}},{"line":954,"address":[5584352],"length":1,"stats":{"Line":0}},{"line":961,"address":[5963800],"length":1,"stats":{"Line":0}},{"line":965,"address":[5415920,5416339,5416333],"length":1,"stats":{"Line":1}},{"line":966,"address":[3566070],"length":1,"stats":{"Line":1}},{"line":968,"address":[5964005,5964073,5963940,5964145],"length":1,"stats":{"Line":4}},{"line":971,"address":[5578529,5578528],"length":1,"stats":{"Line":2}},{"line":972,"address":[3410320,3410342],"length":1,"stats":{"Line":2}},{"line":973,"address":[5416213],"length":1,"stats":{"Line":1}},{"line":976,"address":[5584880,5584898],"length":1,"stats":{"Line":4}},{"line":977,"address":[3410516,3410717,3410562,3410619],"length":1,"stats":{"Line":3}},{"line":980,"address":[5416400,5416418],"length":1,"stats":{"Line":4}},{"line":981,"address":[5467315],"length":1,"stats":{"Line":1}},{"line":983,"address":[5915760],"length":1,"stats":{"Line":2}},{"line":984,"address":[2997988],"length":1,"stats":{"Line":1}},{"line":988,"address":[5467524,5467600],"length":1,"stats":{"Line":4}},{"line":989,"address":[5917258,5917322,5917040,5917072,5916141,5918259,5917048,5917134,5917503],"length":1,"stats":{"Line":16}},{"line":990,"address":[5770521,5771195,5770385,5770280,5770188],"length":1,"stats":{"Line":8}},{"line":992,"address":[5771128,5771082,5771559,5770944,5773135,5771472,5771414],"length":1,"stats":{"Line":30}},{"line":993,"address":[3000190,3000083],"length":1,"stats":{"Line":14}},{"line":994,"address":[5917309,5918535,5918109,5918169,5918454,5918265],"length":1,"stats":{"Line":17}},{"line":996,"address":[5771668,5771748,5771826],"length":1,"stats":{"Line":11}},{"line":997,"address":[3414403,3415261,3415357],"length":1,"stats":{"Line":3}},{"line":998,"address":[3415267],"length":1,"stats":{"Line":1}},{"line":1001,"address":[5470467,5470632],"length":1,"stats":{"Line":2}},{"line":1002,"address":[3414553,3414478],"length":1,"stats":{"Line":3}},{"line":1003,"address":[3414737,3414918],"length":1,"stats":{"Line":4}},{"line":1004,"address":[5772624,5772561,5772554],"length":1,"stats":{"Line":3}},{"line":1007,"address":[3414747],"length":1,"stats":{"Line":2}},{"line":1009,"address":[3414857],"length":1,"stats":{"Line":3}},{"line":1011,"address":[5471824],"length":1,"stats":{"Line":1}},{"line":1012,"address":[5583947,5583981],"length":1,"stats":{"Line":2}},{"line":1014,"address":[5920211],"length":1,"stats":{"Line":1}},{"line":1015,"address":[3002293],"length":1,"stats":{"Line":1}},{"line":1018,"address":[21060791],"length":1,"stats":{"Line":2}},{"line":1020,"address":[5584416],"length":1,"stats":{"Line":1}},{"line":1021,"address":[5472435,5472380],"length":1,"stats":{"Line":2}},{"line":1022,"address":[20740209,20740333],"length":1,"stats":{"Line":1}},{"line":1023,"address":[5773755],"length":1,"stats":{"Line":1}},{"line":1024,"address":[20593187,20593244],"length":1,"stats":{"Line":0}},{"line":1028,"address":[2998401,2997889,2998441,2998740,2998494,2998263,2999110,2998667,2998875],"length":1,"stats":{"Line":11}},{"line":1030,"address":[5845568],"length":1,"stats":{"Line":1}},{"line":1033,"address":[5699376,5699399],"length":1,"stats":{"Line":14}},{"line":1034,"address":[20740651],"length":1,"stats":{"Line":3}},{"line":1035,"address":[3416731,3418720],"length":1,"stats":{"Line":0}},{"line":1038,"address":[3003383,3003264],"length":1,"stats":{"Line":10}},{"line":1041,"address":[3416895,3416989],"length":1,"stats":{"Line":10}},{"line":1042,"address":[5585436,5585337],"length":1,"stats":{"Line":10}},{"line":1043,"address":[3003802,3003878],"length":1,"stats":{"Line":5}},{"line":1044,"address":[5921909],"length":1,"stats":{"Line":0}},{"line":1048,"address":[5473870],"length":1,"stats":{"Line":8}},{"line":1049,"address":[3417827,3417756,3418050],"length":1,"stats":{"Line":12}},{"line":1050,"address":[18447353,18447448],"length":1,"stats":{"Line":10}},{"line":1052,"address":[20803980],"length":1,"stats":{"Line":2}},{"line":1055,"address":[20649603,20649498],"length":1,"stats":{"Line":2}},{"line":1057,"address":[5586311],"length":1,"stats":{"Line":2}},{"line":1058,"address":[18505175,18505099,18509647],"length":1,"stats":{"Line":13}},{"line":1060,"address":[3004790,3004744],"length":1,"stats":{"Line":10}},{"line":1061,"address":[5474423],"length":1,"stats":{"Line":8}},{"line":1064,"address":[3012002,3005042,3005781,3005691,3005125,3004919,3005647],"length":1,"stats":{"Line":28}},{"line":1065,"address":[18448416,18452602,18448343],"length":1,"stats":{"Line":0}},{"line":1066,"address":[5586697],"length":1,"stats":{"Line":8}},{"line":1067,"address":[5452034],"length":1,"stats":{"Line":25}},{"line":1068,"address":[5783504,5776741,5783522],"length":1,"stats":{"Line":0}},{"line":1070,"address":[3006264,3005909],"length":1,"stats":{"Line":16}},{"line":1071,"address":[3419432],"length":1,"stats":{"Line":7}},{"line":1072,"address":[5587829,5587746],"length":1,"stats":{"Line":15}},{"line":1073,"address":[5852950,5852850],"length":1,"stats":{"Line":15}},{"line":1076,"address":[20805370],"length":1,"stats":{"Line":7}},{"line":1078,"address":[21067648,21067657],"length":1,"stats":{"Line":15}},{"line":1079,"address":[5853324,5853470],"length":1,"stats":{"Line":2}},{"line":1080,"address":[5777781],"length":1,"stats":{"Line":1}},{"line":1081,"address":[5588623],"length":1,"stats":{"Line":1}},{"line":1082,"address":[5588703],"length":1,"stats":{"Line":1}},{"line":1083,"address":[5853915,5853802],"length":1,"stats":{"Line":2}},{"line":1085,"address":[5854263,5853860],"length":1,"stats":{"Line":2}},{"line":1086,"address":[5854272,5855856,5855896],"length":1,"stats":{"Line":0}},{"line":1087,"address":[20743710,20743541],"length":1,"stats":{"Line":0}},{"line":1088,"address":[3422614],"length":1,"stats":{"Line":0}},{"line":1093,"address":[5925018,5925591],"length":1,"stats":{"Line":2}},{"line":1094,"address":[3008345,3007625],"length":1,"stats":{"Line":2}},{"line":1095,"address":[20650796,20651078],"length":1,"stats":{"Line":1}},{"line":1096,"address":[5925597,5926826,5925697,5926598],"length":1,"stats":{"Line":1}},{"line":1097,"address":[5590119,5589487],"length":1,"stats":{"Line":0}},{"line":1099,"address":[5589447,5589765,5589530],"length":1,"stats":{"Line":0}},{"line":1107,"address":[3421604],"length":1,"stats":{"Line":0}},{"line":1110,"address":[5478725,5482044,5478663],"length":1,"stats":{"Line":3}},{"line":1111,"address":[5478563,5477983],"length":1,"stats":{"Line":2}},{"line":1113,"address":[3008958,3012242,3008996,3003251,3012022],"length":1,"stats":{"Line":3}},{"line":1118,"address":[3006672,3009504],"length":1,"stats":{"Line":14}},{"line":1119,"address":[18452800,18452809],"length":1,"stats":{"Line":0}},{"line":1121,"address":[3426153,3426144],"length":1,"stats":{"Line":0}},{"line":1122,"address":[3012537,3012528],"length":1,"stats":{"Line":0}},{"line":1124,"address":[20807187,20807235],"length":1,"stats":{"Line":0}},{"line":1125,"address":[18507940,18508083],"length":1,"stats":{"Line":0}},{"line":1126,"address":[5929568],"length":1,"stats":{"Line":0}},{"line":1127,"address":[21065748,21065807],"length":1,"stats":{"Line":0}},{"line":1128,"address":[5593423,5593496],"length":1,"stats":{"Line":0}},{"line":1133,"address":[3425541],"length":1,"stats":{"Line":0}},{"line":1136,"address":[5927850,5927558],"length":1,"stats":{"Line":14}},{"line":1137,"address":[5856685,5856784],"length":1,"stats":{"Line":0}},{"line":1139,"address":[5928289,5928007],"length":1,"stats":{"Line":0}},{"line":1140,"address":[5480045,5480124],"length":1,"stats":{"Line":0}},{"line":1141,"address":[20652820,20652035],"length":1,"stats":{"Line":0}},{"line":1142,"address":[5781567,5782161],"length":1,"stats":{"Line":0}},{"line":1143,"address":[20652828,20652898],"length":1,"stats":{"Line":0}},{"line":1144,"address":[5592593,5592350],"length":1,"stats":{"Line":0}},{"line":1145,"address":[3424433],"length":1,"stats":{"Line":0}},{"line":1146,"address":[5781945,5782030],"length":1,"stats":{"Line":0}},{"line":1151,"address":[18509293,18508732],"length":1,"stats":{"Line":0}},{"line":1156,"address":[5856469],"length":1,"stats":{"Line":7}},{"line":1159,"address":[5259888,5261576,5261033],"length":1,"stats":{"Line":6}},{"line":1160,"address":[5699495],"length":1,"stats":{"Line":2}},{"line":1162,"address":[5699503],"length":1,"stats":{"Line":8}},{"line":1163,"address":[3566771],"length":1,"stats":{"Line":0}},{"line":1166,"address":[5416619],"length":1,"stats":{"Line":3}},{"line":1168,"address":[3566856,3566740],"length":1,"stats":{"Line":12}},{"line":1169,"address":[5585402,5586217],"length":1,"stats":{"Line":0}},{"line":1170,"address":[3568024,3567959],"length":1,"stats":{"Line":0}},{"line":1171,"address":[5586451],"length":1,"stats":{"Line":0}},{"line":1175,"address":[5585436],"length":1,"stats":{"Line":6}},{"line":1176,"address":[18453562,18453536,18453738,18454933,18453428],"length":1,"stats":{"Line":2}},{"line":1177,"address":[5965022],"length":1,"stats":{"Line":9}},{"line":1178,"address":[5965155,5965084],"length":1,"stats":{"Line":5}},{"line":1179,"address":[5260666,5260748],"length":1,"stats":{"Line":2}},{"line":1180,"address":[3567434],"length":1,"stats":{"Line":1}},{"line":1185,"address":[5416914],"length":1,"stats":{"Line":2}},{"line":1188,"address":[21069754,21068791],"length":1,"stats":{"Line":8}},{"line":1189,"address":[3533267],"length":1,"stats":{"Line":7}},{"line":1190,"address":[5261750,5261687],"length":1,"stats":{"Line":15}},{"line":1193,"address":[5586960,5586983],"length":1,"stats":{"Line":28}},{"line":1194,"address":[5482693,5483056,5482960,5483269,5482566,5482908],"length":1,"stats":{"Line":23}},{"line":1196,"address":[5455911],"length":1,"stats":{"Line":17}},{"line":1197,"address":[3427104,3426854,3427122],"length":1,"stats":{"Line":0}},{"line":1199,"address":[5784460],"length":1,"stats":{"Line":1}},{"line":1202,"address":[5483424,5483676,5484731,5483612,5483486],"length":1,"stats":{"Line":4}},{"line":1204,"address":[3013911,3013753],"length":1,"stats":{"Line":2}},{"line":1205,"address":[5595982,5596040],"length":1,"stats":{"Line":2}},{"line":1207,"address":[21071035],"length":1,"stats":{"Line":2}},{"line":1211,"address":[5932657,5932501,5932601],"length":1,"stats":{"Line":3}},{"line":1212,"address":[3014419,3014899,3014783,3015457,3013814],"length":1,"stats":{"Line":2}},{"line":1213,"address":[20603005],"length":1,"stats":{"Line":8}},{"line":1215,"address":[3015426,3015485,3015366,3013835,3015677],"length":1,"stats":{"Line":6}},{"line":1216,"address":[3017088,3015777,3017111],"length":1,"stats":{"Line":0}},{"line":1218,"address":[18456235],"length":1,"stats":{"Line":0}},{"line":1224,"address":[3016002,3016464,3016430],"length":1,"stats":{"Line":5}},{"line":1225,"address":[20750544],"length":1,"stats":{"Line":2}},{"line":1226,"address":[20812793],"length":1,"stats":{"Line":1}},{"line":1229,"address":[5701463,5701440],"length":1,"stats":{"Line":4}},{"line":1231,"address":[5935649,5935803],"length":1,"stats":{"Line":2}},{"line":1232,"address":[3017714,3017768,3017818],"length":1,"stats":{"Line":3}},{"line":1234,"address":[5487559],"length":1,"stats":{"Line":1}},{"line":1235,"address":[20940794,20940836],"length":1,"stats":{"Line":1}},{"line":1236,"address":[21067871],"length":1,"stats":{"Line":1}},{"line":1241,"address":[3431862,3431962,3432018],"length":1,"stats":{"Line":3}},{"line":1242,"address":[20813120],"length":1,"stats":{"Line":2}},{"line":1243,"address":[5937957,5937533,5937843,5937427,5937785],"length":1,"stats":{"Line":4}},{"line":1245,"address":[5937817,5937506,5935735,5937566,5937625],"length":1,"stats":{"Line":3}},{"line":1246,"address":[5790917,5792256,5792274],"length":1,"stats":{"Line":0}},{"line":1248,"address":[20813136],"length":1,"stats":{"Line":3}},{"line":1254,"address":[5791578,5791146,5791612],"length":1,"stats":{"Line":3}},{"line":1255,"address":[18456730],"length":1,"stats":{"Line":2}},{"line":1256,"address":[5938862],"length":1,"stats":{"Line":1}},{"line":1259,"address":[5701488],"length":1,"stats":{"Line":1}},{"line":1265,"address":[18456976],"length":1,"stats":{"Line":0}},{"line":1266,"address":[20658556],"length":1,"stats":{"Line":2}},{"line":1267,"address":[5868801,5868911,5868685,5868743],"length":1,"stats":{"Line":4}},{"line":1269,"address":[5868606],"length":1,"stats":{"Line":1}},{"line":1270,"address":[5939972],"length":1,"stats":{"Line":1}},{"line":1271,"address":[20751264],"length":1,"stats":{"Line":1}},{"line":1272,"address":[5793128],"length":1,"stats":{"Line":1}},{"line":1273,"address":[20751312],"length":1,"stats":{"Line":0}},{"line":1277,"address":[5604400,5604246,5604346],"length":1,"stats":{"Line":3}},{"line":1278,"address":[5794037,5794093,5793600],"length":1,"stats":{"Line":3}},{"line":1280,"address":[5870890,5869787,5868425,5870288,5870149],"length":1,"stats":{"Line":4}},{"line":1281,"address":[5606089,5606261,5605831,5611051,5605725,5606147],"length":1,"stats":{"Line":8}},{"line":1283,"address":[3111618],"length":1,"stats":{"Line":6}},{"line":1284,"address":[18457120],"length":1,"stats":{"Line":0}},{"line":1286,"address":[5942846],"length":1,"stats":{"Line":8}},{"line":1292,"address":[5943228,5942720,5943188],"length":1,"stats":{"Line":9}},{"line":1293,"address":[3438690,3438965],"length":1,"stats":{"Line":2}},{"line":1294,"address":[3025321,3025136,3025101,3025085,3025245],"length":1,"stats":{"Line":4}},{"line":1296,"address":[5495180,5495372,5495172],"length":1,"stats":{"Line":2}},{"line":1299,"address":[20813693,20813751],"length":1,"stats":{"Line":3}},{"line":1300,"address":[5944649,5944787,5944009],"length":1,"stats":{"Line":0}},{"line":1301,"address":[5608467,5610492],"length":1,"stats":{"Line":0}},{"line":1302,"address":[5798007,5797830],"length":1,"stats":{"Line":0}},{"line":1303,"address":[5797943,5799404],"length":1,"stats":{"Line":0}},{"line":1305,"address":[5873900,5873794],"length":1,"stats":{"Line":0}},{"line":1308,"address":[3026681,3027118,3027172],"length":1,"stats":{"Line":0}},{"line":1309,"address":[20604598],"length":1,"stats":{"Line":0}},{"line":1315,"address":[21072676,21072169],"length":1,"stats":{"Line":0}},{"line":1321,"address":[5797040],"length":1,"stats":{"Line":2}},{"line":1324,"address":[5948959,5947456,5947668,5947518,5947732],"length":1,"stats":{"Line":4}},{"line":1326,"address":[3029359,3029201],"length":1,"stats":{"Line":2}},{"line":1327,"address":[5499622,5499680,5499761],"length":1,"stats":{"Line":3}},{"line":1329,"address":[5499543],"length":1,"stats":{"Line":1}},{"line":1330,"address":[3029537],"length":1,"stats":{"Line":1}},{"line":1332,"address":[5948066],"length":1,"stats":{"Line":1}},{"line":1336,"address":[5948514,5948358,5948458],"length":1,"stats":{"Line":3}},{"line":1337,"address":[5620655],"length":1,"stats":{"Line":2}},{"line":1338,"address":[5802391,5802497,5802921,5802749,5802807,5804493],"length":1,"stats":{"Line":4}},{"line":1340,"address":[3108258],"length":1,"stats":{"Line":3}},{"line":1341,"address":[5880258,5878633,5880240],"length":1,"stats":{"Line":0}},{"line":1343,"address":[3031788],"length":1,"stats":{"Line":0}},{"line":1349,"address":[5950547,5950134],"length":1,"stats":{"Line":2}},{"line":1350,"address":[5879389,5880190,5879302],"length":1,"stats":{"Line":2}},{"line":1354,"address":[5614675,5614585],"length":1,"stats":{"Line":2}},{"line":1356,"address":[3446658],"length":1,"stats":{"Line":1}},{"line":1357,"address":[5502791],"length":1,"stats":{"Line":1}},{"line":1358,"address":[5502823],"length":1,"stats":{"Line":1}},{"line":1364,"address":[5418727,5418704],"length":1,"stats":{"Line":4}},{"line":1366,"address":[5615723,5615569],"length":1,"stats":{"Line":2}},{"line":1367,"address":[5503953,5503814,5503872],"length":1,"stats":{"Line":3}},{"line":1369,"address":[5880807],"length":1,"stats":{"Line":1}},{"line":1370,"address":[3447661],"length":1,"stats":{"Line":1}},{"line":1372,"address":[5503922],"length":1,"stats":{"Line":1}},{"line":1376,"address":[5504214,5504314,5504370],"length":1,"stats":{"Line":3}},{"line":1377,"address":[5880626,5881919,5881783,5882497,5881392],"length":1,"stats":{"Line":2}},{"line":1378,"address":[5882327,5882743,5882433,5882685,5882857,5884429],"length":1,"stats":{"Line":4}},{"line":1380,"address":[6002290],"length":1,"stats":{"Line":3}},{"line":1381,"address":[5954089,5955696,5955714],"length":1,"stats":{"Line":0}},{"line":1383,"address":[5954453,5954346,5954222,5954513,5954312],"length":1,"stats":{"Line":0}},{"line":1389,"address":[5807731,5807318],"length":1,"stats":{"Line":2}},{"line":1390,"address":[5506422,5507310,5506509],"length":1,"stats":{"Line":2}},{"line":1393,"address":[3036515,3036417],"length":1,"stats":{"Line":2}},{"line":1395,"address":[5884098],"length":1,"stats":{"Line":1}},{"line":1396,"address":[5884055],"length":1,"stats":{"Line":1}},{"line":1397,"address":[5808343],"length":1,"stats":{"Line":1}},{"line":1404,"address":[5587280],"length":1,"stats":{"Line":0}},{"line":1405,"address":[5262133],"length":1,"stats":{"Line":0}},{"line":1411,"address":[3534192],"length":1,"stats":{"Line":0}},{"line":1412,"address":[3569185],"length":1,"stats":{"Line":0}},{"line":1421,"address":[5956287,5956507,5956215],"length":1,"stats":{"Line":3}},{"line":1422,"address":[3121351],"length":1,"stats":{"Line":3}},{"line":1425,"address":[3534391],"length":1,"stats":{"Line":4}},{"line":1426,"address":[5630935],"length":1,"stats":{"Line":1}},{"line":1434,"address":[5621730,5621856,5621449],"length":1,"stats":{"Line":0}},{"line":1437,"address":[5588048],"length":1,"stats":{"Line":0}},{"line":1438,"address":[5262913],"length":1,"stats":{"Line":0}},{"line":1441,"address":[5419568],"length":1,"stats":{"Line":0}},{"line":1442,"address":[5967493],"length":1,"stats":{"Line":0}},{"line":1445,"address":[5967504],"length":1,"stats":{"Line":0}},{"line":1446,"address":[5967521],"length":1,"stats":{"Line":0}},{"line":1449,"address":[5420591,5421483,5419632],"length":1,"stats":{"Line":1}},{"line":1453,"address":[5263120],"length":1,"stats":{"Line":1}},{"line":1454,"address":[5263186],"length":1,"stats":{"Line":1}},{"line":1456,"address":[5263637,5263247,5263048],"length":1,"stats":{"Line":3}},{"line":1457,"address":[5589152,5589743,5589842],"length":1,"stats":{"Line":3}},{"line":1458,"address":[5589202,5589562],"length":1,"stats":{"Line":2}},{"line":1459,"address":[5421042],"length":1,"stats":{"Line":1}},{"line":1460,"address":[5704013,5704078],"length":1,"stats":{"Line":2}},{"line":1461,"address":[3536182],"length":1,"stats":{"Line":1}},{"line":1464,"address":[3535713,3535865,3535940],"length":1,"stats":{"Line":3}},{"line":1465,"address":[5420718],"length":1,"stats":{"Line":1}},{"line":1466,"address":[5420738],"length":1,"stats":{"Line":1}},{"line":1467,"address":[5264157],"length":1,"stats":{"Line":1}},{"line":1470,"address":[5702962,5703353,5703428],"length":1,"stats":{"Line":3}},{"line":1471,"address":[5420314,5420063],"length":1,"stats":{"Line":2}},{"line":1472,"address":[5263698],"length":1,"stats":{"Line":1}},{"line":1473,"address":[5703293],"length":1,"stats":{"Line":1}},{"line":1476,"address":[5263518,5263462],"length":1,"stats":{"Line":2}},{"line":1480,"address":[5622163,5622416,5622463,5622267,5622595,5622877,5622128],"length":1,"stats":{"Line":4}},{"line":1481,"address":[5622621,5622294,5622497],"length":1,"stats":{"Line":1}},{"line":1484,"address":[5704566],"length":1,"stats":{"Line":4}},{"line":1485,"address":[3120727],"length":1,"stats":{"Line":1}},{"line":1488,"address":[3571590],"length":1,"stats":{"Line":4}},{"line":1489,"address":[5633031],"length":1,"stats":{"Line":1}},{"line":1498,"address":[5624845,5625152,5624917],"length":1,"stats":{"Line":4}},{"line":1499,"address":[5464935],"length":1,"stats":{"Line":4}},{"line":1502,"address":[5513519,5513472,5513323,5513219,5513933,5513651,5513184],"length":1,"stats":{"Line":4}},{"line":1503,"address":[5962013,5961686,5961889],"length":1,"stats":{"Line":1}},{"line":1506,"address":[5265408],"length":1,"stats":{"Line":1}},{"line":1507,"address":[5590591],"length":1,"stats":{"Line":1}},{"line":1510,"address":[5422344,5422376,5422128],"length":1,"stats":{"Line":2}},{"line":1511,"address":[3572075,3572124,3571983],"length":1,"stats":{"Line":6}},{"line":1512,"address":[5970103],"length":1,"stats":{"Line":2}},{"line":1513,"address":[5422214],"length":1,"stats":{"Line":2}},{"line":1517,"address":[3572192,3572428,3572400],"length":1,"stats":{"Line":1}},{"line":1518,"address":[3572380,3572239,3572331],"length":1,"stats":{"Line":3}},{"line":1519,"address":[5265815],"length":1,"stats":{"Line":1}},{"line":1520,"address":[3572278],"length":1,"stats":{"Line":1}},{"line":1524,"address":[5266016,5266230,5266262],"length":1,"stats":{"Line":1}},{"line":1525,"address":[5422686,5422825,5422777],"length":1,"stats":{"Line":3}},{"line":1526,"address":[5970614],"length":1,"stats":{"Line":1}},{"line":1527,"address":[3572532],"length":1,"stats":{"Line":1}},{"line":1531,"address":[5266272,5266652,5266646],"length":1,"stats":{"Line":1}},{"line":1536,"address":[5705897,5706147,5706075],"length":1,"stats":{"Line":3}},{"line":1537,"address":[5266361],"length":1,"stats":{"Line":1}},{"line":1538,"address":[5970936,5971006],"length":1,"stats":{"Line":2}},{"line":1539,"address":[5423094],"length":1,"stats":{"Line":1}},{"line":1543,"address":[5423312],"length":1,"stats":{"Line":2}},{"line":1544,"address":[5423342],"length":1,"stats":{"Line":2}},{"line":1547,"address":[5591936],"length":1,"stats":{"Line":1}},{"line":1551,"address":[5971384],"length":1,"stats":{"Line":1}},{"line":1552,"address":[5591979],"length":1,"stats":{"Line":1}},{"line":1557,"address":[5706694,5706662,5706448],"length":1,"stats":{"Line":1}},{"line":1558,"address":[3538590,3538729,3538681],"length":1,"stats":{"Line":3}},{"line":1559,"address":[3573318],"length":1,"stats":{"Line":1}},{"line":1560,"address":[5592132],"length":1,"stats":{"Line":1}},{"line":1564,"address":[5267398,5267152,5267366],"length":1,"stats":{"Line":1}},{"line":1565,"address":[3573641,3573550,3573690],"length":1,"stats":{"Line":5}},{"line":1566,"address":[3538854],"length":1,"stats":{"Line":2}},{"line":1567,"address":[5267236],"length":1,"stats":{"Line":2}},{"line":1571,"address":[3539094],"length":1,"stats":{"Line":4}},{"line":1572,"address":[3043574,3043900,3043775],"length":1,"stats":{"Line":1}},{"line":1575,"address":[5707110],"length":1,"stats":{"Line":4}},{"line":1576,"address":[5816435,5816230,5816572],"length":1,"stats":{"Line":1}},{"line":1579,"address":[5892701,5892960,5892840,5892592,5892617,5892768,5893182],"length":1,"stats":{"Line":4}},{"line":1580,"address":[5515712,5515914,5515815,5515656],"length":1,"stats":{"Line":2}},{"line":1589,"address":[5516870,5516650,5516577],"length":1,"stats":{"Line":3}},{"line":1590,"address":[5631127],"length":1,"stats":{"Line":3}}],"covered":581,"coverable":738},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","album_tracks.rs"],"content":"use super::common::filter_by_original_album_artist;\nuse crate::{\n    AsyncDiscoveryIterator, AsyncPaginatedIterator, ExactScrobbleEdit, LastFmEditClientImpl,\n    Result, ScrobbleEdit,\n};\nuse async_trait::async_trait;\n\n/// Case 3: Album tracks discovery (album specified, track not specified)\n///\n/// This discovers all tracks in a specific album by iterating through the album's tracks\n/// and for each track, loading its scrobbles incrementally. This is now truly incremental\n/// like the artist tracks discovery.\npub struct AlbumTracksDiscovery {\n    client: LastFmEditClientImpl,\n    edit: ScrobbleEdit,\n    album_name: String,\n    tracks_iterator: crate::AlbumTracksIterator,\n    current_track_results: Vec\u003cExactScrobbleEdit\u003e,\n    current_track_index: usize,\n}\n\nimpl AlbumTracksDiscovery {\n    pub fn new(client: LastFmEditClientImpl, edit: ScrobbleEdit, album_name: String) -\u003e Self {\n        let tracks_iterator = crate::AlbumTracksIterator::new(\n            client.clone(),\n            album_name.clone(),\n            edit.artist_name_original.clone(),\n        );\n\n        Self {\n            client,\n            edit,\n            album_name,\n            tracks_iterator,\n            current_track_results: Vec::new(),\n            current_track_index: 0,\n        }\n    }\n}\n\n#[async_trait(?Send)]\nimpl AsyncDiscoveryIterator\u003cExactScrobbleEdit\u003e for AlbumTracksDiscovery {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cExactScrobbleEdit\u003e\u003e {\n        // If we have results from the current track, return the next one\n        if self.current_track_index \u003c self.current_track_results.len() {\n            let result = self.current_track_results[self.current_track_index].clone();\n            self.current_track_index += 1;\n            return Ok(Some(result));\n        }\n\n        // Get the next track from the iterator\n        while let Some(track) = self.tracks_iterator.next().await? {\n            log::debug!(\n                \"Getting scrobble data for track '{}' from album '{}' by '{}'\",\n                track.name,\n                self.album_name,\n                self.edit.artist_name_original\n            );\n\n            // Get scrobble data for this track\n            match self\n                .client\n                .load_edit_form_values_internal(\u0026track.name, \u0026self.edit.artist_name_original)\n                .await\n            {\n                Ok(track_scrobbles) =\u003e {\n                    // Apply user's changes and filtering\n                    let mut modified_edits = Vec::new();\n                    for scrobble in track_scrobbles {\n                        let mut modified_edit = scrobble.clone();\n                        if let Some(new_track_name) = \u0026self.edit.track_name {\n                            modified_edit.track_name = new_track_name.clone();\n                        }\n                        if let Some(new_album_name) = \u0026self.edit.album_name {\n                            modified_edit.album_name = new_album_name.clone();\n                        }\n                        modified_edit.artist_name = self.edit.artist_name.clone();\n                        if let Some(new_album_artist_name) = \u0026self.edit.album_artist_name {\n                            modified_edit.album_artist_name = new_album_artist_name.clone();\n                        }\n                        modified_edit.edit_all = self.edit.edit_all;\n                        modified_edits.push(modified_edit);\n                    }\n\n                    let filtered_edits =\n                        filter_by_original_album_artist(modified_edits, \u0026self.edit);\n\n                    if !filtered_edits.is_empty() {\n                        // Store results and return the first one\n                        self.current_track_results = filtered_edits;\n                        self.current_track_index = 1; // We'll return the first result below\n                        return Ok(Some(self.current_track_results[0].clone()));\n                    }\n                }\n                Err(e) =\u003e {\n                    log::debug!(\n                        \"Failed to get scrobble data for track '{}': {}\",\n                        track.name,\n                        e\n                    );\n                    // Continue with next track\n                }\n            }\n        }\n\n        // No more tracks\n        Ok(None)\n    }\n}\n","traces":[{"line":23,"address":[3805936,3806942,3806776],"length":1,"stats":{"Line":1}},{"line":25,"address":[6050797,6050744],"length":1,"stats":{"Line":4}},{"line":26,"address":[6150595,6150533],"length":1,"stats":{"Line":3}},{"line":27,"address":[3322427],"length":1,"stats":{"Line":1}},{"line":35,"address":[3322771],"length":1,"stats":{"Line":1}},{"line":43,"address":[5660335],"length":1,"stats":{"Line":4}},{"line":45,"address":[5983377],"length":1,"stats":{"Line":1}},{"line":46,"address":[6248492],"length":1,"stats":{"Line":1}},{"line":47,"address":[3549278,3549130],"length":1,"stats":{"Line":1}},{"line":48,"address":[5500283],"length":1,"stats":{"Line":1}},{"line":52,"address":[5983451,5987551,5989002,5983154,5983822,5987603],"length":1,"stats":{"Line":3}},{"line":53,"address":[5871157,5871285,5871229],"length":1,"stats":{"Line":3}},{"line":61,"address":[5693849,5689122,5689013,5693803,5693299],"length":1,"stats":{"Line":5}},{"line":63,"address":[5505426,5505002],"length":1,"stats":{"Line":2}},{"line":64,"address":[5301778],"length":1,"stats":{"Line":5}},{"line":66,"address":[5500910],"length":1,"stats":{"Line":1}},{"line":68,"address":[5689270],"length":1,"stats":{"Line":1}},{"line":69,"address":[6249621,6249486,6249370],"length":1,"stats":{"Line":3}},{"line":70,"address":[5689680,5690521],"length":1,"stats":{"Line":2}},{"line":71,"address":[5690931,5690561],"length":1,"stats":{"Line":1}},{"line":72,"address":[5868578,5868731,5868712],"length":1,"stats":{"Line":0}},{"line":74,"address":[3744293,3744576,3744799],"length":1,"stats":{"Line":3}},{"line":75,"address":[3744660,3744641,3744584],"length":1,"stats":{"Line":2}},{"line":77,"address":[3744823,3744603,3744804],"length":1,"stats":{"Line":2}},{"line":78,"address":[3744962,3745363],"length":1,"stats":{"Line":1}},{"line":79,"address":[3552096,3551919,3552077],"length":1,"stats":{"Line":0}},{"line":81,"address":[5869369],"length":1,"stats":{"Line":1}},{"line":82,"address":[5691458],"length":1,"stats":{"Line":1}},{"line":85,"address":[5984749,5984863],"length":1,"stats":{"Line":2}},{"line":88,"address":[3743534,3743463],"length":1,"stats":{"Line":2}},{"line":90,"address":[3550444,3550528],"length":1,"stats":{"Line":1}},{"line":91,"address":[5690126],"length":1,"stats":{"Line":1}},{"line":92,"address":[5690149],"length":1,"stats":{"Line":1}},{"line":95,"address":[3742782],"length":1,"stats":{"Line":0}},{"line":96,"address":[3745805,3745777,3742814],"length":1,"stats":{"Line":0}},{"line":107,"address":[3747519],"length":1,"stats":{"Line":1}}],"covered":32,"coverable":36},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","artist_tracks.rs"],"content":"use super::common::filter_by_original_album_artist;\nuse crate::{\n    AsyncDiscoveryIterator, AsyncPaginatedIterator, ExactScrobbleEdit, LastFmEditClientImpl,\n    Result, ScrobbleEdit,\n};\nuse async_trait::async_trait;\n\n/// Case 4: Artist tracks discovery (neither track nor album specified)\n///\n/// This discovers all tracks by an artist by iterating through the artist's catalog\n/// and for each track, loading its scrobbles incrementally. This is the most complex\n/// case as it involves nested iteration.\npub struct ArtistTracksDiscovery {\n    client: LastFmEditClientImpl,\n    edit: ScrobbleEdit,\n    tracks_iterator: crate::ArtistTracksIterator,\n    current_track_results: Vec\u003cExactScrobbleEdit\u003e,\n    current_track_index: usize,\n}\n\nimpl ArtistTracksDiscovery {\n    pub fn new(client: LastFmEditClientImpl, edit: ScrobbleEdit) -\u003e Self {\n        let tracks_iterator =\n            crate::ArtistTracksIterator::new(client.clone(), edit.artist_name_original.clone());\n\n        Self {\n            client,\n            edit,\n            tracks_iterator,\n            current_track_results: Vec::new(),\n            current_track_index: 0,\n        }\n    }\n}\n\n#[async_trait(?Send)]\nimpl AsyncDiscoveryIterator\u003cExactScrobbleEdit\u003e for ArtistTracksDiscovery {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cExactScrobbleEdit\u003e\u003e {\n        // If we have results from the current track, return the next one\n        if self.current_track_index \u003c self.current_track_results.len() {\n            let result = self.current_track_results[self.current_track_index].clone();\n            self.current_track_index += 1;\n            return Ok(Some(result));\n        }\n\n        // Get the next track from the iterator\n        while let Some(track) = self.tracks_iterator.next().await? {\n            // Get scrobble data for this track\n            match self\n                .client\n                .load_edit_form_values_internal(\u0026track.name, \u0026self.edit.artist_name_original)\n                .await\n            {\n                Ok(track_scrobbles) =\u003e {\n                    // Apply user's changes and filtering\n                    let mut modified_edits = Vec::new();\n                    for scrobble in track_scrobbles {\n                        let mut modified_edit = scrobble.clone();\n                        if let Some(new_track_name) = \u0026self.edit.track_name {\n                            modified_edit.track_name = new_track_name.clone();\n                        }\n                        if let Some(new_album_name) = \u0026self.edit.album_name {\n                            modified_edit.album_name = new_album_name.clone();\n                        }\n                        modified_edit.artist_name = self.edit.artist_name.clone();\n                        if let Some(new_album_artist_name) = \u0026self.edit.album_artist_name {\n                            modified_edit.album_artist_name = new_album_artist_name.clone();\n                        }\n                        modified_edit.edit_all = self.edit.edit_all;\n                        modified_edits.push(modified_edit);\n                    }\n\n                    let filtered_edits =\n                        filter_by_original_album_artist(modified_edits, \u0026self.edit);\n\n                    if !filtered_edits.is_empty() {\n                        // Store results and return the first one\n                        self.current_track_results = filtered_edits;\n                        self.current_track_index = 1; // We'll return the first result below\n                        return Ok(Some(self.current_track_results[0].clone()));\n                    }\n                }\n                Err(e) =\u003e {\n                    log::warn!(\n                        \"Failed to get scrobble data for track '{}': {}\",\n                        track.name,\n                        e\n                    );\n                    // Continue with next track\n                }\n            }\n        }\n\n        // No more tracks\n        Ok(None)\n    }\n}\n","traces":[{"line":22,"address":[2790720,2791427,2791346],"length":1,"stats":{"Line":1}},{"line":23,"address":[3792507],"length":1,"stats":{"Line":1}},{"line":30,"address":[5808898],"length":1,"stats":{"Line":1}},{"line":38,"address":[6395679],"length":1,"stats":{"Line":4}},{"line":40,"address":[6334465],"length":1,"stats":{"Line":1}},{"line":41,"address":[3777980],"length":1,"stats":{"Line":1}},{"line":42,"address":[6072410,6072558],"length":1,"stats":{"Line":1}},{"line":43,"address":[5952539],"length":1,"stats":{"Line":1}},{"line":47,"address":[5471087],"length":1,"stats":{"Line":3}},{"line":49,"address":[5570053,5570162,5574432,5574237,5574386],"length":1,"stats":{"Line":5}},{"line":51,"address":[3544797,3544732],"length":1,"stats":{"Line":2}},{"line":52,"address":[6339553,6335173,6334263,6334978,6339493,6334944],"length":1,"stats":{"Line":5}},{"line":54,"address":[5570270],"length":1,"stats":{"Line":1}},{"line":56,"address":[5760486],"length":1,"stats":{"Line":1}},{"line":57,"address":[6335466,6335582,6335717],"length":1,"stats":{"Line":3}},{"line":58,"address":[5954457,5953616],"length":1,"stats":{"Line":2}},{"line":59,"address":[5761777,5762144],"length":1,"stats":{"Line":1}},{"line":60,"address":[6074664,6074514,6074645],"length":1,"stats":{"Line":0}},{"line":62,"address":[6337066,6337289,6336789],"length":1,"stats":{"Line":1}},{"line":63,"address":[5571986,5572062,5572043],"length":1,"stats":{"Line":0}},{"line":65,"address":[3542730,3542749,3542529],"length":1,"stats":{"Line":2}},{"line":66,"address":[3780844,3781233],"length":1,"stats":{"Line":2}},{"line":67,"address":[3542963,3543134,3543115],"length":1,"stats":{"Line":2}},{"line":69,"address":[5572461],"length":1,"stats":{"Line":1}},{"line":70,"address":[3543010],"length":1,"stats":{"Line":1}},{"line":73,"address":[5570863,5570749],"length":1,"stats":{"Line":2}},{"line":76,"address":[3779351,3779422],"length":1,"stats":{"Line":2}},{"line":78,"address":[5571040,5570948],"length":1,"stats":{"Line":1}},{"line":79,"address":[3541710],"length":1,"stats":{"Line":1}},{"line":80,"address":[5761365],"length":1,"stats":{"Line":1}},{"line":83,"address":[5570190],"length":1,"stats":{"Line":0}},{"line":84,"address":[5760398,5763343,5763371],"length":1,"stats":{"Line":0}},{"line":95,"address":[3782950],"length":1,"stats":{"Line":1}}],"covered":29,"coverable":33},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","common.rs"],"content":"use crate::{ExactScrobbleEdit, ScrobbleEdit};\n\n/// Filter discovered edits based on original album artist if specified\n///\n/// When album_artist_name_original is specified in the ScrobbleEdit, we only want\n/// to return ExactScrobbleEdits that match that original album artist value.\n/// This prevents implicit fan-out over different album artists.\npub fn filter_by_original_album_artist(\n    discovered_edits: Vec\u003cExactScrobbleEdit\u003e,\n    edit: \u0026ScrobbleEdit,\n) -\u003e Vec\u003cExactScrobbleEdit\u003e {\n    if let Some(target_album_artist) = \u0026edit.album_artist_name_original {\n        log::debug!(\n            \"Filtering {} discovered edits to only include album artist '{}'\",\n            discovered_edits.len(),\n            target_album_artist\n        );\n\n        let filtered: Vec\u003cExactScrobbleEdit\u003e = discovered_edits\n            .into_iter()\n            .filter(|scrobble| scrobble.album_artist_name_original == *target_album_artist)\n            .collect();\n\n        log::debug!(\n            \"After filtering by album artist '{}': {} edits remain\",\n            target_album_artist,\n            filtered.len()\n        );\n\n        filtered\n    } else {\n        discovered_edits\n    }\n}\n","traces":[{"line":8,"address":[5980000,5981204],"length":1,"stats":{"Line":1}},{"line":12,"address":[5715191,5715038,5715851],"length":1,"stats":{"Line":3}},{"line":13,"address":[5715387],"length":1,"stats":{"Line":0}},{"line":19,"address":[6094292,6094701],"length":1,"stats":{"Line":2}},{"line":21,"address":[5715656],"length":1,"stats":{"Line":3}},{"line":24,"address":[3550159,3550032,3549981,3549891],"length":1,"stats":{"Line":3}},{"line":30,"address":[3549992],"length":1,"stats":{"Line":1}},{"line":32,"address":[3549337],"length":1,"stats":{"Line":1}}],"covered":7,"coverable":8},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","discovery_iterator.rs"],"content":"use crate::Result;\nuse async_trait::async_trait;\n\n/// Async iterator trait for discovering scrobble edits incrementally\n///\n/// This trait is designed for iterators that yield individual results one at a time,\n/// unlike AsyncPaginatedIterator which is designed for page-based iteration.\n/// This is particularly useful for discovery operations that might make many API\n/// requests and need to avoid rate limiting by yielding results incrementally.\n#[async_trait(?Send)]\npub trait AsyncDiscoveryIterator\u003cT\u003e {\n    /// Get the next item from the iterator\n    ///\n    /// Returns `Ok(Some(item))` if there's a next item available,\n    /// `Ok(None)` if the iterator is exhausted, or `Err(e)` if an error occurred.\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cT\u003e\u003e;\n\n    /// Collect all remaining items from the iterator into a Vec\n    ///\n    /// This is a convenience method that calls `next()` repeatedly until\n    /// the iterator is exhausted and collects all results.\n    async fn collect_all(\u0026mut self) -\u003e Result\u003cVec\u003cT\u003e\u003e {\n        let mut items = Vec::new();\n        while let Some(item) = self.next().await? {\n            items.push(item);\n        }\n        Ok(items)\n    }\n\n    /// Take the first `n` items from the iterator\n    ///\n    /// This stops after collecting `n` items or when the iterator is exhausted,\n    /// whichever comes first.\n    async fn take(\u0026mut self, n: usize) -\u003e Result\u003cVec\u003cT\u003e\u003e {\n        let mut items = Vec::with_capacity(n);\n        for _ in 0..n {\n            if let Some(item) = self.next().await? {\n                items.push(item);\n            } else {\n                break;\n            }\n        }\n        Ok(items)\n    }\n}\n","traces":[{"line":22,"address":[3545033],"length":1,"stats":{"Line":8}},{"line":23,"address":[6153964,6149884,6152604,6151244],"length":1,"stats":{"Line":2}},{"line":24,"address":[5415292,5414343,5412983,5414969,5412006,5412572,5410621,5413932,5414726,5410646,5410263,5411623,5411212,5411922,5410562,5410889,5413341,5413366,5412249,5414642,5411981,5414701,5413609,5413282],"length":1,"stats":{"Line":8}},{"line":25,"address":[5411197,5412557,5413917,5411151,5413871,5412511,5415231,5415277],"length":1,"stats":{"Line":4}},{"line":27,"address":[3438297,3439593,3440889,3442185],"length":1,"stats":{"Line":2}},{"line":34,"address":[6053486],"length":1,"stats":{"Line":0}},{"line":35,"address":[5776343,5777847,5773335,5774839],"length":1,"stats":{"Line":0}},{"line":36,"address":[5420647,5417559,5417639,5421255,5419143,5419156,5416055,5416135,5416743,5416148,5420660,5420567,5419751,5419063,5418247,5417652],"length":1,"stats":{"Line":0}},{"line":37,"address":[3349444,3351940,3348884,3353332],"length":1,"stats":{"Line":0}},{"line":38,"address":[3658463,3659967,3657005,3661517,3656959,3660013,3661471,3658509],"length":1,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}}],"covered":5,"coverable":12},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","exact_match.rs"],"content":"use super::common::filter_by_original_album_artist;\nuse crate::{\n    AsyncDiscoveryIterator, ExactScrobbleEdit, LastFmEditClientImpl, LastFmError, Result,\n    ScrobbleEdit,\n};\nuse async_trait::async_trait;\n\n/// Case 1: Exact match discovery (track + album specified)\n///\n/// This discovers the specific scrobble that matches both the track and album,\n/// yielding at most one result.\npub struct ExactMatchDiscovery {\n    client: LastFmEditClientImpl,\n    edit: ScrobbleEdit,\n    track_name: String,\n    album_name: String,\n    result: Option\u003cExactScrobbleEdit\u003e,\n    completed: bool,\n}\n\nimpl ExactMatchDiscovery {\n    pub fn new(\n        client: LastFmEditClientImpl,\n        edit: ScrobbleEdit,\n        track_name: String,\n        album_name: String,\n    ) -\u003e Self {\n        Self {\n            client,\n            edit,\n            track_name,\n            album_name,\n            result: None,\n            completed: false,\n        }\n    }\n}\n\n#[async_trait(?Send)]\nimpl AsyncDiscoveryIterator\u003cExactScrobbleEdit\u003e for ExactMatchDiscovery {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cExactScrobbleEdit\u003e\u003e {\n        if self.completed {\n            return Ok(None);\n        }\n\n        if self.result.is_none() {\n            // Perform the lookup inline (previously discover_track_album_exact_match)\n            log::debug!(\n                \"Looking up missing metadata for track '{}' on album '{}' by '{}'\",\n                self.track_name,\n                self.album_name,\n                self.edit.artist_name_original\n            );\n\n            match self\n                .client\n                .load_edit_form_values_internal(\u0026self.track_name, \u0026self.edit.artist_name_original)\n                .await\n            {\n                Ok(all_variations) =\u003e {\n                    // Filter by album artist first if specified, then find the variation that matches the specific album\n                    let filtered_variations =\n                        filter_by_original_album_artist(all_variations, \u0026self.edit);\n\n                    if let Some(exact_edit) = filtered_variations\n                        .iter()\n                        .find(|variation| variation.album_name_original == self.album_name)\n                    {\n                        // Apply the user's desired changes to this exact variation\n                        let mut modified_edit = exact_edit.clone();\n                        if let Some(new_track_name) = \u0026self.edit.track_name {\n                            modified_edit.track_name = new_track_name.clone();\n                        }\n                        if let Some(new_album_name) = \u0026self.edit.album_name {\n                            modified_edit.album_name = new_album_name.clone();\n                        }\n                        modified_edit.artist_name = self.edit.artist_name.clone();\n                        if let Some(new_album_artist_name) = \u0026self.edit.album_artist_name {\n                            modified_edit.album_artist_name = new_album_artist_name.clone();\n                        }\n                        modified_edit.edit_all = self.edit.edit_all;\n\n                        self.result = Some(modified_edit);\n                    } else {\n                        let album_artist_filter = if self.edit.album_artist_name_original.is_some()\n                        {\n                            format!(\n                                \" with album artist '{}'\",\n                                self.edit.album_artist_name_original.as_ref().unwrap()\n                            )\n                        } else {\n                            String::new()\n                        };\n                        self.completed = true;\n                        return Err(LastFmError::Parse(format!(\n                            \"Track '{}' not found on album '{}' by '{}'{} in recent scrobbles\",\n                            self.track_name,\n                            self.album_name,\n                            self.edit.artist_name_original,\n                            album_artist_filter\n                        )));\n                    }\n                }\n                Err(e) =\u003e {\n                    self.completed = true;\n                    return Err(e);\n                }\n            }\n        }\n\n        self.completed = true;\n        Ok(self.result.take())\n    }\n}\n","traces":[{"line":22,"address":[3741040],"length":1,"stats":{"Line":1}},{"line":41,"address":[5740752,5740975,5740590,5741916,5740528,5740925,5744259],"length":1,"stats":{"Line":4}},{"line":42,"address":[3305926],"length":1,"stats":{"Line":1}},{"line":43,"address":[3305984],"length":1,"stats":{"Line":1}},{"line":46,"address":[5662667,5662760],"length":1,"stats":{"Line":2}},{"line":48,"address":[5466882,5466762],"length":1,"stats":{"Line":2}},{"line":55,"address":[3073696,3074009,3073958,3073726,3073112],"length":1,"stats":{"Line":5}},{"line":57,"address":[6054741,6054273],"length":1,"stats":{"Line":2}},{"line":58,"address":[3348759],"length":1,"stats":{"Line":3}},{"line":60,"address":[5836407],"length":1,"stats":{"Line":1}},{"line":62,"address":[3074243],"length":1,"stats":{"Line":1}},{"line":65,"address":[5742430,5742513,5742579],"length":1,"stats":{"Line":3}},{"line":67,"address":[3310128,3310145,3307488],"length":1,"stats":{"Line":3}},{"line":70,"address":[5664319,5664427],"length":1,"stats":{"Line":2}},{"line":71,"address":[3074651,3075012],"length":1,"stats":{"Line":1}},{"line":72,"address":[5743044,5743025,5742894],"length":1,"stats":{"Line":0}},{"line":74,"address":[6056198,6056421,6055921],"length":1,"stats":{"Line":1}},{"line":75,"address":[5837322,5837303,5837246],"length":1,"stats":{"Line":0}},{"line":77,"address":[5469002,5468801,5469021],"length":1,"stats":{"Line":2}},{"line":78,"address":[5743999,5743576],"length":1,"stats":{"Line":1}},{"line":79,"address":[5665508,5665299,5665489],"length":1,"stats":{"Line":0}},{"line":81,"address":[3075505],"length":1,"stats":{"Line":1}},{"line":83,"address":[3308932,3308626],"length":1,"stats":{"Line":1}},{"line":85,"address":[3307606,3309408],"length":1,"stats":{"Line":0}},{"line":87,"address":[5666284],"length":1,"stats":{"Line":0}},{"line":89,"address":[3076325,3076424],"length":1,"stats":{"Line":0}},{"line":92,"address":[5666142,5666181],"length":1,"stats":{"Line":0}},{"line":94,"address":[3309463],"length":1,"stats":{"Line":0}},{"line":95,"address":[5666202,5666460],"length":1,"stats":{"Line":0}},{"line":104,"address":[3074041],"length":1,"stats":{"Line":0}},{"line":105,"address":[5836301],"length":1,"stats":{"Line":0}},{"line":106,"address":[5663920],"length":1,"stats":{"Line":0}},{"line":111,"address":[5835166],"length":1,"stats":{"Line":1}},{"line":112,"address":[3306065,3309099],"length":1,"stats":{"Line":2}}],"covered":22,"coverable":34},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","mod.rs"],"content":"pub mod album_tracks;\npub mod artist_tracks;\npub mod common;\npub mod discovery_iterator;\npub mod exact_match;\npub mod track_variations;\n\npub use album_tracks::AlbumTracksDiscovery;\npub use artist_tracks::ArtistTracksDiscovery;\npub use common::filter_by_original_album_artist;\npub use discovery_iterator::AsyncDiscoveryIterator;\npub use exact_match::ExactMatchDiscovery;\npub use track_variations::TrackVariationsDiscovery;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","src","discovery","track_variations.rs"],"content":"use super::common::filter_by_original_album_artist;\nuse crate::{\n    AsyncDiscoveryIterator, ExactScrobbleEdit, LastFmEditClientImpl, Result, ScrobbleEdit,\n};\nuse async_trait::async_trait;\n\n/// Case 2: Track variations discovery (track specified, album not specified)\n///\n/// This discovers all album variations of a specific track by loading the track's\n/// scrobble data incrementally and yielding each variation as it processes them.\n/// This is now truly incremental like the artist and album tracks discovery.\npub struct TrackVariationsDiscovery {\n    client: LastFmEditClientImpl,\n    edit: ScrobbleEdit,\n    track_name: String,\n    scrobbles_loaded: bool,\n    current_results: Vec\u003cExactScrobbleEdit\u003e,\n    current_index: usize,\n}\n\nimpl TrackVariationsDiscovery {\n    pub fn new(client: LastFmEditClientImpl, edit: ScrobbleEdit, track_name: String) -\u003e Self {\n        Self {\n            client,\n            edit,\n            track_name,\n            scrobbles_loaded: false,\n            current_results: Vec::new(),\n            current_index: 0,\n        }\n    }\n}\n\n#[async_trait(?Send)]\nimpl AsyncDiscoveryIterator\u003cExactScrobbleEdit\u003e for TrackVariationsDiscovery {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cExactScrobbleEdit\u003e\u003e {\n        // If we have results from current batch, return the next one\n        if self.current_index \u003c self.current_results.len() {\n            let result = self.current_results[self.current_index].clone();\n            self.current_index += 1;\n            return Ok(Some(result));\n        }\n\n        // If we haven't loaded scrobbles yet, load them\n        if !self.scrobbles_loaded {\n            log::debug!(\n                \"Getting scrobble data for track '{}' by '{}'\",\n                self.track_name,\n                self.edit.artist_name_original\n            );\n\n            match self\n                .client\n                .load_edit_form_values_internal(\u0026self.track_name, \u0026self.edit.artist_name_original)\n                .await\n            {\n                Ok(track_scrobbles) =\u003e {\n                    // Apply user's changes and filtering\n                    let mut modified_edits = Vec::new();\n                    for scrobble in track_scrobbles {\n                        let mut modified_edit = scrobble.clone();\n                        if let Some(new_track_name) = \u0026self.edit.track_name {\n                            modified_edit.track_name = new_track_name.clone();\n                        }\n                        if let Some(new_album_name) = \u0026self.edit.album_name {\n                            modified_edit.album_name = new_album_name.clone();\n                        }\n                        modified_edit.artist_name = self.edit.artist_name.clone();\n                        if let Some(new_album_artist_name) = \u0026self.edit.album_artist_name {\n                            modified_edit.album_artist_name = new_album_artist_name.clone();\n                        }\n                        modified_edit.edit_all = self.edit.edit_all;\n                        modified_edits.push(modified_edit);\n                    }\n\n                    let filtered_edits =\n                        filter_by_original_album_artist(modified_edits, \u0026self.edit);\n\n                    if !filtered_edits.is_empty() {\n                        // Store results and return the first one\n                        self.current_results = filtered_edits;\n                        self.current_index = 1; // We'll return the first result below\n                        self.scrobbles_loaded = true;\n                        return Ok(Some(self.current_results[0].clone()));\n                    }\n                }\n                Err(e) =\u003e {\n                    log::debug!(\n                        \"Failed to get scrobble data for track '{}': {}\",\n                        self.track_name,\n                        e\n                    );\n                    self.scrobbles_loaded = true;\n                    return Err(e);\n                }\n            }\n            self.scrobbles_loaded = true;\n        }\n\n        // No more results\n        Ok(None)\n    }\n}\n","traces":[{"line":22,"address":[6087232,6087682,6087641],"length":1,"stats":{"Line":1}},{"line":28,"address":[6087402],"length":1,"stats":{"Line":1}},{"line":36,"address":[5842111],"length":1,"stats":{"Line":4}},{"line":38,"address":[5985637],"length":1,"stats":{"Line":1}},{"line":39,"address":[5274424,5273606],"length":1,"stats":{"Line":2}},{"line":40,"address":[5605389,5605247],"length":1,"stats":{"Line":1}},{"line":41,"address":[5274490],"length":1,"stats":{"Line":1}},{"line":45,"address":[5435839,5438361],"length":1,"stats":{"Line":1}},{"line":46,"address":[3555135,3555203,3555008],"length":1,"stats":{"Line":3}},{"line":52,"address":[3555645,3556173,3556228,3555141,3555691],"length":1,"stats":{"Line":5}},{"line":54,"address":[3555578,3555170],"length":1,"stats":{"Line":2}},{"line":55,"address":[5640807],"length":1,"stats":{"Line":3}},{"line":57,"address":[5605805],"length":1,"stats":{"Line":1}},{"line":59,"address":[3318981],"length":1,"stats":{"Line":2}},{"line":60,"address":[5275097,5275348,5275213],"length":1,"stats":{"Line":6}},{"line":61,"address":[5607032,5606249],"length":1,"stats":{"Line":4}},{"line":62,"address":[5723753,5723392],"length":1,"stats":{"Line":4}},{"line":63,"address":[5438587,5438737,5438718],"length":1,"stats":{"Line":4}},{"line":65,"address":[5988978,5988755,5988478],"length":1,"stats":{"Line":1}},{"line":66,"address":[5438967,5438948,5438891],"length":1,"stats":{"Line":0}},{"line":68,"address":[5439111,5439130,5438910],"length":1,"stats":{"Line":2}},{"line":69,"address":[5608218,5607829],"length":1,"stats":{"Line":3}},{"line":70,"address":[3321155,3320984,3321136],"length":1,"stats":{"Line":2}},{"line":72,"address":[3321006],"length":1,"stats":{"Line":1}},{"line":73,"address":[3321031],"length":1,"stats":{"Line":1}},{"line":76,"address":[3556920,3556806],"length":1,"stats":{"Line":2}},{"line":79,"address":[3319512,3319565],"length":1,"stats":{"Line":2}},{"line":81,"address":[5606471,5606563],"length":1,"stats":{"Line":1}},{"line":82,"address":[5438129],"length":1,"stats":{"Line":1}},{"line":83,"address":[5723032],"length":1,"stats":{"Line":2}},{"line":84,"address":[3557259],"length":1,"stats":{"Line":2}},{"line":87,"address":[3318856],"length":1,"stats":{"Line":0}},{"line":88,"address":[5440069,5440249,5437200],"length":1,"stats":{"Line":0}},{"line":93,"address":[5440079],"length":1,"stats":{"Line":0}},{"line":94,"address":[3559186],"length":1,"stats":{"Line":0}},{"line":97,"address":[3557430],"length":1,"stats":{"Line":0}},{"line":101,"address":[3555053],"length":1,"stats":{"Line":1}}],"covered":31,"coverable":37},{"path":["/","home","imalison","Projects","lastfm-edit","src","edit_analysis.rs"],"content":"use http_types::StatusCode;\nuse scraper::{Html, Selector};\n\n/// Result of analyzing an edit response from Last.fm\n#[derive(Debug, Clone)]\npub struct EditAnalysisResult {\n    /// Whether the edit was successful based on all indicators\n    pub success: bool,\n    /// Optional detailed message about the result\n    pub message: Option\u003cString\u003e,\n    /// Track name found in the response (if any)\n    pub actual_track_name: Option\u003cString\u003e,\n    /// Album name found in the response (if any)\n    pub actual_album_name: Option\u003cString\u003e,\n}\n\n/// Analyze the HTML response from a Last.fm edit request to determine success/failure\n///\n/// This function parses the response HTML to look for success/error indicators\n/// and extract the actual track/album names that were processed.\n///\n/// # Arguments\n/// * `response_text` - The HTML response body from the edit request\n/// * `status_code` - The HTTP status code of the response\n///\n/// # Returns\n/// An `EditAnalysisResult` containing the analysis results\npub fn analyze_edit_response(response_text: \u0026str, status_code: StatusCode) -\u003e EditAnalysisResult {\n    // Parse the HTML response to check for actual success/failure\n    let document = Html::parse_document(response_text);\n\n    // Check for success indicator\n    let success_selector = Selector::parse(\".alert-success\").unwrap();\n    let error_selector = Selector::parse(\".alert-danger, .alert-error, .error\").unwrap();\n\n    let has_success_alert = document.select(\u0026success_selector).next().is_some();\n    let has_error_alert = document.select(\u0026error_selector).next().is_some();\n\n    // Extract track and album names from the response\n    let (actual_track_name, actual_album_name) =\n        extract_track_album_names(\u0026document, response_text);\n\n    log::debug!(\n        \"Response analysis: success_alert={}, error_alert={}, track='{}', album='{}'\",\n        has_success_alert,\n        has_error_alert,\n        actual_track_name.as_deref().unwrap_or(\"not found\"),\n        actual_album_name.as_deref().unwrap_or(\"not found\")\n    );\n\n    // Determine if edit was truly successful\n    let final_success = status_code.is_success() \u0026\u0026 has_success_alert \u0026\u0026 !has_error_alert;\n\n    // Create detailed message\n    let message = if has_error_alert {\n        // Extract error message\n        if let Some(error_element) = document.select(\u0026error_selector).next() {\n            Some(format!(\n                \"Edit failed: {}\",\n                error_element.text().collect::\u003cString\u003e().trim()\n            ))\n        } else {\n            Some(\"Edit failed with unknown error\".to_string())\n        }\n    } else if final_success {\n        Some(format!(\n            \"Edit successful - Track: '{}', Album: '{}'\",\n            actual_track_name.as_deref().unwrap_or(\"unknown\"),\n            actual_album_name.as_deref().unwrap_or(\"unknown\")\n        ))\n    } else {\n        Some(format!(\"Edit failed with status: {status_code}\"))\n    };\n\n    EditAnalysisResult {\n        success: final_success,\n        message,\n        actual_track_name,\n        actual_album_name,\n    }\n}\n\n/// Extract track and album names from the edit response\n///\n/// This function tries multiple strategies to find the actual track and album names\n/// in the response, including direct CSS selectors and regex patterns.\nfn extract_track_album_names(\n    document: \u0026Html,\n    response_text: \u0026str,\n) -\u003e (Option\u003cString\u003e, Option\u003cString\u003e) {\n    let mut actual_track_name = None;\n    let mut actual_album_name = None;\n\n    // Try direct selectors first\n    let track_name_selector = Selector::parse(\"td.chartlist-name a\").unwrap();\n    let album_name_selector = Selector::parse(\"td.chartlist-album a\").unwrap();\n\n    if let Some(track_element) = document.select(\u0026track_name_selector).next() {\n        actual_track_name = Some(track_element.text().collect::\u003cString\u003e().trim().to_string());\n    }\n\n    if let Some(album_element) = document.select(\u0026album_name_selector).next() {\n        actual_album_name = Some(album_element.text().collect::\u003cString\u003e().trim().to_string());\n    }\n\n    // If not found, try extracting from the raw response text using generic patterns\n    if actual_track_name.is_none() || actual_album_name.is_none() {\n        if actual_track_name.is_none() {\n            actual_track_name = extract_track_name_from_text(response_text);\n        }\n\n        if actual_album_name.is_none() {\n            actual_album_name = extract_album_name_from_text(response_text);\n        }\n    }\n\n    (actual_track_name, actual_album_name)\n}\n\n/// Extract track name from response text using regex patterns\nfn extract_track_name_from_text(response_text: \u0026str) -\u003e Option\u003cString\u003e {\n    // Look for track name in href=\"/music/{artist}/_/{track}\"\n    // Use regex to find track URLs\n    let track_pattern = regex::Regex::new(r#\"href=\"/music/[^\"]+/_/([^\"]+)\"\"#).unwrap();\n    if let Some(captures) = track_pattern.captures(response_text) {\n        if let Some(track_match) = captures.get(1) {\n            let raw_track = track_match.as_str();\n            // URL decode the track name\n            let decoded_track = urlencoding::decode(raw_track)\n                .unwrap_or_else(|_| raw_track.into())\n                .replace('+', \" \");\n            return Some(decoded_track);\n        }\n    }\n    None\n}\n\n/// Extract album name from response text using regex patterns\nfn extract_album_name_from_text(response_text: \u0026str) -\u003e Option\u003cString\u003e {\n    // Look for album name in href=\"/music/{artist}/{album}\"\n    // Find album links that are not track links (don't contain /_/)\n    let album_pattern =\n        regex::Regex::new(r#\"href=\"/music/[^\"]+/([^\"/_]+)\"[^\u003e]*\u003e[^\u003c]*\u003c/a\u003e\"#).unwrap();\n    if let Some(captures) = album_pattern.captures(response_text) {\n        if let Some(album_match) = captures.get(1) {\n            let raw_album = album_match.as_str();\n            // URL decode the album name\n            let decoded_album = urlencoding::decode(raw_album)\n                .unwrap_or_else(|_| raw_album.into())\n                .replace('+', \" \");\n            return Some(decoded_album);\n        }\n    }\n    None\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_analyze_success_response() {\n        let html = r#\"\n            \u003cdiv class=\"alert-success\"\u003eEdit successful\u003c/div\u003e\n            \u003ctable\u003e\n                \u003ctr\u003e\n                    \u003ctd class=\"chartlist-name\"\u003e\u003ca href=\"/music/artist/_/track\"\u003eTest Track\u003c/a\u003e\u003c/td\u003e\n                    \u003ctd class=\"chartlist-album\"\u003e\u003ca href=\"/music/artist/album\"\u003eTest Album\u003c/a\u003e\u003c/td\u003e\n                \u003c/tr\u003e\n            \u003c/table\u003e\n        \"#;\n\n        let result = analyze_edit_response(html, StatusCode::Ok);\n        assert!(result.success);\n        // The CSS selectors should extract the text content of the links\n        assert_eq!(result.actual_track_name, Some(\"Test Track\".to_string()));\n        assert_eq!(result.actual_album_name, Some(\"Test Album\".to_string()));\n    }\n\n    #[test]\n    fn test_analyze_error_response() {\n        let html = r#\"\n            \u003cdiv class=\"alert-danger\"\u003eEdit failed: Invalid data\u003c/div\u003e\n        \"#;\n\n        let result = analyze_edit_response(html, StatusCode::Ok);\n        assert!(!result.success);\n        assert!(result\n            .message\n            .unwrap()\n            .contains(\"Edit failed: Invalid data\"));\n    }\n\n    #[test]\n    fn test_extract_from_regex_patterns() {\n        let html = r#\"\n            Some content with \u003ca href=\"/music/Artist/AlbumName\"\u003ealbum link\u003c/a\u003e\n            and later \u003ca href=\"/music/Artist/_/TrackName\"\u003etrack link\u003c/a\u003e\n        \"#;\n\n        let result = analyze_edit_response(html, StatusCode::Ok);\n        // Should extract from regex patterns when direct selectors fail\n        // The track pattern captures from /_/ URLs, album pattern from non-/_/ URLs\n        assert_eq!(result.actual_track_name, Some(\"TrackName\".to_string()));\n        assert_eq!(result.actual_album_name, Some(\"AlbumName\".to_string()));\n    }\n}\n","traces":[{"line":28,"address":[3735429,3735556,3732384],"length":1,"stats":{"Line":4}},{"line":30,"address":[5976834],"length":1,"stats":{"Line":4}},{"line":33,"address":[5976851,5976926],"length":1,"stats":{"Line":8}},{"line":34,"address":[3425500,3425575],"length":1,"stats":{"Line":8}},{"line":36,"address":[3732717,3732796],"length":1,"stats":{"Line":8}},{"line":37,"address":[5977309],"length":1,"stats":{"Line":4}},{"line":40,"address":[3733124],"length":1,"stats":{"Line":2}},{"line":43,"address":[3426187,3426222,3426476,3426607,3426091],"length":1,"stats":{"Line":3}},{"line":52,"address":[5858142,5857473],"length":1,"stats":{"Line":4}},{"line":55,"address":[3426906],"length":1,"stats":{"Line":2}},{"line":57,"address":[3735483,3734032,3734945,3734874],"length":1,"stats":{"Line":6}},{"line":58,"address":[6241326,6241421],"length":1,"stats":{"Line":2}},{"line":60,"address":[3428060,3427974,3427897],"length":1,"stats":{"Line":6}},{"line":63,"address":[3735435,3735032],"length":1,"stats":{"Line":0}},{"line":65,"address":[5921135,5919748,5920597,5920629],"length":1,"stats":{"Line":6}},{"line":66,"address":[5975894,5975769],"length":1,"stats":{"Line":4}},{"line":68,"address":[5978481,5978878],"length":1,"stats":{"Line":4}},{"line":69,"address":[6240788],"length":1,"stats":{"Line":2}},{"line":72,"address":[5978454,5978513],"length":1,"stats":{"Line":2}},{"line":87,"address":[3430714,3428464,3429402],"length":1,"stats":{"Line":4}},{"line":91,"address":[6241848],"length":1,"stats":{"Line":4}},{"line":92,"address":[5980066],"length":1,"stats":{"Line":5}},{"line":95,"address":[5921498,5921426],"length":1,"stats":{"Line":10}},{"line":96,"address":[3735889,3735814],"length":1,"stats":{"Line":10}},{"line":98,"address":[5860253,5860185,5860114],"length":1,"stats":{"Line":15}},{"line":99,"address":[6242394,6242345,6242597],"length":1,"stats":{"Line":2}},{"line":102,"address":[6242851,6242753],"length":1,"stats":{"Line":8}},{"line":103,"address":[3429636,3429819,3429571],"length":1,"stats":{"Line":2}},{"line":107,"address":[5978316,5978402],"length":1,"stats":{"Line":5}},{"line":108,"address":[5861526,5861332,5861741],"length":1,"stats":{"Line":10}},{"line":109,"address":[5923128,5923154],"length":1,"stats":{"Line":4}},{"line":112,"address":[5982150,5981958,5981740],"length":1,"stats":{"Line":6}},{"line":113,"address":[5923329,5923355],"length":1,"stats":{"Line":2}},{"line":117,"address":[3430061],"length":1,"stats":{"Line":2}},{"line":121,"address":[6245099,6244096,6245025],"length":1,"stats":{"Line":4}},{"line":124,"address":[6244139],"length":1,"stats":{"Line":4}},{"line":125,"address":[5923755,5923803],"length":1,"stats":{"Line":7}},{"line":126,"address":[6244428,6244516],"length":1,"stats":{"Line":4}},{"line":127,"address":[5979595,5979644],"length":1,"stats":{"Line":4}},{"line":129,"address":[3738460,3738606],"length":1,"stats":{"Line":4}},{"line":130,"address":[6256576,6256603],"length":1,"stats":{"Line":0}},{"line":132,"address":[5924439],"length":1,"stats":{"Line":2}},{"line":135,"address":[5924574],"length":1,"stats":{"Line":2}},{"line":139,"address":[5864091,5864017,5863088],"length":1,"stats":{"Line":2}},{"line":142,"address":[6245171],"length":1,"stats":{"Line":2}},{"line":144,"address":[3739099,3739051],"length":1,"stats":{"Line":8}},{"line":145,"address":[5983716,5983628],"length":1,"stats":{"Line":4}},{"line":146,"address":[5925131,5925180],"length":1,"stats":{"Line":4}},{"line":148,"address":[5980846,5980700],"length":1,"stats":{"Line":4}},{"line":149,"address":[5874608,5874635],"length":1,"stats":{"Line":0}},{"line":151,"address":[5863911],"length":1,"stats":{"Line":2}},{"line":154,"address":[3739870],"length":1,"stats":{"Line":2}}],"covered":49,"coverable":52},{"path":["/","home","imalison","Projects","lastfm-edit","src","headers.rs"],"content":"use http_client::Request;\n\n/// Common Chrome user agent string for all requests\nconst USER_AGENT: \u0026str = \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36\";\n\n/// Common Chrome headers for security info\nconst SEC_CH_UA: \u0026str =\n    \"\\\"Not)A;Brand\\\";v=\\\"8\\\", \\\"Chromium\\\";v=\\\"138\\\", \\\"Google Chrome\\\";v=\\\"138\\\"\";\nconst SEC_CH_UA_MOBILE: \u0026str = \"?0\";\nconst SEC_CH_UA_PLATFORM: \u0026str = \"\\\"Linux\\\"\";\n\n/// Add common browser headers to a request\npub fn add_common_headers(request: \u0026mut Request) {\n    let _ = request.insert_header(\"User-Agent\", USER_AGENT);\n    let _ = request.insert_header(\"Accept-Language\", \"en-US,en;q=0.9\");\n    let _ = request.insert_header(\"Accept-Encoding\", \"gzip, deflate, br\");\n    let _ = request.insert_header(\"DNT\", \"1\");\n    let _ = request.insert_header(\"Connection\", \"keep-alive\");\n    let _ = request.insert_header(\"sec-ch-ua\", SEC_CH_UA);\n    let _ = request.insert_header(\"sec-ch-ua-mobile\", SEC_CH_UA_MOBILE);\n    let _ = request.insert_header(\"sec-ch-ua-platform\", SEC_CH_UA_PLATFORM);\n}\n\n/// Add headers for AJAX form edit requests\npub fn add_edit_headers(request: \u0026mut Request, referer_url: \u0026str) {\n    add_common_headers(request);\n    let _ = request.insert_header(\"Accept\", \"*/*\");\n    let _ = request.insert_header(\n        \"Content-Type\",\n        \"application/x-www-form-urlencoded;charset=UTF-8\",\n    );\n    let _ = request.insert_header(\"Priority\", \"u=1, i\");\n    let _ = request.insert_header(\"X-Requested-With\", \"XMLHttpRequest\");\n    let _ = request.insert_header(\"Sec-Fetch-Dest\", \"empty\");\n    let _ = request.insert_header(\"Sec-Fetch-Mode\", \"cors\");\n    let _ = request.insert_header(\"Sec-Fetch-Site\", \"same-origin\");\n    let _ = request.insert_header(\"Referer\", referer_url);\n}\n\n/// Add headers for GET requests (regular pages or AJAX)\npub fn add_get_headers(request: \u0026mut Request, is_ajax: bool, referer_url: Option\u003c\u0026str\u003e) {\n    add_common_headers(request);\n\n    if is_ajax {\n        let _ = request.insert_header(\"Accept\", \"*/*\");\n        let _ = request.insert_header(\"X-Requested-With\", \"XMLHttpRequest\");\n    } else {\n        let _ = request.insert_header(\n            \"Accept\",\n            \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\"\n        );\n        let _ = request.insert_header(\"Upgrade-Insecure-Requests\", \"1\");\n    }\n\n    if let Some(referer) = referer_url {\n        let _ = request.insert_header(\"Referer\", referer);\n    }\n}\n\n/// Add cookies to a request if they exist\npub fn add_cookies(request: \u0026mut Request, cookies: \u0026[String]) {\n    if !cookies.is_empty() {\n        let cookie_header = cookies.join(\"; \");\n        let _ = request.insert_header(\"Cookie\", \u0026cookie_header);\n    }\n}\n","traces":[{"line":13,"address":[6088944],"length":1,"stats":{"Line":5}},{"line":14,"address":[2801271],"length":1,"stats":{"Line":8}},{"line":15,"address":[20633524,20633460,20633440,20633504],"length":1,"stats":{"Line":5}},{"line":16,"address":[21125814],"length":1,"stats":{"Line":8}},{"line":17,"address":[3612771],"length":1,"stats":{"Line":5}},{"line":18,"address":[20916384],"length":1,"stats":{"Line":8}},{"line":19,"address":[6089231],"length":1,"stats":{"Line":5}},{"line":20,"address":[2801581],"length":1,"stats":{"Line":8}},{"line":21,"address":[6089347],"length":1,"stats":{"Line":5}},{"line":25,"address":[2801696],"length":1,"stats":{"Line":0}},{"line":26,"address":[5707544],"length":1,"stats":{"Line":0}},{"line":27,"address":[5707565],"length":1,"stats":{"Line":0}},{"line":28,"address":[6089550],"length":1,"stats":{"Line":0}},{"line":29,"address":[2801872],"length":1,"stats":{"Line":0}},{"line":30,"address":[2801922],"length":1,"stats":{"Line":0}},{"line":34,"address":[3613347],"length":1,"stats":{"Line":0}},{"line":35,"address":[6089757],"length":1,"stats":{"Line":0}},{"line":36,"address":[5824823],"length":1,"stats":{"Line":0}},{"line":37,"address":[2802146],"length":1,"stats":{"Line":0}},{"line":38,"address":[5896763],"length":1,"stats":{"Line":0}},{"line":42,"address":[5708064],"length":1,"stats":{"Line":1}},{"line":43,"address":[5708110],"length":1,"stats":{"Line":1}},{"line":44,"address":[3613705],"length":1,"stats":{"Line":1}},{"line":45,"address":[3613757],"length":1,"stats":{"Line":1}},{"line":49,"address":[5896993],"length":1,"stats":{"Line":1}},{"line":50,"address":[2802478],"length":1,"stats":{"Line":1}},{"line":51,"address":[2802534],"length":1,"stats":{"Line":1}},{"line":52,"address":[5708393],"length":1,"stats":{"Line":1}},{"line":53,"address":[5975651],"length":1,"stats":{"Line":1}},{"line":54,"address":[3614103],"length":1,"stats":{"Line":1}},{"line":58,"address":[5975776],"length":1,"stats":{"Line":5}},{"line":59,"address":[5897390],"length":1,"stats":{"Line":8}},{"line":61,"address":[3614216],"length":1,"stats":{"Line":8}},{"line":62,"address":[5897521],"length":1,"stats":{"Line":3}},{"line":63,"address":[2802990],"length":1,"stats":{"Line":2}},{"line":65,"address":[6090577],"length":1,"stats":{"Line":2}},{"line":69,"address":[5708693],"length":1,"stats":{"Line":6}},{"line":72,"address":[5897620],"length":1,"stats":{"Line":5}},{"line":73,"address":[2803094],"length":1,"stats":{"Line":6}},{"line":78,"address":[3614544,3614781,3614775],"length":1,"stats":{"Line":7}},{"line":79,"address":[3614610],"length":1,"stats":{"Line":5}},{"line":80,"address":[5825990],"length":1,"stats":{"Line":8}},{"line":81,"address":[3614746,3614672],"length":1,"stats":{"Line":13}}],"covered":32,"coverable":43},{"path":["/","home","imalison","Projects","lastfm-edit","src","iterator.rs"],"content":"use crate::r#trait::LastFmEditClient;\nuse crate::{Album, AlbumPage, Result, Track, TrackPage};\n\nuse async_trait::async_trait;\n\n/// Async iterator trait for paginated Last.fm data.\n///\n/// This trait provides a common interface for iterating over paginated data from Last.fm,\n/// such as tracks, albums, and recent scrobbles. All iterators implement efficient streaming\n/// with automatic pagination and built-in rate limiting.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n///\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut tracks = client.artist_tracks(\"Radiohead\");\n///\n/// // Iterate one by one\n/// while let Some(track) = tracks.next().await? {\n///     println!(\"{}\", track.name);\n/// }\n///\n/// // Or collect a limited number\n/// let first_10 = tracks.take(10).await?;\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\n#[cfg_attr(feature = \"mock\", mockall::automock)]\n#[async_trait(?Send)]\npub trait AsyncPaginatedIterator\u003cT\u003e {\n    /// Fetch the next item from the iterator.\n    ///\n    /// This method automatically handles pagination, fetching new pages as needed.\n    /// Returns `None` when there are no more items available.\n    ///\n    /// # Returns\n    ///\n    /// - `Ok(Some(item))` - Next item in the sequence\n    /// - `Ok(None)` - No more items available\n    /// - `Err(...)` - Network or parsing error occurred\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cT\u003e\u003e;\n\n    /// Collect all remaining items into a Vec.\n    ///\n    /// **Warning**: This method will fetch ALL remaining pages, which could be\n    /// many thousands of items for large libraries. Use [`take`](Self::take) for\n    /// safer bounded collection.\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n    /// # tokio_test::block_on(async {\n    /// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n    /// let mut tracks = client.artist_tracks(\"Small Artist\");\n    /// let all_tracks = tracks.collect_all().await?;\n    /// println!(\"Found {} tracks total\", all_tracks.len());\n    /// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n    /// # });\n    /// ```\n    async fn collect_all(\u0026mut self) -\u003e Result\u003cVec\u003cT\u003e\u003e {\n        let mut items = Vec::new();\n        while let Some(item) = self.next().await? {\n            items.push(item);\n        }\n        Ok(items)\n    }\n\n    /// Take up to n items from the iterator.\n    ///\n    /// This is the recommended way to collect a bounded number of items\n    /// from potentially large datasets.\n    ///\n    /// # Arguments\n    ///\n    /// * `n` - Maximum number of items to collect\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n    /// # tokio_test::block_on(async {\n    /// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n    /// let mut tracks = client.artist_tracks(\"Radiohead\");\n    /// let top_20 = tracks.take(20).await?;\n    /// println!(\"Top 20 tracks: {:?}\", top_20);\n    /// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n    /// # });\n    /// ```\n    async fn take(\u0026mut self, n: usize) -\u003e Result\u003cVec\u003cT\u003e\u003e {\n        let mut items = Vec::new();\n        for _ in 0..n {\n            match self.next().await? {\n                Some(item) =\u003e items.push(item),\n                None =\u003e break,\n            }\n        }\n        Ok(items)\n    }\n\n    /// Get the current page number (0-indexed).\n    ///\n    /// Returns the page number of the most recently fetched page.\n    fn current_page(\u0026self) -\u003e u32;\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `Some(n)` if the total page count is known, `None` otherwise.\n    /// This information may not be available until at least one page has been fetched.\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        None // Default implementation returns None\n    }\n}\n\n/// Iterator for browsing an artist's tracks from a user's library.\n///\n/// This iterator provides access to all tracks by a specific artist\n/// in the authenticated user's Last.fm library. Unlike the basic track listing,\n/// this iterator fetches tracks by iterating through the artist's albums first,\n/// which provides complete album information for each track.\n///\n/// The iterator loads albums and their tracks as needed and handles rate limiting\n/// automatically to be respectful to Last.fm's servers.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut tracks = client.artist_tracks(\"The Beatles\");\n///\n/// // Get the top 5 tracks with album information\n/// let top_tracks = tracks.take(5).await?;\n/// for track in top_tracks {\n///     let album = track.album.as_deref().unwrap_or(\"Unknown Album\");\n///     println!(\"{} [{}] (played {} times)\", track.name, album, track.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct ArtistTracksIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    artist: String,\n    album_iterator: Option\u003cArtistAlbumsIterator\u003cC\u003e\u003e,\n    current_album_tracks: Option\u003cAlbumTracksIterator\u003cC\u003e\u003e,\n    track_buffer: Vec\u003cTrack\u003e,\n    finished: bool,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient + Clone\u003e AsyncPaginatedIterator\u003cTrack\u003e for ArtistTracksIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        // If we're finished, return None\n        if self.finished {\n            return Ok(None);\n        }\n\n        // If track buffer is empty, try to get more tracks\n        while self.track_buffer.is_empty() {\n            // If we don't have a current album tracks iterator, get the next album\n            if self.current_album_tracks.is_none() {\n                // Initialize album iterator if needed\n                if self.album_iterator.is_none() {\n                    self.album_iterator = Some(ArtistAlbumsIterator::new(\n                        self.client.clone(),\n                        self.artist.clone(),\n                    ));\n                }\n\n                // Get next album\n                if let Some(ref mut album_iter) = self.album_iterator {\n                    if let Some(album) = album_iter.next().await? {\n                        log::debug!(\n                            \"Processing album '{}' for artist '{}'\",\n                            album.name,\n                            self.artist\n                        );\n                        // Create album tracks iterator for this album\n                        self.current_album_tracks = Some(AlbumTracksIterator::new(\n                            self.client.clone(),\n                            album.name.clone(),\n                            self.artist.clone(),\n                        ));\n                    } else {\n                        // No more albums, we're done\n                        log::debug!(\"No more albums for artist '{}'\", self.artist);\n                        self.finished = true;\n                        return Ok(None);\n                    }\n                }\n            }\n\n            // Get tracks from current album\n            if let Some(ref mut album_tracks) = self.current_album_tracks {\n                if let Some(track) = album_tracks.next().await? {\n                    self.track_buffer.push(track);\n                } else {\n                    // This album is exhausted, move to next album\n                    log::debug!(\n                        \"Finished processing current album for artist '{}'\",\n                        self.artist\n                    );\n                    self.current_album_tracks = None;\n                    // Continue the loop to try getting the next album\n                }\n            }\n        }\n\n        // Return the next track from our buffer\n        Ok(self.track_buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        // Since we're iterating through albums, return the album iterator's current page\n        if let Some(ref album_iter) = self.album_iterator {\n            album_iter.current_page()\n        } else {\n            0\n        }\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        // Since we're iterating through albums, return the album iterator's total pages\n        if let Some(ref album_iter) = self.album_iterator {\n            album_iter.total_pages()\n        } else {\n            None\n        }\n    }\n}\n\nimpl\u003cC: LastFmEditClient + Clone\u003e ArtistTracksIterator\u003cC\u003e {\n    /// Create a new artist tracks iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::artist_tracks`](crate::LastFmEditClient::artist_tracks).\n    pub fn new(client: C, artist: String) -\u003e Self {\n        Self {\n            client,\n            artist,\n            album_iterator: None,\n            current_album_tracks: None,\n            track_buffer: Vec::new(),\n            finished: false,\n        }\n    }\n}\n\n/// Iterator for browsing an artist's tracks directly using the paginated artist tracks endpoint.\n///\n/// This iterator provides access to all tracks by a specific artist\n/// in the authenticated user's Last.fm library by directly using the\n/// `/user/{username}/library/music/{artist}/+tracks` endpoint with pagination.\n/// This is more efficient than the album-based approach as it doesn't need to\n/// iterate through albums first.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut tracks = client.artist_tracks_direct(\"The Beatles\");\n///\n/// // Get the first 10 tracks directly from the paginated endpoint\n/// let first_10_tracks = tracks.take(10).await?;\n/// for track in first_10_tracks {\n///     println!(\"{} (played {} times)\", track.name, track.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct ArtistTracksDirectIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    artist: String,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003cTrack\u003e,\n    total_pages: Option\u003cu32\u003e,\n    tracks_yielded: u32,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cTrack\u003e for ArtistTracksDirectIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if let Some(page) = self.next_page().await? {\n                self.buffer = page.tracks;\n                self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            }\n        }\n\n        if let Some(track) = self.buffer.pop() {\n            self.tracks_yielded += 1;\n            Ok(Some(track))\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e ArtistTracksDirectIterator\u003cC\u003e {\n    /// Create a new direct artist tracks iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::artist_tracks_direct`](crate::LastFmEditClient::artist_tracks_direct).\n    pub fn new(client: C, artist: String) -\u003e Self {\n        Self {\n            client,\n            artist,\n            current_page: 1,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n            tracks_yielded: 0,\n        }\n    }\n\n    /// Fetch the next page of tracks.\n    ///\n    /// This method handles pagination automatically and includes rate limiting.\n    pub async fn next_page(\u0026mut self) -\u003e Result\u003cOption\u003cTrackPage\u003e\u003e {\n        if !self.has_more {\n            return Ok(None);\n        }\n\n        log::debug!(\n            \"Fetching page {} of {} tracks (yielded {} tracks so far)\",\n            self.current_page,\n            self.artist,\n            self.tracks_yielded\n        );\n\n        let page = self\n            .client\n            .get_artist_tracks_page(\u0026self.artist, self.current_page)\n            .await?;\n\n        self.has_more = page.has_next_page;\n        self.current_page += 1;\n        self.total_pages = page.total_pages;\n\n        Ok(Some(page))\n    }\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `None` until at least one page has been fetched.\n    pub fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\n/// Iterator for browsing an artist's albums from a user's library.\n///\n/// This iterator provides paginated access to all albums by a specific artist\n/// in the authenticated user's Last.fm library, ordered by play count.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut albums = client.artist_albums(\"Pink Floyd\");\n///\n/// // Get all albums (be careful with large discographies!)\n/// while let Some(album) = albums.next().await? {\n///     println!(\"{} (played {} times)\", album.name, album.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct ArtistAlbumsIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    artist: String,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003cAlbum\u003e,\n    total_pages: Option\u003cu32\u003e,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cAlbum\u003e for ArtistAlbumsIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cAlbum\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if let Some(page) = self.next_page().await? {\n                self.buffer = page.albums;\n                self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            }\n        }\n\n        Ok(self.buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e ArtistAlbumsIterator\u003cC\u003e {\n    /// Create a new artist albums iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::artist_albums`](crate::LastFmEditClient::artist_albums).\n    pub fn new(client: C, artist: String) -\u003e Self {\n        Self {\n            client,\n            artist,\n            current_page: 1,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Fetch the next page of albums.\n    ///\n    /// This method handles pagination automatically and includes rate limiting.\n    pub async fn next_page(\u0026mut self) -\u003e Result\u003cOption\u003cAlbumPage\u003e\u003e {\n        if !self.has_more {\n            return Ok(None);\n        }\n\n        let page = self\n            .client\n            .get_artist_albums_page(\u0026self.artist, self.current_page)\n            .await?;\n\n        self.has_more = page.has_next_page;\n        self.current_page += 1;\n        self.total_pages = page.total_pages;\n\n        Ok(Some(page))\n    }\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `None` until at least one page has been fetched.\n    pub fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\n/// Iterator for browsing a user's recent tracks/scrobbles.\n///\n/// This iterator provides access to the user's recent listening history with timestamps,\n/// which is essential for finding tracks that can be edited. It supports optional\n/// timestamp-based filtering to avoid reprocessing old data.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// // Get recent tracks with timestamps\n/// let mut recent = client.recent_tracks();\n/// while let Some(track) = recent.next().await? {\n///     if let Some(timestamp) = track.timestamp {\n///         println!(\"{} - {} ({})\", track.artist, track.name, timestamp);\n///     }\n/// }\n///\n/// // Or stop at a specific timestamp to avoid reprocessing\n/// let last_processed = 1640995200;\n/// let mut recent = lastfm_edit::RecentTracksIterator::new(client).with_stop_timestamp(last_processed);\n/// let new_tracks = recent.collect_all().await?;\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct RecentTracksIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003cTrack\u003e,\n    stop_at_timestamp: Option\u003cu64\u003e,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cTrack\u003e for RecentTracksIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if !self.has_more {\n                return Ok(None);\n            }\n\n            let page = self\n                .client\n                .get_recent_tracks_page(self.current_page)\n                .await?;\n\n            if page.tracks.is_empty() {\n                self.has_more = false;\n                return Ok(None);\n            }\n\n            self.has_more = page.has_next_page;\n\n            // Check if we should stop based on timestamp\n            if let Some(stop_timestamp) = self.stop_at_timestamp {\n                let mut filtered_tracks = Vec::new();\n                for track in page.tracks {\n                    if let Some(track_timestamp) = track.timestamp {\n                        if track_timestamp \u003c= stop_timestamp {\n                            self.has_more = false;\n                            break;\n                        }\n                    }\n                    filtered_tracks.push(track);\n                }\n                self.buffer = filtered_tracks;\n            } else {\n                self.buffer = page.tracks;\n            }\n\n            self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            self.current_page += 1;\n        }\n\n        Ok(self.buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e RecentTracksIterator\u003cC\u003e {\n    /// Create a new recent tracks iterator starting from page 1.\n    ///\n    /// This is typically called via [`LastFmEditClient::recent_tracks`](crate::LastFmEditClient::recent_tracks).\n    pub fn new(client: C) -\u003e Self {\n        Self::with_starting_page(client, 1)\n    }\n\n    /// Create a new recent tracks iterator starting from a specific page.\n    ///\n    /// This allows resuming pagination from an arbitrary page, useful for\n    /// continuing from where a previous iteration left off.\n    ///\n    /// # Arguments\n    ///\n    /// * `client` - The LastFmEditClient to use for API calls\n    /// * `starting_page` - The page number to start from (1-indexed)\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n    /// # tokio_test::block_on(async {\n    /// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n    ///\n    /// // Start from page 5\n    /// let mut recent = client.recent_tracks_from_page(5);\n    /// let tracks = recent.take(10).await?;\n    /// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n    /// # });\n    /// ```\n    pub fn with_starting_page(client: C, starting_page: u32) -\u003e Self {\n        let page = std::cmp::max(1, starting_page);\n        Self {\n            client,\n            current_page: page,\n            has_more: true,\n            buffer: Vec::new(),\n            stop_at_timestamp: None,\n        }\n    }\n\n    /// Set a timestamp to stop iteration at.\n    ///\n    /// When this is set, the iterator will stop returning tracks once it encounters\n    /// a track with a timestamp less than or equal to the specified value. This is\n    /// useful for incremental processing to avoid reprocessing old data.\n    ///\n    /// # Arguments\n    ///\n    /// * `timestamp` - Unix timestamp to stop at\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n    /// # tokio_test::block_on(async {\n    /// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n    /// let last_processed = 1640995200; // Some previous timestamp\n    ///\n    /// let mut recent = lastfm_edit::RecentTracksIterator::new(client).with_stop_timestamp(last_processed);\n    /// let new_tracks = recent.collect_all().await?; // Only gets new tracks\n    /// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n    /// # });\n    /// ```\n    pub fn with_stop_timestamp(mut self, timestamp: u64) -\u003e Self {\n        self.stop_at_timestamp = Some(timestamp);\n        self\n    }\n}\n\n/// Iterator for browsing tracks in a specific album from a user's library.\n///\n/// This iterator provides access to all tracks in a specific album by an artist\n/// in the authenticated user's Last.fm library. Unlike paginated iterators,\n/// this loads tracks once and iterates through them.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut tracks = client.album_tracks(\"The Dark Side of the Moon\", \"Pink Floyd\");\n///\n/// // Get all tracks in the album\n/// while let Some(track) = tracks.next().await? {\n///     println!(\"{} - {}\", track.name, track.artist);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct AlbumTracksIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    album_name: String,\n    artist_name: String,\n    tracks: Option\u003cVec\u003cTrack\u003e\u003e,\n    index: usize,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cTrack\u003e for AlbumTracksIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        // Load tracks if not already loaded\n        if self.tracks.is_none() {\n            // Use get_album_tracks_page instead of get_album_tracks to avoid infinite recursion\n            let tracks_page = self\n                .client\n                .get_album_tracks_page(\u0026self.album_name, \u0026self.artist_name, 1)\n                .await?;\n            log::debug!(\n                \"Album '{}' by '{}' has {} tracks: {:?}\",\n                self.album_name,\n                self.artist_name,\n                tracks_page.tracks.len(),\n                tracks_page\n                    .tracks\n                    .iter()\n                    .map(|t| \u0026t.name)\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n            );\n\n            if tracks_page.tracks.is_empty() {\n                log::warn!(\n                    \"🚨 ZERO TRACKS FOUND for album '{}' by '{}' - investigating...\",\n                    self.album_name,\n                    self.artist_name\n                );\n                log::debug!(\"Full TrackPage for empty album: has_next_page={}, page_number={}, total_pages={:?}\", \n                           tracks_page.has_next_page, tracks_page.page_number, tracks_page.total_pages);\n            }\n            self.tracks = Some(tracks_page.tracks);\n        }\n\n        // Return next track\n        if let Some(tracks) = \u0026self.tracks {\n            if self.index \u003c tracks.len() {\n                let track = tracks[self.index].clone();\n                self.index += 1;\n                Ok(Some(track))\n            } else {\n                Ok(None)\n            }\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        // Album tracks don't have pages, so return 0\n        0\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e AlbumTracksIterator\u003cC\u003e {\n    /// Create a new album tracks iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::album_tracks`](crate::LastFmEditClient::album_tracks).\n    pub fn new(client: C, album_name: String, artist_name: String) -\u003e Self {\n        Self {\n            client,\n            album_name,\n            artist_name,\n            tracks: None,\n            index: 0,\n        }\n    }\n}\n\n/// Iterator for searching tracks in the user's library.\n///\n/// This iterator provides paginated access to tracks that match a search query\n/// in the authenticated user's Last.fm library, using Last.fm's built-in search functionality.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut search_results = client.search_tracks(\"remaster\");\n///\n/// // Get first 20 search results\n/// while let Some(track) = search_results.next().await? {\n///     println!(\"{} - {} (played {} times)\", track.artist, track.name, track.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct SearchTracksIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    query: String,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003cTrack\u003e,\n    total_pages: Option\u003cu32\u003e,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cTrack\u003e for SearchTracksIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cTrack\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if let Some(page) = self.next_page().await? {\n                self.buffer = page.tracks;\n                self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            }\n        }\n\n        Ok(self.buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e SearchTracksIterator\u003cC\u003e {\n    /// Create a new search tracks iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::search_tracks`](crate::LastFmEditClient::search_tracks).\n    pub fn new(client: C, query: String) -\u003e Self {\n        Self {\n            client,\n            query,\n            current_page: 1,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Create a new search tracks iterator starting from a specific page.\n    ///\n    /// This is useful for implementing offset functionality efficiently by starting\n    /// at the appropriate page rather than iterating through all previous pages.\n    pub fn with_starting_page(client: C, query: String, starting_page: u32) -\u003e Self {\n        let page = std::cmp::max(1, starting_page);\n        Self {\n            client,\n            query,\n            current_page: page,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Fetch the next page of search results.\n    ///\n    /// This method handles pagination automatically and includes rate limiting\n    /// to be respectful to Last.fm's servers.\n    pub async fn next_page(\u0026mut self) -\u003e Result\u003cOption\u003cTrackPage\u003e\u003e {\n        if !self.has_more {\n            return Ok(None);\n        }\n\n        let page = self\n            .client\n            .search_tracks_page(\u0026self.query, self.current_page)\n            .await?;\n\n        self.has_more = page.has_next_page;\n        self.current_page += 1;\n        self.total_pages = page.total_pages;\n\n        Ok(Some(page))\n    }\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `None` until at least one page has been fetched.\n    pub fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\n/// Iterator for searching albums in the user's library.\n///\n/// This iterator provides paginated access to albums that match a search query\n/// in the authenticated user's Last.fm library, using Last.fm's built-in search functionality.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut search_results = client.search_albums(\"deluxe\");\n///\n/// // Get first 10 search results\n/// let top_10 = search_results.take(10).await?;\n/// for album in top_10 {\n///     println!(\"{} - {} (played {} times)\", album.artist, album.name, album.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct SearchAlbumsIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    query: String,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003cAlbum\u003e,\n    total_pages: Option\u003cu32\u003e,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003cAlbum\u003e for SearchAlbumsIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003cAlbum\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if let Some(page) = self.next_page().await? {\n                self.buffer = page.albums;\n                self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            }\n        }\n\n        Ok(self.buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e SearchAlbumsIterator\u003cC\u003e {\n    /// Create a new search albums iterator.\n    ///\n    /// This is typically called via [`LastFmEditClient::search_albums`](crate::LastFmEditClient::search_albums).\n    pub fn new(client: C, query: String) -\u003e Self {\n        Self {\n            client,\n            query,\n            current_page: 1,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Create a new search albums iterator starting from a specific page.\n    ///\n    /// This is useful for implementing offset functionality efficiently by starting\n    /// at the appropriate page rather than iterating through all previous pages.\n    pub fn with_starting_page(client: C, query: String, starting_page: u32) -\u003e Self {\n        let page = std::cmp::max(1, starting_page);\n        Self {\n            client,\n            query,\n            current_page: page,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Fetch the next page of search results.\n    ///\n    /// This method handles pagination automatically and includes rate limiting\n    /// to be respectful to Last.fm's servers.\n    pub async fn next_page(\u0026mut self) -\u003e Result\u003cOption\u003cAlbumPage\u003e\u003e {\n        if !self.has_more {\n            return Ok(None);\n        }\n\n        let page = self\n            .client\n            .search_albums_page(\u0026self.query, self.current_page)\n            .await?;\n\n        self.has_more = page.has_next_page;\n        self.current_page += 1;\n        self.total_pages = page.total_pages;\n\n        Ok(Some(page))\n    }\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `None` until at least one page has been fetched.\n    pub fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\n// =============================================================================\n// ARTISTS ITERATOR\n// =============================================================================\n\n/// Iterator for browsing all artists in the user's library.\n///\n/// This iterator provides access to all artists in the authenticated user's Last.fm library,\n/// sorted by play count (highest first). The iterator loads artists as needed and handles\n/// rate limiting automatically to be respectful to Last.fm's servers.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// # use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession, AsyncPaginatedIterator};\n/// # tokio_test::block_on(async {\n/// # let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n/// let mut client = LastFmEditClientImpl::from_session(Box::new(http_client::native::NativeClient::new()), test_session);\n///\n/// let mut artists = client.artists();\n///\n/// // Get the top 10 artists\n/// let top_artists = artists.take(10).await?;\n/// for artist in top_artists {\n///     println!(\"{} ({} plays)\", artist.name, artist.playcount);\n/// }\n/// # Ok::\u003c(), Box\u003cdyn std::error::Error\u003e\u003e(())\n/// # });\n/// ```\npub struct ArtistsIterator\u003cC: LastFmEditClient\u003e {\n    client: C,\n    current_page: u32,\n    has_more: bool,\n    buffer: Vec\u003ccrate::Artist\u003e,\n    total_pages: Option\u003cu32\u003e,\n}\n\n#[async_trait(?Send)]\nimpl\u003cC: LastFmEditClient\u003e AsyncPaginatedIterator\u003ccrate::Artist\u003e for ArtistsIterator\u003cC\u003e {\n    async fn next(\u0026mut self) -\u003e Result\u003cOption\u003ccrate::Artist\u003e\u003e {\n        // If buffer is empty, try to load next page\n        if self.buffer.is_empty() {\n            if let Some(page) = self.next_page().await? {\n                self.buffer = page.artists;\n                self.buffer.reverse(); // Reverse so we can pop from end efficiently\n            }\n        }\n\n        Ok(self.buffer.pop())\n    }\n\n    fn current_page(\u0026self) -\u003e u32 {\n        self.current_page.saturating_sub(1)\n    }\n\n    fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n\nimpl\u003cC: LastFmEditClient\u003e ArtistsIterator\u003cC\u003e {\n    /// Create a new artists iterator.\n    ///\n    /// This iterator will start from page 1 and load all artists in the user's library.\n    pub fn new(client: C) -\u003e Self {\n        Self {\n            client,\n            current_page: 1,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Create a new artists iterator starting from a specific page.\n    ///\n    /// This is useful for implementing offset functionality efficiently by starting\n    /// at the appropriate page rather than iterating through all previous pages.\n    pub fn with_starting_page(client: C, starting_page: u32) -\u003e Self {\n        let page = std::cmp::max(1, starting_page);\n        Self {\n            client,\n            current_page: page,\n            has_more: true,\n            buffer: Vec::new(),\n            total_pages: None,\n        }\n    }\n\n    /// Fetch the next page of artists.\n    ///\n    /// This method handles pagination automatically and includes rate limiting\n    /// to be respectful to Last.fm's servers.\n    pub async fn next_page(\u0026mut self) -\u003e Result\u003cOption\u003ccrate::ArtistPage\u003e\u003e {\n        if !self.has_more {\n            return Ok(None);\n        }\n\n        let page = self.client.get_artists_page(self.current_page).await?;\n\n        self.has_more = page.has_next_page;\n        self.current_page += 1;\n        self.total_pages = page.total_pages;\n\n        Ok(Some(page))\n    }\n\n    /// Get the total number of pages, if known.\n    ///\n    /// Returns `None` until at least one page has been fetched.\n    pub fn total_pages(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.total_pages\n    }\n}\n","traces":[{"line":67,"address":[6171501,6175471,6171434,6174064,6178829,6174099,6178718,6174541,6178476,6170889,6172668,6174474,6180349,6177198,6181758,6175523,6175848,6181427,6175488,6175959,6178339,6179996,6176823,6178762,6181869,6170937,6179872,6176832,6175892,6174188,6180238,6170841,6174051,6176867,6176956,6172544,6179907,6179859,6171390,6171059,6170745,6170649,6180282,6172910,6174430,6182799,6172579,6177309,6171024,6178387,6181379,6173021,6181802,6170697,6172954,6181392,6175612,6172531,6181516,6170793,6171148,6170985,6177242,6178352],"length":1,"stats":{"Line":0}},{"line":68,"address":[5626790,5629830,5622502,5623920,5628310,5620982,5619462,5625270],"length":1,"stats":{"Line":0}},{"line":69,"address":[5758404,5758788,5758020,5757172,5756548,5758212,5758596,5759188],"length":1,"stats":{"Line":0}},{"line":70,"address":[5626098,5629138,5624530,5627618,5627564,5624584,5620236,5621756,5620290,5621810,5629084,5623176,5626044,5630504,5630558,5623230],"length":1,"stats":{"Line":0}},{"line":72,"address":[5434514,5438802,5432994,5443262,5437286,5435934,5441842,5440322],"length":1,"stats":{"Line":0}},{"line":97,"address":[5448819,5443870,5452406,5444362,5443678,5444019,5447219,5452362,5445574,5452586,5448774,5443806,5445584,5449162,5450806,5456418,5451984,5450762,5449386,5445708,5450374,5453846,5450986,5443550,5451974,5453459,5443614,5444586,5447606,5455306,5448784,5454914,5447184,5445619,5448908,5450384,5455052,5447308,5453410,5447786,5454928,5447174,5446186,5450419,5453802,5443486,5443934,5444108,5443984,5447562,5444406,5452019,5455350,5449206,5443742,5446006,5453548,5454026,5452108,5455530,5450508,5453424,5445962,5454963],"length":1,"stats":{"Line":19}},{"line":98,"address":[3687928,3691128,3694168,3689528,3695672,3684728,3692728,3686328],"length":1,"stats":{"Line":5}},{"line":99,"address":[3107042,3107029,3108594,3104804,3107908,3111513,3112468,3108581,3106953,3111589,3109460,3114521,3114610,3110057,3114597,3105477,3113141,3115312,3106356,3113065,3103938,3113154,3105490,3103925,3110133,3108505,3103849,3110912,3110146,3111602,3113920,3105401],"length":1,"stats":{"Line":19}},{"line":100,"address":[3351364,3350756,3349732,3350468,3348580,3350084,3351060,3353012],"length":1,"stats":{"Line":7}},{"line":101,"address":[],"length":0,"stats":{"Line":6}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[5456116,5451672,5454612,5448472,5453108,5445272,5446872,5450072],"length":1,"stats":{"Line":3}},{"line":117,"address":[5643792,5643824],"length":1,"stats":{"Line":0}},{"line":118,"address":[6195813,6195781],"length":1,"stats":{"Line":0}},{"line":162,"address":[5643865,5648357,5643904,5643963,5644472,5644345,5644298,5644107],"length":1,"stats":{"Line":4}},{"line":164,"address":[3697296],"length":1,"stats":{"Line":1}},{"line":165,"address":[5931421],"length":1,"stats":{"Line":0}},{"line":169,"address":[6196373,6197939],"length":1,"stats":{"Line":2}},{"line":171,"address":[5816046,5815951],"length":1,"stats":{"Line":2}},{"line":173,"address":[],"length":0,"stats":{"Line":2}},{"line":174,"address":[3118061,3117986,3118089],"length":1,"stats":{"Line":2}},{"line":175,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[5816280],"length":1,"stats":{"Line":1}},{"line":181,"address":[5648330,5646618,5646201],"length":1,"stats":{"Line":3}},{"line":182,"address":[5469713],"length":1,"stats":{"Line":3}},{"line":183,"address":[5934448,5934313,5934484],"length":1,"stats":{"Line":3}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[3700934,3701037,3701069],"length":1,"stats":{"Line":2}},{"line":190,"address":[5817414,5817796],"length":1,"stats":{"Line":2}},{"line":191,"address":[6199836,6199909],"length":1,"stats":{"Line":2}},{"line":192,"address":[3700861],"length":1,"stats":{"Line":1}},{"line":196,"address":[5818532,5818341,5817315],"length":1,"stats":{"Line":3}},{"line":197,"address":[5461039],"length":1,"stats":{"Line":1}},{"line":198,"address":[5935410],"length":1,"stats":{"Line":1}},{"line":204,"address":[6198084,6200892,6197908],"length":1,"stats":{"Line":3}},{"line":205,"address":[5644563,5645901,5644532,5644903,5648935,5644158],"length":1,"stats":{"Line":5}},{"line":206,"address":[5458042,5457895],"length":1,"stats":{"Line":2}},{"line":209,"address":[],"length":0,"stats":{"Line":3}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":1}},{"line":220,"address":[5815913,5815985],"length":1,"stats":{"Line":2}},{"line":223,"address":[5461728],"length":1,"stats":{"Line":0}},{"line":225,"address":[6201086],"length":1,"stats":{"Line":0}},{"line":226,"address":[5649155],"length":1,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[5936176],"length":1,"stats":{"Line":0}},{"line":234,"address":[5819150],"length":1,"stats":{"Line":0}},{"line":235,"address":[3120755],"length":1,"stats":{"Line":0}},{"line":237,"address":[5461907],"length":1,"stats":{"Line":0}},{"line":246,"address":[6161478,6161072,6161538],"length":1,"stats":{"Line":2}},{"line":252,"address":[5896228],"length":1,"stats":{"Line":2}},{"line":296,"address":[3702605,3704072,3702561,3702272,3702838,3702233,3702307,3702409],"length":1,"stats":{"Line":4}},{"line":298,"address":[3703672,3702617],"length":1,"stats":{"Line":2}},{"line":299,"address":[5462148,5462471,5462408,5462576],"length":1,"stats":{"Line":2}},{"line":300,"address":[5820390,5820495],"length":1,"stats":{"Line":1}},{"line":301,"address":[5937655],"length":1,"stats":{"Line":1}},{"line":305,"address":[5819682,5821000,5820755,5820898],"length":1,"stats":{"Line":4}},{"line":306,"address":[5463513,5463690,5463595],"length":1,"stats":{"Line":2}},{"line":307,"address":[6202954],"length":1,"stats":{"Line":1}},{"line":309,"address":[3703836],"length":1,"stats":{"Line":1}},{"line":313,"address":[5821248],"length":1,"stats":{"Line":0}},{"line":314,"address":[3122725],"length":1,"stats":{"Line":0}},{"line":317,"address":[3122752],"length":1,"stats":{"Line":0}},{"line":318,"address":[5463973],"length":1,"stats":{"Line":0}},{"line":326,"address":[5609945,5609967,5609568],"length":1,"stats":{"Line":1}},{"line":332,"address":[5609690],"length":1,"stats":{"Line":1}},{"line":341,"address":[5423584,5422640,5422624,5424300,5422632,5422786,5422965,5422681],"length":1,"stats":{"Line":4}},{"line":342,"address":[3082923],"length":1,"stats":{"Line":1}},{"line":343,"address":[3082986],"length":1,"stats":{"Line":1}},{"line":346,"address":[3663304,3663160,3663351],"length":1,"stats":{"Line":3}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[3663828,3663310,3664228,3664061,3664132,3664594,3663766],"length":1,"stats":{"Line":5}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[3083199,3083620],"length":1,"stats":{"Line":2}},{"line":356,"address":[5897861,5897908,5898260,5897165,5897962,5898173],"length":1,"stats":{"Line":3}},{"line":358,"address":[5424029],"length":1,"stats":{"Line":1}},{"line":359,"address":[6163401,6163580],"length":1,"stats":{"Line":1}},{"line":360,"address":[5424115],"length":1,"stats":{"Line":1}},{"line":362,"address":[5898505],"length":1,"stats":{"Line":1}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[5821489,5822846,5821321,5821360,5821685,5821641,5821918,5821395],"length":1,"stats":{"Line":4}},{"line":408,"address":[5821697,5822752],"length":1,"stats":{"Line":2}},{"line":409,"address":[5469380],"length":1,"stats":{"Line":2}},{"line":410,"address":[5822551,5822446],"length":1,"stats":{"Line":1}},{"line":411,"address":[5939711],"length":1,"stats":{"Line":1}},{"line":415,"address":[3705752,3704714],"length":1,"stats":{"Line":2}},{"line":418,"address":[3705840],"length":1,"stats":{"Line":0}},{"line":419,"address":[3705845],"length":1,"stats":{"Line":0}},{"line":422,"address":[5939936],"length":1,"stats":{"Line":0}},{"line":423,"address":[5822901],"length":1,"stats":{"Line":0}},{"line":431,"address":[5424320,5424709,5424687],"length":1,"stats":{"Line":2}},{"line":437,"address":[5898794],"length":1,"stats":{"Line":2}},{"line":445,"address":[5425900,5425034,5424752,5424874,5425208,5424787,5424736,5424744],"length":1,"stats":{"Line":4}},{"line":446,"address":[5612214],"length":1,"stats":{"Line":1}},{"line":447,"address":[5612274],"length":1,"stats":{"Line":1}},{"line":450,"address":[6164452,6165250,6164896,6164514,6164732,6164298,6164800],"length":1,"stats":{"Line":5}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":2}},{"line":453,"address":[5461556],"length":1,"stats":{"Line":3}},{"line":455,"address":[6164985],"length":1,"stats":{"Line":1}},{"line":456,"address":[5900018,5900188],"length":1,"stats":{"Line":1}},{"line":457,"address":[],"length":0,"stats":{"Line":1}},{"line":459,"address":[5900105],"length":1,"stats":{"Line":1}},{"line":465,"address":[5783232],"length":1,"stats":{"Line":0}},{"line":466,"address":[3666213],"length":1,"stats":{"Line":0}},{"line":509,"address":[3706095,3705952,3708367,3706606,3705913,3705987,3706253,3706297],"length":1,"stats":{"Line":4}},{"line":511,"address":[3706309,3708612],"length":1,"stats":{"Line":2}},{"line":512,"address":[3706388],"length":1,"stats":{"Line":1}},{"line":513,"address":[5466118],"length":1,"stats":{"Line":0}},{"line":516,"address":[5655801,5653640,5653521,5653852,5653543,5653920,5654016],"length":1,"stats":{"Line":5}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[5940529],"length":1,"stats":{"Line":1}},{"line":519,"address":[],"length":0,"stats":{"Line":3}},{"line":521,"address":[3125537,3125481],"length":1,"stats":{"Line":2}},{"line":522,"address":[5824235],"length":1,"stats":{"Line":0}},{"line":523,"address":[3125611],"length":1,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":1}},{"line":529,"address":[5467101,5466896,5468242],"length":1,"stats":{"Line":2}},{"line":530,"address":[6206471],"length":1,"stats":{"Line":0}},{"line":531,"address":[6206595,6206708,6206843],"length":1,"stats":{"Line":0}},{"line":532,"address":[5654956,5654913],"length":1,"stats":{"Line":0}},{"line":533,"address":[5654972],"length":1,"stats":{"Line":0}},{"line":534,"address":[5942138],"length":1,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[6207235,6207168],"length":1,"stats":{"Line":0}},{"line":542,"address":[5468107,5467146],"length":1,"stats":{"Line":1}},{"line":545,"address":[5468034,5468257],"length":1,"stats":{"Line":2}},{"line":546,"address":[6207673,6207612],"length":1,"stats":{"Line":1}},{"line":549,"address":[5823374,5825661],"length":1,"stats":{"Line":2}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[5825765],"length":1,"stats":{"Line":0}},{"line":561,"address":[3086032],"length":1,"stats":{"Line":2}},{"line":562,"address":[3086040],"length":1,"stats":{"Line":2}},{"line":589,"address":[5613344,5613764],"length":1,"stats":{"Line":2}},{"line":590,"address":[5783336,5783422],"length":1,"stats":{"Line":4}},{"line":595,"address":[3666493],"length":1,"stats":{"Line":2}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":4}},{"line":665,"address":[3127539,3130269],"length":1,"stats":{"Line":3}},{"line":667,"address":[5469567,5469638,5469043,5469239,5469734,5469331],"length":1,"stats":{"Line":9}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[6208407,6208501],"length":1,"stats":{"Line":2}},{"line":670,"address":[5826927,5826600,5827014,5826029,5826659,5826716],"length":1,"stats":{"Line":6}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[5827286,5827984],"length":1,"stats":{"Line":6}},{"line":684,"address":[5470880,5470783],"length":1,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[6210179,6210556],"length":1,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[5470678,5471576],"length":1,"stats":{"Line":3}},{"line":696,"address":[5471738,5468969,5471824],"length":1,"stats":{"Line":3}},{"line":697,"address":[5829148,5829429,5829058,5829191],"length":1,"stats":{"Line":4}},{"line":698,"address":[],"length":0,"stats":{"Line":2}},{"line":699,"address":[5829294,5829434],"length":1,"stats":{"Line":2}},{"line":700,"address":[3130575],"length":1,"stats":{"Line":1}},{"line":702,"address":[5829153],"length":1,"stats":{"Line":1}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[3666736],"length":1,"stats":{"Line":1}},{"line":763,"address":[5660021,5659977,5661182,5659696,5659825,5659657,5659731,5660254],"length":1,"stats":{"Line":4}},{"line":765,"address":[5829985,5831040],"length":1,"stats":{"Line":2}},{"line":766,"address":[3713040,3712780,3713103,3713208],"length":1,"stats":{"Line":2}},{"line":767,"address":[5947879,5947774],"length":1,"stats":{"Line":1}},{"line":768,"address":[3713935],"length":1,"stats":{"Line":1}},{"line":772,"address":[5661112,5660074],"length":1,"stats":{"Line":2}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[6213189],"length":1,"stats":{"Line":0}},{"line":779,"address":[5948224],"length":1,"stats":{"Line":0}},{"line":780,"address":[5473877],"length":1,"stats":{"Line":0}},{"line":788,"address":[],"length":0,"stats":{"Line":1}},{"line":794,"address":[],"length":0,"stats":{"Line":1}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[3539564,3539670],"length":1,"stats":{"Line":0}},{"line":810,"address":[3539796],"length":1,"stats":{"Line":0}},{"line":819,"address":[5901459,5901880,5901416,5902572,5901706,5901408,5901546,5901424],"length":1,"stats":{"Line":4}},{"line":820,"address":[3667462],"length":1,"stats":{"Line":1}},{"line":821,"address":[5901586],"length":1,"stats":{"Line":1}},{"line":824,"address":[5785538,5785088,5784740,5785020,5784586,5784802,5785184],"length":1,"stats":{"Line":5}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[5427413,5427288],"length":1,"stats":{"Line":2}},{"line":827,"address":[5629764],"length":1,"stats":{"Line":3}},{"line":829,"address":[3668249],"length":1,"stats":{"Line":1}},{"line":830,"address":[6167330,6167500],"length":1,"stats":{"Line":1}},{"line":831,"address":[5902390],"length":1,"stats":{"Line":1}},{"line":833,"address":[],"length":0,"stats":{"Line":1}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[5661273,5661441,5661593,5661347,5661312,5662798,5661637,5661870],"length":1,"stats":{"Line":4}},{"line":880,"address":[5948641,5949696],"length":1,"stats":{"Line":2}},{"line":881,"address":[5948460,5948783,5948720,5948888],"length":1,"stats":{"Line":2}},{"line":882,"address":[5949390,5949495],"length":1,"stats":{"Line":1}},{"line":883,"address":[5662623],"length":1,"stats":{"Line":1}},{"line":887,"address":[3132786,3133772],"length":1,"stats":{"Line":2}},{"line":890,"address":[3715744],"length":1,"stats":{"Line":0}},{"line":891,"address":[5832773],"length":1,"stats":{"Line":0}},{"line":894,"address":[6214832],"length":1,"stats":{"Line":0}},{"line":895,"address":[3715781],"length":1,"stats":{"Line":0}},{"line":903,"address":[3668528,3668895,3668917],"length":1,"stats":{"Line":2}},{"line":909,"address":[],"length":0,"stats":{"Line":2}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":934,"address":[5903008,5904172,5903024,5903059,5903480,5903146,5903016,5903306],"length":1,"stats":{"Line":4}},{"line":935,"address":[],"length":0,"stats":{"Line":1}},{"line":936,"address":[],"length":0,"stats":{"Line":1}},{"line":939,"address":[5903660,5903728,5903226,5903380,5903824,5904178,5903442],"length":1,"stats":{"Line":5}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":941,"address":[3089013,3088888],"length":1,"stats":{"Line":2}},{"line":942,"address":[5294980],"length":1,"stats":{"Line":3}},{"line":944,"address":[6168905],"length":1,"stats":{"Line":1}},{"line":945,"address":[5617116,5616946],"length":1,"stats":{"Line":1}},{"line":946,"address":[],"length":0,"stats":{"Line":1}},{"line":948,"address":[6169017],"length":1,"stats":{"Line":1}},{"line":954,"address":[],"length":0,"stats":{"Line":0}},{"line":955,"address":[],"length":0,"stats":{"Line":0}},{"line":997,"address":[3716402,3715985,3716175,3716131,3715856,3717322,3715817,3715891],"length":1,"stats":{"Line":5}},{"line":999,"address":[6216284,6215243],"length":1,"stats":{"Line":2}},{"line":1000,"address":[5301108],"length":1,"stats":{"Line":2}},{"line":1001,"address":[5476744,5476642],"length":1,"stats":{"Line":1}},{"line":1002,"address":[5834176],"length":1,"stats":{"Line":1}},{"line":1006,"address":[],"length":0,"stats":{"Line":2}},{"line":1009,"address":[5834352],"length":1,"stats":{"Line":0}},{"line":1010,"address":[5664405],"length":1,"stats":{"Line":0}},{"line":1013,"address":[6216416],"length":1,"stats":{"Line":0}},{"line":1014,"address":[5477077],"length":1,"stats":{"Line":0}},{"line":1022,"address":[5430136,5429840],"length":1,"stats":{"Line":1}},{"line":1027,"address":[3670227],"length":1,"stats":{"Line":1}},{"line":1036,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":0}},{"line":1042,"address":[],"length":0,"stats":{"Line":0}},{"line":1051,"address":[5904811,5904520,5904563,5904512,5904650,5904528,5904934,5905626],"length":1,"stats":{"Line":4}},{"line":1052,"address":[5430278],"length":1,"stats":{"Line":1}},{"line":1053,"address":[3090306],"length":1,"stats":{"Line":0}},{"line":1056,"address":[6011236],"length":1,"stats":{"Line":2}},{"line":1058,"address":[],"length":0,"stats":{"Line":1}},{"line":1059,"address":[5431210,5431040],"length":1,"stats":{"Line":1}},{"line":1060,"address":[],"length":0,"stats":{"Line":1}},{"line":1062,"address":[3671415],"length":1,"stats":{"Line":1}},{"line":1068,"address":[],"length":0,"stats":{"Line":0}},{"line":1069,"address":[],"length":0,"stats":{"Line":0}}],"covered":155,"coverable":262},{"path":["/","home","imalison","Projects","lastfm-edit","src","lib.rs"],"content":"//! # lastfm-edit\n//!\n//! A Rust crate for programmatic access to Last.fm's scrobble editing functionality via web scraping.\n//!\n//! This crate provides a high-level interface for authenticating with Last.fm, browsing user libraries,\n//! and performing bulk edits on scrobbled tracks. It uses web scraping to access functionality not\n//! available through Last.fm's public API.\n//!\n//! ## Features\n//!\n//! - **Authentication**: Login to Last.fm with username/password\n//! - **Library browsing**: Paginated access to tracks, albums, and recent scrobbles\n//! - **Bulk editing**: Edit track names, artist names, and album information\n//! - **Async iterators**: Stream large datasets efficiently\n//! - **HTTP client abstraction**: Works with any HTTP client implementation\n//!\n//! ## Quick Start\n//!\n//! ```rust,no_run\n//! use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, AsyncPaginatedIterator, Result};\n//!\n//! #[tokio::main]\n//! async fn main() -\u003e Result\u003c()\u003e {\n//!     // Create HTTP client and login\n//!     let http_client = http_client::native::NativeClient::new();\n//!     let client = LastFmEditClientImpl::login_with_credentials(\n//!         Box::new(http_client),\n//!         \"username\",\n//!         \"password\"\n//!     ).await?;\n//!\n//!     // Browse recent tracks\n//!     let mut recent_tracks = client.recent_tracks();\n//!     while let Some(track) = recent_tracks.next().await? {\n//!         println!(\"{} - {}\", track.artist, track.name);\n//!     }\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ## Core Components\n//!\n//! - [`LastFmEditClient`] - Main client trait for interacting with Last.fm\n//! - [`Track`], [`Album`] - Data structures for music metadata\n//! - [`AsyncPaginatedIterator`] - Trait for streaming paginated data\n//! - [`ScrobbleEdit`] - Represents track edit operations\n//! - [`LastFmError`] - Error types for the crate\n//!\n//! ## Installation\n//!\n//! Add this to your `Cargo.toml`:\n//! ```toml\n//! [dependencies]\n//! lastfm-edit = \"3.1.0\"\n//! http-client = { version = \"^6.6.3\", package = \"http-client-2\", features = [\"curl_client\"] }\n//! tokio = { version = \"1.0\", features = [\"full\"] }\n//! ```\n//!\n//! ## Usage Patterns\n//!\n//! ### Basic Library Browsing\n//!\n//! ```rust,no_run\n//! use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, AsyncPaginatedIterator, Result};\n//!\n//! #[tokio::main]\n//! async fn main() -\u003e Result\u003c()\u003e {\n//!     let http_client = http_client::native::NativeClient::new();\n//!     let client = LastFmEditClientImpl::login_with_credentials(\n//!         Box::new(http_client),\n//!         \"username\",\n//!         \"password\"\n//!     ).await?;\n//!\n//!     // Get all tracks by an artist\n//!     let mut tracks = client.artist_tracks(\"Radiohead\");\n//!     while let Some(track) = tracks.next().await? {\n//!         println!(\"{} - {}\", track.artist, track.name);\n//!     }\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ### Bulk Track Editing\n//!\n//! ```rust,no_run\n//! use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, ScrobbleEdit, AsyncPaginatedIterator, Result};\n//!\n//! #[tokio::main]\n//! async fn main() -\u003e Result\u003c()\u003e {\n//!     let http_client = http_client::native::NativeClient::new();\n//!     let client = LastFmEditClientImpl::login_with_credentials(\n//!         Box::new(http_client),\n//!         \"username\",\n//!         \"password\"\n//!     ).await?;\n//!\n//!     // Find and edit tracks\n//!     let tracks = client.artist_tracks(\"Artist Name\").collect_all().await?;\n//!     for track in tracks {\n//!         if track.name.contains(\"(Remaster)\") {\n//!             let new_name = track.name.replace(\" (Remaster)\", \"\");\n//!\n//!             // Create edit for this track\n//!             let edit = ScrobbleEdit::from_track_info(\n//!                 \u0026track.name,\n//!                 \u0026track.name, // Use track name as album fallback\n//!                 \u0026track.artist,\n//!                 0 // No timestamp needed for bulk edit\n//!             )\n//!             .with_track_name(\u0026new_name)\n//!             .with_edit_all(true);\n//!\n//!             let response = client.edit_scrobble(\u0026edit).await?;\n//!             if response.success() {\n//!                 println!(\"Successfully edited: {} -\u003e {}\", track.name, new_name);\n//!             }\n//!         }\n//!     }\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ### Recent Tracks Monitoring\n//!\n//! ```rust,no_run\n//! use lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, AsyncPaginatedIterator, Result};\n//!\n//! #[tokio::main]\n//! async fn main() -\u003e Result\u003c()\u003e {\n//!     let http_client = http_client::native::NativeClient::new();\n//!     let client = LastFmEditClientImpl::login_with_credentials(\n//!         Box::new(http_client),\n//!         \"username\",\n//!         \"password\"\n//!     ).await?;\n//!\n//!     // Get recent tracks (first 100)\n//!     let recent_tracks = client.recent_tracks().take(100).await?;\n//!     println!(\"Found {} recent tracks\", recent_tracks.len());\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ### Mocking for Testing\n//!\n//! Enable the `mock` feature to use `MockLastFmEditClient` for testing:\n//!\n//! ```toml\n//! [dev-dependencies]\n//! lastfm-edit = { version = \"3.1.0\", features = [\"mock\"] }\n//! mockall = \"0.13\"\n//! ```\n//!\n//! ```rust,ignore\n//! #[cfg(feature = \"mock\")]\n//! mod tests {\n//!     use lastfm_edit::{LastFmEditClient, MockLastFmEditClient, Result, EditResponse, ScrobbleEdit};\n//!     use mockall::predicate::*;\n//!\n//!     #[tokio::test]\n//!     async fn test_edit_workflow() -\u003e Result\u003c()\u003e {\n//!         let mut mock_client = MockLastFmEditClient::new();\n//!\n//!         // Set up expectations\n//!         mock_client\n//!             .expect_login()\n//!             .with(eq(\"testuser\"), eq(\"testpass\"))\n//!             .times(1)\n//!             .returning(|_, _| Ok(()));\n//!\n//!         mock_client\n//!             .expect_edit_scrobble()\n//!             .times(1)\n//!             .returning(|_| Ok(EditResponse {\n//!                 success: true,\n//!                 message: Some(\"Edit successful\".to_string()),\n//!             }));\n//!\n//!         // Use as trait object\n//!         let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n//!\n//!         client.login(\"testuser\", \"testpass\").await?;\n//!\n//!         let edit = ScrobbleEdit::new(\n//!             Some(\"Old Track\".to_string()),\n//!             Some(\"Old Album\".to_string()),\n//!             Some(\"Old Artist\".to_string()),\n//!             Some(\"Old Artist\".to_string()),\n//!             \"New Track\".to_string(),\n//!             \"New Album\".to_string(),\n//!             \"New Artist\".to_string(),\n//!             \"New Artist\".to_string(),\n//!             1640995200,\n//!             false,\n//!         );\n//!\n//!         let response = client.edit_scrobble(\u0026edit).await?;\n//!         assert!(response.success);\n//!\n//!         Ok(())\n//!     }\n//! }\n//! ```\n//!\n//! ## License\n//!\n//! MIT\n\npub mod client;\npub mod discovery;\npub mod edit_analysis;\npub mod headers;\npub mod iterator;\npub mod login;\npub mod parsing;\npub mod retry;\npub mod session_persistence;\npub mod r#trait;\npub mod types;\npub mod vcr_form_data;\npub mod vcr_matcher;\npub mod vcr_test_utils;\n\npub use client::LastFmEditClientImpl;\npub use discovery::{\n    AlbumTracksDiscovery, ArtistTracksDiscovery, AsyncDiscoveryIterator, ExactMatchDiscovery,\n    TrackVariationsDiscovery,\n};\npub use login::LoginManager;\npub use r#trait::LastFmEditClient;\n\n// Re-export all types from the consolidated types module\npub use iterator::AsyncPaginatedIterator;\npub use types::{\n    Album, AlbumPage, Artist, ArtistPage, ClientConfig, ClientEvent, ClientEventReceiver,\n    ClientEventWatcher, EditResponse, ExactScrobbleEdit, LastFmEditSession, LastFmError,\n    OperationalDelayConfig, RateLimitConfig, RateLimitType, RequestInfo, RetryConfig, RetryResult,\n    ScrobbleEdit, SharedEventBroadcaster, SingleEditResponse, Track, TrackPage,\n};\n\n// Type aliases for iterators with the concrete client type\npub type ArtistsIterator = iterator::ArtistsIterator\u003cLastFmEditClientImpl\u003e;\npub type ArtistTracksIterator = iterator::ArtistTracksIterator\u003cLastFmEditClientImpl\u003e;\npub type ArtistTracksDirectIterator = iterator::ArtistTracksDirectIterator\u003cLastFmEditClientImpl\u003e;\npub type ArtistAlbumsIterator = iterator::ArtistAlbumsIterator\u003cLastFmEditClientImpl\u003e;\npub type AlbumTracksIterator = iterator::AlbumTracksIterator\u003cLastFmEditClientImpl\u003e;\npub type RecentTracksIterator = iterator::RecentTracksIterator\u003cLastFmEditClientImpl\u003e;\npub type SearchTracksIterator = iterator::SearchTracksIterator\u003cLastFmEditClientImpl\u003e;\npub type SearchAlbumsIterator = iterator::SearchAlbumsIterator\u003cLastFmEditClientImpl\u003e;\n#[cfg(feature = \"mock\")]\npub use r#trait::MockLastFmEditClient;\n\n// Re-export the mock iterator when the mock feature is enabled\n#[cfg(feature = \"mock\")]\npub use iterator::MockAsyncPaginatedIterator;\npub use session_persistence::{SessionManager, SessionPersistence};\n\n// Re-export scraper types for testing\npub use scraper::Html;\n\n/// A convenient type alias for [`Result`] with [`LastFmError`] as the error type.\npub type Result\u003cT\u003e = std::result::Result\u003cT, LastFmError\u003e;\n","traces":[{"line":247,"address":[21751198,21750062,21752213,21750128,21752135,21751264,21749415,21749349],"length":1,"stats":{"Line":4}},{"line":248,"address":[6536206,6532355],"length":1,"stats":{"Line":3}},{"line":249,"address":[23989440,23986630,23987343,23988485],"length":1,"stats":{"Line":1}},{"line":250,"address":[24001399,24001467],"length":1,"stats":{"Line":2}},{"line":251,"address":[27275824],"length":1,"stats":{"Line":6}},{"line":252,"address":[24259880,24259963],"length":1,"stats":{"Line":1}},{"line":253,"address":[24001660],"length":1,"stats":{"Line":1}},{"line":254,"address":[6961025,6961185],"length":1,"stats":{"Line":2}},{"line":267,"address":[9260613,9260704,9260666,9260709,9260496,9260608,9260656,9260514],"length":1,"stats":{"Line":2}}],"covered":9,"coverable":9},{"path":["/","home","imalison","Projects","lastfm-edit","src","login.rs"],"content":"use crate::types::{LastFmEditSession, LastFmError};\nuse crate::Result;\nuse http_client::{HttpClient, Request};\nuse http_types::{Method, Url};\nuse scraper::{Html, Selector};\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\n/// Login functionality separated from the main client\npub struct LoginManager {\n    client: Arc\u003cdyn HttpClient + Send + Sync\u003e,\n    base_url: String,\n}\n\nimpl LoginManager {\n    pub fn new(client: Arc\u003cdyn HttpClient + Send + Sync\u003e, base_url: String) -\u003e Self {\n        Self { client, base_url }\n    }\n\n    /// Authenticate with Last.fm using username and password.\n    ///\n    /// This method:\n    /// 1. Fetches the login page to extract CSRF tokens\n    /// 2. Submits the login form with credentials\n    /// 3. Validates the authentication by checking for session cookies\n    /// 4. Returns a valid session for use with the client\n    ///\n    /// # Arguments\n    ///\n    /// * `username` - Last.fm username or email\n    /// * `password` - Last.fm password\n    ///\n    /// # Returns\n    ///\n    /// Returns a [`LastFmEditSession`] on successful authentication, or [`LastFmError::Auth`] on failure.\n    pub async fn login(\u0026self, username: \u0026str, password: \u0026str) -\u003e Result\u003cLastFmEditSession\u003e {\n        log::info!(\"🔐 Starting Last.fm login for username: {username}\");\n\n        // Step 1: Fetch login page and extract CSRF token and cookies\n        let login_url = format!(\"{}/login\", self.base_url);\n        let (csrf_token, next_field, mut cookies) = self.fetch_login_page(\u0026login_url).await?;\n\n        // Step 2: Submit login form\n        let response = self\n            .submit_login_form(\n                \u0026login_url,\n                username,\n                password,\n                \u0026csrf_token,\n                \u0026next_field,\n                \u0026cookies,\n            )\n            .await?;\n\n        // Step 3: Extract cookies from login response\n        extract_cookies_from_response(\u0026response, \u0026mut cookies);\n        log::debug!(\"🍪 Cookies after login response: {cookies:?}\");\n\n        // Step 4: Validate login response\n        self.validate_login_response(response, username, cookies, csrf_token)\n            .await\n    }\n\n    /// Fetch the login page and extract CSRF token, next field, and cookies\n    async fn fetch_login_page(\n        \u0026self,\n        login_url: \u0026str,\n    ) -\u003e Result\u003c(String, Option\u003cString\u003e, Vec\u003cString\u003e)\u003e {\n        log::debug!(\"📡 Fetching login page: {login_url}\");\n        let mut response = self.get(login_url).await?;\n\n        log::debug!(\"📋 Login page response status: {}\", response.status());\n        log::debug!(\n            \"📋 Login page response headers: {:?}\",\n            response.iter().collect::\u003cVec\u003c_\u003e\u003e()\n        );\n\n        // Extract cookies from the login page response\n        let mut cookies = Vec::new();\n        extract_cookies_from_response(\u0026response, \u0026mut cookies);\n        log::debug!(\"🍪 Initial cookies from login page: {cookies:?}\");\n\n        // Read and parse the HTML response\n        let html = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\"📄 Login page HTML length: {} chars\", html.len());\n        if html.len() \u003c 500 {\n            log::debug!(\"📄 Login page HTML content (short): {html}\");\n        }\n\n        // Extract CSRF token and next field from form\n        let (csrf_token, next_field) = self.extract_login_form_data(\u0026html)?;\n        log::debug!(\"🔑 Extracted CSRF token: {csrf_token}\",);\n        log::debug!(\"➡️  Next field: {next_field:?}\");\n\n        Ok((csrf_token, next_field, cookies))\n    }\n\n    /// Submit the login form with credentials\n    async fn submit_login_form(\n        \u0026self,\n        login_url: \u0026str,\n        username: \u0026str,\n        password: \u0026str,\n        csrf_token: \u0026str,\n        next_field: \u0026Option\u003cString\u003e,\n        cookies: \u0026[String],\n    ) -\u003e Result\u003chttp_types::Response\u003e {\n        // Prepare form data\n        let mut form_data = HashMap::new();\n        form_data.insert(\"csrfmiddlewaretoken\", csrf_token);\n        form_data.insert(\"username_or_email\", username);\n        form_data.insert(\"password\", password);\n\n        if let Some(ref next_value) = next_field {\n            form_data.insert(\"next\", next_value);\n            log::debug!(\"➡️  Including next field in form: {next_value}\");\n        }\n\n        log::debug!(\n            \"📝 Form data fields: {:?}\",\n            form_data.keys().collect::\u003cVec\u003c_\u003e\u003e()\n        );\n        log::debug!(\"📝 Form username: {username}\");\n        log::debug!(\"📝 Form password length: {} chars\", password.len());\n\n        // Create and configure the POST request\n        let mut request = self.create_login_request(login_url, cookies)?;\n\n        // Convert form data to URL-encoded string\n        let form_string: String = form_data\n            .iter()\n            .map(|(k, v)| format!(\"{}={}\", urlencoding::encode(k), urlencoding::encode(v)))\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\u0026\");\n\n        log::debug!(\"📤 Sending POST request to: {login_url}\");\n        log::debug!(\"📤 Form body length: {} chars\", form_string.len());\n        log::debug!(\"📤 Form body (masked): {form_string}\");\n        log::debug!(\"📤 Request headers: Referer={}, Origin={}, Content-Type=application/x-www-form-urlencoded\", \n            login_url, \u0026self.base_url);\n\n        request.set_body(form_string);\n\n        // Send the request\n        let response = self\n            .client\n            .send(request)\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\"📥 Login response status: {}\", response.status());\n        log::debug!(\n            \"📥 Login response headers: {:?}\",\n            response.iter().collect::\u003cVec\u003c_\u003e\u003e()\n        );\n\n        Ok(response)\n    }\n\n    /// Create and configure the login POST request with all necessary headers\n    fn create_login_request(\u0026self, login_url: \u0026str, cookies: \u0026[String]) -\u003e Result\u003cRequest\u003e {\n        let mut request = Request::new(Method::Post, login_url.parse::\u003cUrl\u003e().unwrap());\n\n        // Set all the required headers\n        let _ = request.insert_header(\"Referer\", login_url);\n        let _ = request.insert_header(\"Origin\", \u0026self.base_url);\n        let _ = request.insert_header(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        let _ = request.insert_header(\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36\"\n        );\n        let _ = request.insert_header(\n            \"Accept\",\n            \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\"\n        );\n        let _ = request.insert_header(\"Accept-Language\", \"en-US,en;q=0.9\");\n        let _ = request.insert_header(\"Accept-Encoding\", \"gzip, deflate, br\");\n        let _ = request.insert_header(\"DNT\", \"1\");\n        let _ = request.insert_header(\"Connection\", \"keep-alive\");\n        let _ = request.insert_header(\"Upgrade-Insecure-Requests\", \"1\");\n        let _ = request.insert_header(\n            \"sec-ch-ua\",\n            \"\\\"Not)A;Brand\\\";v=\\\"8\\\", \\\"Chromium\\\";v=\\\"138\\\", \\\"Google Chrome\\\";v=\\\"138\\\"\",\n        );\n        let _ = request.insert_header(\"sec-ch-ua-mobile\", \"?0\");\n        let _ = request.insert_header(\"sec-ch-ua-platform\", \"\\\"Linux\\\"\");\n        let _ = request.insert_header(\"Sec-Fetch-Dest\", \"document\");\n        let _ = request.insert_header(\"Sec-Fetch-Mode\", \"navigate\");\n        let _ = request.insert_header(\"Sec-Fetch-Site\", \"same-origin\");\n        let _ = request.insert_header(\"Sec-Fetch-User\", \"?1\");\n\n        // Add cookies if we have any\n        if !cookies.is_empty() {\n            let cookie_header = cookies.join(\"; \");\n            let _ = request.insert_header(\"Cookie\", \u0026cookie_header);\n        }\n\n        Ok(request)\n    }\n\n    /// Validate the login response and return a session if successful\n    async fn validate_login_response(\n        \u0026self,\n        mut response: http_types::Response,\n        username: \u0026str,\n        cookies: Vec\u003cString\u003e,\n        csrf_token: String,\n    ) -\u003e Result\u003cLastFmEditSession\u003e {\n        // Handle 403 Forbidden responses (likely CSRF failures)\n        if response.status() == 403 {\n            return self.handle_403_response(response).await;\n        }\n\n        // Check for successful session establishment\n        if let Some(session) =\n            self.check_session_success(\u0026response, username, \u0026cookies, \u0026csrf_token)\n        {\n            return Ok(session);\n        }\n\n        // For other cases, analyze the response body\n        let response_html = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\n            \"📄 Login response HTML length: {} chars\",\n            response_html.len()\n        );\n        if response_html.len() \u003c 500 {\n            log::debug!(\"📄 Login response HTML content (short): {response_html}\");\n        }\n\n        // Check if we were redirected away from login page (success indicator)\n        let has_login_form = self.check_for_login_form(\u0026response_html);\n        log::debug!(\"🔍 Final login validation:\");\n        log::debug!(\"   - Response contains login form: {has_login_form}\");\n        log::debug!(\"   - Response status: {}\", response.status());\n\n        if !has_login_form \u0026\u0026 response.status() == 200 {\n            log::info!(\"✅ Login successful - no login form detected in response\");\n            Ok(LastFmEditSession::new(\n                username.to_string(),\n                cookies,\n                Some(csrf_token),\n                self.base_url.clone(),\n            ))\n        } else {\n            // Parse and return error message\n            let error_msg = self.parse_login_error(\u0026response_html);\n            log::warn!(\"❌ Login failed: {error_msg}\");\n            Err(LastFmError::Auth(error_msg))\n        }\n    }\n\n    /// Handle 403 Forbidden responses\n    async fn handle_403_response(\n        \u0026self,\n        mut response: http_types::Response,\n    ) -\u003e Result\u003cLastFmEditSession\u003e {\n        let response_html = response\n            .body_string()\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))?;\n\n        log::debug!(\"📄 403 response HTML length: {} chars\", response_html.len());\n        if response_html.len() \u003c 2000 {\n            log::debug!(\"📄 403 response HTML content: {response_html}\");\n        } else {\n            // Log first and last 500 chars for large responses\n            log::debug!(\"📄 403 response HTML start: {}\", \u0026response_html[..500]);\n            log::debug!(\n                \"📄 403 response HTML end: {}\",\n                \u0026response_html[response_html.len() - 500..]\n            );\n        }\n\n        let login_error = self.parse_login_error(\u0026response_html);\n        Err(LastFmError::Auth(login_error))\n    }\n\n    /// Check if the response indicates successful session establishment\n    fn check_session_success(\n        \u0026self,\n        response: \u0026http_types::Response,\n        username: \u0026str,\n        cookies: \u0026[String],\n        csrf_token: \u0026str,\n    ) -\u003e Option\u003cLastFmEditSession\u003e {\n        let has_real_session = cookies\n            .iter()\n            .any(|cookie| cookie.starts_with(\"sessionid=.\") \u0026\u0026 cookie.len() \u003e 50);\n\n        log::debug!(\"🔍 Session validation:\");\n        log::debug!(\"   - Has real session cookie: {has_real_session}\");\n        log::debug!(\"   - Response status: {}\", response.status());\n        log::debug!(\"   - All cookies: {cookies:?}\");\n\n        if has_real_session \u0026\u0026 (response.status() == 302 || response.status() == 200) {\n            log::info!(\"✅ Login successful - authenticated session established\");\n            Some(LastFmEditSession::new(\n                username.to_string(),\n                cookies.to_vec(),\n                Some(csrf_token.to_string()),\n                self.base_url.clone(),\n            ))\n        } else {\n            None\n        }\n    }\n\n    /// Make a simple HTTP GET request (without retry logic)\n    async fn get(\u0026self, url: \u0026str) -\u003e Result\u003chttp_types::Response\u003e {\n        let mut request = Request::new(Method::Get, url.parse::\u003cUrl\u003e().unwrap());\n        let _ = request.insert_header(\"User-Agent\", \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36\");\n\n        self.client\n            .send(request)\n            .await\n            .map_err(|e| LastFmError::Http(e.to_string()))\n    }\n\n    /// Extract login form data (CSRF token and next field)\n    fn extract_login_form_data(\u0026self, html: \u0026str) -\u003e Result\u003c(String, Option\u003cString\u003e)\u003e {\n        let document = Html::parse_document(html);\n\n        let csrf_token = self.extract_csrf_token(\u0026document)?;\n\n        // Check if there's a 'next' field in the form\n        let next_selector = Selector::parse(\"input[name=\\\"next\\\"]\").unwrap();\n        let next_field = document\n            .select(\u0026next_selector)\n            .next()\n            .and_then(|input| input.value().attr(\"value\"))\n            .map(|s| s.to_string());\n\n        Ok((csrf_token, next_field))\n    }\n\n    fn extract_csrf_token(\u0026self, document: \u0026Html) -\u003e Result\u003cString\u003e {\n        let csrf_selector = Selector::parse(\"input[name=\\\"csrfmiddlewaretoken\\\"]\").unwrap();\n\n        let csrf_token = document\n            .select(\u0026csrf_selector)\n            .next()\n            .and_then(|input| input.value().attr(\"value\"))\n            .map(|token| token.to_string())\n            .ok_or(LastFmError::CsrfNotFound)?;\n\n        log::debug!(\"🔑 CSRF token extracted from HTML: {csrf_token}\");\n        Ok(csrf_token)\n    }\n\n    /// Parse login error messages from HTML\n    fn parse_login_error(\u0026self, html: \u0026str) -\u003e String {\n        let document = Html::parse_document(html);\n\n        let error_selector = Selector::parse(\".alert-danger, .form-error, .error-message\").unwrap();\n\n        let mut error_messages = Vec::new();\n        for error in document.select(\u0026error_selector) {\n            let error_text = error.text().collect::\u003cString\u003e().trim().to_string();\n            if !error_text.is_empty() {\n                error_messages.push(error_text);\n            }\n        }\n\n        if error_messages.is_empty() {\n            \"Login failed - please check your credentials\".to_string()\n        } else {\n            format!(\"Login failed: {}\", error_messages.join(\"; \"))\n        }\n    }\n\n    /// Check if HTML contains a login form\n    fn check_for_login_form(\u0026self, html: \u0026str) -\u003e bool {\n        let document = Html::parse_document(html);\n        let login_form_selector =\n            Selector::parse(\"form[action*=\\\"login\\\"], input[name=\\\"username_or_email\\\"]\").unwrap();\n        document.select(\u0026login_form_selector).next().is_some()\n    }\n}\n\n/// Extract cookies from HTTP response - utility function\npub fn extract_cookies_from_response(response: \u0026http_types::Response, cookies: \u0026mut Vec\u003cString\u003e) {\n    if let Some(cookie_headers) = response.header(\"set-cookie\") {\n        for cookie_header in cookie_headers {\n            let cookie_str = cookie_header.as_str();\n            // Extract just the cookie name=value part (before any semicolon)\n            if let Some(cookie_value) = cookie_str.split(';').next() {\n                let cookie_name = cookie_value.split('=').next().unwrap_or(\"\");\n\n                // Remove any existing cookie with the same name\n                cookies.retain(|existing| !existing.starts_with(\u0026format!(\"{cookie_name}=\")));\n                cookies.push(cookie_value.to_string());\n            }\n        }\n    }\n}\n","traces":[{"line":16,"address":[5478176],"length":1,"stats":{"Line":1}},{"line":36,"address":[3235146,3234080,3234425,3234340,3236350,3234164],"length":1,"stats":{"Line":4}},{"line":37,"address":[5959874,5959914,5959684],"length":1,"stats":{"Line":3}},{"line":40,"address":[3234810,3234488],"length":1,"stats":{"Line":2}},{"line":41,"address":[3364082],"length":1,"stats":{"Line":2}},{"line":44,"address":[5961173,5962064,5961571,5961647,5961977,5961949],"length":1,"stats":{"Line":5}},{"line":46,"address":[6082857],"length":1,"stats":{"Line":1}},{"line":47,"address":[5578279],"length":1,"stats":{"Line":1}},{"line":48,"address":[5578311],"length":1,"stats":{"Line":1}},{"line":49,"address":[3507855],"length":1,"stats":{"Line":1}},{"line":50,"address":[6344122],"length":1,"stats":{"Line":1}},{"line":51,"address":[6083105],"length":1,"stats":{"Line":1}},{"line":53,"address":[5316760],"length":1,"stats":{"Line":3}},{"line":56,"address":[3236798],"length":1,"stats":{"Line":1}},{"line":57,"address":[5769477,5769716],"length":1,"stats":{"Line":2}},{"line":60,"address":[5770568,5770064,5769533],"length":1,"stats":{"Line":3}},{"line":61,"address":[3509309,3509637,3509349,3510000,3506332],"length":1,"stats":{"Line":3}},{"line":65,"address":[2876032],"length":1,"stats":{"Line":1}},{"line":69,"address":[6346607,6346770,6346817],"length":1,"stats":{"Line":3}},{"line":70,"address":[5281535],"length":1,"stats":{"Line":2}},{"line":72,"address":[6086704,6086604,6086758],"length":1,"stats":{"Line":3}},{"line":73,"address":[3240075,3239654,3240211,3240040],"length":1,"stats":{"Line":3}},{"line":79,"address":[6087102],"length":1,"stats":{"Line":1}},{"line":80,"address":[5773109],"length":1,"stats":{"Line":1}},{"line":81,"address":[6087752,6087660],"length":1,"stats":{"Line":2}},{"line":84,"address":[3515540,3513090,3512798,3512446,3513254,3513164],"length":1,"stats":{"Line":4}},{"line":86,"address":[5998114],"length":1,"stats":{"Line":3}},{"line":87,"address":[5776466,5774038,5776448],"length":1,"stats":{"Line":0}},{"line":89,"address":[5967067,5967099,5966971],"length":1,"stats":{"Line":3}},{"line":90,"address":[6089082,6088745],"length":1,"stats":{"Line":2}},{"line":91,"address":[5967471],"length":1,"stats":{"Line":0}},{"line":95,"address":[6089471,6089090],"length":1,"stats":{"Line":2}},{"line":96,"address":[3514439,3514529,3514580],"length":1,"stats":{"Line":3}},{"line":97,"address":[5776004,5775682,5775367],"length":1,"stats":{"Line":3}},{"line":99,"address":[3243100],"length":1,"stats":{"Line":1}},{"line":103,"address":[5953520],"length":1,"stats":{"Line":1}},{"line":113,"address":[5586808],"length":1,"stats":{"Line":1}},{"line":114,"address":[3516328],"length":1,"stats":{"Line":1}},{"line":115,"address":[6352748],"length":1,"stats":{"Line":1}},{"line":116,"address":[6091770],"length":1,"stats":{"Line":1}},{"line":118,"address":[6352853],"length":1,"stats":{"Line":1}},{"line":119,"address":[3244928,3244805],"length":1,"stats":{"Line":2}},{"line":120,"address":[3516687],"length":1,"stats":{"Line":1}},{"line":123,"address":[5778030],"length":1,"stats":{"Line":0}},{"line":127,"address":[3245312,3245824,3245770],"length":1,"stats":{"Line":3}},{"line":128,"address":[3517835,3517898,3517492],"length":1,"stats":{"Line":3}},{"line":131,"address":[5591355,5588517,5588930],"length":1,"stats":{"Line":2}},{"line":134,"address":[3246793,3247036,3246887],"length":1,"stats":{"Line":3}},{"line":136,"address":[3522240,3522286],"length":1,"stats":{"Line":2}},{"line":140,"address":[3518849,3518955],"length":1,"stats":{"Line":2}},{"line":141,"address":[3247215,3247554,3247608],"length":1,"stats":{"Line":3}},{"line":142,"address":[6095001,6094616,6095055],"length":1,"stats":{"Line":3}},{"line":143,"address":[5973343,5973901,5973777,5973689],"length":1,"stats":{"Line":0}},{"line":146,"address":[5780895],"length":1,"stats":{"Line":1}},{"line":149,"address":[5591219,5591751,5591107,5591609,5591637,5591296],"length":1,"stats":{"Line":5}},{"line":151,"address":[5974162],"length":1,"stats":{"Line":1}},{"line":152,"address":[5616583],"length":1,"stats":{"Line":3}},{"line":153,"address":[5593376,5591719,5593394],"length":1,"stats":{"Line":0}},{"line":155,"address":[3249631,3249490,3249580],"length":1,"stats":{"Line":3}},{"line":156,"address":[5975589,5975330,5975466,5974978],"length":1,"stats":{"Line":0}},{"line":161,"address":[5592359],"length":1,"stats":{"Line":1}},{"line":165,"address":[2876304,2877801,2877795],"length":1,"stats":{"Line":1}},{"line":166,"address":[5836802],"length":1,"stats":{"Line":1}},{"line":169,"address":[6218945,6219017],"length":1,"stats":{"Line":2}},{"line":170,"address":[2876597],"length":1,"stats":{"Line":1}},{"line":171,"address":[5837064],"length":1,"stats":{"Line":1}},{"line":172,"address":[5478988],"length":1,"stats":{"Line":1}},{"line":176,"address":[5479056],"length":1,"stats":{"Line":1}},{"line":180,"address":[2876824],"length":1,"stats":{"Line":1}},{"line":181,"address":[5837336],"length":1,"stats":{"Line":1}},{"line":182,"address":[5479260],"length":1,"stats":{"Line":1}},{"line":183,"address":[6219504],"length":1,"stats":{"Line":1}},{"line":184,"address":[6219570],"length":1,"stats":{"Line":1}},{"line":185,"address":[3720006],"length":1,"stats":{"Line":1}},{"line":189,"address":[2877182],"length":1,"stats":{"Line":1}},{"line":190,"address":[5837742],"length":1,"stats":{"Line":1}},{"line":191,"address":[5954850],"length":1,"stats":{"Line":1}},{"line":192,"address":[5954918],"length":1,"stats":{"Line":1}},{"line":193,"address":[3720346],"length":1,"stats":{"Line":1}},{"line":194,"address":[3720414],"length":1,"stats":{"Line":1}},{"line":197,"address":[5668140],"length":1,"stats":{"Line":1}},{"line":198,"address":[5668175],"length":1,"stats":{"Line":1}},{"line":199,"address":[5668266,5668354],"length":1,"stats":{"Line":2}},{"line":202,"address":[6220191],"length":1,"stats":{"Line":1}},{"line":206,"address":[2877824],"length":1,"stats":{"Line":1}},{"line":214,"address":[6098765,6098611],"length":1,"stats":{"Line":2}},{"line":215,"address":[5785129,5784459,5784211,5785009],"length":1,"stats":{"Line":0}},{"line":219,"address":[5784355,5784604],"length":1,"stats":{"Line":2}},{"line":222,"address":[5784802],"length":1,"stats":{"Line":1}},{"line":226,"address":[5978497,5978669,5978555,5982718,5977678,5977739],"length":1,"stats":{"Line":0}},{"line":228,"address":[5999877],"length":1,"stats":{"Line":0}},{"line":229,"address":[3524853,3529159,3529136],"length":1,"stats":{"Line":0}},{"line":231,"address":[5595746,5595991,5595874,5595842],"length":1,"stats":{"Line":0}},{"line":235,"address":[3525092,3525441],"length":1,"stats":{"Line":0}},{"line":236,"address":[3525506],"length":1,"stats":{"Line":0}},{"line":240,"address":[3254271,3253845],"length":1,"stats":{"Line":0}},{"line":241,"address":[5596779,5596673],"length":1,"stats":{"Line":0}},{"line":242,"address":[3254651,3254363,3254705],"length":1,"stats":{"Line":0}},{"line":243,"address":[5597389,5597025,5597364],"length":1,"stats":{"Line":0}},{"line":245,"address":[5597807,5599012,5597723,5597370],"length":1,"stats":{"Line":0}},{"line":246,"address":[3527179,3527083],"length":1,"stats":{"Line":0}},{"line":247,"address":[3527761,3527666],"length":1,"stats":{"Line":0}},{"line":248,"address":[5597907,5598201],"length":1,"stats":{"Line":0}},{"line":249,"address":[5598209],"length":1,"stats":{"Line":0}},{"line":250,"address":[5788494],"length":1,"stats":{"Line":0}},{"line":251,"address":[5598363],"length":1,"stats":{"Line":0}},{"line":255,"address":[3526982,3527935],"length":1,"stats":{"Line":0}},{"line":256,"address":[3256354,3256444,3256649],"length":1,"stats":{"Line":0}},{"line":257,"address":[3256454],"length":1,"stats":{"Line":0}},{"line":262,"address":[5480432],"length":1,"stats":{"Line":0}},{"line":266,"address":[6105501,6104918,6105329,6105387,6105070],"length":1,"stats":{"Line":0}},{"line":268,"address":[6105361,6104982,6105163,6105043,6105103],"length":1,"stats":{"Line":0}},{"line":269,"address":[3529989,3532160,3532183],"length":1,"stats":{"Line":0}},{"line":271,"address":[5791234,5791138,5791266],"length":1,"stats":{"Line":0}},{"line":272,"address":[5601373,5601024],"length":1,"stats":{"Line":0}},{"line":273,"address":[5791650,5792579],"length":1,"stats":{"Line":0}},{"line":276,"address":[3259167,3259013,3259113],"length":1,"stats":{"Line":0}},{"line":277,"address":[5792245],"length":1,"stats":{"Line":0}},{"line":283,"address":[3531860,3531103],"length":1,"stats":{"Line":0}},{"line":284,"address":[5792891],"length":1,"stats":{"Line":0}},{"line":288,"address":[3723102,3721056,3723130],"length":1,"stats":{"Line":1}},{"line":295,"address":[3721211],"length":1,"stats":{"Line":1}},{"line":297,"address":[5986158,5986128],"length":1,"stats":{"Line":2}},{"line":299,"address":[6220987,6220910],"length":1,"stats":{"Line":2}},{"line":300,"address":[5956195,5955949],"length":1,"stats":{"Line":2}},{"line":301,"address":[5480965,5481288],"length":1,"stats":{"Line":2}},{"line":302,"address":[2879155,2878841],"length":1,"stats":{"Line":2}},{"line":304,"address":[5669733,5670723,5669998],"length":1,"stats":{"Line":2}},{"line":305,"address":[5957085,5957203],"length":1,"stats":{"Line":2}},{"line":306,"address":[6222585,6222689],"length":1,"stats":{"Line":2}},{"line":307,"address":[6222138],"length":1,"stats":{"Line":1}},{"line":308,"address":[5670179,5670434],"length":1,"stats":{"Line":2}},{"line":309,"address":[3722794,3722856],"length":1,"stats":{"Line":2}},{"line":310,"address":[5957536],"length":1,"stats":{"Line":1}},{"line":313,"address":[5669985],"length":1,"stats":{"Line":0}},{"line":318,"address":[5482624,5482642],"length":1,"stats":{"Line":4}},{"line":319,"address":[5793685,5793586],"length":1,"stats":{"Line":2}},{"line":320,"address":[6369264,6369362],"length":1,"stats":{"Line":2}},{"line":322,"address":[5794376,5794436,5794066,5794007,5793882],"length":1,"stats":{"Line":5}},{"line":323,"address":[5603724],"length":1,"stats":{"Line":1}},{"line":324,"address":[5483223],"length":1,"stats":{"Line":3}},{"line":325,"address":[6108992,6109010],"length":1,"stats":{"Line":0}},{"line":329,"address":[5957856,5958820,5958869],"length":1,"stats":{"Line":1}},{"line":330,"address":[3723288],"length":1,"stats":{"Line":1}},{"line":332,"address":[5671029,5670981],"length":1,"stats":{"Line":2}},{"line":335,"address":[5483102,5483030],"length":1,"stats":{"Line":2}},{"line":336,"address":[5671338,5671414,5671482],"length":1,"stats":{"Line":3}},{"line":339,"address":[6370177,6370176],"length":1,"stats":{"Line":2}},{"line":340,"address":[5671441,5671538],"length":1,"stats":{"Line":3}},{"line":342,"address":[2880978],"length":1,"stats":{"Line":1}},{"line":345,"address":[3724256,3725286,3725324],"length":1,"stats":{"Line":1}},{"line":346,"address":[2881302],"length":1,"stats":{"Line":1}},{"line":348,"address":[3724559,3724686,3724356,3724489,3724421],"length":1,"stats":{"Line":4}},{"line":351,"address":[6370273,6370272],"length":1,"stats":{"Line":2}},{"line":352,"address":[3533798,3533776],"length":1,"stats":{"Line":2}},{"line":353,"address":[6224080,6224286,6224179,6224924,6224411],"length":1,"stats":{"Line":2}},{"line":355,"address":[5484462,5484298],"length":1,"stats":{"Line":2}},{"line":356,"address":[6224531],"length":1,"stats":{"Line":1}},{"line":360,"address":[5843858,5844300,5842944],"length":1,"stats":{"Line":0}},{"line":361,"address":[5960051],"length":1,"stats":{"Line":0}},{"line":363,"address":[5484889,5484961],"length":1,"stats":{"Line":0}},{"line":365,"address":[3725549],"length":1,"stats":{"Line":0}},{"line":366,"address":[5960322,5961294,5960446,5960249],"length":1,"stats":{"Line":0}},{"line":367,"address":[5485322,5485765],"length":1,"stats":{"Line":0}},{"line":368,"address":[3726537],"length":1,"stats":{"Line":0}},{"line":369,"address":[5961284,5961198],"length":1,"stats":{"Line":0}},{"line":373,"address":[6225547],"length":1,"stats":{"Line":0}},{"line":374,"address":[5960904,5960622],"length":1,"stats":{"Line":0}},{"line":376,"address":[5960588,5960658],"length":1,"stats":{"Line":0}},{"line":381,"address":[5961800,5961360,5961806],"length":1,"stats":{"Line":0}},{"line":382,"address":[5486207],"length":1,"stats":{"Line":0}},{"line":383,"address":[3726834,3726765],"length":1,"stats":{"Line":0}},{"line":385,"address":[3727001,3726939,3726872],"length":1,"stats":{"Line":0}},{"line":390,"address":[5844784],"length":1,"stats":{"Line":8}},{"line":391,"address":[5961852],"length":1,"stats":{"Line":7}},{"line":392,"address":[5486772,5486732],"length":1,"stats":{"Line":15}},{"line":393,"address":[3727382],"length":1,"stats":{"Line":8}},{"line":395,"address":[2884382],"length":1,"stats":{"Line":7}},{"line":396,"address":[5962173],"length":1,"stats":{"Line":8}},{"line":399,"address":[2884583],"length":1,"stats":{"Line":23}},{"line":400,"address":[5487088],"length":1,"stats":{"Line":1}}],"covered":126,"coverable":181},{"path":["/","home","imalison","Projects","lastfm-edit","src","parsing.rs"],"content":"//! HTML parsing utilities for Last.fm pages.\n//!\n//! This module contains all the HTML parsing logic for extracting track, album,\n//! and other data from Last.fm web pages. These functions are primarily pure\n//! functions that take HTML documents and return structured data.\n\nuse crate::{Album, AlbumPage, Artist, ArtistPage, LastFmError, Result, Track, TrackPage};\nuse scraper::{Html, Selector};\n\n/// Parser struct containing parsing methods for Last.fm HTML pages.\n///\n/// This struct holds the parsing logic that was previously embedded in the client.\n/// It's designed to be stateless and focused purely on HTML parsing.\n#[derive(Debug, Clone)]\npub struct LastFmParser;\n\nimpl LastFmParser {\n    /// Create a new parser instance.\n    pub fn new() -\u003e Self {\n        Self\n    }\n\n    /// Parse recent scrobbles from the user's library page\n    /// This extracts real scrobble data with timestamps for editing\n    pub fn parse_recent_scrobbles(\u0026self, document: \u0026Html) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        let mut tracks = Vec::new();\n\n        // Recent scrobbles are typically in chartlist tables - there can be multiple\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let row_selector = Selector::parse(\"tbody tr\").unwrap();\n\n        let tables: Vec\u003c_\u003e = document.select(\u0026table_selector).collect();\n        log::debug!(\"Found {} chartlist tables\", tables.len());\n\n        for table in tables {\n            for row in table.select(\u0026row_selector) {\n                if let Ok(track) = self.parse_recent_scrobble_row(\u0026row) {\n                    tracks.push(track);\n                }\n            }\n        }\n\n        if tracks.is_empty() {\n            log::debug!(\"No tracks found in recent scrobbles\");\n        }\n\n        log::debug!(\"Parsed {} recent scrobbles\", tracks.len());\n        Ok(tracks)\n    }\n\n    /// Parse a single row from the recent scrobbles table\n    fn parse_recent_scrobble_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cTrack\u003e {\n        // Extract track name\n        let name_selector = Selector::parse(\".chartlist-name a\").unwrap();\n        let name = row\n            .select(\u0026name_selector)\n            .next()\n            .ok_or(LastFmError::Parse(\"Missing track name\".to_string()))?\n            .text()\n            .collect::\u003cString\u003e()\n            .trim()\n            .to_string();\n\n        // Extract artist name\n        let artist_selector = Selector::parse(\".chartlist-artist a\").unwrap();\n        let artist = row\n            .select(\u0026artist_selector)\n            .next()\n            .ok_or(LastFmError::Parse(\"Missing artist name\".to_string()))?\n            .text()\n            .collect::\u003cString\u003e()\n            .trim()\n            .to_string();\n\n        // Extract timestamp from data attributes or hidden inputs\n        let timestamp = self.extract_scrobble_timestamp(row);\n\n        // Extract album from hidden inputs in edit form\n        let album = self.extract_scrobble_album(row);\n\n        // Extract album artist from hidden inputs in edit form\n        let album_artist = self.extract_scrobble_album_artist(row);\n\n        // For recent scrobbles, playcount is typically 1 since they're individual scrobbles\n        let playcount = 1;\n\n        Ok(Track {\n            name,\n            artist,\n            playcount,\n            timestamp,\n            album,\n            album_artist,\n        })\n    }\n\n    /// Extract timestamp from scrobble row elements\n    fn extract_scrobble_timestamp(\u0026self, row: \u0026scraper::ElementRef) -\u003e Option\u003cu64\u003e {\n        // Look for timestamp in various places:\n\n        // 1. Check for data-timestamp attribute\n        if let Some(timestamp_str) = row.value().attr(\"data-timestamp\") {\n            if let Ok(timestamp) = timestamp_str.parse::\u003cu64\u003e() {\n                return Some(timestamp);\n            }\n        }\n\n        // 2. Look for hidden timestamp input\n        let timestamp_input_selector = Selector::parse(\"input[name='timestamp']\").unwrap();\n        if let Some(input) = row.select(\u0026timestamp_input_selector).next() {\n            if let Some(value) = input.value().attr(\"value\") {\n                if let Ok(timestamp) = value.parse::\u003cu64\u003e() {\n                    return Some(timestamp);\n                }\n            }\n        }\n\n        // 3. Look for edit form with timestamp\n        let edit_form_selector =\n            Selector::parse(\"form[data-edit-scrobble] input[name='timestamp']\").unwrap();\n        if let Some(timestamp_input) = row.select(\u0026edit_form_selector).next() {\n            if let Some(value) = timestamp_input.value().attr(\"value\") {\n                if let Ok(timestamp) = value.parse::\u003cu64\u003e() {\n                    return Some(timestamp);\n                }\n            }\n        }\n\n        // Removed time element parsing - testing if needed\n\n        None\n    }\n\n    /// Extract album name from scrobble row elements\n    fn extract_scrobble_album(\u0026self, row: \u0026scraper::ElementRef) -\u003e Option\u003cString\u003e {\n        // Look for album_name in hidden inputs within edit forms\n        let album_input_selector =\n            Selector::parse(\"form[data-edit-scrobble] input[name='album_name']\").unwrap();\n\n        if let Some(album_input) = row.select(\u0026album_input_selector).next() {\n            if let Some(album_name) = album_input.value().attr(\"value\") {\n                if !album_name.is_empty() {\n                    return Some(album_name.to_string());\n                }\n            }\n        }\n\n        None\n    }\n\n    /// Extract album artist name from scrobble row elements\n    fn extract_scrobble_album_artist(\u0026self, row: \u0026scraper::ElementRef) -\u003e Option\u003cString\u003e {\n        // Look for album_artist_name in hidden inputs within edit forms\n        let album_artist_input_selector =\n            Selector::parse(\"form[data-edit-scrobble] input[name='album_artist_name']\").unwrap();\n\n        if let Some(album_artist_input) = row.select(\u0026album_artist_input_selector).next() {\n            if let Some(album_artist_name) = album_artist_input.value().attr(\"value\") {\n                if !album_artist_name.is_empty() {\n                    return Some(album_artist_name.to_string());\n                }\n            }\n        }\n\n        None\n    }\n\n    /// Parse a tracks page into a `TrackPage` structure\n    pub fn parse_tracks_page(\n        \u0026self,\n        document: \u0026Html,\n        page_number: u32,\n        artist: \u0026str,\n        album: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cTrackPage\u003e {\n        let tracks = self.extract_tracks_from_document(document, artist, album)?;\n\n        // Check for pagination\n        let (has_next_page, total_pages) = self.parse_pagination(document, page_number)?;\n\n        Ok(TrackPage {\n            tracks,\n            page_number,\n            has_next_page,\n            total_pages,\n        })\n    }\n\n    /// Extract tracks from HTML document\n    pub fn extract_tracks_from_document(\n        \u0026self,\n        document: \u0026Html,\n        artist: \u0026str,\n        album: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        let mut tracks = Vec::new();\n        let mut seen_tracks = std::collections::HashSet::new();\n\n        log::debug!(\"Starting track extraction for artist: {artist}, album: {album:?}\");\n\n        // JSON parsing removed - was not implemented and always failed\n\n        // Parse track data from data-track-name attributes (AJAX response)\n        let track_selector = Selector::parse(\"[data-track-name]\").unwrap();\n        let track_elements: Vec\u003c_\u003e = document.select(\u0026track_selector).collect();\n        log::debug!(\n            \"Found {} elements with data-track-name\",\n            track_elements.len()\n        );\n\n        for element in track_elements {\n            let track_name = element.value().attr(\"data-track-name\").unwrap_or(\"\");\n            if track_name.is_empty() {\n                continue;\n            }\n            if seen_tracks.contains(track_name) {\n                continue;\n            }\n            seen_tracks.insert(track_name.to_string());\n\n            match self.find_playcount_for_track(document, track_name) {\n                Ok(playcount) =\u003e {\n                    let timestamp = self.find_timestamp_for_track(document, track_name);\n                    let track = Track {\n                        name: track_name.to_string(),\n                        artist: artist.to_string(),\n                        playcount,\n                        timestamp,\n                        album: album.map(|a| a.to_string()),\n                        album_artist: None, // Not available in aggregate track listings\n                    };\n                    tracks.push(track);\n                    log::debug!(\"Added track '{track_name}' with {playcount} plays\");\n                }\n                Err(e) =\u003e {\n                    log::debug!(\"FAILED to find playcount for track '{track_name}': {e}\");\n                }\n            }\n        }\n\n        // Always try fallback parsing from chartlist tables to catch tracks without data-track-name\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let tables: Vec\u003c_\u003e = document.select(\u0026table_selector).collect();\n\n        for table in tables {\n            let row_selector = Selector::parse(\"tbody tr\").unwrap();\n            let rows: Vec\u003c_\u003e = table.select(\u0026row_selector).collect();\n\n            for row in rows.iter() {\n                // Try to parse as track row\n                if let Ok(mut track) = self.parse_track_row(row) {\n                    track.artist = artist.to_string();\n                    if let Some(album_name) = album {\n                        track.album = Some(album_name.to_string());\n                    }\n\n                    // Only add if we don't already have this track\n                    if !seen_tracks.contains(\u0026track.name) {\n                        seen_tracks.insert(track.name.clone());\n                        tracks.push(track);\n                    }\n                }\n            }\n        }\n\n        log::debug!(\"Successfully extracted {} unique tracks\", tracks.len());\n        Ok(tracks)\n    }\n\n    // Removed parse_tracks_from_rows - no longer needed\n\n    /// Parse a single track row from chartlist table\n    pub fn parse_track_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cTrack\u003e {\n        // Extract track name using shared method\n        let name = self.extract_name_from_row(row, \"track\")?;\n\n        // Parse play count using shared method\n        let playcount = self.extract_playcount_from_row(row);\n\n        let artist = \"\".to_string(); // Will be filled in by caller\n\n        Ok(Track {\n            name,\n            artist,\n            playcount,\n            timestamp: None,    // Not available in table parsing mode\n            album: None,        // Not available in table parsing mode\n            album_artist: None, // Not available in table parsing mode\n        })\n    }\n\n    /// Parse albums page into `AlbumPage` structure\n    pub fn parse_albums_page(\n        \u0026self,\n        document: \u0026Html,\n        page_number: u32,\n        artist: \u0026str,\n    ) -\u003e Result\u003cAlbumPage\u003e {\n        let mut albums = Vec::new();\n\n        // Try parsing album data from data attributes (AJAX response)\n        let album_selector = Selector::parse(\"[data-album-name]\").unwrap();\n        let album_elements: Vec\u003c_\u003e = document.select(\u0026album_selector).collect();\n\n        if !album_elements.is_empty() {\n            log::debug!(\n                \"Found {} album elements with data-album-name\",\n                album_elements.len()\n            );\n\n            // Use a set to track unique albums\n            let mut seen_albums = std::collections::HashSet::new();\n\n            for element in album_elements {\n                let album_name = element.value().attr(\"data-album-name\").unwrap_or(\"\");\n                if !album_name.is_empty() \u0026\u0026 !seen_albums.contains(album_name) {\n                    seen_albums.insert(album_name.to_string());\n\n                    if let Ok(playcount) = self.find_playcount_for_album(document, album_name) {\n                        let timestamp = self.find_timestamp_for_album(document, album_name);\n                        let album = Album {\n                            name: album_name.to_string(),\n                            artist: artist.to_string(),\n                            playcount,\n                            timestamp,\n                        };\n                        albums.push(album);\n                    }\n                }\n            }\n        } else {\n            // Fall back to parsing album rows from chartlist tables\n            albums = self.parse_albums_from_rows(document, artist)?;\n        }\n\n        let (has_next_page, total_pages) = self.parse_pagination(document, page_number)?;\n\n        Ok(AlbumPage {\n            albums,\n            page_number,\n            has_next_page,\n            total_pages,\n        })\n    }\n\n    /// Parse albums from chartlist table rows\n    fn parse_albums_from_rows(\u0026self, document: \u0026Html, artist: \u0026str) -\u003e Result\u003cVec\u003cAlbum\u003e\u003e {\n        let mut albums = Vec::new();\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let row_selector = Selector::parse(\"tbody tr\").unwrap();\n\n        for table in document.select(\u0026table_selector) {\n            for row in table.select(\u0026row_selector) {\n                if let Ok(mut album) = self.parse_album_row(\u0026row) {\n                    album.artist = artist.to_string();\n                    albums.push(album);\n                }\n            }\n        }\n        Ok(albums)\n    }\n\n    /// Parse a single album row from chartlist table\n    pub fn parse_album_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cAlbum\u003e {\n        // Extract album name using shared method\n        let name = self.extract_name_from_row(row, \"album\")?;\n\n        // Parse play count using shared method\n        let playcount = self.extract_playcount_from_row(row);\n\n        let artist = \"\".to_string(); // Will be filled in by caller\n\n        Ok(Album {\n            name,\n            artist,\n            playcount,\n            timestamp: None, // Not available in table parsing\n        })\n    }\n\n    // === SEARCH RESULTS PARSING ===\n\n    /// Parse track search results from AJAX response\n    ///\n    /// This parses the HTML returned by `/user/{username}/library/tracks/search?ajax=1\u0026query={query}`\n    /// which contains chartlist tables with track results.\n    pub fn parse_track_search_results(\u0026self, document: \u0026Html) -\u003e Result\u003cVec\u003cTrack\u003e\u003e {\n        let mut tracks = Vec::new();\n\n        // Search results use the same chartlist structure as library pages\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let row_selector = Selector::parse(\"tbody tr\").unwrap();\n\n        let tables: Vec\u003c_\u003e = document.select(\u0026table_selector).collect();\n        log::debug!(\"Found {} chartlist tables in search results\", tables.len());\n\n        for table in tables {\n            for row in table.select(\u0026row_selector) {\n                if let Ok(track) = self.parse_search_track_row(\u0026row) {\n                    tracks.push(track);\n                }\n            }\n        }\n\n        log::debug!(\"Parsed {} tracks from search results\", tracks.len());\n        Ok(tracks)\n    }\n\n    /// Parse album search results from AJAX response\n    ///\n    /// This parses the HTML returned by `/user/{username}/library/albums/search?ajax=1\u0026query={query}`\n    /// which contains chartlist tables with album results.\n    pub fn parse_album_search_results(\u0026self, document: \u0026Html) -\u003e Result\u003cVec\u003cAlbum\u003e\u003e {\n        let mut albums = Vec::new();\n\n        // Search results use the same chartlist structure as library pages\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let row_selector = Selector::parse(\"tbody tr\").unwrap();\n\n        let tables: Vec\u003c_\u003e = document.select(\u0026table_selector).collect();\n        log::debug!(\n            \"Found {} chartlist tables in album search results\",\n            tables.len()\n        );\n\n        for table in tables {\n            for row in table.select(\u0026row_selector) {\n                if let Ok(album) = self.parse_search_album_row(\u0026row) {\n                    albums.push(album);\n                }\n            }\n        }\n\n        log::debug!(\"Parsed {} albums from search results\", albums.len());\n        Ok(albums)\n    }\n\n    /// Parse a single track row from search results\n    fn parse_search_track_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cTrack\u003e {\n        // Extract track name using the standard chartlist structure\n        let name = self.extract_name_from_row(row, \"track\")?;\n\n        // Extract artist name from chartlist-artist column\n        let artist_selector = Selector::parse(\".chartlist-artist a\").unwrap();\n        let artist = row\n            .select(\u0026artist_selector)\n            .next()\n            .map(|el| el.text().collect::\u003cString\u003e().trim().to_string())\n            .ok_or_else(|| {\n                LastFmError::Parse(\"Missing artist name in search results\".to_string())\n            })?;\n\n        // Extract playcount from the bar value\n        let playcount = self.extract_playcount_from_row(row);\n\n        // Search results typically don't have timestamps since they're aggregated\n        let timestamp = None;\n\n        // Try to extract album information if available in the search results\n        let album = self.extract_album_from_search_row(row);\n        let album_artist = self.extract_album_artist_from_search_row(row);\n\n        Ok(Track {\n            name,\n            artist,\n            playcount,\n            timestamp,\n            album,\n            album_artist,\n        })\n    }\n\n    /// Parse a single album row from search results\n    fn parse_search_album_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cAlbum\u003e {\n        // Extract album name using the standard chartlist structure\n        let name = self.extract_name_from_row(row, \"album\")?;\n\n        // Extract artist name from chartlist-artist column\n        let artist_selector = Selector::parse(\".chartlist-artist a\").unwrap();\n        let artist = row\n            .select(\u0026artist_selector)\n            .next()\n            .map(|el| el.text().collect::\u003cString\u003e().trim().to_string())\n            .ok_or_else(|| {\n                LastFmError::Parse(\"Missing artist name in album search results\".to_string())\n            })?;\n\n        // Extract playcount from the bar value\n        let playcount = self.extract_playcount_from_row(row);\n\n        Ok(Album {\n            name,\n            artist,\n            playcount,\n            timestamp: None, // Search results don't have timestamps\n        })\n    }\n\n    /// Extract album information from search track row\n    fn extract_album_from_search_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Option\u003cString\u003e {\n        // Look for album information in hidden form inputs (similar to recent scrobbles)\n        let album_input_selector = Selector::parse(\"input[name='album']\").unwrap();\n        if let Some(input) = row.select(\u0026album_input_selector).next() {\n            if let Some(value) = input.value().attr(\"value\") {\n                let album = value.trim().to_string();\n                if !album.is_empty() {\n                    return Some(album);\n                }\n            }\n        }\n        None\n    }\n\n    /// Extract album artist information from search track row\n    fn extract_album_artist_from_search_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Option\u003cString\u003e {\n        // Look for album artist information in hidden form inputs\n        let album_artist_input_selector = Selector::parse(\"input[name='album_artist']\").unwrap();\n        if let Some(input) = row.select(\u0026album_artist_input_selector).next() {\n            if let Some(value) = input.value().attr(\"value\") {\n                let album_artist = value.trim().to_string();\n                if !album_artist.is_empty() {\n                    return Some(album_artist);\n                }\n            }\n        }\n        None\n    }\n\n    // === SHARED PARSING UTILITIES ===\n\n    /// Extract name from chartlist row (works for both tracks and albums)\n    fn extract_name_from_row(\u0026self, row: \u0026scraper::ElementRef, item_type: \u0026str) -\u003e Result\u003cString\u003e {\n        let name_selector = Selector::parse(\".chartlist-name a\").unwrap();\n        let name = row\n            .select(\u0026name_selector)\n            .next()\n            .map(|el| el.text().collect::\u003cString\u003e().trim().to_string())\n            .ok_or_else(|| LastFmError::Parse(format!(\"Missing {item_type} name\")))?;\n        Ok(name)\n    }\n\n    /// Extract playcount from chartlist row (works for both tracks and albums)\n    fn extract_playcount_from_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e u32 {\n        let playcount_selector = Selector::parse(\".chartlist-count-bar-value\").unwrap();\n        let mut playcount = 1; // default fallback\n\n        if let Some(element) = row.select(\u0026playcount_selector).next() {\n            let text = element.text().collect::\u003cString\u003e().trim().to_string();\n            // Extract just the number part (before \"scrobbles\" if present)\n            if let Some(number_part) = text.split_whitespace().next() {\n                if let Ok(count) = number_part.parse::\u003cu32\u003e() {\n                    playcount = count;\n                }\n            }\n        }\n        playcount\n    }\n\n    /// Parse pagination information from document\n    pub fn parse_pagination(\n        \u0026self,\n        document: \u0026Html,\n        _current_page: u32,\n    ) -\u003e Result\u003c(bool, Option\u003cu32\u003e)\u003e {\n        let pagination_selector = Selector::parse(\".pagination-list\").unwrap();\n\n        if let Some(pagination) = document.select(\u0026pagination_selector).next() {\n            // Try multiple possible selectors for next page link\n            let next_selectors = [\n                \"a[aria-label=\\\"Next\\\"]\",\n                \".pagination-next a\",\n                \"a:contains(\\\"Next\\\")\",\n                \".next a\",\n            ];\n\n            let mut has_next = false;\n            for selector_str in \u0026next_selectors {\n                if let Ok(selector) = Selector::parse(selector_str) {\n                    if pagination.select(\u0026selector).next().is_some() {\n                        has_next = true;\n                        break;\n                    }\n                }\n            }\n\n            // Try to extract total pages from pagination text\n            let total_pages = self.extract_total_pages_from_pagination(\u0026pagination);\n\n            Ok((has_next, total_pages))\n        } else {\n            // No pagination found - single page\n            Ok((false, Some(1)))\n        }\n    }\n\n    /// Helper functions for pagination parsing\n    fn extract_total_pages_from_pagination(\u0026self, pagination: \u0026scraper::ElementRef) -\u003e Option\u003cu32\u003e {\n        // Look for patterns like \"Page 1 of 42\"\n        let text = pagination.text().collect::\u003cString\u003e();\n        if let Some(of_pos) = text.find(\" of \") {\n            let after_of = \u0026text[of_pos + 4..];\n            if let Some(number_end) = after_of.find(|c: char| !c.is_ascii_digit()) {\n                if let Ok(total) = after_of[..number_end].parse::\u003cu32\u003e() {\n                    return Some(total);\n                }\n            } else if let Ok(total) = after_of.trim().parse::\u003cu32\u003e() {\n                return Some(total);\n            }\n        }\n        None\n    }\n\n    // === JSON PARSING METHODS ===\n    // Removed unused JSON parsing method\n\n    // === FIND HELPER METHODS ===\n\n    pub fn find_timestamp_for_track(\u0026self, _document: \u0026Html, _track_name: \u0026str) -\u003e Option\u003cu64\u003e {\n        // Implementation would search for timestamp data\n        None\n    }\n\n    pub fn find_playcount_for_track(\u0026self, document: \u0026Html, track_name: \u0026str) -\u003e Result\u003cu32\u003e {\n        // Look for chartlist-count-bar-value elements near the track\n        let count_selector = Selector::parse(\".chartlist-count-bar-value\").unwrap();\n        let link_selector = Selector::parse(\"a[href*=\\\"/music/\\\"]\").unwrap();\n\n        // Find all track links that match our track name\n        for link in document.select(\u0026link_selector) {\n            let link_text = link.text().collect::\u003cString\u003e().trim().to_string();\n            if link_text == track_name {\n                if let Some(row) = self.find_ancestor_row(link) {\n                    if let Some(count_element) = row.select(\u0026count_selector).next() {\n                        let text = count_element.text().collect::\u003cString\u003e().trim().to_string();\n                        if let Some(number_part) = text.split_whitespace().next() {\n                            if let Ok(count) = number_part.parse::\u003cu32\u003e() {\n                                return Ok(count);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        Err(LastFmError::Parse(format!(\n            \"Could not find playcount for track: {track_name}\"\n        )))\n    }\n\n    pub fn find_timestamp_for_album(\u0026self, _document: \u0026Html, _album_name: \u0026str) -\u003e Option\u003cu64\u003e {\n        // Implementation would search for timestamp data\n        None\n    }\n\n    pub fn find_playcount_for_album(\u0026self, document: \u0026Html, album_name: \u0026str) -\u003e Result\u003cu32\u003e {\n        // Look for chartlist-count-bar-value elements near the album\n        let count_selector = Selector::parse(\".chartlist-count-bar-value\").unwrap();\n        let link_selector = Selector::parse(\"a[href*=\\\"/music/\\\"]\").unwrap();\n\n        // Find all album links that match our album name\n        for link in document.select(\u0026link_selector) {\n            let link_text = link.text().collect::\u003cString\u003e().trim().to_string();\n            if link_text == album_name {\n                if let Some(row) = self.find_ancestor_row(link) {\n                    if let Some(count_element) = row.select(\u0026count_selector).next() {\n                        let text = count_element.text().collect::\u003cString\u003e().trim().to_string();\n                        if let Some(number_part) = text.split_whitespace().next() {\n                            if let Ok(count) = number_part.parse::\u003cu32\u003e() {\n                                return Ok(count);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        Err(LastFmError::Parse(format!(\n            \"Could not find playcount for album: {album_name}\"\n        )))\n    }\n\n    pub fn find_ancestor_row\u003c'a\u003e(\n        \u0026self,\n        element: scraper::ElementRef\u003c'a\u003e,\n    ) -\u003e Option\u003cscraper::ElementRef\u003c'a\u003e\u003e {\n        let mut current = element;\n        while let Some(parent) = current.parent() {\n            if let Some(parent_elem) = scraper::ElementRef::wrap(parent) {\n                if parent_elem.value().name() == \"tr\" {\n                    return Some(parent_elem);\n                }\n                current = parent_elem;\n            } else {\n                break;\n            }\n        }\n        None\n    }\n\n    /// Parse artists page from user's library\n    pub fn parse_artists_page(\u0026self, document: \u0026Html, page_number: u32) -\u003e Result\u003cArtistPage\u003e {\n        let mut artists = Vec::new();\n\n        // Parse artists from chartlist table rows\n        let table_selector = Selector::parse(\"table.chartlist\").unwrap();\n        let row_selector = Selector::parse(\"tr.js-link-block\").unwrap();\n\n        let tables: Vec\u003c_\u003e = document.select(\u0026table_selector).collect();\n        log::debug!(\"Found {} chartlist tables for artists\", tables.len());\n\n        for table in tables {\n            for row in table.select(\u0026row_selector) {\n                if let Ok(artist) = self.parse_artist_row(\u0026row) {\n                    artists.push(artist);\n                }\n            }\n        }\n\n        log::debug!(\"Parsed {} artists from page {}\", artists.len(), page_number);\n\n        let (has_next_page, total_pages) = self.parse_pagination(document, page_number)?;\n\n        Ok(ArtistPage {\n            artists,\n            page_number,\n            has_next_page,\n            total_pages,\n        })\n    }\n\n    /// Parse a single artist row from the artist library table\n    fn parse_artist_row(\u0026self, row: \u0026scraper::ElementRef) -\u003e Result\u003cArtist\u003e {\n        // Extract artist name from the name column\n        let name_selector = Selector::parse(\"td.chartlist-name a\").unwrap();\n        let name = row\n            .select(\u0026name_selector)\n            .next()\n            .ok_or(LastFmError::Parse(\"Missing artist name\".to_string()))?\n            .text()\n            .collect::\u003cString\u003e()\n            .trim()\n            .to_string();\n\n        // Extract playcount from the count bar\n        let count_selector = Selector::parse(\".chartlist-count-bar\").unwrap();\n        let playcount = if let Some(count_element) = row.select(\u0026count_selector).next() {\n            let count_text = count_element.text().collect::\u003cString\u003e();\n            self.extract_number_from_count_text(\u0026count_text)\n                .unwrap_or(0)\n        } else {\n            0\n        };\n\n        // Artists in library listings typically don't have individual timestamps\n        let timestamp = None;\n\n        Ok(Artist {\n            name,\n            playcount,\n            timestamp,\n        })\n    }\n\n    /// Extract numeric value from count text like \"3,395 scrobbles\"\n    fn extract_number_from_count_text(\u0026self, text: \u0026str) -\u003e Option\u003cu32\u003e {\n        // Remove commas and extract the first numeric part\n        let cleaned = text.replace(',', \"\");\n        cleaned.split_whitespace().next()?.parse::\u003cu32\u003e().ok()\n    }\n}\n\nimpl Default for LastFmParser {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[{"line":19,"address":[20688748,20688466],"length":1,"stats":{"Line":0}},{"line":20,"address":[20688896,20688910],"length":1,"stats":{"Line":0}},{"line":25,"address":[20843733],"length":1,"stats":{"Line":1}},{"line":26,"address":[5663207],"length":1,"stats":{"Line":1}},{"line":29,"address":[5495488,5495416],"length":1,"stats":{"Line":2}},{"line":30,"address":[18487570],"length":1,"stats":{"Line":2}},{"line":32,"address":[5780443,5780514],"length":1,"stats":{"Line":2}},{"line":33,"address":[5495765,5495928,5495852],"length":1,"stats":{"Line":3}},{"line":35,"address":[3272626,3273121,3272994],"length":1,"stats":{"Line":3}},{"line":36,"address":[18488144],"length":1,"stats":{"Line":4}},{"line":37,"address":[5497612,5497510,5497539],"length":1,"stats":{"Line":3}},{"line":38,"address":[5329556,5329644],"length":1,"stats":{"Line":2}},{"line":43,"address":[21103180,21103134],"length":1,"stats":{"Line":2}},{"line":44,"address":[20635292],"length":1,"stats":{"Line":0}},{"line":47,"address":[5496838,5496519,5496953],"length":1,"stats":{"Line":6}},{"line":48,"address":[5781636],"length":1,"stats":{"Line":3}},{"line":52,"address":[20690015],"length":1,"stats":{"Line":1}},{"line":54,"address":[5665884],"length":1,"stats":{"Line":1}},{"line":55,"address":[5329937,5330151,5330504,5330008,5330278],"length":1,"stats":{"Line":4}},{"line":58,"address":[6048044,6048214],"length":1,"stats":{"Line":1}},{"line":65,"address":[5666710],"length":1,"stats":{"Line":1}},{"line":66,"address":[20783099],"length":1,"stats":{"Line":4}},{"line":67,"address":[21103802,21103937],"length":1,"stats":{"Line":0}},{"line":69,"address":[5783876,5784046],"length":1,"stats":{"Line":1}},{"line":76,"address":[3573126],"length":1,"stats":{"Line":1}},{"line":79,"address":[3573206],"length":1,"stats":{"Line":1}},{"line":82,"address":[5667650],"length":1,"stats":{"Line":1}},{"line":85,"address":[20690798,20690579],"length":1,"stats":{"Line":1}},{"line":87,"address":[5499980],"length":1,"stats":{"Line":1}},{"line":88,"address":[5667716],"length":1,"stats":{"Line":1}},{"line":89,"address":[18546375],"length":1,"stats":{"Line":1}},{"line":92,"address":[21104234],"length":1,"stats":{"Line":1}},{"line":93,"address":[21103823,21104269],"length":1,"stats":{"Line":0}},{"line":98,"address":[6051575,6051581,6050208],"length":1,"stats":{"Line":1}},{"line":102,"address":[5500473],"length":1,"stats":{"Line":1}},{"line":103,"address":[5785471,5785348],"length":1,"stats":{"Line":0}},{"line":104,"address":[5668540],"length":1,"stats":{"Line":0}},{"line":109,"address":[5500592],"length":1,"stats":{"Line":1}},{"line":110,"address":[5668684,5668500,5668616],"length":1,"stats":{"Line":3}},{"line":111,"address":[5668795,5668744],"length":1,"stats":{"Line":2}},{"line":112,"address":[3277761],"length":1,"stats":{"Line":1}},{"line":113,"address":[5785920],"length":1,"stats":{"Line":1}},{"line":119,"address":[5669028],"length":1,"stats":{"Line":0}},{"line":121,"address":[3278087,3277948,3278019],"length":1,"stats":{"Line":0}},{"line":122,"address":[5333326,5333275],"length":1,"stats":{"Line":0}},{"line":123,"address":[3575062],"length":1,"stats":{"Line":0}},{"line":124,"address":[5669537],"length":1,"stats":{"Line":0}},{"line":131,"address":[3575176],"length":1,"stats":{"Line":0}},{"line":135,"address":[6052236,6051600,6052230],"length":1,"stats":{"Line":1}},{"line":137,"address":[6051638],"length":1,"stats":{"Line":1}},{"line":140,"address":[5786841,5786773,5786708],"length":1,"stats":{"Line":3}},{"line":141,"address":[3575541,3575592],"length":1,"stats":{"Line":2}},{"line":142,"address":[5502299],"length":1,"stats":{"Line":1}},{"line":143,"address":[6052109],"length":1,"stats":{"Line":1}},{"line":148,"address":[6052204],"length":1,"stats":{"Line":0}},{"line":152,"address":[5503110,5503116,5502480],"length":1,"stats":{"Line":1}},{"line":154,"address":[5787302],"length":1,"stats":{"Line":3}},{"line":157,"address":[6052421,6052356,6052489],"length":1,"stats":{"Line":3}},{"line":158,"address":[5670664,5670613],"length":1,"stats":{"Line":2}},{"line":159,"address":[5334763],"length":1,"stats":{"Line":1}},{"line":160,"address":[3576413],"length":1,"stats":{"Line":1}},{"line":165,"address":[3279768],"length":1,"stats":{"Line":0}},{"line":169,"address":[5335723,5335717,5334944],"length":1,"stats":{"Line":1}},{"line":176,"address":[3576694],"length":1,"stats":{"Line":1}},{"line":179,"address":[5503541,5503481],"length":1,"stats":{"Line":3}},{"line":181,"address":[5671626],"length":1,"stats":{"Line":1}},{"line":182,"address":[5503747],"length":1,"stats":{"Line":1}},{"line":190,"address":[5335744,5340265,5342229],"length":1,"stats":{"Line":1}},{"line":196,"address":[5504031],"length":1,"stats":{"Line":1}},{"line":197,"address":[3577528],"length":1,"stats":{"Line":1}},{"line":199,"address":[3577681,3577721,3577588],"length":1,"stats":{"Line":3}},{"line":204,"address":[6054400,6054039],"length":1,"stats":{"Line":2}},{"line":205,"address":[6054529,6054458],"length":1,"stats":{"Line":2}},{"line":206,"address":[5672921,5672628,5672797,5672721],"length":1,"stats":{"Line":0}},{"line":211,"address":[6055063,6054663,6055198],"length":1,"stats":{"Line":3}},{"line":212,"address":[3285261,3282114],"length":1,"stats":{"Line":4}},{"line":213,"address":[5676656],"length":1,"stats":{"Line":2}},{"line":216,"address":[5676697],"length":1,"stats":{"Line":2}},{"line":219,"address":[3285454],"length":1,"stats":{"Line":2}},{"line":221,"address":[5676828],"length":1,"stats":{"Line":1}},{"line":222,"address":[3582568],"length":1,"stats":{"Line":2}},{"line":223,"address":[5793942],"length":1,"stats":{"Line":1}},{"line":225,"address":[3285769],"length":1,"stats":{"Line":2}},{"line":226,"address":[3582696],"length":1,"stats":{"Line":1}},{"line":229,"address":[5794135],"length":1,"stats":{"Line":5}},{"line":232,"address":[3583037],"length":1,"stats":{"Line":1}},{"line":233,"address":[5509647],"length":1,"stats":{"Line":2}},{"line":235,"address":[5340859],"length":1,"stats":{"Line":0}},{"line":236,"address":[6058859,6059866,6059838],"length":1,"stats":{"Line":0}},{"line":242,"address":[3578955],"length":1,"stats":{"Line":1}},{"line":243,"address":[5673460,5673531],"length":1,"stats":{"Line":3}},{"line":245,"address":[5505880,5505718],"length":1,"stats":{"Line":3}},{"line":246,"address":[5505940,5506552],"length":1,"stats":{"Line":3}},{"line":247,"address":[5506602,5506681],"length":1,"stats":{"Line":2}},{"line":249,"address":[3283304,3283384,3285233],"length":1,"stats":{"Line":5}},{"line":251,"address":[3284914,3283584,3283632,3283705],"length":1,"stats":{"Line":5}},{"line":252,"address":[5675133,5675209,5675228],"length":1,"stats":{"Line":6}},{"line":253,"address":[6057300,6057609],"length":1,"stats":{"Line":6}},{"line":254,"address":[6057419,6057470,6057363],"length":1,"stats":{"Line":6}},{"line":258,"address":[6057621,6057382],"length":1,"stats":{"Line":3}},{"line":259,"address":[6057627,6057673],"length":1,"stats":{"Line":2}},{"line":260,"address":[3284488],"length":1,"stats":{"Line":1}},{"line":266,"address":[5790777,5790936],"length":1,"stats":{"Line":2}},{"line":267,"address":[5506059],"length":1,"stats":{"Line":1}},{"line":273,"address":[5342979,5342272,5342973],"length":1,"stats":{"Line":2}},{"line":275,"address":[5678347],"length":1,"stats":{"Line":3}},{"line":278,"address":[5795556,5795500],"length":1,"stats":{"Line":3}},{"line":280,"address":[6060555],"length":1,"stats":{"Line":1}},{"line":282,"address":[3584327],"length":1,"stats":{"Line":1}},{"line":283,"address":[3584240],"length":1,"stats":{"Line":2}},{"line":286,"address":[3584279],"length":1,"stats":{"Line":1}},{"line":287,"address":[5510867],"length":1,"stats":{"Line":2}},{"line":288,"address":[3584309],"length":1,"stats":{"Line":1}},{"line":293,"address":[3584608,3586667,3587548],"length":1,"stats":{"Line":1}},{"line":299,"address":[6061061],"length":1,"stats":{"Line":1}},{"line":302,"address":[5343134,5343206],"length":1,"stats":{"Line":2}},{"line":303,"address":[3584880,3584951],"length":1,"stats":{"Line":2}},{"line":305,"address":[5345371,5343370,5343441],"length":1,"stats":{"Line":3}},{"line":306,"address":[5343577,5343549,5343698,5343447],"length":1,"stats":{"Line":0}},{"line":312,"address":[5679587],"length":1,"stats":{"Line":0}},{"line":314,"address":[5797120,5796874,5796985],"length":1,"stats":{"Line":0}},{"line":315,"address":[6062284,6062172],"length":1,"stats":{"Line":0}},{"line":316,"address":[5344429],"length":1,"stats":{"Line":0}},{"line":317,"address":[5512703],"length":1,"stats":{"Line":0}},{"line":319,"address":[5797654,5797559],"length":1,"stats":{"Line":0}},{"line":320,"address":[5344781,5344696],"length":1,"stats":{"Line":0}},{"line":322,"address":[5797789],"length":1,"stats":{"Line":0}},{"line":323,"address":[6062816],"length":1,"stats":{"Line":0}},{"line":327,"address":[3289640],"length":1,"stats":{"Line":0}},{"line":333,"address":[5343532,5345232,5345057,5345838],"length":1,"stats":{"Line":2}},{"line":336,"address":[5798800,5798352,5797265],"length":1,"stats":{"Line":2}},{"line":338,"address":[3290251],"length":1,"stats":{"Line":1}},{"line":339,"address":[3587207],"length":1,"stats":{"Line":1}},{"line":347,"address":[5515881,5515741,5514160],"length":1,"stats":{"Line":1}},{"line":348,"address":[3587653],"length":1,"stats":{"Line":1}},{"line":349,"address":[3290764,3290695],"length":1,"stats":{"Line":2}},{"line":350,"address":[6064166,6064235],"length":1,"stats":{"Line":2}},{"line":352,"address":[6064282,6064471,6064347],"length":1,"stats":{"Line":3}},{"line":353,"address":[3588362,3589281,3588179,3588486],"length":1,"stats":{"Line":4}},{"line":354,"address":[3292093,3291539,3291651,3291568],"length":1,"stats":{"Line":4}},{"line":355,"address":[3291834,3291815,3291755],"length":1,"stats":{"Line":2}},{"line":356,"address":[5347370],"length":1,"stats":{"Line":1}},{"line":360,"address":[5682657],"length":1,"stats":{"Line":1}},{"line":364,"address":[5684329,5683760,5684335],"length":1,"stats":{"Line":1}},{"line":366,"address":[3589387],"length":1,"stats":{"Line":1}},{"line":369,"address":[3292594,3292538],"length":1,"stats":{"Line":2}},{"line":371,"address":[3589659],"length":1,"stats":{"Line":1}},{"line":373,"address":[3589747],"length":1,"stats":{"Line":1}},{"line":374,"address":[3589696],"length":1,"stats":{"Line":1}},{"line":377,"address":[3292677],"length":1,"stats":{"Line":1}},{"line":387,"address":[3589936,3592155,3592244],"length":1,"stats":{"Line":1}},{"line":388,"address":[3589979],"length":1,"stats":{"Line":1}},{"line":391,"address":[3292968,3293040],"length":1,"stats":{"Line":2}},{"line":392,"address":[5348528,5348603],"length":1,"stats":{"Line":2}},{"line":394,"address":[5684755,5684684],"length":1,"stats":{"Line":2}},{"line":395,"address":[5348921,5348845,5348758],"length":1,"stats":{"Line":3}},{"line":397,"address":[3590843,3590978,3590467],"length":1,"stats":{"Line":3}},{"line":398,"address":[5802957,5802398,5803081,5803558],"length":1,"stats":{"Line":4}},{"line":399,"address":[3591831,3591904,3591802],"length":1,"stats":{"Line":3}},{"line":400,"address":[5518616,5518704],"length":1,"stats":{"Line":2}},{"line":405,"address":[5517829,5517671],"length":1,"stats":{"Line":2}},{"line":406,"address":[5517728],"length":1,"stats":{"Line":1}},{"line":413,"address":[5805908,5803648,5805819],"length":1,"stats":{"Line":1}},{"line":414,"address":[5350715],"length":1,"stats":{"Line":1}},{"line":417,"address":[6068732,6068804],"length":1,"stats":{"Line":2}},{"line":418,"address":[5519072,5519147],"length":1,"stats":{"Line":2}},{"line":420,"address":[5519267,5519196],"length":1,"stats":{"Line":2}},{"line":421,"address":[5351110,5351379,5351197,5351273],"length":1,"stats":{"Line":0}},{"line":426,"address":[5804690,5804555,5804179],"length":1,"stats":{"Line":3}},{"line":427,"address":[5520525,5520649,5519966,5521078],"length":1,"stats":{"Line":4}},{"line":428,"address":[5520730,5520832,5520759],"length":1,"stats":{"Line":3}},{"line":429,"address":[3297180,3297264],"length":1,"stats":{"Line":2}},{"line":434,"address":[3296449,3296291],"length":1,"stats":{"Line":2}},{"line":435,"address":[3593504],"length":1,"stats":{"Line":1}},{"line":439,"address":[5690440,5689008,5690375],"length":1,"stats":{"Line":1}},{"line":441,"address":[5689051],"length":1,"stats":{"Line":1}},{"line":444,"address":[5806210,5806282],"length":1,"stats":{"Line":2}},{"line":445,"address":[5689672,5689458,5689526,5689387],"length":1,"stats":{"Line":3}},{"line":448,"address":[6393824,6393841],"length":1,"stats":{"Line":2}},{"line":449,"address":[5807632],"length":1,"stats":{"Line":0}},{"line":450,"address":[5631614],"length":1,"stats":{"Line":0}},{"line":454,"address":[5806782],"length":1,"stats":{"Line":1}},{"line":457,"address":[5689870],"length":1,"stats":{"Line":1}},{"line":460,"address":[5689890],"length":1,"stats":{"Line":1}},{"line":461,"address":[5689915],"length":1,"stats":{"Line":1}},{"line":463,"address":[5354041],"length":1,"stats":{"Line":1}},{"line":464,"address":[5522135],"length":1,"stats":{"Line":1}},{"line":465,"address":[6071945],"length":1,"stats":{"Line":1}},{"line":468,"address":[3595625],"length":1,"stats":{"Line":1}},{"line":474,"address":[5355585,5355650,5354448],"length":1,"stats":{"Line":1}},{"line":476,"address":[6072459],"length":1,"stats":{"Line":1}},{"line":479,"address":[5354778,5354706],"length":1,"stats":{"Line":2}},{"line":480,"address":[5354827,5355112,5354898,5354966],"length":1,"stats":{"Line":3}},{"line":483,"address":[5631696,5631713],"length":1,"stats":{"Line":2}},{"line":484,"address":[6023136],"length":1,"stats":{"Line":0}},{"line":485,"address":[6023150],"length":1,"stats":{"Line":0}},{"line":489,"address":[5355278],"length":1,"stats":{"Line":1}},{"line":491,"address":[5691415],"length":1,"stats":{"Line":1}},{"line":492,"address":[5355305],"length":1,"stats":{"Line":1}},{"line":493,"address":[5691371],"length":1,"stats":{"Line":1}},{"line":495,"address":[5355371],"length":1,"stats":{"Line":1}},{"line":500,"address":[5692422,5691712,5692459],"length":1,"stats":{"Line":1}},{"line":502,"address":[5355718],"length":1,"stats":{"Line":1}},{"line":503,"address":[5808821,5808756,5808889],"length":1,"stats":{"Line":3}},{"line":504,"address":[3597589,3597640],"length":1,"stats":{"Line":0}},{"line":505,"address":[5692178],"length":1,"stats":{"Line":0}},{"line":506,"address":[5809235,5809176],"length":1,"stats":{"Line":0}},{"line":507,"address":[3597886],"length":1,"stats":{"Line":0}},{"line":511,"address":[5809377],"length":1,"stats":{"Line":1}},{"line":515,"address":[5525387,5524640,5525350],"length":1,"stats":{"Line":1}},{"line":517,"address":[6074454],"length":1,"stats":{"Line":1}},{"line":518,"address":[3598229,3598297,3598164],"length":1,"stats":{"Line":3}},{"line":519,"address":[5356792,5356741],"length":1,"stats":{"Line":0}},{"line":520,"address":[5809890],"length":1,"stats":{"Line":0}},{"line":521,"address":[5357027,5356968],"length":1,"stats":{"Line":0}},{"line":522,"address":[3301418],"length":1,"stats":{"Line":0}},{"line":526,"address":[5525361],"length":1,"stats":{"Line":1}},{"line":532,"address":[5357894,5357856,5357216],"length":1,"stats":{"Line":1}},{"line":533,"address":[3598879],"length":1,"stats":{"Line":1}},{"line":534,"address":[5693357,5693422,5693631,5693490],"length":1,"stats":{"Line":4}},{"line":537,"address":[3289168,3289185],"length":1,"stats":{"Line":2}},{"line":538,"address":[3599302,3599478,3599033,3599186],"length":1,"stats":{"Line":8}},{"line":539,"address":[3599366],"length":1,"stats":{"Line":1}},{"line":543,"address":[5357920,5358792,5358752],"length":1,"stats":{"Line":1}},{"line":544,"address":[5357948],"length":1,"stats":{"Line":1}},{"line":545,"address":[5358010],"length":1,"stats":{"Line":1}},{"line":547,"address":[6075989,6076122,6076054],"length":1,"stats":{"Line":3}},{"line":548,"address":[5811239,5811190],"length":1,"stats":{"Line":2}},{"line":550,"address":[5811462],"length":1,"stats":{"Line":1}},{"line":551,"address":[5526942,5526834,5526877],"length":1,"stats":{"Line":3}},{"line":552,"address":[5358743],"length":1,"stats":{"Line":1}},{"line":556,"address":[5811734],"length":1,"stats":{"Line":1}},{"line":560,"address":[3303152,3304602,3304453],"length":1,"stats":{"Line":2}},{"line":565,"address":[3600482],"length":1,"stats":{"Line":1}},{"line":567,"address":[5359001,5359069,5358936,5359370],"length":1,"stats":{"Line":5}},{"line":569,"address":[6077101],"length":1,"stats":{"Line":1}},{"line":576,"address":[5359241],"length":1,"stats":{"Line":1}},{"line":577,"address":[6078165,6077353,6077217],"length":1,"stats":{"Line":3}},{"line":578,"address":[5527734,5527807,5527677],"length":1,"stats":{"Line":3}},{"line":579,"address":[3303971,3304050],"length":1,"stats":{"Line":2}},{"line":580,"address":[5812912],"length":1,"stats":{"Line":1}},{"line":587,"address":[3304360,3303856],"length":1,"stats":{"Line":2}},{"line":589,"address":[6078018],"length":1,"stats":{"Line":1}},{"line":592,"address":[5695315],"length":1,"stats":{"Line":1}},{"line":597,"address":[5697153,5696336,5697159],"length":1,"stats":{"Line":1}},{"line":599,"address":[5360327],"length":1,"stats":{"Line":1}},{"line":600,"address":[6078361,6078444],"length":1,"stats":{"Line":2}},{"line":601,"address":[3304932,3304881],"length":1,"stats":{"Line":0}},{"line":602,"address":[3575360,3575373],"length":1,"stats":{"Line":0}},{"line":603,"address":[3602417,3602482],"length":1,"stats":{"Line":0}},{"line":604,"address":[3602565],"length":1,"stats":{"Line":0}},{"line":606,"address":[5696871,5697025],"length":1,"stats":{"Line":0}},{"line":607,"address":[3602692],"length":1,"stats":{"Line":0}},{"line":610,"address":[5528773],"length":1,"stats":{"Line":1}},{"line":618,"address":[5814128],"length":1,"stats":{"Line":2}},{"line":620,"address":[3602788],"length":1,"stats":{"Line":1}},{"line":623,"address":[3604870,3602816,3604876],"length":1,"stats":{"Line":1}},{"line":625,"address":[5529460],"length":1,"stats":{"Line":1}},{"line":626,"address":[5814332,5814400],"length":1,"stats":{"Line":2}},{"line":629,"address":[5697505,5697700,5697576],"length":1,"stats":{"Line":4}},{"line":630,"address":[6079696,6079996],"length":1,"stats":{"Line":2}},{"line":631,"address":[5362259],"length":1,"stats":{"Line":1}},{"line":632,"address":[3603926],"length":1,"stats":{"Line":1}},{"line":633,"address":[5815405,5815511],"length":1,"stats":{"Line":3}},{"line":634,"address":[5815620,5815571],"length":1,"stats":{"Line":2}},{"line":635,"address":[3604483],"length":1,"stats":{"Line":2}},{"line":636,"address":[3307303,3307340],"length":1,"stats":{"Line":3}},{"line":637,"address":[6081098],"length":1,"stats":{"Line":1}},{"line":644,"address":[5814753],"length":1,"stats":{"Line":0}},{"line":649,"address":[6081248],"length":1,"stats":{"Line":0}},{"line":651,"address":[5531492],"length":1,"stats":{"Line":0}},{"line":654,"address":[5533580,5531520,5533574],"length":1,"stats":{"Line":0}},{"line":656,"address":[5699428],"length":1,"stats":{"Line":0}},{"line":657,"address":[6081520,6081452],"length":1,"stats":{"Line":0}},{"line":660,"address":[6081640,6081764,6081569],"length":1,"stats":{"Line":0}},{"line":661,"address":[3308432,3308116],"length":1,"stats":{"Line":0}},{"line":662,"address":[3606003],"length":1,"stats":{"Line":0}},{"line":663,"address":[3606054],"length":1,"stats":{"Line":0}},{"line":664,"address":[5817533,5817639],"length":1,"stats":{"Line":0}},{"line":665,"address":[5817699,5817748],"length":1,"stats":{"Line":0}},{"line":666,"address":[6082963],"length":1,"stats":{"Line":0}},{"line":667,"address":[6083119,6083160],"length":1,"stats":{"Line":0}},{"line":668,"address":[6083226],"length":1,"stats":{"Line":0}},{"line":675,"address":[6081873],"length":1,"stats":{"Line":0}},{"line":680,"address":[3607024],"length":1,"stats":{"Line":1}},{"line":684,"address":[5365432],"length":1,"stats":{"Line":1}},{"line":685,"address":[6083426,6083732],"length":1,"stats":{"Line":3}},{"line":686,"address":[3607253,3607154],"length":1,"stats":{"Line":3}},{"line":687,"address":[6083638],"length":1,"stats":{"Line":1}},{"line":688,"address":[5533965],"length":1,"stats":{"Line":1}},{"line":690,"address":[5365731],"length":1,"stats":{"Line":2}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[5818601],"length":1,"stats":{"Line":0}},{"line":699,"address":[3310064,3312566,3312647],"length":1,"stats":{"Line":1}},{"line":700,"address":[5701909],"length":1,"stats":{"Line":1}},{"line":703,"address":[3607542,3607614],"length":1,"stats":{"Line":2}},{"line":704,"address":[6084085,6084010],"length":1,"stats":{"Line":2}},{"line":706,"address":[6084205,6084134],"length":1,"stats":{"Line":2}},{"line":707,"address":[6084403,6084240,6084327],"length":1,"stats":{"Line":3}},{"line":709,"address":[5819717,5819852,5819341],"length":1,"stats":{"Line":3}},{"line":710,"address":[6084904,6085881,6086402,6086005],"length":1,"stats":{"Line":6}},{"line":711,"address":[5704150,5704252,5704179],"length":1,"stats":{"Line":4}},{"line":712,"address":[6086244,6086332],"length":1,"stats":{"Line":2}},{"line":717,"address":[5367084,5366993],"length":1,"stats":{"Line":2}},{"line":719,"address":[5535247,5535622],"length":1,"stats":{"Line":2}},{"line":721,"address":[5367670],"length":1,"stats":{"Line":1}},{"line":722,"address":[3609246],"length":1,"stats":{"Line":1}},{"line":730,"address":[5536704,5538077,5538366],"length":1,"stats":{"Line":2}},{"line":732,"address":[5704587],"length":1,"stats":{"Line":2}},{"line":733,"address":[3313127,3312865,3312800,3313032,3313345],"length":1,"stats":{"Line":7}},{"line":736,"address":[3610547,3610377],"length":1,"stats":{"Line":2}},{"line":743,"address":[5369363],"length":1,"stats":{"Line":1}},{"line":744,"address":[3611059,3611296,3611198,3611130],"length":1,"stats":{"Line":3}},{"line":745,"address":[5822618,5822661],"length":1,"stats":{"Line":2}},{"line":746,"address":[3313868,3313944],"length":1,"stats":{"Line":2}},{"line":749,"address":[5537861],"length":1,"stats":{"Line":0}},{"line":753,"address":[5822872],"length":1,"stats":{"Line":1}},{"line":755,"address":[3314103],"length":1,"stats":{"Line":1}},{"line":756,"address":[5369908],"length":1,"stats":{"Line":1}},{"line":757,"address":[6087916],"length":1,"stats":{"Line":1}},{"line":763,"address":[5823168,5823632,5823638],"length":1,"stats":{"Line":1}},{"line":765,"address":[5370223],"length":1,"stats":{"Line":1}},{"line":766,"address":[6088231,6088603,6088307],"length":1,"stats":{"Line":2}},{"line":771,"address":[5370688],"length":1,"stats":{"Line":0}},{"line":772,"address":[3612305],"length":1,"stats":{"Line":0}}],"covered":256,"coverable":325},{"path":["/","home","imalison","Projects","lastfm-edit","src","retry.rs"],"content":"use crate::types::{LastFmError, RetryConfig, RetryResult};\nuse crate::Result;\nuse std::future::Future;\nuse std::time::{Instant, SystemTime, UNIX_EPOCH};\n\n/// Execute an async operation with retry logic for rate limiting\n///\n/// This function handles the common pattern of retrying operations that may fail\n/// due to rate limiting, with exponential backoff and configurable limits.\n///\n/// # Arguments\n/// * `config` - Retry configuration\n/// * `operation_name` - Name of the operation for logging\n/// * `operation` - Async function that returns a Result\n/// * `on_rate_limit` - Callback for rate limit events (delay in seconds, timestamp)\n/// * `on_rate_limit_end` - Optional callback for when rate limiting ends (total duration in seconds)\n///\n/// # Returns\n/// A `RetryResult` containing the successful result and retry statistics\npub async fn retry_with_backoff\u003cT, F, Fut, OnRateLimit, OnRateLimitEnd\u003e(\n    config: RetryConfig,\n    operation_name: \u0026str,\n    mut operation: F,\n    mut on_rate_limit: OnRateLimit,\n    mut on_rate_limit_end: OnRateLimitEnd,\n) -\u003e Result\u003cRetryResult\u003cT\u003e\u003e\nwhere\n    F: FnMut() -\u003e Fut,\n    Fut: Future\u003cOutput = Result\u003cT\u003e\u003e,\n    OnRateLimit: FnMut(u64, u64, \u0026str),\n    OnRateLimitEnd: FnMut(u64, \u0026str),\n{\n    let mut retries = 0;\n    let mut total_retry_time = 0;\n    let mut rate_limit_start_time: Option\u003cInstant\u003e = None;\n\n    loop {\n        match operation().await {\n            Ok(result) =\u003e {\n                // If we had rate limiting and now succeeded, emit rate limit end event\n                if let Some(start_time) = rate_limit_start_time {\n                    let total_duration = start_time.elapsed().as_secs();\n                    on_rate_limit_end(total_duration, operation_name);\n                }\n\n                return Ok(RetryResult {\n                    result,\n                    attempts_made: retries,\n                    total_retry_time,\n                });\n            }\n            Err(LastFmError::RateLimit { retry_after }) =\u003e {\n                // Track when rate limiting first occurs\n                if rate_limit_start_time.is_none() {\n                    rate_limit_start_time = Some(Instant::now());\n                }\n\n                if !config.enabled || retries \u003e= config.max_retries {\n                    if !config.enabled {\n                        log::debug!(\"Retries disabled for {operation_name} operation\");\n                    } else {\n                        log::warn!(\n                            \"Max retries ({}) exceeded for {operation_name} operation\",\n                            config.max_retries\n                        );\n                    }\n                    return Err(LastFmError::RateLimit { retry_after });\n                }\n\n                // Calculate delay with exponential backoff\n                let base_backoff = config.base_delay * 2_u64.pow(retries);\n                let delay = std::cmp::min(\n                    std::cmp::min(retry_after + base_backoff, config.max_delay),\n                    retry_after + (retries as u64 * 30), // Legacy backoff for compatibility\n                );\n\n                log::info!(\n                    \"{} rate limited. Waiting {} seconds before retry {} of {}\",\n                    operation_name,\n                    delay,\n                    retries + 1,\n                    config.max_retries\n                );\n\n                // Notify caller about rate limit\n                let timestamp = SystemTime::now()\n                    .duration_since(UNIX_EPOCH)\n                    .unwrap_or_default()\n                    .as_secs();\n                on_rate_limit(delay, timestamp, operation_name);\n\n                tokio::time::sleep(std::time::Duration::from_secs(delay)).await;\n                retries += 1;\n                total_retry_time += delay;\n            }\n            Err(other_error) =\u003e {\n                return Err(other_error);\n            }\n        }\n    }\n}\n\n/// Simplified retry function for operations that don't need custom rate limit handling\npub async fn retry_operation\u003cT, F, Fut\u003e(\n    config: RetryConfig,\n    operation_name: \u0026str,\n    operation: F,\n) -\u003e Result\u003cRetryResult\u003cT\u003e\u003e\nwhere\n    F: FnMut() -\u003e Fut,\n    Fut: Future\u003cOutput = Result\u003cT\u003e\u003e,\n{\n    retry_with_backoff(\n        config,\n        operation_name,\n        operation,\n        |delay, timestamp, op_name| {\n            log::debug!(\n                \"Rate limited during {op_name}: waiting {delay} seconds (at timestamp {timestamp})\"\n            );\n        },\n        |duration, op_name| {\n            log::debug!(\"Rate limiting ended for {op_name} after {duration} seconds\");\n        },\n    )\n    .await\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::sync::atomic::{AtomicU32, Ordering};\n    use std::sync::Arc;\n\n    #[tokio::test]\n    async fn test_successful_operation() {\n        let config = RetryConfig {\n            max_retries: 3,\n            base_delay: 1,\n            max_delay: 60,\n            enabled: true,\n        };\n\n        let result = retry_operation(config, \"test\", || async { Ok::\u003ci32, LastFmError\u003e(42) }).await;\n\n        assert!(result.is_ok());\n        let retry_result = result.unwrap();\n        assert_eq!(retry_result.result, 42);\n        assert_eq!(retry_result.attempts_made, 0);\n        assert_eq!(retry_result.total_retry_time, 0);\n    }\n\n    #[tokio::test]\n    async fn test_retry_on_rate_limit() {\n        let config = RetryConfig {\n            max_retries: 2,\n            base_delay: 1,\n            max_delay: 60,\n            enabled: true,\n        };\n\n        let call_count = Arc::new(AtomicU32::new(0));\n        let call_count_clone = call_count.clone();\n\n        let result = retry_operation(config, \"test\", move || {\n            let count = call_count_clone.fetch_add(1, Ordering::SeqCst);\n            async move {\n                if count \u003c 2 {\n                    Err(LastFmError::RateLimit { retry_after: 1 })\n                } else {\n                    Ok::\u003ci32, LastFmError\u003e(42)\n                }\n            }\n        })\n        .await;\n\n        assert!(result.is_ok());\n        let retry_result = result.unwrap();\n        assert_eq!(retry_result.result, 42);\n        assert_eq!(retry_result.attempts_made, 2);\n        assert!(retry_result.total_retry_time \u003e= 2); // At least 2 seconds of delay\n    }\n\n    #[tokio::test]\n    async fn test_max_retries_exceeded() {\n        let config = RetryConfig {\n            max_retries: 1,\n            base_delay: 1,\n            max_delay: 60,\n            enabled: true,\n        };\n\n        let result = retry_operation(config, \"test\", || async {\n            Err::\u003ci32, LastFmError\u003e(LastFmError::RateLimit { retry_after: 1 })\n        })\n        .await;\n\n        assert!(result.is_err());\n        match result.unwrap_err() {\n            LastFmError::RateLimit { .. } =\u003e {} // Expected\n            other =\u003e panic!(\"Expected rate limit error, got: {other:?}\"),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_retries_disabled() {\n        let config = RetryConfig::disabled();\n\n        let result = retry_operation(config, \"test\", || async {\n            Err::\u003ci32, LastFmError\u003e(LastFmError::RateLimit { retry_after: 1 })\n        })\n        .await;\n\n        assert!(result.is_err());\n        match result.unwrap_err() {\n            LastFmError::RateLimit { .. } =\u003e {} // Expected - should fail immediately\n            other =\u003e panic!(\"Expected rate limit error, got: {other:?}\"),\n        }\n    }\n}\n","traces":[{"line":20,"address":[5877168,5877360,5877504],"length":1,"stats":{"Line":7}},{"line":33,"address":[5995389,5985930,5990559],"length":1,"stats":{"Line":10}},{"line":34,"address":[3413500,3409004,3395242,3404479,3390609,3386028,3399804],"length":1,"stats":{"Line":7}},{"line":35,"address":[5882676,5878047,5887506],"length":1,"stats":{"Line":8}},{"line":37,"address":[5991275,5995444,5985982,5986631,5990611,5996095],"length":1,"stats":{"Line":12}},{"line":38,"address":[6269730,6265563,6260212,6269646,6260854,6260184,6264841,6270318,6270383,6265498,6264901,6269674,6260919,6264813,6260272],"length":1,"stats":{"Line":28}},{"line":39,"address":[5934257,5929573,5939040],"length":1,"stats":{"Line":6}},{"line":41,"address":[6008475,5999008,6003698],"length":1,"stats":{"Line":8}},{"line":42,"address":[5939329,5929664,5934607,5934354,5929853,5939140],"length":1,"stats":{"Line":4}},{"line":43,"address":[5929907,5939383,5934661],"length":1,"stats":{"Line":2}},{"line":46,"address":[5996701,5991949,5987225],"length":1,"stats":{"Line":8}},{"line":47,"address":[3759607],"length":1,"stats":{"Line":2}},{"line":48,"address":[5996672,5987196,5991905],"length":1,"stats":{"Line":8}},{"line":49,"address":[5929722,5934438,5939198],"length":1,"stats":{"Line":6}},{"line":52,"address":[],"length":0,"stats":{"Line":4}},{"line":54,"address":[5992520,5997333,5987732,5987553,5997216,5992316,5997033,5992631,5987843],"length":1,"stats":{"Line":12}},{"line":55,"address":[6261933,6271417,6266721],"length":1,"stats":{"Line":4}},{"line":58,"address":[],"length":0,"stats":{"Line":7}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[5881394,5891005,5886292,5881303,5886177,5890811,5881497,5890902,5886086],"length":1,"stats":{"Line":3}},{"line":62,"address":[6263441,6268661,6272949,6273381,6263870,6268224],"length":1,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[3761839,3766564,3757056],"length":1,"stats":{"Line":2}},{"line":71,"address":[5999941,5999821,6004729,6009311,6009434,6004609],"length":1,"stats":{"Line":3}},{"line":73,"address":[5940055,5930562,5930515,5935303,5935350,5940008],"length":1,"stats":{"Line":6}},{"line":74,"address":[3760618,3760765,3755977,3765326,3765473,3755830],"length":1,"stats":{"Line":3}},{"line":77,"address":[6267253,6272264,6267501,6262465,6262765,6272216,6272045,6267337,6262549,6267549,6271961,6262717],"length":1,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":3}},{"line":92,"address":[3132504,3134936,3132984],"length":1,"stats":{"Line":9}},{"line":93,"address":[3758765,3754231,3763690,3763591,3754132,3758864],"length":1,"stats":{"Line":3}},{"line":94,"address":[5933601,5938551,5929091,5933676,5928968,5929043,5933728,5938427,5938502],"length":1,"stats":{"Line":6}},{"line":96,"address":[5987586,5997069,5992349],"length":1,"stats":{"Line":0}},{"line":97,"address":[5884512,5889220,5879736],"length":1,"stats":{"Line":0}},{"line":104,"address":[3417776,3417840,3417904,3417968],"length":1,"stats":{"Line":4}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[3421264,3420880,3420496,3421648],"length":1,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":4}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":14}}],"covered":37,"coverable":51},{"path":["/","home","imalison","Projects","lastfm-edit","src","session_persistence.rs"],"content":"use crate::types::{LastFmEditSession, LastFmError};\nuse crate::Result;\nuse std::fs;\nuse std::path::PathBuf;\n\n/// Configurable session manager for storing session data in XDG directories.\n///\n/// This struct allows customization of the application prefix for session storage.\n/// Sessions are stored per-user in the format:\n/// `~/.local/share/{app_name}/users/{username}/session.json`\n#[derive(Clone, Debug)]\npub struct SessionManager {\n    app_name: String,\n}\n\nimpl SessionManager {\n    /// Create a new session manager with a custom application name.\n    ///\n    /// # Arguments\n    /// * `app_name` - The application name to use as the directory prefix\n    pub fn new(app_name: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            app_name: app_name.into(),\n        }\n    }\n\n    /// Get the session file path for a given username using the configured app name.\n    ///\n    /// Returns a path like: `~/.local/share/{app_name}/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns the path where the session should be stored, or an error if\n    /// the XDG data directory cannot be determined.\n    pub fn get_session_path(\u0026self, username: \u0026str) -\u003e Result\u003cPathBuf\u003e {\n        let data_dir = dirs::data_dir()\n            .ok_or_else(|| LastFmError::Http(\"Cannot determine XDG data directory\".to_string()))?;\n\n        let session_dir = data_dir.join(\u0026self.app_name).join(\"users\").join(username);\n\n        Ok(session_dir.join(\"session.json\"))\n    }\n\n    /// Save a session to the XDG data directory.\n    ///\n    /// This creates the necessary directory structure and saves the session\n    /// as JSON to `~/.local/share/{app_name}/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `session` - The session to save\n    ///\n    /// # Returns\n    /// Returns Ok(()) on success, or an error if the save fails.\n    pub fn save_session(\u0026self, session: \u0026LastFmEditSession) -\u003e Result\u003c()\u003e {\n        let session_path = self.get_session_path(\u0026session.username)?;\n\n        // Create parent directories if they don't exist\n        if let Some(parent) = session_path.parent() {\n            fs::create_dir_all(parent).map_err(|e| {\n                LastFmError::Http(format!(\"Failed to create session directory: {e}\"))\n            })?;\n        }\n\n        // Serialize session to JSON\n        let session_json = session\n            .to_json()\n            .map_err(|e| LastFmError::Http(format!(\"Failed to serialize session: {e}\")))?;\n\n        // Write to file\n        fs::write(\u0026session_path, session_json)\n            .map_err(|e| LastFmError::Http(format!(\"Failed to write session file: {e}\")))?;\n\n        log::debug!(\"Session saved to: {}\", session_path.display());\n        Ok(())\n    }\n\n    /// Load a session from the XDG data directory.\n    ///\n    /// Attempts to load a session from `~/.local/share/{app_name}/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns the loaded session on success, or an error if the file doesn't exist\n    /// or cannot be parsed.\n    pub fn load_session(\u0026self, username: \u0026str) -\u003e Result\u003cLastFmEditSession\u003e {\n        let session_path = self.get_session_path(username)?;\n\n        if !session_path.exists() {\n            return Err(LastFmError::Http(format!(\n                \"No saved session found for user: {username}\"\n            )));\n        }\n\n        // Read and parse session file\n        let session_json = fs::read_to_string(\u0026session_path)\n            .map_err(|e| LastFmError::Http(format!(\"Failed to read session file: {e}\")))?;\n\n        let session = LastFmEditSession::from_json(\u0026session_json)\n            .map_err(|e| LastFmError::Http(format!(\"Failed to parse session JSON: {e}\")))?;\n\n        log::debug!(\"Session loaded from: {}\", session_path.display());\n        Ok(session)\n    }\n\n    /// Check if a saved session exists for the given username.\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns true if a session file exists, false otherwise.\n    pub fn session_exists(\u0026self, username: \u0026str) -\u003e bool {\n        match self.get_session_path(username) {\n            Ok(path) =\u003e path.exists(),\n            Err(_) =\u003e false,\n        }\n    }\n\n    /// Remove a saved session for the given username.\n    ///\n    /// This deletes the session file from the XDG data directory.\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns Ok(()) on success, or an error if the deletion fails.\n    pub fn remove_session(\u0026self, username: \u0026str) -\u003e Result\u003c()\u003e {\n        let session_path = self.get_session_path(username)?;\n\n        if session_path.exists() {\n            fs::remove_file(\u0026session_path)\n                .map_err(|e| LastFmError::Http(format!(\"Failed to remove session file: {e}\")))?;\n            log::debug!(\"Session removed from: {}\", session_path.display());\n        }\n\n        Ok(())\n    }\n\n    /// List all usernames that have saved sessions.\n    ///\n    /// Scans the XDG data directory for session files and returns the usernames.\n    ///\n    /// # Returns\n    /// Returns a vector of usernames that have saved sessions.\n    pub fn list_saved_users(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        let data_dir = dirs::data_dir()\n            .ok_or_else(|| LastFmError::Http(\"Cannot determine XDG data directory\".to_string()))?;\n\n        let users_dir = data_dir.join(\u0026self.app_name).join(\"users\");\n\n        if !users_dir.exists() {\n            return Ok(Vec::new());\n        }\n\n        let mut users = Vec::new();\n        let entries = fs::read_dir(\u0026users_dir)\n            .map_err(|e| LastFmError::Http(format!(\"Failed to read users directory: {e}\")))?;\n\n        for entry in entries {\n            let entry = entry\n                .map_err(|e| LastFmError::Http(format!(\"Failed to read directory entry: {e}\")))?;\n\n            if entry.file_type().map(|t| t.is_dir()).unwrap_or(false) {\n                let session_file = entry.path().join(\"session.json\");\n                if session_file.exists() {\n                    if let Some(username) = entry.file_name().to_str() {\n                        users.push(username.to_string());\n                    }\n                }\n            }\n        }\n\n        Ok(users)\n    }\n\n    /// Get the application name used by this session manager.\n    pub fn app_name(\u0026self) -\u003e \u0026str {\n        \u0026self.app_name\n    }\n}\n\n/// Session persistence utilities for managing session data in XDG directories.\n///\n/// This module provides functionality to save and load Last.fm session data\n/// using the XDG Base Directory Specification. Sessions are stored per-user\n/// in the format: `~/.local/share/lastfm-edit/users/{username}/session.json`\n///\n/// # Deprecated\n/// Use [`SessionManager`] instead for more flexibility and customization.\npub struct SessionPersistence;\n\nimpl SessionPersistence {\n    /// Get the default session manager for lastfm-edit.\n    fn default_manager() -\u003e SessionManager {\n        SessionManager::new(\"lastfm-edit\")\n    }\n\n    /// Get the session file path for a given username using XDG directories.\n    ///\n    /// Returns a path like: `~/.local/share/lastfm-edit/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns the path where the session should be stored, or an error if\n    /// the XDG data directory cannot be determined.\n    pub fn get_session_path(username: \u0026str) -\u003e Result\u003cPathBuf\u003e {\n        Self::default_manager().get_session_path(username)\n    }\n\n    /// Save a session to the XDG data directory.\n    ///\n    /// This creates the necessary directory structure and saves the session\n    /// as JSON to `~/.local/share/lastfm-edit/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `session` - The session to save\n    ///\n    /// # Returns\n    /// Returns Ok(()) on success, or an error if the save fails.\n    pub fn save_session(session: \u0026LastFmEditSession) -\u003e Result\u003c()\u003e {\n        Self::default_manager().save_session(session)\n    }\n\n    /// Load a session from the XDG data directory.\n    ///\n    /// Attempts to load a session from `~/.local/share/lastfm-edit/users/{username}/session.json`\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns the loaded session on success, or an error if the file doesn't exist\n    /// or cannot be parsed.\n    pub fn load_session(username: \u0026str) -\u003e Result\u003cLastFmEditSession\u003e {\n        Self::default_manager().load_session(username)\n    }\n\n    /// Check if a saved session exists for the given username.\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns true if a session file exists, false otherwise.\n    pub fn session_exists(username: \u0026str) -\u003e bool {\n        Self::default_manager().session_exists(username)\n    }\n\n    /// Remove a saved session for the given username.\n    ///\n    /// This deletes the session file from the XDG data directory.\n    ///\n    /// # Arguments\n    /// * `username` - The Last.fm username\n    ///\n    /// # Returns\n    /// Returns Ok(()) on success, or an error if the deletion fails.\n    pub fn remove_session(username: \u0026str) -\u003e Result\u003c()\u003e {\n        Self::default_manager().remove_session(username)\n    }\n\n    /// List all usernames that have saved sessions.\n    ///\n    /// Scans the XDG data directory for session files and returns the usernames.\n    ///\n    /// # Returns\n    /// Returns a vector of usernames that have saved sessions.\n    pub fn list_saved_users() -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        Self::default_manager().list_saved_users()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_session_path_generation() {\n        let path = SessionPersistence::get_session_path(\"testuser\").unwrap();\n        assert!(path\n            .to_string_lossy()\n            .contains(\"lastfm-edit/users/testuser/session.json\"));\n    }\n\n    #[test]\n    fn test_session_exists_nonexistent() {\n        let fake_username = format!(\"nonexistent_user_{}\", std::process::id());\n        assert!(!SessionPersistence::session_exists(\u0026fake_username));\n    }\n}\n","traces":[{"line":21,"address":[5892368],"length":1,"stats":{"Line":2}},{"line":23,"address":[5892391],"length":1,"stats":{"Line":2}},{"line":37,"address":[5456851,5456845,5455968],"length":1,"stats":{"Line":2}},{"line":38,"address":[3171937,3171784],"length":1,"stats":{"Line":2}},{"line":39,"address":[5727875],"length":1,"stats":{"Line":0}},{"line":41,"address":[3172101,3172028],"length":1,"stats":{"Line":4}},{"line":43,"address":[3172464],"length":1,"stats":{"Line":2}},{"line":56,"address":[5730323,5728624,5730331],"length":1,"stats":{"Line":1}},{"line":57,"address":[5456924],"length":1,"stats":{"Line":1}},{"line":60,"address":[5636021,5635950],"length":1,"stats":{"Line":2}},{"line":61,"address":[3180480,3180715,3180721],"length":1,"stats":{"Line":2}},{"line":62,"address":[5892647,5892582],"length":1,"stats":{"Line":0}},{"line":67,"address":[5636462,5636152,5637321,5636340],"length":1,"stats":{"Line":2}},{"line":69,"address":[5510864,5510886],"length":1,"stats":{"Line":0}},{"line":72,"address":[5458526,5458043,5457811,5457929],"length":1,"stats":{"Line":2}},{"line":73,"address":[5700726,5700704],"length":1,"stats":{"Line":0}},{"line":75,"address":[5811880,5811974],"length":1,"stats":{"Line":2}},{"line":76,"address":[5811940],"length":1,"stats":{"Line":1}},{"line":89,"address":[5637344,5639386,5639353],"length":1,"stats":{"Line":1}},{"line":90,"address":[5812441],"length":1,"stats":{"Line":1}},{"line":92,"address":[3174589,3174660],"length":1,"stats":{"Line":2}},{"line":93,"address":[3293813,3293756],"length":1,"stats":{"Line":0}},{"line":99,"address":[3294058,3293783,3294177,3295413],"length":1,"stats":{"Line":2}},{"line":100,"address":[5638113],"length":1,"stats":{"Line":0}},{"line":102,"address":[3294349,3294278,3294496],"length":1,"stats":{"Line":2}},{"line":103,"address":[5731440],"length":1,"stats":{"Line":0}},{"line":105,"address":[3294807,3295011,3294717],"length":1,"stats":{"Line":3}},{"line":106,"address":[3294822],"length":1,"stats":{"Line":1}},{"line":116,"address":[3176607,3176613,3176336],"length":1,"stats":{"Line":2}},{"line":117,"address":[6030719],"length":1,"stats":{"Line":2}},{"line":118,"address":[5814541],"length":1,"stats":{"Line":2}},{"line":119,"address":[5814531],"length":1,"stats":{"Line":0}},{"line":132,"address":[3177631,3176672,3177625],"length":1,"stats":{"Line":1}},{"line":133,"address":[6031065],"length":1,"stats":{"Line":1}},{"line":135,"address":[5640078,5640010],"length":1,"stats":{"Line":2}},{"line":136,"address":[3296296,3296159],"length":1,"stats":{"Line":1}},{"line":137,"address":[5815288],"length":1,"stats":{"Line":0}},{"line":138,"address":[6031573],"length":1,"stats":{"Line":1}},{"line":141,"address":[5815160],"length":1,"stats":{"Line":1}},{"line":150,"address":[5818289,5818191,5815792],"length":1,"stats":{"Line":1}},{"line":151,"address":[3296973,3296807],"length":1,"stats":{"Line":1}},{"line":152,"address":[5733885],"length":1,"stats":{"Line":0}},{"line":154,"address":[5462378,5462287],"length":1,"stats":{"Line":2}},{"line":156,"address":[5734345],"length":1,"stats":{"Line":1}},{"line":157,"address":[5462679,5462633],"length":1,"stats":{"Line":0}},{"line":160,"address":[3297436],"length":1,"stats":{"Line":1}},{"line":161,"address":[3178421,3180085,3178586,3178488],"length":1,"stats":{"Line":2}},{"line":162,"address":[5641657],"length":1,"stats":{"Line":0}},{"line":164,"address":[5641865,5641771,5641950],"length":1,"stats":{"Line":3}},{"line":165,"address":[3298221,3298319,3298044],"length":1,"stats":{"Line":2}},{"line":166,"address":[5894448,5894470],"length":1,"stats":{"Line":0}},{"line":168,"address":[3179376,3179289],"length":1,"stats":{"Line":4}},{"line":169,"address":[5817623],"length":1,"stats":{"Line":1}},{"line":170,"address":[3179649],"length":1,"stats":{"Line":1}},{"line":171,"address":[5735960,5735854],"length":1,"stats":{"Line":2}},{"line":172,"address":[5736066,5736107],"length":1,"stats":{"Line":2}},{"line":178,"address":[3298101],"length":1,"stats":{"Line":1}},{"line":182,"address":[5736256],"length":1,"stats":{"Line":1}},{"line":183,"address":[3180133],"length":1,"stats":{"Line":1}},{"line":199,"address":[5643264],"length":1,"stats":{"Line":1}},{"line":200,"address":[5643272],"length":1,"stats":{"Line":1}},{"line":213,"address":[5643435,5643296,5643429],"length":1,"stats":{"Line":1}},{"line":214,"address":[3299372],"length":1,"stats":{"Line":1}},{"line":227,"address":[3299488,3299606,3299612],"length":1,"stats":{"Line":0}},{"line":228,"address":[5464738],"length":1,"stats":{"Line":0}},{"line":241,"address":[3180572,3180578,3180448],"length":1,"stats":{"Line":0}},{"line":242,"address":[5818700],"length":1,"stats":{"Line":0}},{"line":252,"address":[6035167,6035161,6035040],"length":1,"stats":{"Line":1}},{"line":253,"address":[5818849],"length":1,"stats":{"Line":1}},{"line":265,"address":[3300069,3299936,3300075],"length":1,"stats":{"Line":0}},{"line":266,"address":[3299980],"length":1,"stats":{"Line":0}},{"line":275,"address":[5819223,5819120,5819229],"length":1,"stats":{"Line":0}},{"line":276,"address":[3300120],"length":1,"stats":{"Line":0}}],"covered":52,"coverable":73},{"path":["/","home","imalison","Projects","lastfm-edit","src","trait.rs"],"content":"use crate::iterator::AsyncPaginatedIterator;\nuse crate::types::{\n    Album, Artist, ArtistPage, ClientEvent, ClientEventReceiver, EditResponse, ExactScrobbleEdit,\n    LastFmEditSession, ScrobbleEdit, Track,\n};\nuse crate::Result;\nuse async_trait::async_trait;\n\n/// Trait for Last.fm client operations that can be mocked for testing.\n///\n/// This trait abstracts the core functionality needed for Last.fm scrobble editing\n/// to enable easy mocking and testing. All methods that perform network operations or\n/// state changes are included to support comprehensive test coverage.\n///\n/// # Mocking Support\n///\n/// When the `mock` feature is enabled, this crate provides `MockLastFmEditClient`\n/// that implements this trait using the `mockall` library.\n///\n#[cfg_attr(feature = \"mock\", mockall::automock)]\n#[async_trait(?Send)]\npub trait LastFmEditClient {\n    // =============================================================================\n    // CORE EDITING METHODS - Most important functionality\n    // =============================================================================\n\n    /// Edit scrobbles by discovering and updating all matching instances.\n    ///\n    /// This is the main editing method that automatically discovers all scrobble instances\n    /// that match the provided criteria and applies the specified changes to each one.\n    ///\n    /// # How it works\n    ///\n    /// 1. **Discovery**: Analyzes the `ScrobbleEdit` to determine what to search for:\n    ///    - If `track_name_original` is specified: finds all album variations of that track\n    ///    - If only `album_name_original` is specified: finds all tracks in that album\n    ///    - If neither is specified: finds all tracks by that artist\n    ///\n    /// 2. **Enrichment**: For each discovered scrobble, extracts complete metadata\n    ///    including album artist information from the user's library\n    ///\n    /// 3. **Editing**: Applies the requested changes to each discovered instance\n    ///\n    /// # Arguments\n    ///\n    /// * `edit` - A `ScrobbleEdit` specifying what to find and how to change it\n    ///\n    /// # Returns\n    ///\n    /// Returns an `EditResponse` containing results for all edited scrobbles, including:\n    /// - Overall success status\n    /// - Individual results for each scrobble instance\n    /// - Detailed error messages if any edits fail\n    ///\n    /// # Errors\n    ///\n    /// Returns `LastFmError::Parse` if no matching scrobbles are found, or other errors\n    /// for network/authentication issues.\n    ///\n    /// # Example\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, ScrobbleEdit, Result};\n    /// # async fn example(client: \u0026dyn LastFmEditClient) -\u003e Result\u003c()\u003e {\n    /// // Change track name for all instances of a track\n    /// let edit = ScrobbleEdit::from_track_and_artist(\"Old Track Name\", \"Artist\")\n    ///     .with_track_name(\"New Track Name\");\n    ///\n    /// let response = client.edit_scrobble(\u0026edit).await?;\n    /// if response.success() {\n    ///     println!(\"Successfully edited {} scrobbles\", response.total_edits());\n    /// }\n    /// # Ok(())\n    /// # }\n    /// ```\n    async fn edit_scrobble(\u0026self, edit: \u0026ScrobbleEdit) -\u003e Result\u003cEditResponse\u003e;\n\n    /// Edit a single scrobble with complete information and retry logic.\n    ///\n    /// This method performs a single edit operation on a fully-specified scrobble.\n    /// Unlike [`edit_scrobble`], this method does not perform discovery, enrichment,\n    /// or multiple edits - it edits exactly one scrobble instance.\n    ///\n    /// # Key Differences from `edit_scrobble`\n    ///\n    /// - **No discovery**: Requires a fully-specified `ExactScrobbleEdit`\n    /// - **Single edit**: Only edits one scrobble instance\n    /// - **No enrichment**: All fields must be provided upfront\n    /// - **Retry logic**: Automatically retries on rate limiting\n    ///\n    /// # Arguments\n    ///\n    /// * `exact_edit` - A fully-specified edit with all required fields populated,\n    ///   including original metadata and timestamps\n    /// * `max_retries` - Maximum number of retry attempts for rate limiting.\n    ///   The method will wait with exponential backoff between retries.\n    ///\n    /// # Returns\n    ///\n    /// Returns an `EditResponse` with a single result indicating success or failure.\n    /// If max retries are exceeded due to rate limiting, returns a failed response\n    /// rather than an error.\n    ///\n    /// # Example\n    ///\n    /// ```rust,no_run\n    /// # use lastfm_edit::{LastFmEditClient, ExactScrobbleEdit, Result};\n    /// # async fn example(client: \u0026dyn LastFmEditClient) -\u003e Result\u003c()\u003e {\n    /// let exact_edit = ExactScrobbleEdit::new(\n    ///     \"Original Track\".to_string(),\n    ///     \"Original Album\".to_string(),\n    ///     \"Artist\".to_string(),\n    ///     \"Artist\".to_string(),\n    ///     \"New Track Name\".to_string(),\n    ///     \"Original Album\".to_string(),\n    ///     \"Artist\".to_string(),\n    ///     \"Artist\".to_string(),\n    ///     1640995200, // timestamp\n    ///     false\n    /// );\n    ///\n    /// let response = client.edit_scrobble_single(\u0026exact_edit, 3).await?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    async fn edit_scrobble_single(\n        \u0026self,\n        exact_edit: \u0026ExactScrobbleEdit,\n        max_retries: u32,\n    ) -\u003e Result\u003cEditResponse\u003e;\n\n    /// Delete a scrobble by its identifying information.\n    ///\n    /// This method deletes a specific scrobble from the user's library using the\n    /// artist name, track name, and timestamp to uniquely identify it.\n    ///\n    /// # Arguments\n    ///\n    /// * `artist_name` - The artist name of the scrobble to delete\n    /// * `track_name` - The track name of the scrobble to delete\n    /// * `timestamp` - The unix timestamp of the scrobble to delete\n    ///\n    /// # Returns\n    ///\n    /// Returns `true` if the deletion was successful, `false` otherwise.\n    async fn delete_scrobble(\n        \u0026self,\n        artist_name: \u0026str,\n        track_name: \u0026str,\n        timestamp: u64,\n    ) -\u003e Result\u003cbool\u003e;\n\n    /// Create an incremental discovery iterator for scrobble editing.\n    ///\n    /// This returns the appropriate discovery iterator based on what fields are specified\n    /// in the ScrobbleEdit. The iterator yields `ExactScrobbleEdit` results incrementally,\n    /// which helps avoid rate limiting issues when discovering many scrobbles.\n    ///\n    /// Returns a `Box\u003cdyn AsyncDiscoveryIterator\u003cExactScrobbleEdit\u003e\u003e` to handle the different\n    /// discovery strategies uniformly.\n    fn discover_scrobbles(\n        \u0026self,\n        edit: ScrobbleEdit,\n    ) -\u003e Box\u003cdyn crate::AsyncDiscoveryIterator\u003ccrate::ExactScrobbleEdit\u003e\u003e;\n\n    // =============================================================================\n    // ITERATOR METHODS - Core library browsing functionality\n    // =============================================================================\n\n    /// Create an iterator for browsing all artists in the user's library.\n    fn artists(\u0026self) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cArtist\u003e\u003e;\n\n    /// Create an iterator for browsing an artist's tracks from the user's library.\n    fn artist_tracks(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for browsing an artist's tracks directly using the paginated endpoint.\n    ///\n    /// This alternative approach uses\n    /// `/user/{username}/library/music/{artist}/+tracks` directly with\n    /// pagination, which is more efficient than the album-based approach since\n    /// it doesn't need to iterate through albums first. The downside of this\n    /// approach is that the tracks will not come with album information, which\n    /// will need to get looked up eventually in the process of making edits.\n    fn artist_tracks_direct(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for browsing an artist's albums from the user's library.\n    fn artist_albums(\u0026self, artist: \u0026str) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cAlbum\u003e\u003e;\n\n    /// Create an iterator for browsing tracks from a specific album.\n    fn album_tracks(\n        \u0026self,\n        album_name: \u0026str,\n        artist_name: \u0026str,\n    ) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for browsing the user's recent tracks/scrobbles.\n    fn recent_tracks(\u0026self) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for browsing the user's recent tracks starting from a specific page.\n    fn recent_tracks_from_page(\u0026self, starting_page: u32)\n        -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for searching tracks in the user's library.\n    ///\n    /// This returns an iterator that uses Last.fm's library search functionality\n    /// to find tracks matching the provided query string. The iterator handles\n    /// pagination automatically.\n    ///\n    /// # Arguments\n    ///\n    /// * `query` - The search query (e.g., \"remaster\", \"live\", artist name, etc.)\n    ///\n    /// # Returns\n    ///\n    /// Returns a `SearchTracksIterator` for streaming search results.\n    fn search_tracks(\u0026self, query: \u0026str) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cTrack\u003e\u003e;\n\n    /// Create an iterator for searching albums in the user's library.\n    ///\n    /// This returns an iterator that uses Last.fm's library search functionality\n    /// to find albums matching the provided query string. The iterator handles\n    /// pagination automatically.\n    ///\n    /// # Arguments\n    ///\n    /// * `query` - The search query (e.g., \"remaster\", \"deluxe\", artist name, etc.)\n    ///\n    /// # Returns\n    ///\n    /// Returns a `SearchAlbumsIterator` for streaming search results.\n    fn search_albums(\u0026self, query: \u0026str) -\u003e Box\u003cdyn AsyncPaginatedIterator\u003cAlbum\u003e\u003e;\n\n    // =============================================================================\n    // SEARCH METHODS - Library search functionality\n    // =============================================================================\n\n    /// Get a single page of track search results from the user's library.\n    ///\n    /// This performs a search using Last.fm's library search functionality,\n    /// returning one page of tracks that match the provided query string.\n    /// For iterator-based access, use [`search_tracks`](Self::search_tracks) instead.\n    ///\n    /// # Arguments\n    ///\n    /// * `query` - The search query (e.g., \"remaster\", \"live\", artist name, etc.)\n    /// * `page` - The page number to retrieve (1-based)\n    ///\n    /// # Returns\n    ///\n    /// Returns a `TrackPage` containing the search results with pagination information.\n    async fn search_tracks_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003ccrate::TrackPage\u003e;\n\n    /// Get a single page of album search results from the user's library.\n    ///\n    /// This performs a search using Last.fm's library search functionality,\n    /// returning one page of albums that match the provided query string.\n    /// For iterator-based access, use [`search_albums`](Self::search_albums) instead.\n    ///\n    /// # Arguments\n    ///\n    /// * `query` - The search query (e.g., \"remaster\", \"deluxe\", artist name, etc.)\n    /// * `page` - The page number to retrieve (1-based)\n    ///\n    /// # Returns\n    ///\n    /// Returns an `AlbumPage` containing the search results with pagination information.\n    async fn search_albums_page(\u0026self, query: \u0026str, page: u32) -\u003e Result\u003ccrate::AlbumPage\u003e;\n\n    // =============================================================================\n    // CORE DATA METHODS - Essential data access\n    // =============================================================================\n\n    /// Get the currently authenticated username.\n    fn username(\u0026self) -\u003e String;\n\n    /// Find the most recent scrobble for a specific track.\n    async fn find_recent_scrobble_for_track(\n        \u0026self,\n        track_name: \u0026str,\n        artist_name: \u0026str,\n        max_pages: u32,\n    ) -\u003e Result\u003cOption\u003cTrack\u003e\u003e;\n\n    /// Get a page of artists from the user's library.\n    async fn get_artists_page(\u0026self, page: u32) -\u003e Result\u003cArtistPage\u003e;\n\n    /// Get a page of tracks from the user's library for the specified artist.\n    async fn get_artist_tracks_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003ccrate::TrackPage\u003e;\n\n    /// Get a page of albums from the user's library for the specified artist.\n    async fn get_artist_albums_page(\u0026self, artist: \u0026str, page: u32) -\u003e Result\u003ccrate::AlbumPage\u003e;\n\n    /// Get a page of tracks from a specific album in the user's library.\n    async fn get_album_tracks_page(\n        \u0026self,\n        album_name: \u0026str,\n        artist_name: \u0026str,\n        page: u32,\n    ) -\u003e Result\u003ccrate::TrackPage\u003e;\n\n    /// Get a page of tracks from the user's recent listening history.\n    async fn get_recent_tracks_page(\u0026self, page: u32) -\u003e Result\u003ccrate::TrackPage\u003e;\n\n    // =============================================================================\n    // CONVENIENCE METHODS - Higher-level helpers and shortcuts\n    // =============================================================================\n\n    /// Discover all scrobble edit variations based on the provided ScrobbleEdit template.\n    ///\n    /// This method analyzes what fields are specified in the input ScrobbleEdit and discovers\n    /// all relevant scrobble instances that match the criteria:\n    /// - If track_name_original is specified: discovers all album variations of that track\n    /// - If only album_name_original is specified: discovers all tracks in that album\n    /// - If neither is specified: discovers all tracks by that artist\n    ///\n    /// Returns fully-specified ExactScrobbleEdit instances with all metadata populated\n    /// from the user's library, ready for editing operations.\n    async fn discover_scrobble_edit_variations(\n        \u0026self,\n        edit: \u0026ScrobbleEdit,\n    ) -\u003e Result\u003cVec\u003cExactScrobbleEdit\u003e\u003e {\n        // Use the incremental iterator and collect all results\n        let mut discovery_iterator = self.discover_scrobbles(edit.clone());\n        discovery_iterator.collect_all().await\n    }\n\n    /// Edit album metadata by updating scrobbles with new album name.\n    async fn edit_album(\n        \u0026self,\n        old_album_name: \u0026str,\n        new_album_name: \u0026str,\n        artist_name: \u0026str,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        log::debug!(\"Editing album '{old_album_name}' -\u003e '{new_album_name}' by '{artist_name}'\");\n\n        let edit = ScrobbleEdit::for_album(old_album_name, artist_name, artist_name)\n            .with_album_name(new_album_name);\n\n        self.edit_scrobble(\u0026edit).await\n    }\n\n    /// Edit artist metadata by updating scrobbles with new artist name.\n    ///\n    /// This edits ALL tracks from the artist that are found in recent scrobbles.\n    async fn edit_artist(\n        \u0026self,\n        old_artist_name: \u0026str,\n        new_artist_name: \u0026str,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        log::debug!(\"Editing artist '{old_artist_name}' -\u003e '{new_artist_name}'\");\n\n        let edit = ScrobbleEdit::for_artist(old_artist_name, new_artist_name);\n\n        self.edit_scrobble(\u0026edit).await\n    }\n\n    /// Edit artist metadata for a specific track only.\n    ///\n    /// This edits only the specified track if found in recent scrobbles.\n    async fn edit_artist_for_track(\n        \u0026self,\n        track_name: \u0026str,\n        old_artist_name: \u0026str,\n        new_artist_name: \u0026str,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        log::debug!(\"Editing artist for track '{track_name}' from '{old_artist_name}' -\u003e '{new_artist_name}'\");\n\n        let edit = ScrobbleEdit::from_track_and_artist(track_name, old_artist_name)\n            .with_artist_name(new_artist_name);\n\n        self.edit_scrobble(\u0026edit).await\n    }\n\n    /// Edit artist metadata for all tracks in a specific album.\n    ///\n    /// This edits ALL tracks from the specified album that are found in recent scrobbles.\n    async fn edit_artist_for_album(\n        \u0026self,\n        album_name: \u0026str,\n        old_artist_name: \u0026str,\n        new_artist_name: \u0026str,\n    ) -\u003e Result\u003cEditResponse\u003e {\n        log::debug!(\"Editing artist for album '{album_name}' from '{old_artist_name}' -\u003e '{new_artist_name}'\");\n\n        let edit = ScrobbleEdit::for_album(album_name, old_artist_name, old_artist_name)\n            .with_artist_name(new_artist_name);\n\n        self.edit_scrobble(\u0026edit).await\n    }\n\n    // =============================================================================\n    // SESSION \u0026 EVENT MANAGEMENT - Authentication and monitoring\n    // =============================================================================\n\n    /// Extract the current session state for persistence.\n    ///\n    /// This allows you to save the authentication state and restore it later\n    /// without requiring the user to log in again.\n    ///\n    /// # Returns\n    ///\n    /// Returns a [`LastFmEditSession`] that can be serialized and saved.\n    fn get_session(\u0026self) -\u003e LastFmEditSession;\n\n    /// Subscribe to internal client events.\n    ///\n    /// Returns a broadcast receiver that can be used to listen to events like rate limiting.\n    /// Multiple subscribers can listen simultaneously.\n    ///\n    /// # Example\n    /// ```rust,no_run\n    /// use lastfm_edit::{LastFmEditClientImpl, LastFmEditSession, ClientEvent};\n    ///\n    /// let http_client = http_client::native::NativeClient::new();\n    /// let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let client = LastFmEditClientImpl::from_session(Box::new(http_client), test_session);\n    /// let mut events = client.subscribe();\n    ///\n    /// // Listen for events in a background task\n    /// tokio::spawn(async move {\n    ///     while let Ok(event) = events.recv().await {\n    ///         match event {\n    ///             ClientEvent::RequestStarted { request } =\u003e {\n    ///                 println!(\"Request started: {}\", request.short_description());\n    ///             }\n    ///             ClientEvent::RequestCompleted { request, status_code, duration_ms } =\u003e {\n    ///                 println!(\"Request completed: {} - {} ({} ms)\", request.short_description(), status_code, duration_ms);\n    ///             }\n    ///             ClientEvent::RateLimited { delay_seconds, .. } =\u003e {\n    ///                 println!(\"Rate limited! Waiting {} seconds\", delay_seconds);\n    ///             }\n    ///             ClientEvent::RateLimitEnded { total_rate_limit_duration_seconds, .. } =\u003e {\n    ///                 println!(\"Rate limiting ended after {} seconds\", total_rate_limit_duration_seconds);\n    ///             }\n    ///             ClientEvent::EditAttempted { edit, success, .. } =\u003e {\n    ///                 println!(\"Edit attempt: '{}' -\u003e '{}' - {}\",\n    ///                          edit.track_name_original, edit.track_name,\n    ///                          if success { \"Success\" } else { \"Failed\" });\n    ///             }\n    ///         }\n    ///     }\n    /// });\n    /// ```\n    fn subscribe(\u0026self) -\u003e ClientEventReceiver;\n\n    /// Get the latest client event without subscribing to future events.\n    ///\n    /// This returns the most recent event that occurred, or `None` if no events have occurred yet.\n    /// Unlike `subscribe()`, this provides instant access to the current state without waiting.\n    ///\n    /// # Example\n    /// ```rust,no_run\n    /// use lastfm_edit::{LastFmEditClientImpl, LastFmEditSession, ClientEvent};\n    ///\n    /// let http_client = http_client::native::NativeClient::new();\n    /// let test_session = LastFmEditSession::new(\"test\".to_string(), vec![\"sessionid=.test123\".to_string()], Some(\"csrf\".to_string()), \"https://www.last.fm\".to_string());\n    /// let client = LastFmEditClientImpl::from_session(Box::new(http_client), test_session);\n    ///\n    /// if let Some(ClientEvent::RateLimited { delay_seconds, .. }) = client.latest_event() {\n    ///     println!(\"Currently rate limited for {} seconds\", delay_seconds);\n    /// }\n    /// ```\n    fn latest_event(\u0026self) -\u003e Option\u003cClientEvent\u003e;\n\n    /// Validate if the current session is still working.\n    ///\n    /// This method makes a test request to a protected Last.fm settings page to verify\n    /// that the current session is still valid. If the session has expired or become\n    /// invalid, Last.fm will redirect to the login page.\n    ///\n    /// This is useful for checking session validity before attempting operations that\n    /// require authentication, especially after loading a previously saved session.\n    ///\n    /// # Returns\n    ///\n    /// Returns `true` if the session is valid and can be used for authenticated operations,\n    /// `false` if the session is invalid or expired.\n    async fn validate_session(\u0026self) -\u003e bool;\n}\n","traces":[{"line":323,"address":[],"length":0,"stats":{"Line":1}},{"line":324,"address":[5465924],"length":1,"stats":{"Line":2}},{"line":334,"address":[3786331,3786227],"length":1,"stats":{"Line":0}},{"line":336,"address":[5949211,5948791],"length":1,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[5950295],"length":1,"stats":{"Line":0}},{"line":354,"address":[3343383],"length":1,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[6387367,6387778],"length":1,"stats":{"Line":0}},{"line":369,"address":[2838221],"length":1,"stats":{"Line":0}},{"line":371,"address":[5464759],"length":1,"stats":{"Line":0}},{"line":383,"address":[6009731,6009835],"length":1,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[5953598],"length":1,"stats":{"Line":0}},{"line":388,"address":[3790320,3791212,3791322,3791127],"length":1,"stats":{"Line":0}}],"covered":2,"coverable":17},{"path":["/","home","imalison","Projects","lastfm-edit","src","types.rs"],"content":"//! Data types for Last.fm music metadata and operations.\n//!\n//! This module contains all the core data structures used throughout the crate,\n//! including track and album metadata, edit operations, error types, session state,\n//! configuration, and event handling.\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fmt;\nuse thiserror::Error;\nuse tokio::sync::{broadcast, watch};\n\n// ================================================================================================\n// TRACK AND ALBUM METADATA\n// ================================================================================================\n\n/// Represents a music track with associated metadata.\n///\n/// This structure contains track information as parsed from Last.fm pages,\n/// including play count and optional timestamp data for scrobbles.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]\npub struct Track {\n    /// The track name/title\n    pub name: String,\n    /// The artist name\n    pub artist: String,\n    /// Number of times this track has been played/scrobbled\n    pub playcount: u32,\n    /// Unix timestamp of when this track was scrobbled (if available)\n    ///\n    /// This field is populated when tracks are retrieved from recent scrobbles\n    /// or individual scrobble data, but may be `None` for aggregate track listings.\n    pub timestamp: Option\u003cu64\u003e,\n    /// The album name (if available)\n    ///\n    /// This field is populated when tracks are retrieved from recent scrobbles\n    /// where album information is available in the edit forms. May be `None`\n    /// for aggregate track listings or when album information is not available.\n    pub album: Option\u003cString\u003e,\n    /// The album artist name (if available and different from track artist)\n    ///\n    /// This field is populated when tracks are retrieved from recent scrobbles\n    /// where album artist information is available. May be `None` for tracks\n    /// where the album artist is the same as the track artist, or when this\n    /// information is not available.\n    pub album_artist: Option\u003cString\u003e,\n}\n\nimpl fmt::Display for Track {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let album_part = if let Some(ref album) = self.album {\n            format!(\" [{album}]\")\n        } else {\n            String::new()\n        };\n        write!(f, \"{} - {}{}\", self.artist, self.name, album_part)\n    }\n}\n\n/// Represents a paginated collection of tracks.\n///\n/// This structure is returned by track listing methods and provides\n/// information about the current page and pagination state.\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]\npub struct TrackPage {\n    /// The tracks on this page\n    pub tracks: Vec\u003cTrack\u003e,\n    /// Current page number (1-indexed)\n    pub page_number: u32,\n    /// Whether there are more pages available\n    pub has_next_page: bool,\n    /// Total number of pages, if known\n    ///\n    /// This may be `None` if the total page count cannot be determined\n    /// from the Last.fm response.\n    pub total_pages: Option\u003cu32\u003e,\n}\n\n/// Represents a music album with associated metadata.\n///\n/// This structure contains album information as parsed from Last.fm pages,\n/// including play count and optional timestamp data for scrobbles.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]\npub struct Album {\n    /// The album name/title\n    pub name: String,\n    /// The artist name\n    pub artist: String,\n    /// Number of times this album has been played/scrobbled\n    pub playcount: u32,\n    /// Unix timestamp of when this album was last scrobbled (if available)\n    ///\n    /// This field is populated when albums are retrieved from recent scrobbles\n    /// or individual scrobble data, but may be `None` for aggregate album listings.\n    pub timestamp: Option\u003cu64\u003e,\n}\n\nimpl fmt::Display for Album {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{} - {}\", self.artist, self.name)\n    }\n}\n\n/// Represents a paginated collection of albums.\n///\n/// This structure is returned by album listing methods and provides\n/// information about the current page and pagination state.\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]\npub struct AlbumPage {\n    /// The albums on this page\n    pub albums: Vec\u003cAlbum\u003e,\n    /// Current page number (1-indexed)\n    pub page_number: u32,\n    /// Whether there are more pages available\n    pub has_next_page: bool,\n    /// Total number of pages, if known\n    ///\n    /// This may be `None` if the total page count cannot be determined\n    /// from the Last.fm response.\n    pub total_pages: Option\u003cu32\u003e,\n}\n\nimpl Album {\n    /// Convert the Unix timestamp to a human-readable datetime.\n    ///\n    /// Returns `None` if no timestamp is available or if the timestamp is invalid.\n    #[must_use]\n    pub fn scrobbled_at(\u0026self) -\u003e Option\u003cDateTime\u003cUtc\u003e\u003e {\n        self.timestamp\n            .and_then(|ts| DateTime::from_timestamp(i64::try_from(ts).ok()?, 0))\n    }\n}\n\n/// Represents a music artist with associated metadata.\n///\n/// This structure contains artist information as parsed from Last.fm pages,\n/// including the total number of scrobbles for this artist.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]\npub struct Artist {\n    /// The artist name\n    pub name: String,\n    /// Number of times this artist has been played/scrobbled\n    pub playcount: u32,\n    /// Unix timestamp of when this artist was last scrobbled (if available)\n    ///\n    /// This field is populated when artists are retrieved from recent scrobbles\n    /// or individual scrobble data, but may be `None` for aggregate artist listings.\n    pub timestamp: Option\u003cu64\u003e,\n}\n\nimpl fmt::Display for Artist {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.name)\n    }\n}\n\n/// Represents a paginated collection of artists.\n///\n/// This structure is returned by artist listing methods and provides\n/// information about the current page and pagination state.\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]\npub struct ArtistPage {\n    /// The artists on this page\n    pub artists: Vec\u003cArtist\u003e,\n    /// Current page number (1-indexed)\n    pub page_number: u32,\n    /// Whether there are more pages available\n    pub has_next_page: bool,\n    /// Total number of pages, if known\n    ///\n    /// This may be `None` if the total page count cannot be determined\n    /// from the Last.fm response.\n    pub total_pages: Option\u003cu32\u003e,\n}\n\nimpl Artist {\n    /// Convert the Unix timestamp to a human-readable datetime.\n    ///\n    /// Returns `None` if no timestamp is available or if the timestamp is invalid.\n    #[must_use]\n    pub fn scrobbled_at(\u0026self) -\u003e Option\u003cDateTime\u003cUtc\u003e\u003e {\n        self.timestamp\n            .and_then(|ts| DateTime::from_timestamp(i64::try_from(ts).ok()?, 0))\n    }\n}\n\n// ================================================================================================\n// EDIT OPERATIONS\n// ================================================================================================\n\n/// Represents a scrobble edit operation.\n///\n/// This structure contains all the information needed to edit a specific scrobble\n/// on Last.fm, including both the original and new metadata values.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]\npub struct ScrobbleEdit {\n    /// Original track name as it appears in the scrobble (optional - if None, edits all tracks)\n    pub track_name_original: Option\u003cString\u003e,\n    /// Original album name as it appears in the scrobble (optional)\n    pub album_name_original: Option\u003cString\u003e,\n    /// Original artist name as it appears in the scrobble (required)\n    pub artist_name_original: String,\n    /// Original album artist name as it appears in the scrobble (optional)\n    pub album_artist_name_original: Option\u003cString\u003e,\n\n    /// New track name to set (optional - if None, keeps original track names)\n    pub track_name: Option\u003cString\u003e,\n    /// New album name to set (optional - if None, keeps original album names)\n    pub album_name: Option\u003cString\u003e,\n    /// New artist name to set\n    pub artist_name: String,\n    /// New album artist name to set (optional - if None, keeps original album artist names)\n    pub album_artist_name: Option\u003cString\u003e,\n\n    /// Unix timestamp of the scrobble to edit (optional)\n    ///\n    /// This identifies the specific scrobble instance to modify.\n    /// If None, the client will attempt to find a representative timestamp.\n    pub timestamp: Option\u003cu64\u003e,\n    /// Whether to edit all instances or just this specific scrobble\n    ///\n    /// When `true`, Last.fm will update all scrobbles with matching metadata.\n    /// When `false`, only this specific scrobble (identified by timestamp) is updated.\n    pub edit_all: bool,\n}\n\nimpl fmt::Display for ScrobbleEdit {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let mut changes = Vec::new();\n\n        // Check if artist is being changed\n        if self.artist_name != self.artist_name_original {\n            changes.push(format!(\n                \"Artist: {} → {}\",\n                self.artist_name_original, self.artist_name\n            ));\n        }\n\n        // Check if track name is being changed\n        if let Some(ref new_track) = self.track_name {\n            if let Some(ref original_track) = self.track_name_original {\n                if new_track != original_track {\n                    changes.push(format!(\"Track: {original_track} → {new_track}\"));\n                }\n            } else {\n                changes.push(format!(\"Track: → {new_track}\"));\n            }\n        }\n\n        // Check if album name is being changed\n        if let Some(ref new_album) = self.album_name {\n            match \u0026self.album_name_original {\n                Some(ref original_album) if new_album != original_album =\u003e {\n                    changes.push(format!(\"Album: {original_album} → {new_album}\"));\n                }\n                None =\u003e {\n                    changes.push(format!(\"Album: → {new_album}\"));\n                }\n                _ =\u003e {} // No change\n            }\n        }\n\n        // Check if album artist is being changed\n        if let Some(ref new_album_artist) = self.album_artist_name {\n            match \u0026self.album_artist_name_original {\n                Some(ref original_album_artist) if new_album_artist != original_album_artist =\u003e {\n                    changes.push(format!(\n                        \"Album Artist: {original_album_artist} → {new_album_artist}\"\n                    ));\n                }\n                None =\u003e {\n                    changes.push(format!(\"Album Artist: → {new_album_artist}\"));\n                }\n                _ =\u003e {} // No change\n            }\n        }\n\n        if changes.is_empty() {\n            write!(f, \"No changes\")\n        } else {\n            let scope = if self.edit_all {\n                \" (all instances)\"\n            } else {\n                \"\"\n            };\n            write!(f, \"{}{}\", changes.join(\", \"), scope)\n        }\n    }\n}\n\n/// Response from a single scrobble edit operation.\n///\n/// This structure contains the result of attempting to edit a specific scrobble instance,\n/// including success status and any error messages.\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]\npub struct SingleEditResponse {\n    /// Whether this individual edit operation was successful\n    pub success: bool,\n    /// Optional message describing the result or any errors\n    pub message: Option\u003cString\u003e,\n    /// Information about which album variation was edited\n    pub album_info: Option\u003cString\u003e,\n    /// The exact scrobble edit that was performed\n    pub exact_scrobble_edit: ExactScrobbleEdit,\n}\n\n/// Response from a scrobble edit operation that may affect multiple album variations.\n///\n/// When editing a track that appears on multiple albums, this response contains\n/// the results of all individual edit operations performed.\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]\npub struct EditResponse {\n    /// Results of individual edit operations\n    pub individual_results: Vec\u003cSingleEditResponse\u003e,\n}\n\n/// Internal representation of a scrobble edit with all fields fully specified.\n///\n/// This type is used internally by the client after enriching metadata from\n/// Last.fm. Unlike `ScrobbleEdit`, all fields are required and non-optional,\n/// ensuring we have complete information before performing edit operations.\n///\n/// This type represents a fully-specified scrobble edit where all fields are known.\n#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]\npub struct ExactScrobbleEdit {\n    /// Original track name as it appears in the scrobble\n    pub track_name_original: String,\n    /// Original album name as it appears in the scrobble\n    pub album_name_original: String,\n    /// Original artist name as it appears in the scrobble\n    pub artist_name_original: String,\n    /// Original album artist name as it appears in the scrobble\n    pub album_artist_name_original: String,\n\n    /// New track name to set\n    pub track_name: String,\n    /// New album name to set\n    pub album_name: String,\n    /// New artist name to set\n    pub artist_name: String,\n    /// New album artist name to set\n    pub album_artist_name: String,\n\n    /// Unix timestamp of the scrobble to edit\n    pub timestamp: u64,\n    /// Whether to edit all instances or just this specific scrobble\n    pub edit_all: bool,\n}\n\nimpl fmt::Display for ExactScrobbleEdit {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let mut changes = Vec::new();\n\n        // Check if artist is being changed\n        if self.artist_name != self.artist_name_original {\n            changes.push(format!(\n                \"Artist: {} → {}\",\n                self.artist_name_original, self.artist_name\n            ));\n        }\n\n        // Check if track name is being changed\n        if self.track_name != self.track_name_original {\n            changes.push(format!(\n                \"Track: {} → {}\",\n                self.track_name_original, self.track_name\n            ));\n        }\n\n        // Check if album name is being changed\n        if self.album_name != self.album_name_original {\n            changes.push(format!(\n                \"Album: {} → {}\",\n                self.album_name_original, self.album_name\n            ));\n        }\n\n        // Check if album artist is being changed\n        if self.album_artist_name != self.album_artist_name_original {\n            changes.push(format!(\n                \"Album Artist: {} → {}\",\n                self.album_artist_name_original, self.album_artist_name\n            ));\n        }\n\n        if changes.is_empty() {\n            write!(f, \"No changes\")\n        } else {\n            let scope = if self.edit_all {\n                \" (all instances)\"\n            } else {\n                \"\"\n            };\n            write!(f, \"{}{}\", changes.join(\", \"), scope)\n        }\n    }\n}\n\nimpl ScrobbleEdit {\n    /// Create a new [`ScrobbleEdit`] with all required fields.\n    ///\n    /// This is the most general constructor that allows setting all fields.\n    /// For convenience, consider using [`from_track_info`](Self::from_track_info) instead.\n    ///\n    /// # Arguments\n    ///\n    /// * `track_name_original` - The current track name in the scrobble\n    /// * `album_name_original` - The current album name in the scrobble\n    /// * `artist_name_original` - The current artist name in the scrobble\n    /// * `album_artist_name_original` - The current album artist name in the scrobble\n    /// * `track_name` - The new track name to set\n    /// * `album_name` - The new album name to set\n    /// * `artist_name` - The new artist name to set\n    /// * `album_artist_name` - The new album artist name to set\n    /// * `timestamp` - Unix timestamp identifying the scrobble\n    /// * `edit_all` - Whether to edit all matching scrobbles or just this one\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        track_name_original: Option\u003cString\u003e,\n        album_name_original: Option\u003cString\u003e,\n        artist_name_original: String,\n        album_artist_name_original: Option\u003cString\u003e,\n        track_name: Option\u003cString\u003e,\n        album_name: Option\u003cString\u003e,\n        artist_name: String,\n        album_artist_name: Option\u003cString\u003e,\n        timestamp: Option\u003cu64\u003e,\n        edit_all: bool,\n    ) -\u003e Self {\n        Self {\n            track_name_original,\n            album_name_original,\n            artist_name_original,\n            album_artist_name_original,\n            track_name,\n            album_name,\n            artist_name,\n            album_artist_name,\n            timestamp,\n            edit_all,\n        }\n    }\n\n    /// Create an edit request from track information (convenience constructor).\n    ///\n    /// This constructor creates a [`ScrobbleEdit`] with the new values initially\n    /// set to the same as the original values. Use the builder methods like\n    /// [`with_track_name`](Self::with_track_name) to specify what should be changed.\n    ///\n    /// # Arguments\n    ///\n    /// * `original_track` - The current track name\n    /// * `original_album` - The current album name\n    /// * `original_artist` - The current artist name\n    /// * `timestamp` - Unix timestamp identifying the scrobble\n    pub fn from_track_info(\n        original_track: \u0026str,\n        original_album: \u0026str,\n        original_artist: \u0026str,\n        timestamp: u64,\n    ) -\u003e Self {\n        Self::new(\n            Some(original_track.to_string()),\n            Some(original_album.to_string()),\n            original_artist.to_string(),\n            Some(original_artist.to_string()), // album_artist defaults to artist\n            Some(original_track.to_string()),\n            Some(original_album.to_string()),\n            original_artist.to_string(),\n            Some(original_artist.to_string()), // album_artist defaults to artist\n            Some(timestamp),\n            true, // edit_all defaults to true\n        )\n    }\n\n    /// Set the new track name.\n    pub fn with_track_name(mut self, track_name: \u0026str) -\u003e Self {\n        self.track_name = Some(track_name.to_string());\n        self\n    }\n\n    /// Set the new album name.\n    pub fn with_album_name(mut self, album_name: \u0026str) -\u003e Self {\n        self.album_name = Some(album_name.to_string());\n        self\n    }\n\n    /// Set the new artist name.\n    ///\n    /// This also sets the album artist name to the same value.\n    pub fn with_artist_name(mut self, artist_name: \u0026str) -\u003e Self {\n        self.artist_name = artist_name.to_string();\n        self.album_artist_name = Some(artist_name.to_string());\n        self\n    }\n\n    /// Set whether to edit all instances of this track.\n    ///\n    /// When `true`, Last.fm will update all scrobbles with the same metadata.\n    /// When `false` (default), only the specific scrobble is updated.\n    pub fn with_edit_all(mut self, edit_all: bool) -\u003e Self {\n        self.edit_all = edit_all;\n        self\n    }\n\n    /// Create an edit request with minimal information, letting the client look up missing metadata.\n    ///\n    /// This constructor is useful when you only know some of the original metadata and want\n    /// the client to automatically fill in missing information by looking up the scrobble.\n    ///\n    /// # Arguments\n    ///\n    /// * `track_name` - The new track name to set\n    /// * `artist_name` - The new artist name to set\n    /// * `album_name` - The new album name to set\n    /// * `timestamp` - Unix timestamp identifying the scrobble\n    pub fn with_minimal_info(\n        track_name: \u0026str,\n        artist_name: \u0026str,\n        album_name: \u0026str,\n        timestamp: u64,\n    ) -\u003e Self {\n        Self::new(\n            Some(track_name.to_string()),\n            Some(album_name.to_string()),\n            artist_name.to_string(),\n            Some(artist_name.to_string()),\n            Some(track_name.to_string()),\n            Some(album_name.to_string()),\n            artist_name.to_string(),\n            Some(artist_name.to_string()),\n            Some(timestamp),\n            true,\n        )\n    }\n    /// Create an edit request with just track and artist information.\n    ///\n    /// This constructor is useful when you only know the track and artist names.\n    /// The client will use these as both original and new values, and will\n    /// attempt to find a representative timestamp and album information.\n    ///\n    /// # Arguments\n    ///\n    /// * `track_name` - The track name (used as both original and new)\n    /// * `artist_name` - The artist name (used as both original and new)\n    pub fn from_track_and_artist(track_name: \u0026str, artist_name: \u0026str) -\u003e Self {\n        Self::new(\n            Some(track_name.to_string()),\n            None, // Client will look up original album name\n            artist_name.to_string(),\n            None, // Client will look up original album artist name\n            Some(track_name.to_string()),\n            None, // Will be filled by client or kept as original\n            artist_name.to_string(),\n            Some(artist_name.to_string()), // album_artist defaults to artist\n            None,                          // Client will find representative timestamp\n            true,\n        )\n    }\n\n    /// Create an edit request for all tracks by an artist.\n    ///\n    /// This constructor creates a [`ScrobbleEdit`] that will edit all tracks\n    /// by the specified artist, changing the artist name to the new value.\n    ///\n    /// # Arguments\n    ///\n    /// * `old_artist_name` - The current artist name to change from\n    /// * `new_artist_name` - The new artist name to change to\n    pub fn for_artist(old_artist_name: \u0026str, new_artist_name: \u0026str) -\u003e Self {\n        Self::new(\n            None, // No specific track - edit all tracks\n            None, // No specific album - edit all albums\n            old_artist_name.to_string(),\n            None, // Client will look up original album artist name\n            None, // No track name change - keep original track names\n            None, // Keep original album names (they can vary)\n            new_artist_name.to_string(),\n            Some(new_artist_name.to_string()), // album_artist also changes for global renames\n            None,                              // Client will find representative timestamp\n            true,                              // Edit all instances by default for artist changes\n        )\n    }\n\n    /// Create an edit request for all tracks in a specific album.\n    ///\n    /// This constructor creates a [`ScrobbleEdit`] that will edit all tracks\n    /// in the specified album by the specified artist.\n    ///\n    /// # Arguments\n    ///\n    /// * `album_name` - The album name containing tracks to edit\n    /// * `artist_name` - The artist name for the album\n    /// * `new_artist_name` - The new artist name to change to\n    pub fn for_album(album_name: \u0026str, old_artist_name: \u0026str, new_artist_name: \u0026str) -\u003e Self {\n        Self::new(\n            None, // No specific track - edit all tracks in album\n            Some(album_name.to_string()),\n            old_artist_name.to_string(),\n            Some(old_artist_name.to_string()),\n            None,                         // No track name change - keep original track names\n            Some(album_name.to_string()), // Keep same album name\n            new_artist_name.to_string(),\n            None, // Keep original album_artist names (they can vary)\n            None, // Client will find representative timestamp\n            true, // Edit all instances by default for album changes\n        )\n    }\n}\n\nimpl ExactScrobbleEdit {\n    /// Create a new [`ExactScrobbleEdit`] with all fields specified.\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        track_name_original: String,\n        album_name_original: String,\n        artist_name_original: String,\n        album_artist_name_original: String,\n        track_name: String,\n        album_name: String,\n        artist_name: String,\n        album_artist_name: String,\n        timestamp: u64,\n        edit_all: bool,\n    ) -\u003e Self {\n        Self {\n            track_name_original,\n            album_name_original,\n            artist_name_original,\n            album_artist_name_original,\n            track_name,\n            album_name,\n            artist_name,\n            album_artist_name,\n            timestamp,\n            edit_all,\n        }\n    }\n\n    /// Build the form data for submitting this scrobble edit.\n    ///\n    /// This creates a HashMap containing all the form fields needed to submit\n    /// the edit request to Last.fm, including the CSRF token and all metadata fields.\n    pub fn build_form_data(\u0026self, csrf_token: \u0026str) -\u003e HashMap\u003c\u0026str, String\u003e {\n        let mut form_data = HashMap::new();\n\n        // Add fresh CSRF token (required)\n        form_data.insert(\"csrfmiddlewaretoken\", csrf_token.to_string());\n\n        // Include ALL form fields (using ExactScrobbleEdit which has all required fields)\n        form_data.insert(\"track_name_original\", self.track_name_original.clone());\n        form_data.insert(\"track_name\", self.track_name.clone());\n        form_data.insert(\"artist_name_original\", self.artist_name_original.clone());\n        form_data.insert(\"artist_name\", self.artist_name.clone());\n        form_data.insert(\"album_name_original\", self.album_name_original.clone());\n        form_data.insert(\"album_name\", self.album_name.clone());\n        form_data.insert(\n            \"album_artist_name_original\",\n            self.album_artist_name_original.clone(),\n        );\n        form_data.insert(\"album_artist_name\", self.album_artist_name.clone());\n\n        // Include timestamp (ExactScrobbleEdit always has a timestamp)\n        form_data.insert(\"timestamp\", self.timestamp.to_string());\n\n        // Edit flags\n        if self.edit_all {\n            form_data.insert(\"edit_all\", \"1\".to_string());\n        }\n        form_data.insert(\"submit\", \"edit-scrobble\".to_string());\n        form_data.insert(\"ajax\", \"1\".to_string());\n\n        form_data\n    }\n\n    /// Convert this exact edit back to a public ScrobbleEdit.\n    ///\n    /// This is useful when you need to expose the edit data through the public API.\n    pub fn to_scrobble_edit(\u0026self) -\u003e ScrobbleEdit {\n        ScrobbleEdit::new(\n            Some(self.track_name_original.clone()),\n            Some(self.album_name_original.clone()),\n            self.artist_name_original.clone(),\n            Some(self.album_artist_name_original.clone()),\n            Some(self.track_name.clone()),\n            Some(self.album_name.clone()),\n            self.artist_name.clone(),\n            Some(self.album_artist_name.clone()),\n            Some(self.timestamp),\n            self.edit_all,\n        )\n    }\n}\n\nimpl EditResponse {\n    /// Create a new EditResponse from a single result.\n    pub fn single(\n        success: bool,\n        message: Option\u003cString\u003e,\n        album_info: Option\u003cString\u003e,\n        exact_scrobble_edit: ExactScrobbleEdit,\n    ) -\u003e Self {\n        Self {\n            individual_results: vec![SingleEditResponse {\n                success,\n                message,\n                album_info,\n                exact_scrobble_edit,\n            }],\n        }\n    }\n\n    /// Create a new EditResponse from multiple results.\n    pub fn from_results(results: Vec\u003cSingleEditResponse\u003e) -\u003e Self {\n        Self {\n            individual_results: results,\n        }\n    }\n\n    /// Check if all individual edit operations were successful.\n    pub fn all_successful(\u0026self) -\u003e bool {\n        !self.individual_results.is_empty() \u0026\u0026 self.individual_results.iter().all(|r| r.success)\n    }\n\n    /// Check if any individual edit operations were successful.\n    pub fn any_successful(\u0026self) -\u003e bool {\n        self.individual_results.iter().any(|r| r.success)\n    }\n\n    /// Get the total number of edit operations performed.\n    pub fn total_edits(\u0026self) -\u003e usize {\n        self.individual_results.len()\n    }\n\n    /// Get the number of successful edit operations.\n    pub fn successful_edits(\u0026self) -\u003e usize {\n        self.individual_results.iter().filter(|r| r.success).count()\n    }\n\n    /// Get the number of failed edit operations.\n    pub fn failed_edits(\u0026self) -\u003e usize {\n        self.individual_results\n            .iter()\n            .filter(|r| !r.success)\n            .count()\n    }\n\n    /// Generate a summary message describing the overall result.\n    pub fn summary_message(\u0026self) -\u003e String {\n        let total = self.total_edits();\n        let successful = self.successful_edits();\n        let failed = self.failed_edits();\n\n        if total == 0 {\n            return \"No edit operations performed\".to_string();\n        }\n\n        if successful == total {\n            if total == 1 {\n                \"Edit completed successfully\".to_string()\n            } else {\n                format!(\"All {total} edits completed successfully\")\n            }\n        } else if successful == 0 {\n            if total == 1 {\n                \"Edit failed\".to_string()\n            } else {\n                format!(\"All {total} edits failed\")\n            }\n        } else {\n            format!(\"{successful} of {total} edits succeeded, {failed} failed\")\n        }\n    }\n\n    /// Get detailed messages from all edit operations.\n    pub fn detailed_messages(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.individual_results\n            .iter()\n            .enumerate()\n            .map(|(i, result)| {\n                let album_info = result\n                    .album_info\n                    .as_deref()\n                    .map(|info| format!(\" ({info})\"))\n                    .unwrap_or_default();\n\n                match \u0026result.message {\n                    Some(msg) =\u003e format!(\"{}: {}{}\", i + 1, msg, album_info),\n                    None =\u003e {\n                        if result.success {\n                            format!(\"{}: Success{}\", i + 1, album_info)\n                        } else {\n                            format!(\"{}: Failed{}\", i + 1, album_info)\n                        }\n                    }\n                }\n            })\n            .collect()\n    }\n\n    /// Check if this response represents a single edit (for backward compatibility).\n    pub fn is_single_edit(\u0026self) -\u003e bool {\n        self.individual_results.len() == 1\n    }\n\n    /// Check if all edits succeeded (for backward compatibility).\n    pub fn success(\u0026self) -\u003e bool {\n        self.all_successful()\n    }\n\n    /// Get a single message for backward compatibility.\n    /// Returns the summary message.\n    pub fn message(\u0026self) -\u003e Option\u003cString\u003e {\n        Some(self.summary_message())\n    }\n}\n\n// ================================================================================================\n// ERROR TYPES\n// ================================================================================================\n\n/// Error types for Last.fm operations.\n///\n/// This enum covers all possible errors that can occur when interacting with Last.fm,\n/// including network issues, authentication failures, parsing errors, and rate limiting.\n#[derive(Error, Debug)]\npub enum LastFmError {\n    /// HTTP/network related errors.\n    ///\n    /// This includes connection failures, timeouts, DNS errors, and other\n    /// low-level networking issues.\n    #[error(\"HTTP error: {0}\")]\n    Http(String),\n\n    /// Authentication failures.\n    ///\n    /// This occurs when login credentials are invalid, sessions expire,\n    /// or authentication is required but not provided.\n    ///\n    /// # Common Causes\n    /// - Invalid username/password\n    /// - Expired session cookies\n    /// - Account locked or suspended\n    /// - Two-factor authentication required\n    #[error(\"Authentication failed: {0}\")]\n    Auth(String),\n\n    /// CSRF token not found in response.\n    ///\n    /// This typically indicates that Last.fm's page structure has changed\n    /// or that the request was blocked.\n    #[error(\"CSRF token not found\")]\n    CsrfNotFound,\n\n    /// Failed to parse Last.fm's response.\n    ///\n    /// This can happen when Last.fm changes their HTML structure or\n    /// returns unexpected data formats.\n    #[error(\"Failed to parse response: {0}\")]\n    Parse(String),\n\n    /// Rate limiting from Last.fm.\n    ///\n    /// Last.fm has rate limits to prevent abuse. When hit, the client\n    /// should wait before making more requests.\n    ///\n    /// The `retry_after` field indicates how many seconds to wait before\n    /// the next request attempt.\n    #[error(\"Rate limited, retry after {retry_after} seconds\")]\n    RateLimit {\n        /// Number of seconds to wait before retrying\n        retry_after: u64,\n    },\n\n    /// Scrobble edit operation failed.\n    ///\n    /// This is returned when an edit request is properly formatted and sent,\n    /// but Last.fm rejects it for business logic reasons.\n    #[error(\"Edit failed: {0}\")]\n    EditFailed(String),\n\n    /// File system I/O errors.\n    ///\n    /// This can occur when saving debug responses or other file operations.\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n}\n\n// ================================================================================================\n// SESSION MANAGEMENT\n// ================================================================================================\n\n/// Serializable client session state that can be persisted and restored.\n///\n/// This contains all the authentication state needed to resume a Last.fm session\n/// without requiring the user to log in again.\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct LastFmEditSession {\n    /// The authenticated username\n    pub username: String,\n    /// Session cookies required for authenticated requests\n    pub cookies: Vec\u003cString\u003e,\n    /// CSRF token for form submissions\n    pub csrf_token: Option\u003cString\u003e,\n    /// Base URL for the Last.fm instance\n    pub base_url: String,\n}\n\nimpl LastFmEditSession {\n    /// Create a new client session with the provided state\n    pub fn new(\n        username: String,\n        session_cookies: Vec\u003cString\u003e,\n        csrf_token: Option\u003cString\u003e,\n        base_url: String,\n    ) -\u003e Self {\n        Self {\n            username,\n            cookies: session_cookies,\n            csrf_token,\n            base_url,\n        }\n    }\n\n    /// Check if this session appears to be valid\n    ///\n    /// This performs basic validation but doesn't guarantee the session\n    /// is still active on the server.\n    pub fn is_valid(\u0026self) -\u003e bool {\n        !self.username.is_empty()\n            \u0026\u0026 !self.cookies.is_empty()\n            \u0026\u0026 self.csrf_token.is_some()\n            \u0026\u0026 self\n                .cookies\n                .iter()\n                .any(|cookie| cookie.starts_with(\"sessionid=\") \u0026\u0026 cookie.len() \u003e 50)\n    }\n\n    /// Serialize session to JSON string\n    pub fn to_json(\u0026self) -\u003e Result\u003cString, serde_json::Error\u003e {\n        serde_json::to_string(self)\n    }\n\n    /// Deserialize session from JSON string\n    pub fn from_json(json: \u0026str) -\u003e Result\u003cSelf, serde_json::Error\u003e {\n        serde_json::from_str(json)\n    }\n}\n\n// ================================================================================================\n// CLIENT CONFIGURATION\n// ================================================================================================\n\n/// Configuration for rate limit detection behavior\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct RateLimitConfig {\n    /// Whether to detect rate limits by HTTP status codes (429, 403)\n    pub detect_by_status: bool,\n    /// Whether to detect rate limits by response body patterns\n    pub detect_by_patterns: bool,\n    /// Patterns to look for in response bodies (used when detect_by_patterns is true)\n    pub patterns: Vec\u003cString\u003e,\n    /// Additional custom patterns to look for in response bodies\n    pub custom_patterns: Vec\u003cString\u003e,\n}\n\nimpl Default for RateLimitConfig {\n    fn default() -\u003e Self {\n        Self {\n            detect_by_status: true,\n            detect_by_patterns: true,\n            patterns: vec![\n                \"you've tried to log in too many times\".to_string(),\n                \"you're requesting too many pages\".to_string(),\n                \"slow down\".to_string(),\n                \"too fast\".to_string(),\n                \"rate limit\".to_string(),\n                \"throttled\".to_string(),\n                \"temporarily blocked\".to_string(),\n                \"temporarily restricted\".to_string(),\n                \"captcha\".to_string(),\n                \"verify you're human\".to_string(),\n                \"prove you're not a robot\".to_string(),\n                \"security check\".to_string(),\n                \"service temporarily unavailable\".to_string(),\n                \"quota exceeded\".to_string(),\n                \"limit exceeded\".to_string(),\n                \"daily limit\".to_string(),\n            ],\n            custom_patterns: vec![],\n        }\n    }\n}\n\nimpl RateLimitConfig {\n    /// Create config with all detection disabled\n    pub fn disabled() -\u003e Self {\n        Self {\n            detect_by_status: false,\n            detect_by_patterns: false,\n            patterns: vec![],\n            custom_patterns: vec![],\n        }\n    }\n\n    /// Create config with only status code detection\n    pub fn status_only() -\u003e Self {\n        Self {\n            detect_by_status: true,\n            detect_by_patterns: false,\n            patterns: vec![],\n            custom_patterns: vec![],\n        }\n    }\n\n    /// Create config with only default pattern detection\n    pub fn patterns_only() -\u003e Self {\n        Self {\n            detect_by_status: false,\n            detect_by_patterns: true,\n            ..Default::default()\n        }\n    }\n\n    /// Create config with custom patterns only (no default patterns)\n    pub fn custom_patterns_only(patterns: Vec\u003cString\u003e) -\u003e Self {\n        Self {\n            detect_by_status: false,\n            detect_by_patterns: false,\n            patterns: vec![],\n            custom_patterns: patterns,\n        }\n    }\n\n    /// Create config with both default and custom patterns\n    pub fn with_custom_patterns(mut self, patterns: Vec\u003cString\u003e) -\u003e Self {\n        self.custom_patterns = patterns;\n        self\n    }\n\n    /// Create config with custom patterns (replaces built-in patterns)\n    pub fn with_patterns(mut self, patterns: Vec\u003cString\u003e) -\u003e Self {\n        self.patterns = patterns;\n        self\n    }\n}\n\n/// Configuration for operational delays between requests\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct OperationalDelayConfig {\n    /// Delay between multiple edit operations (in milliseconds)\n    pub edit_delay_ms: u64,\n    /// Delay between delete operations (in milliseconds)\n    pub delete_delay_ms: u64,\n}\n\nimpl Default for OperationalDelayConfig {\n    fn default() -\u003e Self {\n        Self {\n            edit_delay_ms: 1000,   // 1 second\n            delete_delay_ms: 1000, // 1 second\n        }\n    }\n}\n\nimpl OperationalDelayConfig {\n    /// Create config with no delays (useful for testing)\n    pub fn no_delays() -\u003e Self {\n        Self {\n            edit_delay_ms: 0,\n            delete_delay_ms: 0,\n        }\n    }\n\n    /// Create config with custom delays\n    pub fn with_delays(edit_delay_ms: u64, delete_delay_ms: u64) -\u003e Self {\n        Self {\n            edit_delay_ms,\n            delete_delay_ms,\n        }\n    }\n}\n\n/// Unified configuration for retry behavior and rate limiting\n#[derive(Debug, Clone, PartialEq, Eq, Default)]\npub struct ClientConfig {\n    /// Retry configuration\n    pub retry: RetryConfig,\n    /// Rate limit detection configuration\n    pub rate_limit: RateLimitConfig,\n    /// Operational delay configuration\n    pub operational_delays: OperationalDelayConfig,\n}\n\nimpl ClientConfig {\n    /// Create a new config with default settings\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Create config with retries disabled\n    pub fn with_retries_disabled() -\u003e Self {\n        Self {\n            retry: RetryConfig::disabled(),\n            rate_limit: RateLimitConfig::default(),\n            operational_delays: OperationalDelayConfig::default(),\n        }\n    }\n\n    /// Create config with rate limit detection disabled\n    pub fn with_rate_limiting_disabled() -\u003e Self {\n        Self {\n            retry: RetryConfig::default(),\n            rate_limit: RateLimitConfig::disabled(),\n            operational_delays: OperationalDelayConfig::default(),\n        }\n    }\n\n    /// Create config with both retries and rate limiting disabled\n    pub fn minimal() -\u003e Self {\n        Self {\n            retry: RetryConfig::disabled(),\n            rate_limit: RateLimitConfig::disabled(),\n            operational_delays: OperationalDelayConfig::default(),\n        }\n    }\n\n    /// Create config optimized for testing (rate limit detection enabled, retries enabled but no delays)\n    pub fn for_testing() -\u003e Self {\n        Self {\n            retry: RetryConfig {\n                max_retries: 3,\n                base_delay: 0, // No delay for fast tests\n                max_delay: 0,  // No delay for fast tests\n                enabled: true,\n            },\n            rate_limit: RateLimitConfig::default(), // Keep detection enabled\n            operational_delays: OperationalDelayConfig::no_delays(),\n        }\n    }\n\n    /// Set custom retry configuration\n    pub fn with_retry_config(mut self, retry_config: RetryConfig) -\u003e Self {\n        self.retry = retry_config;\n        self\n    }\n\n    /// Set custom rate limit configuration\n    pub fn with_rate_limit_config(mut self, rate_limit_config: RateLimitConfig) -\u003e Self {\n        self.rate_limit = rate_limit_config;\n        self\n    }\n\n    /// Set custom operational delay configuration\n    pub fn with_operational_delays(mut self, operational_delays: OperationalDelayConfig) -\u003e Self {\n        self.operational_delays = operational_delays;\n        self\n    }\n\n    /// Set custom retry count\n    pub fn with_max_retries(mut self, max_retries: u32) -\u003e Self {\n        self.retry.max_retries = max_retries;\n        self.retry.enabled = max_retries \u003e 0;\n        self\n    }\n\n    /// Set custom retry delays\n    pub fn with_retry_delays(mut self, base_delay: u64, max_delay: u64) -\u003e Self {\n        self.retry.base_delay = base_delay;\n        self.retry.max_delay = max_delay;\n        self\n    }\n\n    /// Add custom rate limit patterns\n    pub fn with_custom_rate_limit_patterns(mut self, patterns: Vec\u003cString\u003e) -\u003e Self {\n        self.rate_limit.custom_patterns = patterns;\n        self\n    }\n\n    /// Enable/disable HTTP status code rate limit detection\n    pub fn with_status_detection(mut self, enabled: bool) -\u003e Self {\n        self.rate_limit.detect_by_status = enabled;\n        self\n    }\n\n    /// Enable/disable response pattern rate limit detection\n    pub fn with_pattern_detection(mut self, enabled: bool) -\u003e Self {\n        self.rate_limit.detect_by_patterns = enabled;\n        self\n    }\n}\n\n/// Configuration for retry behavior\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct RetryConfig {\n    /// Maximum number of retry attempts (set to 0 to disable retries)\n    pub max_retries: u32,\n    /// Base delay for exponential backoff (in seconds)\n    pub base_delay: u64,\n    /// Maximum delay cap (in seconds)\n    pub max_delay: u64,\n    /// Whether retries are enabled at all\n    pub enabled: bool,\n}\n\nimpl Default for RetryConfig {\n    fn default() -\u003e Self {\n        Self {\n            max_retries: 3,\n            base_delay: 5,\n            max_delay: 300, // 5 minutes\n            enabled: true,\n        }\n    }\n}\n\nimpl RetryConfig {\n    /// Create a config with retries disabled\n    pub fn disabled() -\u003e Self {\n        Self {\n            max_retries: 0,\n            base_delay: 5,\n            max_delay: 300,\n            enabled: false,\n        }\n    }\n\n    /// Create a config with custom retry count\n    pub fn with_retries(max_retries: u32) -\u003e Self {\n        Self {\n            max_retries,\n            enabled: max_retries \u003e 0,\n            ..Default::default()\n        }\n    }\n\n    /// Create a config with custom delays\n    pub fn with_delays(base_delay: u64, max_delay: u64) -\u003e Self {\n        Self {\n            base_delay,\n            max_delay,\n            ..Default::default()\n        }\n    }\n}\n\n/// Result of a retry operation with context\n#[derive(Debug)]\npub struct RetryResult\u003cT\u003e {\n    /// The successful result\n    pub result: T,\n    /// Number of retry attempts made\n    pub attempts_made: u32,\n    /// Total time spent retrying (in seconds)\n    pub total_retry_time: u64,\n}\n\n// ================================================================================================\n// EVENT SYSTEM\n// ================================================================================================\n\n/// Request information for client events\n#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct RequestInfo {\n    /// The HTTP method (GET, POST, etc.)\n    pub method: String,\n    /// The full URI being requested\n    pub uri: String,\n    /// Query parameters as key-value pairs\n    pub query_params: Vec\u003c(String, String)\u003e,\n    /// Path without query parameters\n    pub path: String,\n}\n\nimpl RequestInfo {\n    /// Create RequestInfo from a URL string and method\n    pub fn from_url_and_method(url: \u0026str, method: \u0026str) -\u003e Self {\n        // Parse URL manually to avoid adding dependencies\n        let (path, query_params) = if let Some(query_start) = url.find('?') {\n            let path = url[..query_start].to_string();\n            let query_string = \u0026url[query_start + 1..];\n\n            let query_params: Vec\u003c(String, String)\u003e = query_string\n                .split('\u0026')\n                .filter_map(|pair| {\n                    if let Some(eq_pos) = pair.find('=') {\n                        let key = \u0026pair[..eq_pos];\n                        let value = \u0026pair[eq_pos + 1..];\n                        Some((key.to_string(), value.to_string()))\n                    } else if !pair.is_empty() {\n                        Some((pair.to_string(), String::new()))\n                    } else {\n                        None\n                    }\n                })\n                .collect();\n\n            (path, query_params)\n        } else {\n            (url.to_string(), Vec::new())\n        };\n\n        // Extract just the path part if it's a full URL\n        let path = if path.starts_with(\"http://\") || path.starts_with(\"https://\") {\n            if let Some(third_slash) = path[8..].find('/') {\n                path[8 + third_slash..].to_string()\n            } else {\n                \"/\".to_string()\n            }\n        } else {\n            path\n        };\n\n        Self {\n            method: method.to_string(),\n            uri: url.to_string(),\n            query_params,\n            path,\n        }\n    }\n\n    /// Get a short description of the request for logging\n    pub fn short_description(\u0026self) -\u003e String {\n        let mut desc = format!(\"{} {}\", self.method, self.path);\n        if !self.query_params.is_empty() {\n            let params: Vec\u003cString\u003e = self\n                .query_params\n                .iter()\n                .map(|(k, v)| format!(\"{k}={v}\"))\n                .collect();\n            if params.len() \u003c= 2 {\n                desc.push_str(\u0026format!(\"?{}\", params.join(\"\u0026\")));\n            } else {\n                desc.push_str(\u0026format!(\"?{}...\", params[0]));\n            }\n        }\n        desc\n    }\n}\n\n/// Type of rate limiting detected\n#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum RateLimitType {\n    /// HTTP 429 Too Many Requests\n    Http429,\n    /// HTTP 403 Forbidden (likely rate limiting)\n    Http403,\n    /// Rate limit patterns detected in response body\n    ResponsePattern,\n}\n\n/// Event type to describe internal HTTP client activity\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub enum ClientEvent {\n    /// Request started\n    RequestStarted {\n        /// Request details\n        request: RequestInfo,\n    },\n    /// Request completed successfully\n    RequestCompleted {\n        /// Request details\n        request: RequestInfo,\n        /// HTTP status code\n        status_code: u16,\n        /// Duration of the request in milliseconds\n        duration_ms: u64,\n    },\n    /// Rate limiting detected with backoff duration in seconds\n    RateLimited {\n        /// Duration to wait in seconds\n        delay_seconds: u64,\n        /// Request that triggered the rate limit (if available)\n        request: Option\u003cRequestInfo\u003e,\n        /// Type of rate limiting detected\n        rate_limit_type: RateLimitType,\n        /// Timestamp when the rate limit was detected (seconds since Unix epoch)\n        rate_limit_timestamp: u64,\n    },\n    /// Rate limiting period has ended and normal operation resumed\n    RateLimitEnded {\n        /// Request that successfully completed after rate limiting\n        request: RequestInfo,\n        /// Type of rate limiting that ended\n        rate_limit_type: RateLimitType,\n        /// Total duration the rate limiting was active in seconds\n        total_rate_limit_duration_seconds: u64,\n    },\n    /// Scrobble edit attempt completed\n    EditAttempted {\n        /// The exact scrobble edit that was attempted\n        edit: ExactScrobbleEdit,\n        /// Whether the edit was successful\n        success: bool,\n        /// Optional error message if the edit failed\n        error_message: Option\u003cString\u003e,\n        /// Duration of the edit operation in milliseconds\n        duration_ms: u64,\n    },\n}\n\n/// Type alias for the broadcast receiver\npub type ClientEventReceiver = broadcast::Receiver\u003cClientEvent\u003e;\n\n/// Type alias for the watch receiver\npub type ClientEventWatcher = watch::Receiver\u003cOption\u003cClientEvent\u003e\u003e;\n\n/// Shared event broadcasting state that persists across client clones\n#[derive(Clone)]\npub struct SharedEventBroadcaster {\n    event_tx: broadcast::Sender\u003cClientEvent\u003e,\n    last_event_tx: watch::Sender\u003cOption\u003cClientEvent\u003e\u003e,\n}\n\nimpl SharedEventBroadcaster {\n    /// Create a new shared event broadcaster\n    pub fn new() -\u003e Self {\n        let (event_tx, _) = broadcast::channel(100);\n        let (last_event_tx, _) = watch::channel(None);\n\n        Self {\n            event_tx,\n            last_event_tx,\n        }\n    }\n\n    /// Broadcast an event to all subscribers\n    pub fn broadcast_event(\u0026self, event: ClientEvent) {\n        let _ = self.event_tx.send(event.clone());\n        let _ = self.last_event_tx.send(Some(event));\n    }\n\n    /// Subscribe to events\n    pub fn subscribe(\u0026self) -\u003e ClientEventReceiver {\n        self.event_tx.subscribe()\n    }\n\n    /// Get the latest event\n    pub fn latest_event(\u0026self) -\u003e Option\u003cClientEvent\u003e {\n        self.last_event_tx.borrow().clone()\n    }\n}\n\nimpl Default for SharedEventBroadcaster {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl std::fmt::Debug for SharedEventBroadcaster {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"SharedEventBroadcaster\")\n            .field(\"subscribers\", \u0026self.event_tx.receiver_count())\n            .finish()\n    }\n}\n\n// ================================================================================================\n// TESTS\n// ================================================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_session_validity() {\n        let valid_session = LastFmEditSession::new(\n            \"testuser\".to_string(),\n            vec![\"sessionid=.eJy1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\".to_string()],\n            Some(\"csrf_token_123\".to_string()),\n            \"https://www.last.fm\".to_string(),\n        );\n        assert!(valid_session.is_valid());\n\n        let invalid_session = LastFmEditSession::new(\n            \"\".to_string(),\n            vec![],\n            None,\n            \"https://www.last.fm\".to_string(),\n        );\n        assert!(!invalid_session.is_valid());\n    }\n\n    #[test]\n    fn test_session_serialization() {\n        let session = LastFmEditSession::new(\n            \"testuser\".to_string(),\n            vec![\n                \"sessionid=.test123\".to_string(),\n                \"csrftoken=abc\".to_string(),\n            ],\n            Some(\"csrf_token_123\".to_string()),\n            \"https://www.last.fm\".to_string(),\n        );\n\n        let json = session.to_json().unwrap();\n        let restored_session = LastFmEditSession::from_json(\u0026json).unwrap();\n\n        assert_eq!(session.username, restored_session.username);\n        assert_eq!(session.cookies, restored_session.cookies);\n        assert_eq!(session.csrf_token, restored_session.csrf_token);\n        assert_eq!(session.base_url, restored_session.base_url);\n    }\n}\n","traces":[{"line":51,"address":[6287562,6287104,6287556],"length":1,"stats":{"Line":1}},{"line":52,"address":[3184001],"length":1,"stats":{"Line":1}},{"line":53,"address":[6287184],"length":1,"stats":{"Line":1}},{"line":55,"address":[3184158],"length":1,"stats":{"Line":1}},{"line":57,"address":[3495186],"length":1,"stats":{"Line":2}},{"line":99,"address":[3550197],"length":1,"stats":{"Line":0}},{"line":100,"address":[3184448],"length":1,"stats":{"Line":1}},{"line":101,"address":[5712711],"length":1,"stats":{"Line":1}},{"line":129,"address":[6287760],"length":1,"stats":{"Line":0}},{"line":130,"address":[5522692],"length":1,"stats":{"Line":0}},{"line":131,"address":[5679534,5679504],"length":1,"stats":{"Line":0}},{"line":153,"address":[6287808],"length":1,"stats":{"Line":1}},{"line":154,"address":[5522744],"length":1,"stats":{"Line":1}},{"line":182,"address":[3184784],"length":1,"stats":{"Line":0}},{"line":183,"address":[3184804],"length":1,"stats":{"Line":0}},{"line":184,"address":[5483568,5483598],"length":1,"stats":{"Line":0}},{"line":229,"address":[5908243,5905776,5908201],"length":1,"stats":{"Line":1}},{"line":230,"address":[5905809],"length":1,"stats":{"Line":1}},{"line":233,"address":[5905828,5905899],"length":1,"stats":{"Line":2}},{"line":234,"address":[5905960],"length":1,"stats":{"Line":1}},{"line":241,"address":[5906162,5905910],"length":1,"stats":{"Line":2}},{"line":242,"address":[3185235,3185325],"length":1,"stats":{"Line":2}},{"line":243,"address":[3185402,3185337],"length":1,"stats":{"Line":2}},{"line":244,"address":[5906355],"length":1,"stats":{"Line":1}},{"line":247,"address":[5906312,5906561],"length":1,"stats":{"Line":0}},{"line":252,"address":[5713982,5713499],"length":1,"stats":{"Line":2}},{"line":253,"address":[5713999],"length":1,"stats":{"Line":1}},{"line":254,"address":[5523925,5524142],"length":1,"stats":{"Line":2}},{"line":255,"address":[3187591],"length":1,"stats":{"Line":1}},{"line":258,"address":[5714151],"length":1,"stats":{"Line":0}},{"line":265,"address":[5907258,5906771],"length":1,"stats":{"Line":1}},{"line":266,"address":[6289467],"length":1,"stats":{"Line":0}},{"line":267,"address":[6289542,6289759],"length":1,"stats":{"Line":0}},{"line":268,"address":[6289768],"length":1,"stats":{"Line":0}},{"line":273,"address":[6289592],"length":1,"stats":{"Line":0}},{"line":279,"address":[3188330,3187866],"length":1,"stats":{"Line":2}},{"line":280,"address":[3187276,3186864],"length":1,"stats":{"Line":2}},{"line":282,"address":[3186918,3186853],"length":1,"stats":{"Line":2}},{"line":283,"address":[6027800],"length":1,"stats":{"Line":1}},{"line":285,"address":[5524941],"length":1,"stats":{"Line":1}},{"line":287,"address":[3188435,3188574],"length":1,"stats":{"Line":2}},{"line":352,"address":[3187312,3188881,3188839],"length":1,"stats":{"Line":1}},{"line":353,"address":[5525393],"length":1,"stats":{"Line":1}},{"line":356,"address":[6290574,6290500],"length":1,"stats":{"Line":2}},{"line":357,"address":[3187479],"length":1,"stats":{"Line":1}},{"line":364,"address":[6290813,6290585],"length":1,"stats":{"Line":2}},{"line":365,"address":[6290858],"length":1,"stats":{"Line":1}},{"line":372,"address":[5525973,5525736],"length":1,"stats":{"Line":2}},{"line":373,"address":[6291109],"length":1,"stats":{"Line":1}},{"line":380,"address":[6291072,6291316],"length":1,"stats":{"Line":2}},{"line":381,"address":[5716438],"length":1,"stats":{"Line":1}},{"line":387,"address":[5526234,5526472],"length":1,"stats":{"Line":2}},{"line":388,"address":[6291582,6291994],"length":1,"stats":{"Line":2}},{"line":390,"address":[5716724,5716659],"length":1,"stats":{"Line":2}},{"line":391,"address":[5716726],"length":1,"stats":{"Line":1}},{"line":393,"address":[5526523],"length":1,"stats":{"Line":1}},{"line":395,"address":[5909473,5909612],"length":1,"stats":{"Line":2}},{"line":419,"address":[5717120],"length":1,"stats":{"Line":1}},{"line":457,"address":[5911385,5911501,5910176],"length":1,"stats":{"Line":0}},{"line":464,"address":[5717572],"length":1,"stats":{"Line":0}},{"line":465,"address":[5717768,5717713],"length":1,"stats":{"Line":0}},{"line":466,"address":[5527699,5527632],"length":1,"stats":{"Line":0}},{"line":467,"address":[5717950,5717883],"length":1,"stats":{"Line":0}},{"line":468,"address":[6292969,6292902],"length":1,"stats":{"Line":0}},{"line":469,"address":[6293009,6293076],"length":1,"stats":{"Line":0}},{"line":470,"address":[3190047,3189980],"length":1,"stats":{"Line":0}},{"line":471,"address":[3190122,3190055],"length":1,"stats":{"Line":0}},{"line":472,"address":[5528202],"length":1,"stats":{"Line":0}},{"line":478,"address":[6031472,6031758],"length":1,"stats":{"Line":1}},{"line":479,"address":[6031589,6031530],"length":1,"stats":{"Line":2}},{"line":480,"address":[3190851],"length":1,"stats":{"Line":1}},{"line":484,"address":[5719120,5719406],"length":1,"stats":{"Line":1}},{"line":485,"address":[3192501,3192442],"length":1,"stats":{"Line":2}},{"line":486,"address":[5719383],"length":1,"stats":{"Line":1}},{"line":492,"address":[3193108,3192688],"length":1,"stats":{"Line":0}},{"line":493,"address":[6294395,6294457],"length":1,"stats":{"Line":0}},{"line":494,"address":[6294560],"length":1,"stats":{"Line":0}},{"line":495,"address":[3191593],"length":1,"stats":{"Line":0}},{"line":502,"address":[6294784],"length":1,"stats":{"Line":1}},{"line":503,"address":[6294807],"length":1,"stats":{"Line":1}},{"line":504,"address":[6032559],"length":1,"stats":{"Line":1}},{"line":518,"address":[3194409,3194525,3193200],"length":1,"stats":{"Line":0}},{"line":525,"address":[3193316],"length":1,"stats":{"Line":0}},{"line":526,"address":[6032849,6032904],"length":1,"stats":{"Line":0}},{"line":527,"address":[5913075,5913008],"length":1,"stats":{"Line":0}},{"line":528,"address":[3192139,3192206],"length":1,"stats":{"Line":0}},{"line":529,"address":[6295382,6295449],"length":1,"stats":{"Line":0}},{"line":530,"address":[3193841,3193908],"length":1,"stats":{"Line":0}},{"line":531,"address":[5913471,5913404],"length":1,"stats":{"Line":0}},{"line":532,"address":[3194090,3194023],"length":1,"stats":{"Line":0}},{"line":533,"address":[5720858],"length":1,"stats":{"Line":0}},{"line":547,"address":[6297114,6297263,6296208],"length":1,"stats":{"Line":1}},{"line":549,"address":[3194629],"length":1,"stats":{"Line":1}},{"line":550,"address":[6296407],"length":1,"stats":{"Line":2}},{"line":551,"address":[5531353,5531408],"length":1,"stats":{"Line":2}},{"line":552,"address":[6034248],"length":1,"stats":{"Line":1}},{"line":553,"address":[3194952,3194882],"length":1,"stats":{"Line":2}},{"line":554,"address":[5531552],"length":1,"stats":{"Line":1}},{"line":555,"address":[5914544,5914474],"length":1,"stats":{"Line":2}},{"line":556,"address":[3195158,3195096],"length":1,"stats":{"Line":2}},{"line":557,"address":[6296838],"length":1,"stats":{"Line":1}},{"line":571,"address":[5915836,5915104,5915988],"length":1,"stats":{"Line":1}},{"line":573,"address":[3195707],"length":1,"stats":{"Line":1}},{"line":574,"address":[5532346],"length":1,"stats":{"Line":1}},{"line":575,"address":[5532429,5532359],"length":1,"stats":{"Line":2}},{"line":576,"address":[6297525],"length":1,"stats":{"Line":1}},{"line":577,"address":[3195903],"length":1,"stats":{"Line":1}},{"line":578,"address":[5722655],"length":1,"stats":{"Line":1}},{"line":579,"address":[5915391,5915461],"length":1,"stats":{"Line":2}},{"line":580,"address":[5722749,5722811],"length":1,"stats":{"Line":2}},{"line":581,"address":[5532667],"length":1,"stats":{"Line":1}},{"line":596,"address":[3197518,3197624,3196576],"length":1,"stats":{"Line":1}},{"line":598,"address":[3196679],"length":1,"stats":{"Line":1}},{"line":599,"address":[3196750,3196820],"length":1,"stats":{"Line":2}},{"line":600,"address":[5723663,5723596],"length":1,"stats":{"Line":2}},{"line":601,"address":[3195498,3195431],"length":1,"stats":{"Line":3}},{"line":602,"address":[6298690],"length":1,"stats":{"Line":2}},{"line":603,"address":[3195634,3195564],"length":1,"stats":{"Line":4}},{"line":604,"address":[5916634],"length":1,"stats":{"Line":2}},{"line":605,"address":[3197250],"length":1,"stats":{"Line":2}},{"line":606,"address":[5533818],"length":1,"stats":{"Line":2}},{"line":615,"address":[5917120],"length":1,"stats":{"Line":1}},{"line":645,"address":[5918774,5918768,5917424],"length":1,"stats":{"Line":1}},{"line":646,"address":[3196525],"length":1,"stats":{"Line":1}},{"line":649,"address":[5534608,5534665],"length":1,"stats":{"Line":2}},{"line":652,"address":[6299812],"length":1,"stats":{"Line":1}},{"line":653,"address":[6299899],"length":1,"stats":{"Line":1}},{"line":654,"address":[5725078],"length":1,"stats":{"Line":1}},{"line":655,"address":[3198433],"length":1,"stats":{"Line":1}},{"line":656,"address":[6300175],"length":1,"stats":{"Line":1}},{"line":657,"address":[6038010],"length":1,"stats":{"Line":1}},{"line":658,"address":[3198732],"length":1,"stats":{"Line":1}},{"line":660,"address":[6038101],"length":1,"stats":{"Line":1}},{"line":662,"address":[3197256],"length":1,"stats":{"Line":1}},{"line":665,"address":[3197346],"length":1,"stats":{"Line":1}},{"line":668,"address":[5918444],"length":1,"stats":{"Line":1}},{"line":669,"address":[6038420],"length":1,"stats":{"Line":1}},{"line":671,"address":[6038514,6038389],"length":1,"stats":{"Line":2}},{"line":672,"address":[5535745],"length":1,"stats":{"Line":1}},{"line":674,"address":[3199284],"length":1,"stats":{"Line":1}},{"line":680,"address":[3197776,3199002,3198886],"length":1,"stats":{"Line":0}},{"line":682,"address":[6038766],"length":1,"stats":{"Line":0}},{"line":683,"address":[5918943,5919005],"length":1,"stats":{"Line":0}},{"line":684,"address":[5536149,5536215],"length":1,"stats":{"Line":0}},{"line":685,"address":[5919185,5919119],"length":1,"stats":{"Line":0}},{"line":686,"address":[5919225,5919291],"length":1,"stats":{"Line":0}},{"line":687,"address":[5919397,5919331],"length":1,"stats":{"Line":0}},{"line":688,"address":[5536610,5536541],"length":1,"stats":{"Line":0}},{"line":689,"address":[3198490,3198564],"length":1,"stats":{"Line":0}},{"line":690,"address":[6039556],"length":1,"stats":{"Line":0}},{"line":691,"address":[3200191],"length":1,"stats":{"Line":0}},{"line":698,"address":[5920711,5920064,5920677],"length":1,"stats":{"Line":1}},{"line":705,"address":[3199088,3199330],"length":1,"stats":{"Line":2}},{"line":715,"address":[3199712],"length":1,"stats":{"Line":1}},{"line":722,"address":[6302976],"length":1,"stats":{"Line":2}},{"line":723,"address":[5537901],"length":1,"stats":{"Line":6}},{"line":727,"address":[5537984],"length":1,"stats":{"Line":0}},{"line":728,"address":[5728169],"length":1,"stats":{"Line":0}},{"line":732,"address":[5728224],"length":1,"stats":{"Line":2}},{"line":733,"address":[3201493],"length":1,"stats":{"Line":2}},{"line":737,"address":[3201504],"length":1,"stats":{"Line":2}},{"line":738,"address":[5483760,5483770],"length":1,"stats":{"Line":6}},{"line":742,"address":[5728304],"length":1,"stats":{"Line":2}},{"line":743,"address":[3199973],"length":1,"stats":{"Line":2}},{"line":745,"address":[5483792,5483802],"length":1,"stats":{"Line":4}},{"line":750,"address":[3201632],"length":1,"stats":{"Line":2}},{"line":751,"address":[5538230],"length":1,"stats":{"Line":2}},{"line":752,"address":[5728422],"length":1,"stats":{"Line":2}},{"line":753,"address":[6303350],"length":1,"stats":{"Line":2}},{"line":755,"address":[6303361],"length":1,"stats":{"Line":2}},{"line":756,"address":[5538286],"length":1,"stats":{"Line":0}},{"line":759,"address":[5538306],"length":1,"stats":{"Line":1}},{"line":760,"address":[6041175],"length":1,"stats":{"Line":1}},{"line":761,"address":[6041594],"length":1,"stats":{"Line":1}},{"line":763,"address":[5728961],"length":1,"stats":{"Line":0}},{"line":765,"address":[6041165],"length":1,"stats":{"Line":1}},{"line":766,"address":[5921256],"length":1,"stats":{"Line":1}},{"line":767,"address":[6303697],"length":1,"stats":{"Line":1}},{"line":769,"address":[6303720],"length":1,"stats":{"Line":0}},{"line":772,"address":[6041209],"length":1,"stats":{"Line":0}},{"line":777,"address":[5729088],"length":1,"stats":{"Line":0}},{"line":778,"address":[5729120],"length":1,"stats":{"Line":0}},{"line":781,"address":[5484807,5483883,5484801,5483824],"length":1,"stats":{"Line":0}},{"line":782,"address":[5679963],"length":1,"stats":{"Line":0}},{"line":785,"address":[5484832,5484859],"length":1,"stats":{"Line":0}},{"line":788,"address":[5483947],"length":1,"stats":{"Line":0}},{"line":789,"address":[5484008,5484569],"length":1,"stats":{"Line":0}},{"line":791,"address":[5333593],"length":1,"stats":{"Line":0}},{"line":792,"address":[3323420,3323710],"length":1,"stats":{"Line":0}},{"line":794,"address":[5484199,5484103,5484055],"length":1,"stats":{"Line":0}},{"line":803,"address":[6041856],"length":1,"stats":{"Line":0}},{"line":804,"address":[3202469],"length":1,"stats":{"Line":0}},{"line":808,"address":[6041888],"length":1,"stats":{"Line":2}},{"line":809,"address":[5539061],"length":1,"stats":{"Line":2}},{"line":814,"address":[3200880],"length":1,"stats":{"Line":2}},{"line":815,"address":[5921987],"length":1,"stats":{"Line":2}},{"line":912,"address":[5539152],"length":1,"stats":{"Line":12}},{"line":930,"address":[3202688],"length":1,"stats":{"Line":1}},{"line":931,"address":[3201098,3201069],"length":1,"stats":{"Line":2}},{"line":932,"address":[5729450],"length":1,"stats":{"Line":1}},{"line":933,"address":[5729477],"length":1,"stats":{"Line":1}},{"line":934,"address":[5922217],"length":1,"stats":{"Line":1}},{"line":937,"address":[5334558,5334528],"length":1,"stats":{"Line":2}},{"line":941,"address":[6304480],"length":1,"stats":{"Line":2}},{"line":942,"address":[5922305],"length":1,"stats":{"Line":2}},{"line":946,"address":[6042272],"length":1,"stats":{"Line":2}},{"line":947,"address":[5539461],"length":1,"stats":{"Line":2}},{"line":969,"address":[5731527,5729664,5731521],"length":1,"stats":{"Line":11}},{"line":973,"address":[6305706,6304776,6305202,6306452,6306294,6304641,6305490,6304845,6305346,6305562,6304710,6304914,6304986,6305058,6305130,6305274,6305747,6304603,6305418,6305634],"length":1,"stats":{"Line":22}},{"line":991,"address":[3204627],"length":1,"stats":{"Line":9}},{"line":998,"address":[5731552,5731711,5731705],"length":1,"stats":{"Line":0}},{"line":1002,"address":[3204829],"length":1,"stats":{"Line":0}},{"line":1003,"address":[5924314],"length":1,"stats":{"Line":0}},{"line":1008,"address":[5731728,5731881,5731887],"length":1,"stats":{"Line":0}},{"line":1012,"address":[3203357],"length":1,"stats":{"Line":0}},{"line":1013,"address":[6044426],"length":1,"stats":{"Line":0}},{"line":1018,"address":[5541728],"length":1,"stats":{"Line":0}},{"line":1027,"address":[6044672,6044846],"length":1,"stats":{"Line":0}},{"line":1031,"address":[3203650],"length":1,"stats":{"Line":0}},{"line":1037,"address":[5732365,5732208],"length":1,"stats":{"Line":0}},{"line":1038,"address":[3203934,3203856],"length":1,"stats":{"Line":0}},{"line":1039,"address":[3205609],"length":1,"stats":{"Line":0}},{"line":1043,"address":[5542359,5542208],"length":1,"stats":{"Line":0}},{"line":1044,"address":[6045072,6045149],"length":1,"stats":{"Line":0}},{"line":1045,"address":[5732515],"length":1,"stats":{"Line":0}},{"line":1059,"address":[6307472],"length":1,"stats":{"Line":8}},{"line":1069,"address":[5542400],"length":1,"stats":{"Line":3}},{"line":1077,"address":[3204208],"length":1,"stats":{"Line":0}},{"line":1098,"address":[6045280],"length":1,"stats":{"Line":0}},{"line":1099,"address":[6307544],"length":1,"stats":{"Line":0}},{"line":1103,"address":[3206104,3205920,3206110],"length":1,"stats":{"Line":0}},{"line":1105,"address":[6045329],"length":1,"stats":{"Line":0}},{"line":1106,"address":[3204304],"length":1,"stats":{"Line":0}},{"line":1107,"address":[3204309],"length":1,"stats":{"Line":0}},{"line":1112,"address":[6045704,6045710,6045520],"length":1,"stats":{"Line":0}},{"line":1114,"address":[6307793],"length":1,"stats":{"Line":0}},{"line":1115,"address":[5925615],"length":1,"stats":{"Line":0}},{"line":1116,"address":[5925629],"length":1,"stats":{"Line":0}},{"line":1121,"address":[5543086,5543080,5542896],"length":1,"stats":{"Line":0}},{"line":1123,"address":[5733089],"length":1,"stats":{"Line":0}},{"line":1124,"address":[3204688],"length":1,"stats":{"Line":0}},{"line":1125,"address":[5733117],"length":1,"stats":{"Line":0}},{"line":1130,"address":[6045936,6046137,6046143],"length":1,"stats":{"Line":5}},{"line":1132,"address":[5926017],"length":1,"stats":{"Line":2}},{"line":1138,"address":[3206592],"length":1,"stats":{"Line":3}},{"line":1139,"address":[5733342],"length":1,"stats":{"Line":4}},{"line":1144,"address":[5733504],"length":1,"stats":{"Line":0}},{"line":1145,"address":[5733512],"length":1,"stats":{"Line":0}},{"line":1146,"address":[3205087],"length":1,"stats":{"Line":0}},{"line":1150,"address":[3205104,3205256],"length":1,"stats":{"Line":0}},{"line":1151,"address":[5733584,5733672],"length":1,"stats":{"Line":0}},{"line":1152,"address":[5733692],"length":1,"stats":{"Line":0}},{"line":1156,"address":[3206992],"length":1,"stats":{"Line":0}},{"line":1157,"address":[5733749],"length":1,"stats":{"Line":0}},{"line":1158,"address":[3205309],"length":1,"stats":{"Line":0}},{"line":1162,"address":[6308688],"length":1,"stats":{"Line":0}},{"line":1163,"address":[5543616],"length":1,"stats":{"Line":0}},{"line":1164,"address":[5543619],"length":1,"stats":{"Line":0}},{"line":1165,"address":[3205358],"length":1,"stats":{"Line":0}},{"line":1169,"address":[3207104],"length":1,"stats":{"Line":0}},{"line":1170,"address":[6046517],"length":1,"stats":{"Line":0}},{"line":1171,"address":[6046521],"length":1,"stats":{"Line":0}},{"line":1172,"address":[5733869],"length":1,"stats":{"Line":0}},{"line":1176,"address":[3205440,3205593],"length":1,"stats":{"Line":0}},{"line":1177,"address":[5734002,5733920],"length":1,"stats":{"Line":0}},{"line":1178,"address":[5926745],"length":1,"stats":{"Line":0}},{"line":1182,"address":[5734064],"length":1,"stats":{"Line":0}},{"line":1183,"address":[5734087],"length":1,"stats":{"Line":0}},{"line":1184,"address":[5543916],"length":1,"stats":{"Line":0}},{"line":1188,"address":[3205664],"length":1,"stats":{"Line":0}},{"line":1189,"address":[5926855],"length":1,"stats":{"Line":0}},{"line":1190,"address":[5734140],"length":1,"stats":{"Line":0}},{"line":1208,"address":[5543984],"length":1,"stats":{"Line":9}},{"line":1220,"address":[5734192],"length":1,"stats":{"Line":1}},{"line":1230,"address":[6309136],"length":1,"stats":{"Line":0}},{"line":1233,"address":[3205797],"length":1,"stats":{"Line":0}},{"line":1239,"address":[5734320],"length":1,"stats":{"Line":0}},{"line":1278,"address":[6309328,6310108,6310102],"length":1,"stats":{"Line":5}},{"line":1280,"address":[6310002,6309437,6310258],"length":1,"stats":{"Line":11}},{"line":1281,"address":[5734614],"length":1,"stats":{"Line":4}},{"line":1282,"address":[3207916,3208014,3208116],"length":1,"stats":{"Line":16}},{"line":1284,"address":[3206420],"length":1,"stats":{"Line":4}},{"line":1286,"address":[5334640,5335165,5335159],"length":1,"stats":{"Line":6}},{"line":1287,"address":[5681219],"length":1,"stats":{"Line":4}},{"line":1288,"address":[3469439],"length":1,"stats":{"Line":6}},{"line":1289,"address":[5681389,5681494,5681326],"length":1,"stats":{"Line":10}},{"line":1290,"address":[5681446,5681507],"length":1,"stats":{"Line":4}},{"line":1291,"address":[5334844,5335400,5335238],"length":1,"stats":{"Line":0}},{"line":1292,"address":[5760052,5760104],"length":1,"stats":{"Line":0}},{"line":1294,"address":[5681737],"length":1,"stats":{"Line":0}},{"line":1299,"address":[3206490],"length":1,"stats":{"Line":6}},{"line":1301,"address":[3208473,3207951],"length":1,"stats":{"Line":1}},{"line":1305,"address":[5545345,5544994,5545229],"length":1,"stats":{"Line":5}},{"line":1306,"address":[6310379,6310574],"length":1,"stats":{"Line":3}},{"line":1307,"address":[5735744,5735796],"length":1,"stats":{"Line":3}},{"line":1309,"address":[5735887,5735760],"length":1,"stats":{"Line":0}},{"line":1312,"address":[5928278],"length":1,"stats":{"Line":0}},{"line":1316,"address":[3207174],"length":1,"stats":{"Line":1}},{"line":1317,"address":[6310864],"length":1,"stats":{"Line":2}},{"line":1324,"address":[3210505,3209616,3210859],"length":1,"stats":{"Line":0}},{"line":1325,"address":[3207940],"length":1,"stats":{"Line":0}},{"line":1326,"address":[5736650,5736577],"length":1,"stats":{"Line":0}},{"line":1327,"address":[6049320,6049411],"length":1,"stats":{"Line":0}},{"line":1330,"address":[5485856,5485888],"length":1,"stats":{"Line":0}},{"line":1332,"address":[6049492,6049565],"length":1,"stats":{"Line":0}},{"line":1333,"address":[5736950,5737257],"length":1,"stats":{"Line":0}},{"line":1335,"address":[5546811,5546739],"length":1,"stats":{"Line":0}},{"line":1338,"address":[5929422],"length":1,"stats":{"Line":0}},{"line":1418,"address":[3209152,3209348,3209342],"length":1,"stats":{"Line":13}},{"line":1419,"address":[6050279],"length":1,"stats":{"Line":11}},{"line":1420,"address":[5547547],"length":1,"stats":{"Line":13}},{"line":1429,"address":[6050833,6050512,6050804],"length":1,"stats":{"Line":5}},{"line":1430,"address":[3211145,3211222],"length":1,"stats":{"Line":13}},{"line":1431,"address":[3209520],"length":1,"stats":{"Line":8}},{"line":1435,"address":[3209696],"length":1,"stats":{"Line":2}},{"line":1436,"address":[3209701],"length":1,"stats":{"Line":2}},{"line":1440,"address":[5738364,5738208,5738358],"length":1,"stats":{"Line":1}},{"line":1441,"address":[6313238,6313150],"length":1,"stats":{"Line":3}},{"line":1446,"address":[5548208],"length":1,"stats":{"Line":0}},{"line":1447,"address":[3209873],"length":1,"stats":{"Line":0}},{"line":1452,"address":[3209888],"length":1,"stats":{"Line":0}},{"line":1453,"address":[3211722,3211683],"length":1,"stats":{"Line":0}},{"line":1454,"address":[3211711],"length":1,"stats":{"Line":0}}],"covered":179,"coverable":323},{"path":["/","home","imalison","Projects","lastfm-edit","src","vcr_form_data.rs"],"content":"use std::collections::HashMap;\n\n/// Parse URL-encoded form data into key-value pairs\npub fn parse_form_data(data: \u0026str) -\u003e HashMap\u003cString, String\u003e {\n    let mut params = HashMap::new();\n\n    for pair in data.split('\u0026') {\n        if let Some((key, value)) = pair.split_once('=') {\n            // URL decode the key and value\n            let decoded_key = urlencoding::decode(key).unwrap_or_else(|_| key.into());\n            let decoded_value = urlencoding::decode(value).unwrap_or_else(|_| value.into());\n            params.insert(decoded_key.to_string(), decoded_value.to_string());\n        }\n    }\n\n    params\n}\n\n/// Encode form data back to URL-encoded string\npub fn encode_form_data(params: \u0026HashMap\u003cString, String\u003e) -\u003e String {\n    params\n        .iter()\n        .map(|(key, value)| {\n            format!(\n                \"{}={}\",\n                urlencoding::encode(key),\n                urlencoding::encode(value)\n            )\n        })\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\"\u0026\")\n}\n","traces":[{"line":4,"address":[6080643,6080649,6079696],"length":1,"stats":{"Line":0}},{"line":5,"address":[3579947],"length":1,"stats":{"Line":0}},{"line":7,"address":[3580044,3579979],"length":1,"stats":{"Line":0}},{"line":8,"address":[3580272,3580215],"length":1,"stats":{"Line":0}},{"line":10,"address":[5728635,5728608],"length":1,"stats":{"Line":0}},{"line":11,"address":[5443883,5443856],"length":1,"stats":{"Line":0}},{"line":12,"address":[3580667,3580632,3580561,3580821],"length":1,"stats":{"Line":0}},{"line":16,"address":[6080036],"length":1,"stats":{"Line":0}},{"line":20,"address":[6080672,6080889,6080895],"length":1,"stats":{"Line":0}},{"line":21,"address":[6080696,6080841],"length":1,"stats":{"Line":0}},{"line":23,"address":[5612977,5612544,5612603,5612971],"length":1,"stats":{"Line":0}},{"line":24,"address":[3231514,3231622],"length":1,"stats":{"Line":0}},{"line":26,"address":[5612619],"length":1,"stats":{"Line":0}},{"line":27,"address":[3563358],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","home","imalison","Projects","lastfm-edit","src","vcr_matcher.rs"],"content":"use http_client::Request;\nuse http_client_vcr::{RequestMatcher, SerializableRequest};\nuse std::fmt::Debug;\n\n/// Last.fm Edit VCR matcher that handles authentication flows properly\n/// Ignores cookies and session-related headers that change between test runs\n#[derive(Debug)]\npub struct LastFmEditVcrMatcher {\n    match_method: bool,\n    match_url: bool,\n    match_body: bool,\n}\n\nimpl LastFmEditVcrMatcher {\n    pub fn new() -\u003e Self {\n        Self {\n            match_method: true,\n            match_url: true,\n            match_body: false,\n        }\n    }\n\n    pub fn with_body(mut self, match_body: bool) -\u003e Self {\n        self.match_body = match_body;\n        self\n    }\n}\n\nimpl RequestMatcher for LastFmEditVcrMatcher {\n    fn matches(\u0026self, request: \u0026Request, recorded_request: \u0026SerializableRequest) -\u003e bool {\n        log::debug!(\n            \"Matching request: {} {} against recorded: {} {}\",\n            request.method(),\n            request.url(),\n            recorded_request.method,\n            recorded_request.url\n        );\n\n        if self.match_method \u0026\u0026 request.method().to_string() != recorded_request.method {\n            log::debug!(\n                \"Method mismatch: {} != {}\",\n                request.method(),\n                recorded_request.method\n            );\n            return false;\n        }\n\n        if self.match_url \u0026\u0026 request.url().to_string() != recorded_request.url {\n            log::debug!(\n                \"URL mismatch: {} != {}\",\n                request.url(),\n                recorded_request.url\n            );\n            return false;\n        }\n\n        // For Last.fm, we explicitly ignore unstable headers that change between sessions\n        // This includes cookies, session tokens, CSRF tokens, and other ephemeral data\n        let unstable_headers = [\n            \"cookie\",\n            \"set-cookie\",\n            \"authorization\",\n            \"x-csrf-token\",\n            \"csrf-token\",\n            \"sessionid\",\n            \"session\",\n            \"x-session-id\",\n            \"x-auth-token\",\n            \"auth-token\",\n        ];\n\n        // Match on all headers EXCEPT the unstable ones\n        log::debug!(\"Checking headers (ignoring unstable ones)\");\n        for (header_name, recorded_values) in \u0026recorded_request.headers {\n            let header_lower = header_name.to_lowercase();\n\n            // Skip unstable headers\n            if unstable_headers\n                .iter()\n                .any(|unstable| header_lower.contains(unstable))\n            {\n                log::debug!(\"Skipping unstable header: {header_name}\");\n                continue;\n            }\n\n            let request_header = request.header(header_name.as_str());\n            log::debug!(\n                \"Comparing stable header '{header_name}': request={:?}, recorded={recorded_values:?}\",\n                request_header.map(|v| v.iter().map(|h| h.as_str()).collect::\u003cVec\u003c_\u003e\u003e())\n            );\n\n            match request_header {\n                Some(req_val) =\u003e {\n                    let req_values: Vec\u003cString\u003e =\n                        req_val.iter().map(|v| v.as_str().to_string()).collect();\n                    if \u0026req_values != recorded_values {\n                        log::debug!(\n                            \"Header '{header_name}' values mismatch: {req_values:?} != {recorded_values:?}\"\n                        );\n                        return false;\n                    }\n                }\n                None =\u003e {\n                    // If the recorded request has a header but the current request doesn't,\n                    // that's a mismatch (unless it's an unstable header we're ignoring)\n                    log::debug!(\"Header '{header_name}' missing from request\");\n                    return false;\n                }\n            }\n        }\n\n        log::debug!(\"Request matched successfully\");\n\n        true\n    }\n\n    fn matches_serializable(\n        \u0026self,\n        request: \u0026SerializableRequest,\n        recorded_request: \u0026SerializableRequest,\n    ) -\u003e bool {\n        log::debug!(\n            \"Matching serializable request: {} {} vs {} {}\",\n            request.method,\n            request.url,\n            recorded_request.method,\n            recorded_request.url\n        );\n        if self.match_method \u0026\u0026 request.method != recorded_request.method {\n            return false;\n        }\n\n        if self.match_url \u0026\u0026 request.url != recorded_request.url {\n            return false;\n        }\n\n        // Same logic as above - ignore unstable headers\n        let unstable_headers = [\n            \"cookie\",\n            \"set-cookie\",\n            \"authorization\",\n            \"x-csrf-token\",\n            \"csrf-token\",\n            \"sessionid\",\n            \"session\",\n            \"x-session-id\",\n            \"x-auth-token\",\n            \"auth-token\",\n        ];\n\n        // Match on all headers EXCEPT the unstable ones\n        log::debug!(\n            \"Checking {} recorded headers\",\n            recorded_request.headers.len()\n        );\n        for (header_name, recorded_values) in \u0026recorded_request.headers {\n            let header_lower = header_name.to_lowercase();\n\n            // Skip unstable headers\n            if unstable_headers\n                .iter()\n                .any(|unstable| header_lower.contains(unstable))\n            {\n                log::debug!(\"Skipping unstable header: {header_name}\");\n                continue;\n            }\n\n            log::debug!(\"Checking stable header: {header_name} = {recorded_values:?}\");\n\n            let request_header = request.headers.get(header_name);\n\n            match request_header {\n                Some(req_values) =\u003e {\n                    log::debug!(\n                        \"Comparing header '{header_name}': request={req_values:?} vs recorded={recorded_values:?}\"\n                    );\n                    if req_values != recorded_values {\n                        log::debug!(\n                            \"Header '{header_name}' MISMATCH! request={req_values:?} != {recorded_values:?}\"\n                        );\n                        return false;\n                    }\n                }\n                None =\u003e {\n                    // Some headers like content-type are automatically added by HTTP clients\n                    // but may not be present during replay. For GET requests, content-type is often optional.\n                    if header_name.to_lowercase() == \"content-type\" \u0026\u0026 request.method == \"GET\" {\n                        log::debug!(\"Ignoring missing content-type header for GET request\");\n                        continue;\n                    }\n\n                    // If the recorded request has a header but the current request doesn't,\n                    // that's a mismatch (unless it's an unstable header we're ignoring)\n                    log::debug!(\n                        \"Header '{header_name}' missing from current request (recorded has: {recorded_values:?})\"\n                    );\n                    return false;\n                }\n            }\n        }\n\n        true\n    }\n}\n\nimpl Default for LastFmEditVcrMatcher {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[{"line":23,"address":[3245616],"length":1,"stats":{"Line":0}},{"line":24,"address":[5497549],"length":1,"stats":{"Line":0}},{"line":25,"address":[3245665],"length":1,"stats":{"Line":0}},{"line":30,"address":[3249827,3245712,3249525],"length":1,"stats":{"Line":0}},{"line":31,"address":[3245767,3245826,3245932,3245888],"length":1,"stats":{"Line":0}},{"line":39,"address":[3246300,3245812],"length":1,"stats":{"Line":0}},{"line":40,"address":[3250242,3246473,3250180],"length":1,"stats":{"Line":0}},{"line":45,"address":[3250167],"length":1,"stats":{"Line":0}},{"line":48,"address":[3246277,3246843],"length":1,"stats":{"Line":0}},{"line":49,"address":[3249853,3247008,3249916],"length":1,"stats":{"Line":0}},{"line":54,"address":[3249840],"length":1,"stats":{"Line":0}},{"line":59,"address":[3246519],"length":1,"stats":{"Line":0}},{"line":73,"address":[5498999,5498677],"length":1,"stats":{"Line":0}},{"line":74,"address":[5499171,5498950],"length":1,"stats":{"Line":0}},{"line":75,"address":[3247376],"length":1,"stats":{"Line":0}},{"line":78,"address":[3247751,3247409],"length":1,"stats":{"Line":0}},{"line":80,"address":[5661680,5661698],"length":1,"stats":{"Line":0}},{"line":82,"address":[3249538,3249563,3247841],"length":1,"stats":{"Line":0}},{"line":86,"address":[5499702,5499805],"length":1,"stats":{"Line":0}},{"line":87,"address":[3248100],"length":1,"stats":{"Line":0}},{"line":92,"address":[3247994],"length":1,"stats":{"Line":0}},{"line":93,"address":[3248518],"length":1,"stats":{"Line":0}},{"line":94,"address":[5465715,5465680],"length":1,"stats":{"Line":0}},{"line":96,"address":[5500951,5500864],"length":1,"stats":{"Line":0}},{"line":97,"address":[5501041,5500976,5501077],"length":1,"stats":{"Line":0}},{"line":100,"address":[3249143],"length":1,"stats":{"Line":0}},{"line":106,"address":[3248621,3248556],"length":1,"stats":{"Line":0}},{"line":107,"address":[3248608],"length":1,"stats":{"Line":0}},{"line":112,"address":[5499340,5499390],"length":1,"stats":{"Line":0}},{"line":114,"address":[5499377],"length":1,"stats":{"Line":0}},{"line":117,"address":[3253580,3254714,3250496],"length":1,"stats":{"Line":1}},{"line":122,"address":[5502514,5502455],"length":1,"stats":{"Line":2}},{"line":129,"address":[3250596,3251050],"length":1,"stats":{"Line":2}},{"line":130,"address":[5502966],"length":1,"stats":{"Line":0}},{"line":133,"address":[5503304,5502926],"length":1,"stats":{"Line":2}},{"line":134,"address":[3251423],"length":1,"stats":{"Line":0}},{"line":138,"address":[5502979],"length":1,"stats":{"Line":1}},{"line":152,"address":[3251559,3251345,3251493],"length":1,"stats":{"Line":0}},{"line":156,"address":[5503657,5503348],"length":1,"stats":{"Line":2}},{"line":157,"address":[3251845],"length":1,"stats":{"Line":1}},{"line":160,"address":[5503783,5503908],"length":1,"stats":{"Line":2}},{"line":162,"address":[6053202,6053184],"length":1,"stats":{"Line":2}},{"line":164,"address":[5506347,5504016],"length":1,"stats":{"Line":15}},{"line":168,"address":[3252210,3252162,3252062],"length":1,"stats":{"Line":3}},{"line":170,"address":[3252176,3252545],"length":1,"stats":{"Line":7}},{"line":172,"address":[5504462],"length":1,"stats":{"Line":8}},{"line":173,"address":[3252584],"length":1,"stats":{"Line":5}},{"line":174,"address":[5505542,5505502,5504509],"length":1,"stats":{"Line":19}},{"line":177,"address":[5505508,5505898],"length":1,"stats":{"Line":13}},{"line":178,"address":[3254014,3254079],"length":1,"stats":{"Line":0}},{"line":181,"address":[3254066],"length":1,"stats":{"Line":0}},{"line":187,"address":[3252891,3252648],"length":1,"stats":{"Line":2}},{"line":188,"address":[3253365,3252925,3253340],"length":1,"stats":{"Line":3}},{"line":194,"address":[3252999,3252838,3252980],"length":1,"stats":{"Line":0}},{"line":197,"address":[3252986],"length":1,"stats":{"Line":0}},{"line":202,"address":[3251918],"length":1,"stats":{"Line":1}},{"line":207,"address":[3254736],"length":1,"stats":{"Line":0}},{"line":208,"address":[3254737],"length":1,"stats":{"Line":0}}],"covered":19,"coverable":58},{"path":["/","home","imalison","Projects","lastfm-edit","src","vcr_test_utils.rs"],"content":"use crate::vcr_form_data::{encode_form_data, parse_form_data};\nuse http_client_vcr::{Filter, FilterChain, SerializableRequest, SerializableResponse};\n\n/// Last.fm-specific utilities for test cassette management.\n/// These helpers understand the Last.fm authentication flow and handle credential replacement appropriately.\n/// A custom filter that only filters passwords while preserving usernames and CSRF tokens\n#[derive(Debug)]\npub struct LastFmPasswordOnlyFilter;\n\nimpl Filter for LastFmPasswordOnlyFilter {\n    fn filter_request(\u0026self, request: \u0026mut SerializableRequest) {\n        // Filter passwords in form data\n        if let Some(body) = \u0026mut request.body {\n            if body.contains('=') \u0026\u0026 (body.contains('\u0026') || !body.contains(' ')) {\n                let mut params = parse_form_data(body);\n\n                // Only filter password field - keep username and CSRF token for request matching\n                if params.contains_key(\"password\") {\n                    params.insert(\"password\".to_string(), \"test_password\".to_string());\n                    *body = encode_form_data(\u0026params);\n                }\n            }\n        }\n\n        // Filter session cookies in request headers\n        if let Some(cookie_values) = request.headers.get_mut(\"cookie\") {\n            for cookie_header in cookie_values.iter_mut() {\n                *cookie_header = self.filter_session_cookies(cookie_header);\n            }\n        }\n    }\n\n    fn filter_response(\u0026self, response: \u0026mut SerializableResponse) {\n        // Filter session cookies in response set-cookie headers\n        if let Some(set_cookie_values) = response.headers.get_mut(\"set-cookie\") {\n            for set_cookie_header in set_cookie_values.iter_mut() {\n                if set_cookie_header.contains(\"sessionid=\") {\n                    *set_cookie_header = self.filter_set_cookie_session(set_cookie_header);\n                }\n            }\n        }\n    }\n}\n\nimpl LastFmPasswordOnlyFilter {\n    /// Filter session cookies from a cookie header string\n    fn filter_session_cookies(\u0026self, cookie_header: \u0026str) -\u003e String {\n        let mut filtered_cookies = Vec::new();\n\n        for cookie in cookie_header.split(';') {\n            let cookie = cookie.trim();\n            if cookie.starts_with(\"sessionid=\") {\n                // Replace session ID with test value\n                filtered_cookies.push(\"sessionid=test_session_id\");\n            } else {\n                filtered_cookies.push(cookie);\n            }\n        }\n\n        filtered_cookies.join(\"; \")\n    }\n\n    /// Filter session cookies from a set-cookie header string\n    fn filter_set_cookie_session(\u0026self, set_cookie_header: \u0026str) -\u003e String {\n        if set_cookie_header.starts_with(\"sessionid=\") {\n            // Extract everything after the session value up to the first semicolon or end\n            if let Some(semicolon_pos) = set_cookie_header.find(';') {\n                let attributes = \u0026set_cookie_header[semicolon_pos..];\n                format!(\"sessionid=test_session_id{attributes}\")\n            } else {\n                \"sessionid=test_session_id\".to_string()\n            }\n        } else {\n            set_cookie_header.to_string()\n        }\n    }\n}\n\n/// Create a Last.fm test filter chain that:\n/// - Keeps usernames and CSRF tokens intact (needed for proper request matching)\n/// - Filters passwords from request bodies with predictable test values\n/// - Filters session tokens with predictable test values\npub fn create_lastfm_test_filter_chain() -\u003e Result\u003cFilterChain, regex::Error\u003e {\n    let filter_chain = FilterChain::new().add_filter(Box::new(LastFmPasswordOnlyFilter));\n    Ok(filter_chain)\n}\n","traces":[{"line":11,"address":[5993877,5993120,5993871],"length":1,"stats":{"Line":0}},{"line":13,"address":[3063073],"length":1,"stats":{"Line":0}},{"line":14,"address":[3063244,3063139],"length":1,"stats":{"Line":0}},{"line":15,"address":[3063310],"length":1,"stats":{"Line":0}},{"line":18,"address":[5993495,5993844,5993423],"length":1,"stats":{"Line":0}},{"line":19,"address":[3063756,3063428,3063498],"length":1,"stats":{"Line":0}},{"line":20,"address":[3063621,3063649],"length":1,"stats":{"Line":0}},{"line":26,"address":[3063797,3063170],"length":1,"stats":{"Line":0}},{"line":27,"address":[3063813,3064099,3063867],"length":1,"stats":{"Line":0}},{"line":28,"address":[3063940,3063997],"length":1,"stats":{"Line":0}},{"line":33,"address":[3064435,3064112],"length":1,"stats":{"Line":0}},{"line":35,"address":[3064147],"length":1,"stats":{"Line":0}},{"line":36,"address":[3064211,3064259],"length":1,"stats":{"Line":0}},{"line":37,"address":[3064495,3064317],"length":1,"stats":{"Line":0}},{"line":38,"address":[3064357,3064469,3064409],"length":1,"stats":{"Line":0}},{"line":47,"address":[3064512,3065082,3065088],"length":1,"stats":{"Line":0}},{"line":48,"address":[3064563],"length":1,"stats":{"Line":0}},{"line":50,"address":[3064587,3064652],"length":1,"stats":{"Line":0}},{"line":51,"address":[5995035,5994919],"length":1,"stats":{"Line":0}},{"line":52,"address":[3064967],"length":1,"stats":{"Line":0}},{"line":54,"address":[5995137,5995177],"length":1,"stats":{"Line":0}},{"line":56,"address":[3065072,3065014],"length":1,"stats":{"Line":0}},{"line":60,"address":[5994936],"length":1,"stats":{"Line":0}},{"line":64,"address":[3065104],"length":1,"stats":{"Line":0}},{"line":65,"address":[3065169],"length":1,"stats":{"Line":0}},{"line":67,"address":[3065281,3065222],"length":1,"stats":{"Line":0}},{"line":68,"address":[3065294],"length":1,"stats":{"Line":0}},{"line":69,"address":[3065317],"length":1,"stats":{"Line":0}},{"line":71,"address":[3065435],"length":1,"stats":{"Line":0}},{"line":74,"address":[3065205],"length":1,"stats":{"Line":0}},{"line":83,"address":[3065639,3065472,3065665],"length":1,"stats":{"Line":0}},{"line":84,"address":[3065522,3065649,3065486],"length":1,"stats":{"Line":0}},{"line":85,"address":[3065600],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":33},{"path":["/","home","imalison","Projects","lastfm-edit","tests","event_broadcasting.rs"],"content":"use http_client_vcr::NoOpClient;\nuse lastfm_edit::{LastFmEditClientImpl, LastFmEditSession};\nuse std::time::Duration;\nuse tokio::time::timeout;\n\nfn create_test_session() -\u003e LastFmEditSession {\n    LastFmEditSession::new(\n        \"test_user\".to_string(),\n        vec![\"sessionid=.test_session_id_12345\".to_string()],\n        Some(\"test_csrf_token\".to_string()),\n        \"https://www.last.fm\".to_string(),\n    )\n}\n\n#[test_log::test(tokio::test)]\nasync fn test_shared_broadcaster_across_clients() {\n    // Create the first client\n    let http_client1 = NoOpClient::new();\n    let client1 = LastFmEditClientImpl::from_session(Box::new(http_client1), create_test_session());\n\n    // Create second client that shares the broadcaster with client1\n    let http_client2 = NoOpClient::new();\n    let client2 = client1.with_shared_broadcaster(Box::new(http_client2));\n\n    // Create third client with independent broadcaster\n    let http_client3 = NoOpClient::new();\n    let session = client1.get_session();\n    let client3 = LastFmEditClientImpl::from_session(Box::new(http_client3), session);\n\n    // Subscribe to events from all clients\n    let mut events1 = client1.subscribe();\n    let mut events2 = client2.subscribe();\n    let mut events3 = client3.subscribe();\n\n    // Test that clients start with no events\n    assert!(client1.latest_event().is_none());\n    assert!(client2.latest_event().is_none());\n    assert!(client3.latest_event().is_none());\n\n    // In a real scenario, rate limit events would be broadcast automatically\n    // when HTTP requests encounter rate limiting. Since we can't easily simulate\n    // that in a unit test, we verify the structure is correct by checking that:\n\n    // 1. Clients with shared broadcasters have the same latest event state\n    // 2. Clients with independent broadcasters maintain separate state\n\n    // For now, we can only test that the event subscriptions are properly set up\n    // and that no events are present initially (which is correct)\n\n    // Test that subscriptions don't immediately have events\n    let no_event_1 = timeout(Duration::from_millis(10), events1.recv()).await;\n    let no_event_2 = timeout(Duration::from_millis(10), events2.recv()).await;\n    let no_event_3 = timeout(Duration::from_millis(10), events3.recv()).await;\n\n    // All should timeout (no events received)\n    assert!(no_event_1.is_err());\n    assert!(no_event_2.is_err());\n    assert!(no_event_3.is_err());\n}\n\n#[test_log::test(tokio::test)]\nasync fn test_session_sharing_vs_broadcaster_sharing() {\n    // Create first client\n    let http_client1 = NoOpClient::new();\n    let client1 = LastFmEditClientImpl::from_session(Box::new(http_client1), create_test_session());\n\n    // Client2: shares session but NOT broadcaster\n    let http_client2 = NoOpClient::new();\n    let session = client1.get_session();\n    let client2 = LastFmEditClientImpl::from_session(Box::new(http_client2), session);\n\n    // Client3: shares BOTH session and broadcaster\n    let http_client3 = NoOpClient::new();\n    let client3 = client1.with_shared_broadcaster(Box::new(http_client3));\n\n    // Verify session sharing\n    assert_eq!(\n        client1.get_session().base_url,\n        client2.get_session().base_url\n    );\n    assert_eq!(\n        client1.get_session().base_url,\n        client3.get_session().base_url\n    );\n\n    // All clients should start with no events\n    assert!(client1.latest_event().is_none());\n    assert!(client2.latest_event().is_none());\n    assert!(client3.latest_event().is_none());\n\n    // Subscribe to verify broadcast setup\n    let _events1 = client1.subscribe();\n    let _events2 = client2.subscribe();\n    let _events3 = client3.subscribe();\n\n    // Test passes if no panics occur - the broadcaster sharing is working correctly\n    // In real usage, when client1 or client3 encounter rate limits, both would see the events\n    // while client2 would not (since it has an independent broadcaster)\n}\n\n#[test_log::test]\nfn test_client_creation_patterns() {\n    // Pattern 1: Independent clients\n    let http_client1 = NoOpClient::new();\n    let client1 = LastFmEditClientImpl::from_session(Box::new(http_client1), create_test_session());\n\n    let http_client2 = NoOpClient::new();\n    let session = client1.get_session();\n    let client2 = LastFmEditClientImpl::from_session(Box::new(http_client2), session);\n\n    // These should be independent - same session but different broadcasters\n    assert_eq!(\n        client1.get_session().base_url,\n        client2.get_session().base_url\n    );\n\n    // Pattern 2: Shared broadcaster\n    let http_client3 = NoOpClient::new();\n    let client3 = client1.with_shared_broadcaster(Box::new(http_client3));\n\n    // These should share both session and broadcaster\n    assert_eq!(\n        client1.get_session().base_url,\n        client3.get_session().base_url\n    );\n\n    // Test that we can create subscriptions without issues\n    let _sub1 = client1.subscribe();\n    let _sub2 = client2.subscribe();\n    let _sub3 = client3.subscribe();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","tests","mock_client.rs"],"content":"#[cfg(feature = \"mock\")]\nmod mock_tests {\n    use lastfm_edit::{\n        Album, AlbumPage, EditResponse, ExactScrobbleEdit, LastFmEditClient, MockLastFmEditClient,\n        Result, ScrobbleEdit, Track, TrackPage,\n    };\n    use mockall::predicate::*; // for eq(), any(), etc.\n\n    #[test_log::test(tokio::test)]\n    async fn test_mock_basic_functionality() -\u003e Result\u003c()\u003e {\n        let mut mock_client = MockLastFmEditClient::new();\n\n        mock_client\n            .expect_username()\n            .times(1)\n            .returning(|| \"testuser\".to_string());\n\n        // Use the mock as a trait object\n        let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n\n        // Test username retrieval\n        assert_eq!(client.username(), \"testuser\");\n\n        Ok(())\n    }\n\n    #[test_log::test(tokio::test)]\n    async fn test_mock_edit_scrobble() -\u003e Result\u003c()\u003e {\n        let mut mock_client = MockLastFmEditClient::new();\n\n        let edit = ScrobbleEdit::new(\n            Some(\"Old Track\".to_string()),\n            Some(\"Old Album\".to_string()),\n            \"Old Artist\".to_string(),\n            Some(\"Old Artist\".to_string()),\n            Some(\"New Track\".to_string()),\n            Some(\"New Album\".to_string()),\n            \"New Artist\".to_string(),\n            Some(\"New Artist\".to_string()),\n            Some(1640995200),\n            false,\n        );\n\n        let expected_exact_edit = ExactScrobbleEdit::new(\n            \"Old Track\".to_string(),\n            \"Old Album\".to_string(),\n            \"Old Artist\".to_string(),\n            \"Old Artist\".to_string(),\n            \"New Track\".to_string(),\n            \"New Album\".to_string(),\n            \"New Artist\".to_string(),\n            \"New Artist\".to_string(),\n            1640995200,\n            false,\n        );\n\n        let expected_response = EditResponse::single(\n            true,\n            Some(\"Edit completed successfully\".to_string()),\n            None,\n            expected_exact_edit,\n        );\n\n        // Set up expectation for edit_scrobble\n        mock_client\n            .expect_edit_scrobble()\n            .with(eq(edit.clone()))\n            .times(1)\n            .returning(move |_| Ok(expected_response.clone()));\n\n        // Use the mock\n        let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n        let response = client.edit_scrobble(\u0026edit).await?;\n\n        assert!(response.success());\n        assert_eq!(\n            response.message(),\n            Some(\"Edit completed successfully\".to_string())\n        );\n\n        Ok(())\n    }\n\n    #[test_log::test(tokio::test)]\n    async fn test_mock_get_recent_scrobbles() -\u003e Result\u003c()\u003e {\n        let mut mock_client = MockLastFmEditClient::new();\n\n        let expected_tracks = vec![\n            Track {\n                name: \"Test Track 1\".to_string(),\n                artist: \"Test Artist 1\".to_string(),\n                album: Some(\"Test Album 1\".to_string()),\n                album_artist: Some(\"Test Artist 1\".to_string()),\n                playcount: 5,\n                timestamp: Some(1640995200),\n            },\n            Track {\n                name: \"Test Track 2\".to_string(),\n                artist: \"Test Artist 2\".to_string(),\n                album: Some(\"Test Album 2\".to_string()),\n                album_artist: Some(\"Test Artist 2\".to_string()),\n                playcount: 3,\n                timestamp: Some(1640995100),\n            },\n        ];\n\n        // Set up expectation\n        mock_client\n            .expect_get_recent_tracks_page()\n            .with(eq(1))\n            .times(1)\n            .returning(move |page| {\n                Ok(TrackPage {\n                    tracks: expected_tracks.clone(),\n                    page_number: page,\n                    has_next_page: false,\n                    total_pages: Some(1),\n                })\n            });\n\n        // Use the mock\n        let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n        let page = client.get_recent_tracks_page(1).await?;\n\n        assert_eq!(page.tracks.len(), 2);\n        assert_eq!(page.tracks[0].name, \"Test Track 1\");\n        assert_eq!(page.tracks[1].name, \"Test Track 2\");\n        assert_eq!(page.page_number, 1);\n\n        Ok(())\n    }\n\n    #[test_log::test(tokio::test)]\n    async fn test_mock_iterator_concept() -\u003e Result\u003c()\u003e {\n        // Note: Due to Rust's lifetime system, mocking iterators that borrow from\n        // the client is complex. In practice, you would typically mock the underlying\n        // pagination methods (like get_artist_tracks_page) rather than the iterators themselves.\n\n        let mut mock_client = MockLastFmEditClient::new();\n\n        // Mock the underlying pagination method that iterators use\n        mock_client\n            .expect_get_artist_tracks_page()\n            .with(eq(\"test_artist\"), eq(1))\n            .returning(|_, _| {\n                Ok(TrackPage {\n                    tracks: vec![Track {\n                        name: \"Mocked Track\".to_string(),\n                        artist: \"Mocked Artist\".to_string(),\n                        album: Some(\"Mocked Album\".to_string()),\n                        album_artist: Some(\"Mocked Artist\".to_string()),\n                        playcount: 10,\n                        timestamp: Some(1640995200),\n                    }],\n                    page_number: 1,\n                    has_next_page: false,\n                    total_pages: Some(1),\n                })\n            });\n\n        let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n\n        // Test that the underlying method works correctly\n        let page = client.get_artist_tracks_page(\"test_artist\", 1).await?;\n        assert_eq!(page.tracks.len(), 1);\n        assert_eq!(page.tracks[0].name, \"Mocked Track\");\n\n        Ok(())\n    }\n\n    #[test_log::test(tokio::test)]\n    async fn test_mock_iterator_trait_objects() -\u003e Result\u003c()\u003e {\n        // This test demonstrates that iterator methods return trait objects\n        // that can be used polymorphically, even though mocking the iterators\n        // themselves is complex due to lifetime constraints.\n\n        let mut mock_client = MockLastFmEditClient::new();\n\n        // Mock the underlying methods that the iterators use\n        mock_client\n            .expect_get_artist_tracks_page()\n            .with(eq(\"test_artist\"), eq(1))\n            .returning(|_, _| {\n                Ok(TrackPage {\n                    tracks: vec![Track {\n                        name: \"Iterator Track 1\".to_string(),\n                        artist: \"test_artist\".to_string(),\n                        album: Some(\"Test Album\".to_string()),\n                        album_artist: Some(\"test_artist\".to_string()),\n                        playcount: 5,\n                        timestamp: Some(1640995200),\n                    }],\n                    page_number: 1,\n                    has_next_page: false,\n                    total_pages: Some(1),\n                })\n            });\n\n        mock_client\n            .expect_get_recent_tracks_page()\n            .with(eq(1))\n            .returning(|page| {\n                Ok(TrackPage {\n                    tracks: vec![Track {\n                        name: \"Recent Track 1\".to_string(),\n                        artist: \"Recent Artist\".to_string(),\n                        album: Some(\"Recent Album\".to_string()),\n                        album_artist: Some(\"Recent Artist\".to_string()),\n                        playcount: 1,\n                        timestamp: Some(1640995300),\n                    }],\n                    page_number: page,\n                    has_next_page: false,\n                    total_pages: Some(1),\n                })\n            });\n\n        mock_client\n            .expect_get_artist_albums_page()\n            .with(eq(\"test_artist\"), eq(1))\n            .returning(|_, _| {\n                Ok(AlbumPage {\n                    albums: vec![Album {\n                        name: \"Test Album\".to_string(),\n                        artist: \"test_artist\".to_string(),\n                        playcount: 10,\n                        timestamp: Some(1640995200),\n                    }],\n                    page_number: 1,\n                    has_next_page: false,\n                    total_pages: Some(1),\n                })\n            });\n\n        let client: \u0026dyn LastFmEditClient = \u0026mock_client;\n\n        // Note: Iterator methods are now implemented on the concrete client type,\n        // not the trait. For testing purposes, we can cast back to the concrete type.\n        // In real code, you would typically create iterators using the concrete client.\n\n        // This demonstrates that the underlying pagination methods work\n        let tracks_page = client.get_artist_tracks_page(\"test_artist\", 1).await?;\n        assert_eq!(tracks_page.tracks.len(), 1);\n        assert_eq!(tracks_page.tracks[0].name, \"Iterator Track 1\");\n\n        let recent_page = client.get_recent_tracks_page(1).await?;\n        assert_eq!(recent_page.tracks.len(), 1);\n        assert_eq!(recent_page.tracks[0].name, \"Recent Track 1\");\n\n        let albums_page = client.get_artist_albums_page(\"test_artist\", 1).await?;\n        assert_eq!(albums_page.albums.len(), 1);\n        assert_eq!(albums_page.albums[0].name, \"Test Album\");\n\n        Ok(())\n    }\n}\n\n#[cfg(not(feature = \"mock\"))]\nmod no_mock_tests {\n    #[test]\n    fn test_mock_feature_disabled() {\n        // This test ensures the code compiles even when the mock feature is disabled\n        log::debug!(\"Mock feature is disabled - MockLastFmEditClient is not available\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","tests","parsing_send_sync.rs"],"content":"use http_client_vcr::NoOpClient;\nuse lastfm_edit::{LastFmEditClient, LastFmEditClientImpl, LastFmEditSession};\n\nfn create_test_session() -\u003e LastFmEditSession {\n    LastFmEditSession::new(\n        \"test_user\".to_string(),\n        vec![\"sessionid=.test_session_id_12345\".to_string()],\n        Some(\"test_csrf_token\".to_string()),\n        \"https://www.last.fm\".to_string(),\n    )\n}\n\n/// Test to check if the parsing methods (non-async) are Send + Sync\n#[test_log::test]\nfn test_parsing_methods_are_send_sync() {\n    fn assert_send_sync\u003cT: Send + Sync\u003e(_: T) {}\n\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // Test that the client itself is Send + Sync (should be now that parsing is separate)\n    assert_send_sync(lastfm_client);\n}\n\n/// Test just the iterator creation without calling next() to isolate HTTP client issues\n#[test_log::test]\nfn test_iterator_creation_is_send_sync() {\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // Create iterators one at a time to avoid borrowing issues\n    let recent_tracks = lastfm_client.recent_tracks();\n    drop(recent_tracks);\n\n    let artist_tracks = lastfm_client.artist_tracks(\"test\");\n    drop(artist_tracks);\n\n    let artist_albums = lastfm_client.artist_albums(\"test\");\n    drop(artist_albums);\n}\n\n/// Test that the client itself is Send + Sync (structure-wise)\n#[test_log::test]\nfn test_client_is_send_sync() {\n    fn assert_send_sync\u003cT: Send + Sync + 'static\u003e(_: T) {}\n\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // The client should be Send + Sync at the structural level\n    assert_send_sync(lastfm_client);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","tests","thread_safety.rs"],"content":"use http_client_vcr::NoOpClient;\nuse lastfm_edit::{LastFmEditClientImpl, LastFmEditSession};\n\nfn create_test_session() -\u003e LastFmEditSession {\n    LastFmEditSession::new(\n        \"test_user\".to_string(),\n        vec![\"sessionid=.test_session_id_12345\".to_string()],\n        Some(\"test_csrf_token\".to_string()),\n        \"https://www.last.fm\".to_string(),\n    )\n}\n\n/// Test that futures from client operations are Send.\n/// This ensures they can be used across await boundaries in async contexts.\n#[test_log::test(tokio::test)]\nasync fn test_client_futures_are_send() {\n    fn assert_send\u003cT: Send\u003e(_: T) {}\n\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // Test that client get_recent_tracks_page future is Send\n    let get_recent_tracks_future = lastfm_client.get_recent_tracks_page(1);\n    assert_send(get_recent_tracks_future);\n\n    // Test that client get_artist_tracks_page future is Send\n    let get_tracks_future = lastfm_client.get_artist_tracks_page(\"test\", 1);\n    assert_send(get_tracks_future);\n}\n\n/// Test that iterator futures are Send.\n/// This ensures they can be used across await boundaries.\n/// Note: Current iterator implementation holds references to the client,\n/// so they are not Send. This is intentional for lifetime safety.\n#[test_log::test(tokio::test)]\nasync fn test_iterator_futures_are_send() {\n    // This test is commented out because iterators now hold references\n    // to the client, making them not Send. This is expected behavior.\n\n    // To use iterators across threads, create the iterator on the same\n    // thread where it will be used, or use the underlying pagination\n    // methods directly which are Send.\n}\n\n/// Test that we can spawn tasks with these futures.\n/// This is the most important practical test - futures must be Send to use with tokio::spawn.\n#[test_log::test(tokio::test)]\nasync fn test_futures_can_be_spawned() {\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // This should compile if futures are Send\n    let handle = tokio::spawn(async move {\n        let _ = lastfm_client.get_recent_tracks_page(1).await;\n        let _ = lastfm_client.get_artist_tracks_page(\"test\", 1).await;\n    });\n\n    // Don't actually await the handle since it will fail without proper credentials\n    handle.abort();\n}\n\n/// Test that pagination methods work across await boundaries.\n/// Note: Iterators are not Send due to holding client references.\n/// Use pagination methods directly for Send behavior.\n#[test_log::test(tokio::test)]\nasync fn test_pagination_methods_across_await_boundaries() {\n    let client = Box::new(NoOpClient::new());\n    let lastfm_client = LastFmEditClientImpl::from_session(client, create_test_session());\n\n    // This demonstrates using the underlying pagination methods which are Send\n    let handle = tokio::spawn(async move {\n        // Simulate some async work\n        tokio::time::sleep(std::time::Duration::from_millis(1)).await;\n\n        // Use pagination methods directly - these are Send\n        let _ = lastfm_client.get_recent_tracks_page(1).await;\n        let _ = lastfm_client.get_artist_tracks_page(\"test\", 1).await;\n    });\n\n    // Don't actually await since it will fail without credentials\n    handle.abort();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","tests","types.rs"],"content":"use lastfm_edit::types::{Album, Artist, ExactScrobbleEdit, ScrobbleEdit, Track};\n\n#[test]\nfn test_display_implementations() {\n    // Test Artist Display\n    let artist = Artist {\n        name: \"The Beatles\".to_string(),\n        playcount: 100,\n        timestamp: Some(1234567890),\n    };\n    assert_eq!(format!(\"{artist}\"), \"The Beatles\");\n\n    // Test Album Display\n    let album = Album {\n        name: \"Abbey Road\".to_string(),\n        artist: \"The Beatles\".to_string(),\n        playcount: 50,\n        timestamp: Some(1234567890),\n    };\n    assert_eq!(format!(\"{album}\"), \"The Beatles - Abbey Road\");\n\n    // Test Track Display with album\n    let track_with_album = Track {\n        name: \"Come Together\".to_string(),\n        artist: \"The Beatles\".to_string(),\n        playcount: 10,\n        timestamp: Some(1234567890),\n        album: Some(\"Abbey Road\".to_string()),\n        album_artist: None,\n    };\n    assert_eq!(\n        format!(\"{track_with_album}\"),\n        \"The Beatles - Come Together [Abbey Road]\"\n    );\n\n    // Test Track Display without album\n    let track_without_album = Track {\n        name: \"Yesterday\".to_string(),\n        artist: \"The Beatles\".to_string(),\n        playcount: 15,\n        timestamp: Some(1234567890),\n        album: None,\n        album_artist: None,\n    };\n    assert_eq!(format!(\"{track_without_album}\"), \"The Beatles - Yesterday\");\n\n    // Test ScrobbleEdit Display - no changes\n    let no_changes_edit = ScrobbleEdit {\n        track_name_original: Some(\"Yesterday\".to_string()),\n        album_name_original: Some(\"Help!\".to_string()),\n        artist_name_original: \"The Beatles\".to_string(),\n        album_artist_name_original: None,\n        track_name: Some(\"Yesterday\".to_string()),\n        album_name: Some(\"Help!\".to_string()),\n        artist_name: \"The Beatles\".to_string(),\n        album_artist_name: None,\n        timestamp: Some(1234567890),\n        edit_all: false,\n    };\n    assert_eq!(format!(\"{no_changes_edit}\"), \"No changes\");\n\n    // Test ScrobbleEdit Display - artist change only\n    let artist_edit = ScrobbleEdit {\n        track_name_original: Some(\"Yesterday\".to_string()),\n        album_name_original: Some(\"Help!\".to_string()),\n        artist_name_original: \"The Beatles\".to_string(),\n        album_artist_name_original: None,\n        track_name: Some(\"Yesterday\".to_string()),\n        album_name: Some(\"Help!\".to_string()),\n        artist_name: \"Beatles, The\".to_string(),\n        album_artist_name: None,\n        timestamp: Some(1234567890),\n        edit_all: false,\n    };\n    assert_eq!(\n        format!(\"{artist_edit}\"),\n        \"Artist: The Beatles → Beatles, The\"\n    );\n\n    // Test ScrobbleEdit Display - multiple field changes\n    let multi_edit = ScrobbleEdit {\n        track_name_original: Some(\"Yesterday\".to_string()),\n        album_name_original: Some(\"Help!\".to_string()),\n        artist_name_original: \"The Beatles\".to_string(),\n        album_artist_name_original: None,\n        track_name: Some(\"Yesterday (Remastered)\".to_string()),\n        album_name: Some(\"Help! (Deluxe Edition)\".to_string()),\n        artist_name: \"Beatles, The\".to_string(),\n        album_artist_name: None,\n        timestamp: Some(1234567890),\n        edit_all: false,\n    };\n    assert_eq!(format!(\"{multi_edit}\"), \"Artist: The Beatles → Beatles, The, Track: Yesterday → Yesterday (Remastered), Album: Help! → Help! (Deluxe Edition)\");\n\n    // Test ScrobbleEdit Display - with edit_all flag\n    let edit_all = ScrobbleEdit {\n        track_name_original: Some(\"Yesterday\".to_string()),\n        album_name_original: Some(\"Help!\".to_string()),\n        artist_name_original: \"The Beatles\".to_string(),\n        album_artist_name_original: None,\n        track_name: Some(\"Yesterday\".to_string()),\n        album_name: Some(\"Help!\".to_string()),\n        artist_name: \"Beatles, The\".to_string(),\n        album_artist_name: None,\n        timestamp: Some(1234567890),\n        edit_all: true,\n    };\n    assert_eq!(\n        format!(\"{edit_all}\"),\n        \"Artist: The Beatles → Beatles, The (all instances)\"\n    );\n\n    // Test ExactScrobbleEdit Display - no changes\n    let exact_no_changes = ExactScrobbleEdit {\n        track_name_original: \"Yesterday\".to_string(),\n        album_name_original: \"Help!\".to_string(),\n        artist_name_original: \"The Beatles\".to_string(),\n        album_artist_name_original: \"The Beatles\".to_string(),\n        track_name: \"Yesterday\".to_string(),\n        album_name: \"Help!\".to_string(),\n        artist_name: \"The Beatles\".to_string(),\n        album_artist_name: \"The Beatles\".to_string(),\n        timestamp: 1234567890,\n        edit_all: false,\n    };\n    assert_eq!(format!(\"{exact_no_changes}\"), \"No changes\");\n\n    // Test ExactScrobbleEdit Display - artist change\n    let exact_artist_change = ExactScrobbleEdit {\n        track_name_original: \"Yesterday\".to_string(),\n        album_name_original: \"Help!\".to_string(),\n        artist_name_original: \"The Beatles\".to_string(),\n        album_artist_name_original: \"The Beatles\".to_string(),\n        track_name: \"Yesterday\".to_string(),\n        album_name: \"Help!\".to_string(),\n        artist_name: \"Beatles, The\".to_string(),\n        album_artist_name: \"The Beatles\".to_string(),\n        timestamp: 1234567890,\n        edit_all: false,\n    };\n    assert_eq!(\n        format!(\"{exact_artist_change}\"),\n        \"Artist: The Beatles → Beatles, The\"\n    );\n\n    // Test ExactScrobbleEdit Display - multiple changes with edit_all\n    let exact_multi_changes = ExactScrobbleEdit {\n        track_name_original: \"Yesterday\".to_string(),\n        album_name_original: \"Help!\".to_string(),\n        artist_name_original: \"The Beatles\".to_string(),\n        album_artist_name_original: \"The Beatles\".to_string(),\n        track_name: \"Yesterday (Remastered)\".to_string(),\n        album_name: \"Help! (Deluxe Edition)\".to_string(),\n        artist_name: \"Beatles, The\".to_string(),\n        album_artist_name: \"Beatles, The\".to_string(),\n        timestamp: 1234567890,\n        edit_all: true,\n    };\n    assert_eq!(format!(\"{exact_multi_changes}\"), \"Artist: The Beatles → Beatles, The, Track: Yesterday → Yesterday (Remastered), Album: Help! → Help! (Deluxe Edition), Album Artist: The Beatles → Beatles, The (all instances)\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","imalison","Projects","lastfm-edit","tests","vcr_tests.rs"],"content":"mod vcr;\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>